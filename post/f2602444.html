<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础学习笔记 | 漂亮鬼</title><meta name="keywords" content="java"><meta name="author" content="漂亮鬼"><meta name="copyright" content="漂亮鬼"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 个人观看后的感悟哈，就是这个Java里面血多的东西 还是和c++和c 里面 太像了，比如说 类，访问权限，变量的类型，等等等等 ，个人建议 对于刚开始的小伙伴 如果不是特别着急要学java的小伙伴完全可以从 c 开始一步一步的学 c c++ Java 呀或者python 啊这些都非常的相似 只有极少数的各自的语言特点。 Java 基础语法对象：对象是类的一个实例，有状态和行为。例如，一">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础学习笔记">
<meta property="og:url" content="http://1yzf2zstgiyhub.io/post/f2602444.html">
<meta property="og:site_name" content="漂亮鬼">
<meta property="og:description" content="[TOC] 个人观看后的感悟哈，就是这个Java里面血多的东西 还是和c++和c 里面 太像了，比如说 类，访问权限，变量的类型，等等等等 ，个人建议 对于刚开始的小伙伴 如果不是特别着急要学java的小伙伴完全可以从 c 开始一步一步的学 c c++ Java 呀或者python 啊这些都非常的相似 只有极少数的各自的语言特点。 Java 基础语法对象：对象是类的一个实例，有状态和行为。例如，一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-dg6rk3.4vgrzrx10s60.webp">
<meta property="article:published_time" content="2022-10-25T15:02:31.000Z">
<meta property="article:modified_time" content="2022-10-25T15:06:41.325Z">
<meta property="article:author" content="漂亮鬼">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-dg6rk3.4vgrzrx10s60.webp"><link rel="shortcut icon" href="https://pic2.zhimg.com/v2-9359c735aa38fa08bc161d8d6c0df38e_r.jpg?source=3af55fa1"><link rel="canonical" href="http://1yzf2zstgiyhub.io/post/f2602444"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fa627d7767ce07eaecb96088287b512d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":1000,"languages":{"author":"作者: 漂亮鬼","link":"链接: ","source":"来源: 漂亮鬼","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-10-25 23:06:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/404/404.css"><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picx.zhimg.com/v2-6576f8c64444c40baa4602979c75d1e3_r.jpg?source=3af55fa1" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> images</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-dg6rk3.4vgrzrx10s60.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">漂亮鬼</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> images</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-25T15:02:31.000Z" title="发表于 2022-10-25 23:02:31">2022-10-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-25T15:06:41.325Z" title="更新于 2022-10-25 23:06:41">2022-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<p>个人观看后的感悟哈，<br>就是这个Java里面血多的东西 还是和c++和c 里面 太像了，比如说 类，访问权限，变量的类型，等等等等 ，个人建议 对于刚开始的小伙伴 如果不是特别着急要学java的小伙伴完全可以从 c 开始一步一步的学 c c++ Java 呀或者python 啊这些都非常的相似 只有极少数的各自的语言特点。</p>
<h4 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h4><p>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
<p>类：类是一个模板，它描述一类对象的行为和状态。</p>
<p>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p>
<p>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
<p>第一个Java程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class test1 &#123;</span><br><span class="line">    /* 第一个Java程序.  </span><br><span class="line">     * 它将打印字符串 Hello World</span><br><span class="line">     */</span><br><span class="line">     public static void main(String []args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;); // 打印 Hello World</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本语法</p>
<p>编写Java程序时，应注意以下几点：</p>
<p>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</p>
<p>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</p>
<p>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</p>
<p>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</p>
<p>主方法入口：所有的Java 程序由public static void main(String[] args) 方法开始执行。</p>
<h5 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h5><p>关于Java标识符，有以下几点需要注意：</p>
<p>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</p>
<p>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</p>
<p>关键字不能用作标识</p>
<p>符标识符是大小写敏感的</p>
<p>合法标识符举例：age、$salary、_value、__1_value<br>非法标识符举例：123abc、-salary</p>
<h5 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h5><p>Java可以使用修饰符来修饰类中方法和属性。</p>
<p>主要有两类修饰符：</p>
<p>访问控制修饰符 : default, public , protected, private</p>
<p>非访问控制修饰符 : final, abstract, static，synchronized 和 volatile</p>
<h5 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h5><p>Java中主要有如下几种类型的变量<br>局部变量<br>类变量（静态变量）<br>成员变量（非静态变量）</p>
<p>Java数组</p>
<p>数组是储存在堆上的对象，可以保存多个同类型变量</p>
<p>Java枚举</p>
<p>枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class FreshJuice &#123;</span><br><span class="line">    enum FreshJuiceSize&#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    FreshJuiceSize size;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> public class test1 &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       FreshJuice juice = new FreshJuice();</span><br><span class="line">       juice.size = FreshJuice. FreshJuiceSize.MEDIUM ;</span><br><span class="line">       System.out.println(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：枚举可以单独声明或者声明在类里面。方法、变量、构造函数也可以在枚举中定义。</p>
<h5 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h5><p>下面列出了Java保留字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<p>abstract<br>抽象方法，抽象类的修饰符</p>
<p>assert<br>断言条件是否满足</p>
<p>boolean<br>布尔数据类型</p>
<p>break<br>跳出循环或者</p>
<p>label<br>代码段</p>
<p>byte<br>8-bit有符号数据类型</p>
<p>case<br>switch语句的一个条件</p>
<p>catch<br>和try搭配捕捉异常信息</p>
<p>char<br>16-bit Unicode字符数据类型</p>
<p>class<br>定义类</p>
<p>const<br>未使用</p>
<p>continue<br>不执行循环体剩余部分</p>
<p>default<br>switch语句中的默认分支</p>
<p>do<br>循环语句，循环体至少会执行一次</p>
<p>double<br>64-bit双精度浮点数</p>
<p>elseif<br>条件不成立时执行的分支</p>
<p>enum<br>枚举类型</p>
<p>extends<br>表示一个类是另一个类的子类</p>
<p>final<br>表示一个值在初始化之后就不能再改变了<br>表示方法不能被重写，或者一个类不能有子类</p>
<p>finally<br>为了完成执行的代码而设计的，主要是为了程序的健壮性和完整性，无论有没有异常发生都执行代码。</p>
<p>float32-bit<br>单精度浮点数</p>
<p>for<br>for循环语句</p>
<p>goto<br>未使用</p>
<p>if<br>条件语句</p>
<p>implements<br>表示一个类实现了接口</p>
<p>import<br>导入类</p>
<p>instanceof<br>测试一个对象是否是某个类的实例</p>
<p>int32<br>位整型数</p>
<p>interface<br>接口，一种抽象的类型，仅有方法和常量的定义</p>
<p>long<br>64位整型数</p>
<p>native<br>表示方法用非</p>
<p>java<br>代码实现</p>
<p>new<br>分配新的类实例</p>
<p>package<br>一系列相关类组成一个包</p>
<p>private<br>表示私有字段，或者方法等，只能从类内部访问</p>
<p>protected<br>表示字段只能通过类或者其子类访问<br>子类或者在同一个包内的其他类</p>
<p>public<br>表示共有属性或者方法</p>
<p>return<br>方法返回值</p>
<p>short<br>16位数字</p>
<p>static<br>表示在类级别定义，所有实例共享的</p>
<p>strictfp<br>浮点数比较使用严格的规则</p>
<p>super<br>表示基类</p>
<p>switch<br>选择语句</p>
<p>synchronized<br>表示同一时间只能由一个线程访问的代码块</p>
<p>this<br>表示调用当前实例<br>或者调用另一个构造函数</p>
<p>throw<br>抛出异常</p>
<p>throws<br>定义方法可能抛出的异常</p>
<p>transient<br>修饰不要序列化的字段</p>
<p>try<br>表示代码块要做异常处理或者和finally配合表示是否抛出异常都执行finally中的代码</p>
<p>void<br>标记方法不返回任何值</p>
<p>volatile<br>标记字段可能会被多个线程同时访问，而不做同步</p>
<p>while<br>while循环</p>
<p>Java注释<br>类似于C&#x2F;C++，Java也支持单行以及多行注释。注释中的字符将被Java编译器忽略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyFirstJavaProgram&#123;</span><br><span class="line">    /* 这是第一个Java程序</span><br><span class="line">     *它将打印Hello World</span><br><span class="line">     * 这是一个多行注释的示例</span><br><span class="line">     */</span><br><span class="line">     public static void main(String []args)&#123;</span><br><span class="line">        // 这是单行注释的示例</span><br><span class="line">        /* 这个也是单行注释的示例 */</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>继承</p>
<p>在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p>
<p>接口</p>
<p>在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h4 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h4><p>在理解Java的类和对象之前，先简单介绍一下面向对象的程序设计。程序设计是通过对象对程序进行设计，对象代表一个实体，实体可以清楚地被识别</p>
<p>Java作为一种面向对象语言。支持以下基本概念：<br>多态 继承 封装 抽象 类对象 实例 方法 消息解析</p>
<p>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
<p>类：类是一个模板，它描述一类对象的行为和状态。</p>
<h5 id="Java中的对象"><a href="#Java中的对象" class="headerlink" title="Java中的对象"></a>Java中的对象</h5><p>看看周围真实的世界，会发现身边有很多对象，车，狗，人等等。所有这些对象都有自己的状态和行为。拿一条狗来举例，它的状态有：名字、品种、颜色，行为有：叫、摇尾巴和跑。对比现实对象和软件对象，它们之间十分相似。软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</p>
<h5 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h5><p>类可以看成是创建 Java 对象的模板。通过下面一个简单的类来理解下 Java 中类的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Dog&#123;</span><br><span class="line">    String breed;</span><br><span class="line">    int age;</span><br><span class="line">    String color;</span><br><span class="line">    void barking()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void hungry()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void sleeping()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含以下类型变量：</p>
<p>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</p>
<p>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</p>
<p>类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</p>
<p>一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和 sleeping()都是 Dog 类的方法。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    public Puppy()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">       // 这个构造器仅有一个参数：name</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><p>对象是根据类创建的。在 Java 中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<p>声明：声明一个对象，包括对象名称和对象类型。</p>
<p>实例化：使用关键字new 来创建一个对象。</p>
<p>初始化：使用 new创建对象时，会调用构造方法初始化对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class test1&#123;</span><br><span class="line">    public test1(String name)&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        test1 mytTest1 = new test1(&quot;yzf&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>访问实例变量和方法</p>
<p>通过已创建的对象来访问成员变量和成员方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 实例化对象 */</span><br><span class="line">ObjectReference = new Constructor();</span><br><span class="line">/* 访问其中的变量 */</span><br><span class="line">ObjectReference.variableName;</span><br><span class="line">/* 访问类中的方法 */</span><br><span class="line">ObjectReference.MethodName();</span><br></pre></td></tr></table></figure>

<p>实例</p>
<p>下面的例子展示如何访问实例变量和调用成员方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Puppy&#123;</span><br><span class="line">    int puppyAge;</span><br><span class="line">    public Puppy(String name)&#123;</span><br><span class="line">       // 这个构造器仅有一个参数：name</span><br><span class="line">       System.out.println(&quot;Passed Name is :&quot; + name );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setAge( int age )&#123;</span><br><span class="line">        puppyAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int getAge( )&#123;</span><br><span class="line">        System.out.println(&quot;Puppy&#x27;s age is :&quot; + puppyAge );</span><br><span class="line">        return puppyAge;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">       /* 创建对象 */</span><br><span class="line">       Puppy myPuppy = new Puppy( &quot;tommy&quot; );</span><br><span class="line">       /* 通过方法来设定age */</span><br><span class="line">       myPuppy.setAge( 2 );</span><br><span class="line">       /* 调用另一个方法获取age */</span><br><span class="line">       myPuppy.getAge( );</span><br><span class="line">       /*你也可以像下面这样访问成员变量 */</span><br><span class="line">       System.out.println(&quot;Variable Value :&quot; + myPuppy.puppyAge );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h5><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package 语句时，要特别注意这些规则。</p>
<p>一个源文件中只能有一个 public 类</p>
<p>一个源文件可以有多个非public类</p>
<p>源文件的名称应该和public类的类名保持一致。例如：源文件中public类的类名是Employee，那么源文件应该命名为Employee.java。</p>
<p>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</p>
<p>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</p>
<p>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</p>
<p>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等<br>除了上面提到的几种类型，Java 还有一些特殊的类，如：内部类、匿名类。</p>
<h5 id="Java包"><a href="#Java包" class="headerlink" title="Java包"></a>Java包</h5><p>包主要用来对类和接口进行分类。当开发 Java 程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>
<p>Import语句</p>
<p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。Import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类</p>
<p>import java.io.*;</p>
<p><strong>包这里还有许多的问题</strong></p>
<h4 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h4><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。<br>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java的两大数据类型：<br>内置数据类型<br>引用数据类型</p>
<h5 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h5><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p>byte型：<br>byte数据类型是8位、有符号的，以二进制补码表示的整数；<br>最小值是-128（-2^7）；最大值是127（2^7-1）；<br>默认值是0；<br>byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；<br>例子：byte a &#x3D; 100，byte b &#x3D; -50。</p>
<p>short型（短整型）：<br>short数据类型是16位、有符号的以二进制补码表示的整数最小值是-32768（-2^15）；</p>
<p>最大值是32767（2^15 - 1）；</p>
<p>Short数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一；</p>
<p>默认值是0；<br>例子：short s &#x3D; 1000，short r &#x3D; -20000。</p>
<p>int型（整型）：<br>int数据类型是32位、有符号的以二进制补码表示的整数；<br>最小值是-2,147,483,648（-2^31）；<br>最大值是2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为int类型；<br>默认值是0；<br>例子：int a &#x3D; 100000, int b &#x3D; -200000。</p>
<p>long（长整型）：</p>
<p>long数据类型是64位、有符号的以二进制补码表示的整数；<br>最小值是-9,223,372,036,854,775,808（-2^63）；<br>最大值是9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>默认值是0L；<br>例子： long a &#x3D; 100000L，long b &#x3D; -200000L。</p>
<p>float（单精度浮点型）：</p>
<p>float数据类型是单精度、32位、符合IEEE 754标准的浮点数；</p>
<p>float在储存大型浮点数组的时候可节省内存空间；</p>
<p>默认值是0.0f；</p>
<p>浮点数不能用来表示精确的值，如货币；<br>例子：float f1 &#x3D; 234.5f。</p>
<p>double（双精度浮点型）：</p>
<p>double数据类型是双精度、64位、符合IEEE 754标准的浮点数；</p>
<p>浮点数的默认类型为double类型；</p>
<p>double类型同样不能表示精确的值，如货币；</p>
<p>默认值是0.0d；<br>例子：double d1 &#x3D; 123.4。</p>
<p>boolean（布尔型）：</p>
<p>boolean数据类型表示一位的信息；</p>
<p>只有两个取值：true和false；</p>
<p>这种类型只作为一种标志来记录true&#x2F;false情况；</p>
<p>默认值是false；</p>
<p>例子：boolean one &#x3D; true。</p>
<p>char（字符型）：</p>
<p>char类型是一个单一的16位Unicode字符；</p>
<p>最小值是’\u0000’（即为0）；</p>
<p>最大值是’\uffff’（即为65,535）；</p>
<p>char数据类型可以储存任何字符；</p>
<p>例子：char letter &#x3D; ‘A’。</p>
<p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class PrimitiveTypeTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    // byte</span><br><span class="line">    System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Byte&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Byte.MIN_VALUE=&quot; + Byte.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Byte.MAX_VALUE=&quot; + Byte.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">   </span><br><span class="line">    // short</span><br><span class="line">    System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Short&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Short.MIN_VALUE=&quot; + Short.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Short.MAX_VALUE=&quot; + Short.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">    // int</span><br><span class="line">    System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Integer&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Integer.MIN_VALUE=&quot; + Integer.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Integer.MAX_VALUE=&quot; + Integer.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">    // long</span><br><span class="line">    System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Long&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Long.MIN_VALUE=&quot; + Long.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Long.MAX_VALUE=&quot; + Long.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">    // float</span><br><span class="line">    System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Float&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Float.MIN_VALUE=&quot; + Float.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Float.MAX_VALUE=&quot; + Float.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">    // double</span><br><span class="line">    System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Double&quot;);</span><br><span class="line">    System.out.println(&quot;最小值：Double.MIN_VALUE=&quot; + Double.MIN_VALUE);</span><br><span class="line">    System.out.println(&quot;最大值：Double.MAX_VALUE=&quot; + Double.MAX_VALUE);</span><br><span class="line">    System.out.println();</span><br><span class="line">    // char</span><br><span class="line">    System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);</span><br><span class="line">    System.out.println(&quot;包装类：java.lang.Character&quot;);</span><br><span class="line">    // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台</span><br><span class="line">    System.out.println(&quot;最小值：Character.MIN_VALUE=&quot;</span><br><span class="line">            + (int) Character.MIN_VALUE);</span><br><span class="line">    // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台</span><br><span class="line">    System.out.println(&quot;最大值：Character.MAX_VALUE=&quot;</span><br><span class="line">            + (int) Character.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的“数字”次幂。比如3.14E3就是3.14×1000&#x3D;3140，3.14E-3就是3.14&#x2F;1000&#x3D;0.00314。实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>引用类型变量由类的构造函数创建，可以使用它们访问所引用的对象。这些变量在声明时被指定为一个特定的类型，比如Employee、Pubby等。变量一旦声明后，类型就不能被改变了。</p>
<p>对象、数组都是引用数据类型。</p>
<p>所有引用类型的默认值都是null。</p>
<p>一个引用变量可以用来引用与任何与之兼容的类型。</p>
<p>例子：Animal animal &#x3D; new Animal(“giraffe”)。</p>
<h5 id="Java常量"><a href="#Java常量" class="headerlink" title="Java常量"></a>Java常量</h5><p>常量就是一个固定值。它们不需要计算，直接代表相应的值。常量指不能改变的量。 在Java中用final标志，声明方式和变量类似：</p>
<p>final double PI &#x3D; 3.1415927;</p>
<p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>
<p>自变量可以赋给任何内置类型的变量。例如：<br>byte a &#x3D; 68; char a &#x3D; ‘A’</p>
<p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。<br>当使用常量的时候，前缀0表明是8进制，而前缀0x代表16进制。例如：</p>
<p>int decimal &#x3D; 100; int octal &#x3D; 0144; int hexa &#x3D; 0x64;</p>
<p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p>
<p>“Hello World” “two\nlines” “&quot;This is in quotes&quot;“</p>
<p>字符串常量和字符常量都可以包含任何Unicode字符。例如：</p>
<p>char a &#x3D; ‘\u0001’; String a &#x3D; “\u0001”;</p>
<p>Java语言支持一些特殊的转义字符序列。</p>
<p>\n<br>换行 (0x0a)</p>
<p>\r<br>回车 (0x0d)</p>
<p>\f<br>换页符(0x0c)</p>
<p>\b<br>退格 (0x08)</p>
<p>\0<br>空字符（0x0）</p>
<p>\s<br>字符串</p>
<p>\t<br>制表符</p>
<p>&quot;<br>双引号</p>
<p>&#39;<br>单引号</p>
<p>\<br>反斜杠</p>
<p>\ddd<br>八进制字符 (ddd)</p>
<p>\uxxxx16<br>进制Unicode字符 (xxxx)</p>
<h4 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h4><p>在 Java 语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p>
<p>type identifier [ &#x3D; value][, identifier [&#x3D; value] …] ;<br>格式说明：type 为 Java 数据类型。identifier 是变量名。可以使用逗号隔开来声明多个同类型变量。</p>
<p>Java 语言支持的变量类型有：</p>
<p>局部变量：类的方法中的变量。<br>实例变量：独立于方法之外的变量，不过没有 static 修饰。<br>类变量：独立于方法之外的变量，用 static 修饰。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Variable&#123;</span><br><span class="line">        static int allClicks=0;    // 类变量</span><br><span class="line">   </span><br><span class="line">        String str=&quot;hello world&quot;;  // 实例变量</span><br><span class="line">     </span><br><span class="line">        public void method()&#123;</span><br><span class="line">            int i =0;  // 局部变量</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Java局部变量"><a href="#Java局部变量" class="headerlink" title="Java局部变量"></a>Java局部变量</h5><p>局部变量声明在方法、构造方法或者语句块中；</p>
<p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p>
<p>访问修饰符不能用于局部变量；<br>局部变量只在声明它的方法、构造方法或者语句块中可见；</p>
<p><strong>局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用</strong>。</p>
<p>实例1</p>
<p>在以下实例中 age 是一个局部变量。定义在 pupAge() 方法中，它的作用域就限制在这个方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public void pupAge()&#123;</span><br><span class="line">       int age = 0;</span><br><span class="line">       age = age + 7;</span><br><span class="line">       System.out.println(&quot;Puppy age is : &quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       Test test = new Test();</span><br><span class="line">       test.pupAge();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>实例2</p>
<p>在下面的例子中 age 变量没有初始化，所以在编译时出错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">   public void pupAge()&#123;</span><br><span class="line">      int age;</span><br><span class="line">      age = age + 7;</span><br><span class="line">      System.out.println(&quot;Puppy age is : &quot; + age);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Test test = new Test();</span><br><span class="line">      test.pupAge();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</p>
<p><strong>当一个对象被实例化之后，每个实例变量的值就跟着确定</strong>(好好注意这句话的意思)；</p>
<p>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</p>
<p>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</p>
<p>实例变量可以声明在使用前或者使用后；</p>
<p><strong>访问修饰符可以修饰实例变量</strong>；</p>
<p><strong>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见</strong>；</p>
<p>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；</p>
<p>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Employee&#123;</span><br><span class="line">   // 这个成员变量对子类可见</span><br><span class="line">   public String name;</span><br><span class="line">   // 私有变量，仅在该类可见</span><br><span class="line">   private double salary;</span><br><span class="line">   //在构造器中对name赋值</span><br><span class="line">   public Employee (String empName)&#123;</span><br><span class="line">      name = empName;</span><br><span class="line">   &#125;</span><br><span class="line">   //设定salary的值</span><br><span class="line">   public void setSalary(double empSal)&#123;</span><br><span class="line">      salary = empSal;</span><br><span class="line">   &#125;  </span><br><span class="line">   // 打印信息</span><br><span class="line">   public void printEmp()&#123;</span><br><span class="line">      System.out.println(&quot;name  : &quot; + name );</span><br><span class="line">      System.out.println(&quot;salary :&quot; + salary);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Employee empOne = new Employee(&quot;Ransika&quot;);</span><br><span class="line">      empOne.setSalary(1000);</span><br><span class="line">      empOne.printEmp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>类变量也称为静态变量，在类中以 static 关键字声明，<strong>但必须在方法、构造方法和语句块之外</strong>。</p>
<p>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</p>
<p>静态变量除了被声明为常量外很少使用。常量是指声明为 public&#x2F;private，final 和 static 类型的变量。常量初始化后不可改变。</p>
<p>静态变量储存在<strong>静态存储区</strong>。经常被声明为常量，很少单独使用 static 声明变量。</p>
<p>静态变量在程序开始时创建，在程序结束时销毁。</p>
<p><strong>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</strong></p>
<p>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</p>
<p>静态变量可以通过：ClassName.VariableName 的方式访问。</p>
<p>类变量被声明为 public static final 类型时，类变量名称必须使用大<strong>写字母</strong>。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Employee&#123;</span><br><span class="line">   //salary是静态的私有变量</span><br><span class="line">   private static double salary;</span><br><span class="line">   // DEPARTMENT是一个常量</span><br><span class="line">   public static final String DEPARTMENT = &quot;Development &quot;;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      salary = 1000;</span><br><span class="line">      System.out.println(DEPARTMENT+&quot;average salary:&quot;+salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT。</p>
<h4 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h4><p>Java 语言提供了很多修饰符，主要分为以下两类：</p>
<p>访问修饰符<br>非访问修饰符</p>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class className &#123;</span><br><span class="line">   // ...</span><br><span class="line">private boolean myFlag;</span><br><span class="line">static final double weeks = 9.5;</span><br><span class="line">protected static final int BOXWIDTH = 42;</span><br><span class="line">public static void main(String[] arguments) &#123;</span><br><span class="line">   // 方法体</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h5><p>Java 中，可以使用访问控制符来保护对<strong>类、变量、方法和构造方法</strong>的访问。</p>
<p>Java 支持4种不同的访问权限。</p>
<p>默认的，也称为 default，在同一包内可见，不使用任何修饰符。</p>
<p>私有的，以 private 修饰符指定，在同一类内可见。</p>
<p>公有的，以 public 修饰符指定，对所有类可见。</p>
<p>受保护的，以 protected 修饰符指定，对同一包内的类和所有子类可见。</p>
<p>默认访问修饰符-不使用任何关键字</p>
<p>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为 public。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = &quot;1.5.1&quot;;</span><br><span class="line">boolean processOrder() &#123;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h5><p>私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>
<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。<br>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Logger &#123;</span><br><span class="line">   private String format;</span><br><span class="line">   public String getFormat() &#123;</span><br><span class="line">      return this.format;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setFormat(String format) &#123;</span><br><span class="line">      this.format = format;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例中，Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个public方法：getFormat() （返回format的值）和setFormat(String)（设置format的值）</p>
<h5 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h5><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>
<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main()&#123;</span><br><span class="line">//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p>
<p>受保护的访问修饰符-protected</p>
<p>被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。</p>
<p>Protected 访问修饰符不能修饰类和接口，方法和成员变量能够声明为 protected，但是接口的成员变量和成员方法不能声明为 protected。</p>
<p>子类能访问 Protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>
<p>下面的父类使用了 protected 访问修饰符，子类重载了父类的 openSpeaker() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class AudioPlayer &#123;</span><br><span class="line">   protected boolean openSpeaker(Speaker sp) &#123;</span><br><span class="line">      // 实现细节</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StreamingAudioPlayer &#123;</span><br><span class="line">   boolean openSpeaker(Speaker sp) &#123;</span><br><span class="line">      // 实现细节</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把 openSpeaker() 方法声明为private，那么除了 AudioPlayer 之外的类将不能访问该方法。如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。</p>
<p> 访问控制和继承</p>
<p>请注意以下方法继承的规则：</p>
<p>父类中声明为 public 的方法在子类中也必须为 public。</p>
<p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public。不能声明为 private。</p>
<p>父类中声明为 private 的方法，不能够被继承。</p>
<h4 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h4><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<p>static 修饰符，用来创建类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h5 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h5><p>静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。</p>
<p>静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
<p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname的方式访问。如下例所示，static 修饰符用来创建类方法和类变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceCounter &#123;</span><br><span class="line">   private static int numInstances = 0;</span><br><span class="line">   protected static int getCount() &#123;</span><br><span class="line">      return numInstances;</span><br><span class="line">   &#125;</span><br><span class="line">   private static void addInstance() &#123;</span><br><span class="line">      numInstances++;</span><br><span class="line">   &#125;</span><br><span class="line">   InstanceCounter() &#123;</span><br><span class="line">      InstanceCounter.addInstance();</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] arguments) &#123;</span><br><span class="line">      System.out.println(&quot;Starting with &quot; +</span><br><span class="line">      InstanceCounter.getCount() + &quot; instances&quot;);</span><br><span class="line">      for (int i = 0; i &lt; 500; ++i)&#123;</span><br><span class="line">          new InstanceCounter();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Created &quot; +</span><br><span class="line">       InstanceCounter.getCount() + &quot; instances&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h5><p>final 变量：final 变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。</p>
<p>也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">   final int value = 10;</span><br><span class="line">   // 下面是声明常量的实例</span><br><span class="line">   public static final int BOXWIDTH = 6;</span><br><span class="line">   static final String TITLE = &quot;Manager&quot;;</span><br><span class="line"> </span><br><span class="line">   public void changeValue()&#123;</span><br><span class="line">      value = 12; //将输出一个错误</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>final 方法：<br>类中的 Final 方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。如下所示，使用 final 修饰符声明方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123; public final void changeName()&#123; // 方法体 &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>final 类：<br>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Test &#123; // 类体 &#125;</span><br></pre></td></tr></table></figure>

<p>abstract 修饰符</p>
<p>抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。</p>
<p><strong>如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。抽象类可以包含抽象方法和非抽象方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class Caravan&#123;</span><br><span class="line">   private double price;</span><br><span class="line">   private String model;</span><br><span class="line">   private String year;</span><br><span class="line">   public abstract void goFast(); //抽象方法</span><br><span class="line">   public abstract void changeColor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象方法<br>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。抽象方法的声明以分号结尾，例如：public abstract sample();</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SuperClass&#123;</span><br><span class="line">   abstract void m(); //抽象方法</span><br><span class="line">&#125;</span><br><span class="line">class SubClass extends SuperClass&#123;</span><br><span class="line">    //实现抽象方法</span><br><span class="line">     void m()&#123;</span><br><span class="line">         .........</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h5><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。Synchronized 修饰符可以应用于四个访问修饰符。</p>
<p>实例：public synchronized void showDetails(){<br>…….<br>} </p>
<h5 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h5><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机 (JVM) 跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>
<p>public transient int limit &#x3D; 55; &#x2F;&#x2F; will not persist<br>public int b; &#x2F;&#x2F; will persist</p>
<h5 id="volatile修饰符"><a href="#volatile修饰符" class="headerlink" title="volatile修饰符"></a>volatile修饰符</h5><p>volatile 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>一个 volatile 对象引用可能是 null。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private volatile boolean active;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        active = true;</span><br><span class="line">        while (active) // line 1</span><br><span class="line">        &#123;</span><br><span class="line">            // 代码</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop()</span><br><span class="line">    &#123;</span><br><span class="line">        active = false; // line 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般地，在一个线程中调用run()方法，在另一个线程中调用stop()方法。如果line 1中的active位于缓冲区的值被使用，那么当把line 2中的active设置成false时，循环也不会停止。</p>
<h4 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h4><p>可以把运算符分成以下几组：<br>算术运算符<br>关系运算符<br>位运算符<br>逻辑运算符<br>赋值运算符<br>其他运算符</p>
<h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p>表格中的实例假设整数变量A的值为10，变量B的值为20：</p>
<ul>
<li>加法 - 相加运算符两侧的值</li>
</ul>
<ul>
<li>减法 - 左操作数减去右操作数</li>
</ul>
<ul>
<li>乘法 - 相乘操作符两侧的值</li>
</ul>
<p>&#x2F;<br>除法 - 左操作数除以右操作数</p>
<p>％<br>取模 - 左操作数除以右操作数的余数</p>
<p>++<br>自增 - 操作数的值增加1</p>
<p>–<br>自减 - 操作数的值减少1</p>
<p> 虽然都是自增（他们的运算结果都是等于B+1），但B++和++B还是有所区别，++B是左值，直接原地操作（可以理解为直接在变量B上+1），B++是右值，在编译器中运算的时候会先构建一个临时变量，用临时变量运算+1后再赋值给B。所以，在下面实例代码中，打印d++的时候发现结果并没有+1（这个时候打印的是d这个变量，运算的是d的临时变量），但是后一条打印的语句显示的结果又是+1后的结果（临时变量的值赋给变量d了）。而打印++d的结果是直接+1的。</p>
<p>实例<br>下面的简单示例程序演示了算术运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      int a = 10;</span><br><span class="line">      int b = 20;</span><br><span class="line">      int c = 25;</span><br><span class="line">      int d = 25;</span><br><span class="line">      System.out.println(&quot;a + b = &quot; + (a + b) );</span><br><span class="line">      System.out.println(&quot;a - b = &quot; + (a - b) );</span><br><span class="line">      System.out.println(&quot;a * b = &quot; + (a * b) );</span><br><span class="line">      System.out.println(&quot;b / a = &quot; + (b / a) );</span><br><span class="line">      System.out.println(&quot;b % a = &quot; + (b % a) );</span><br><span class="line">      System.out.println(&quot;c % a = &quot; + (c % a) );</span><br><span class="line">      System.out.println(&quot;a++   = &quot; +  (a++) );</span><br><span class="line">      System.out.println(&quot;a--   = &quot; +  (a--) );</span><br><span class="line">      // 查看  d++ 与 ++d 的不同</span><br><span class="line">      System.out.println(&quot;d++   = &quot; +  (d++) );</span><br><span class="line">      System.out.println(&quot;d     = &quot; +  d);</span><br><span class="line">      System.out.println(&quot;++d   = &quot; +  (++d) );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<p>&#x3D;&#x3D;<br>检查如果两个操作数的值是否相等，如果相等则条件为真。</p>
<p>!&#x3D;<br>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</p>
<blockquote>
<p>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</p>
</blockquote>
<p>&lt;<br>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</p>
<blockquote>
<p>&#x3D;<br>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</p>
</blockquote>
<p>&lt;&#x3D;<br>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</p>
<p>实例<br>下面的简单示例程序演示了关系运算符。复制并粘贴下面的Java程序并保存为Test.java文件，然后编译并运行这个程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      int a = 10;</span><br><span class="line">      int b = 20;</span><br><span class="line">      System.out.println(&quot;a == b = &quot; + (a == b) );</span><br><span class="line">      System.out.println(&quot;a != b = &quot; + (a != b) );</span><br><span class="line">      System.out.println(&quot;a &gt; b = &quot; + (a &gt; b) );</span><br><span class="line">      System.out.println(&quot;a &lt; b = &quot; + (a &lt; b) );</span><br><span class="line">      System.out.println(&quot;b &gt;= a = &quot; + (b &gt;= a) );</span><br><span class="line">      System.out.println(&quot;b &lt;= a = &quot; + (b &lt;= a) );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。<br>位运算符作用在所有的位上，并且按位运算。假设a &#x3D; 60，和b &#x3D; 13;它们的二进制格式表示将如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = 0011 1100</span><br><span class="line">B = 0000 1101</span><br><span class="line">-----------------</span><br><span class="line">A&amp;B = 0000 1100</span><br><span class="line">A | B = 0011 1101</span><br><span class="line">A ^ B = 0011 0001</span><br><span class="line">~A= 1100 0011</span><br></pre></td></tr></table></figure>

<p>下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13：</p>
<p>＆<br>按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。<br>（A＆B），得到12，即0000 1100<br>|<br>按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。</p>
<p>（A | B）得到61，即 0011 1101<br>^<br>按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。</p>
<p>（A ^ B）得到49，即 0011 0001<br>〜<br>按位补运算符翻转操作数的每一位。</p>
<p>（〜A）得到-61，即1100 0011</p>
<p>&lt;&lt;<br>按位左移运算符。左操作数按位左移右操作数指定的位数。</p>
<p>A &lt;&lt; 2得到240，即 1111 0000</p>
<blockquote>
<p>按位右移运算符。左操作数按位右移右操作数指定的位数。</p>
</blockquote>
<p>A &gt;&gt; 2得到15即 1111</p>
<blockquote>
<p>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</p>
</blockquote>
<p>A&gt;&gt;&gt;2得到15即0000 1111</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      int a = 60; /* 60 = 0011 1100 */</span><br><span class="line">      int b = 13; /* 13 = 0000 1101 */</span><br><span class="line">      int c = 0;</span><br><span class="line">      c = a &amp; b;       /* 12 = 0000 1100 */</span><br><span class="line">      System.out.println(&quot;a &amp; b = &quot; + c );</span><br><span class="line"> </span><br><span class="line">      c = a | b;       /* 61 = 0011 1101 */</span><br><span class="line">      System.out.println(&quot;a | b = &quot; + c );</span><br><span class="line"> </span><br><span class="line">      c = a ^ b;       /* 49 = 0011 0001 */</span><br><span class="line">      System.out.println(&quot;a ^ b = &quot; + c );</span><br><span class="line"> </span><br><span class="line">      c = ~a;          /*-61 = 1100 0011 */</span><br><span class="line">      System.out.println(&quot;~a = &quot; + c );</span><br><span class="line"> </span><br><span class="line">      c = a &lt;&lt; 2;     /* 240 = 1111 0000 */</span><br><span class="line">      System.out.println(&quot;a &lt;&lt; 2 = &quot; + c );</span><br><span class="line">      c = a &gt;&gt; 2;     /* 215 = 1111 */</span><br><span class="line">      System.out.println(&quot;a &gt;&gt; 2  = &quot; + c );</span><br><span class="line">   </span><br><span class="line">      c = a &gt;&gt;&gt; 2;     /* 215 = 0000 1111 */</span><br><span class="line">      System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + c );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<p>&amp;&amp;<br>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</p>
<p>| |<br>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</p>
<p>！<br>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      boolean a = true;</span><br><span class="line">      boolean b = false;</span><br><span class="line">      System.out.println(&quot;a &amp;&amp; b = &quot; + (a&amp;&amp;b));</span><br><span class="line">      System.out.println(&quot;a || b = &quot; + (a||b) );</span><br><span class="line">      System.out.println(&quot;!(a &amp;&amp; b) = &quot; + !(a &amp;&amp; b));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>&#x3D;<br>简单的赋值运算符，将右操作数的值赋给左侧操作数</p>
<ul>
<li>&#x3D;<br>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</li>
</ul>
<ul>
<li>&#x3D;<br>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</li>
</ul>
<ul>
<li>&#x3D;<br>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</li>
</ul>
<p>&#x2F; &#x3D;<br>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</p>
<p>％&#x3D;<br>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</p>
<p>&lt;&lt; &#x3D;<br>左移位赋值运算符</p>
<blockquote>
<blockquote>
<p>&#x3D;<br>右移位赋值运算符</p>
</blockquote>
</blockquote>
<p>^ &#x3D;<br>按位异或赋值操作符</p>
<h5 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h5><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<p>variable x &#x3D; (expression) ? value if true : value if false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      int a , b;  </span><br><span class="line">      a = 10;    </span><br><span class="line">      b = (a == 1) ? 20: 30;    </span><br><span class="line">      System.out.println( &quot;Value of b is : &quot; +  b );</span><br><span class="line">      b = (a == 10) ? 20: 30;    </span><br><span class="line">      System.out.println( &quot;Value of b is : &quot; + b );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h5><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。instanceof运算符使用格式如下：</p>
<p>( Object reference variable ) instanceof (class&#x2F;interface type)</p>
<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。下面是一个例子：</p>
<p>String name &#x3D; ‘James’;<br>boolean result &#x3D; name instanceof String; &#x2F;&#x2F; 由于name是String类型，所以返回真</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Vehicle &#123;&#125;</span><br><span class="line">public class Car extends Vehicle &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Vehicle a = new Car();</span><br><span class="line">      boolean result =  a instanceof Car;</span><br><span class="line">      System.out.println( result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java运算符优先级</p>
<img src="/post/undefined/429.png" class title="This is an image">



<h4 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h4><p>Java中有三种主要的循环结构：while循环do…while循环for循环</p>
<p>while循环while是最基本的循环，它的结构为：<br>while( 布尔表达式 ) {<br>        &#x2F;&#x2F;循环内容<br>}</p>
<p>do…while循环对于while语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while循环和while循环相似，不同的是，do…while循环至少会执行一次。</p>
<p>do {<br>&#x2F;&#x2F;代码语句<br>}while(布尔表达式);</p>
<p>注意：布尔表达式在循环体的后面，所以语句块在检测布尔表达式之前已经执行了。 如果布尔表达式的值为true，则语句块一直执行，直到布尔表达式的值为false。</p>
<p>for循环</p>
<p>虽然所有循环结构都可以用while或者do…while表示，但Java提供了另一种语句 —— for循环，使一些循环结构变得更加简单。for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<p>for(初始化; 布尔表达式; 更新) { &#x2F;&#x2F;代码语句 }</p>
<p>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。执行一次循环后，更新循环控制变量。再次检测布尔表达式。循环执行上面的过程。</p>
<p><strong>与c里面的规则一样的。</strong></p>
<p>Java增强for循环</p>
<p>for(声明语句 : 表达式) { &#x2F;&#x2F;代码句子 }</p>
<p>声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p>表达式：表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line">      for(int x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(&quot;\n&quot;);</span><br><span class="line">      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;</span><br><span class="line">      for( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与python里面的迭代有一点相似。</p>
<p>break关键字</p>
<p>break主要用在循环语句或者switch语句中，用来跳出整个语句块。break跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<p>continue关键字</p>
<p>continue适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在for循环中，continue语句使程序立即跳转到更新语句。在while或者do…while循环中，程序立即跳转到布尔表达式的判断语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line">      for(int x : numbers ) &#123;</span><br><span class="line">         if( x == 30 ) &#123;</span><br><span class="line">         continue;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(&quot;\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-分支结构-if…else-x2F-switch"><a href="#Java-分支结构-if…else-x2F-switch" class="headerlink" title="Java 分支结构 - if…else&#x2F;switch"></a>Java 分支结构 - if…else&#x2F;switch</h4><p>if语句一个if语句包含一个布尔表达式和一条或多条语句。</p>
<p>if(布尔表达式) { &#x2F;&#x2F;如果布尔表达式为true将执行的语句 }</p>
<p>if…else 语句if 语句后面可以跟 else 语句，当if语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<p>if(布尔表达式){ &#x2F;&#x2F;如果布尔表达式的值为true }else{ &#x2F;&#x2F;如果布尔表达式的值为false }</p>
<p>if…else if…else 语句</p>
<p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。使用if，else if，else语句的时候，需要注意下面几点：</p>
<p>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</p>
<p>If 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</p>
<p>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</p>
<p>if(布尔表达式 1){<br>   &#x2F;&#x2F;如果布尔表达式 1的值为true执行代码<br>}else if(布尔表达式 2){<br>   &#x2F;&#x2F;如果布尔表达式 2的值为true执行代码<br>}else if(布尔表达式 3){<br>   &#x2F;&#x2F;如果布尔表达式 3的值为true执行代码<br>}else {<br>   &#x2F;&#x2F;如果以上布尔表达式都不为true执行代码<br>}</p>
<p>switch 语句</p>
<p>switch 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<p>switch(expression){<br>   case value :<br>      &#x2F;&#x2F;语句<br>      break; &#x2F;&#x2F;可选<br>   case value :<br>      &#x2F;&#x2F;语句<br>      break; &#x2F;&#x2F;可选<br>   &#x2F;&#x2F;你可以有任意数量的case语句<br>   default : &#x2F;&#x2F;可选<br>      &#x2F;&#x2F;语句<br>}<br>switch 语句中的变量类型只能为 byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</p>
<p>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</p>
<p>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</p>
<p>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到break语句出现才会跳出 switch 语句。</p>
<p>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。<br>switch 语句可以包含一个 default 分支，该分支必须是 switch 语句的最后一个分支。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      //char grade = args[0].charAt(0);</span><br><span class="line">      char grade = &#x27;C&#x27;;</span><br><span class="line">      switch(grade)</span><br><span class="line">      &#123;</span><br><span class="line">         case &#x27;A&#x27; :</span><br><span class="line">            System.out.println(&quot;优秀&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#x27;B&#x27; :</span><br><span class="line">         case &#x27;C&#x27; :</span><br><span class="line">            System.out.println(&quot;良好&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &#x27;D&#x27; :</span><br><span class="line">            System.out.println(&quot;及格&quot;);</span><br><span class="line">         case &#x27;F&#x27; :</span><br><span class="line">            System.out.println(&quot;你需要继续努力&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default :</span><br><span class="line">            System.out.println(&quot;无效等级&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;你的等级是 &quot; + grade);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-Number类"><a href="#Java-Number类" class="headerlink" title="Java Number类"></a>Java Number类</h4><p>一般情况下我们会使用数据的基本数据类型：byte、int、short、long、double、float、boolean、char；对应的包装类型也有八种：Byte、Integer、Short、Long、Double、Float、Character、Boolean;包装类型都是用 final 声明了，不可以被继承重写；在实际情况中编译器会自动的将基本数据类型装箱成对象类型，或者将对象类型拆箱成基本数据类型；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   int num1 = 1;</span><br><span class="line">   //将基本数据类型装箱成对象包装类型</span><br><span class="line">   Integer num2 = num1;</span><br><span class="line">   Integer num3 = 3;</span><br><span class="line">   //将对象数据类拆箱</span><br><span class="line">   int num4 = num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Number 类是 java.lang 包下的一个抽象类，提供了将包装类型拆箱成基本类型的方法，所有基本类型（数据类型）的包装类型都继承了该抽象类，并且是final声明不可继承改变；</p>
<figure class="highlight plaintext"><figcaption><span>package java.lang;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class Number implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    public abstract int intValue();</span><br><span class="line"></span><br><span class="line">    public abstract long longValue();</span><br><span class="line"></span><br><span class="line">    public abstract float floatValue();</span><br><span class="line"></span><br><span class="line">    public abstract double doubleValue();</span><br><span class="line"></span><br><span class="line">    public byte byteValue() &#123;</span><br><span class="line">        return (byte)intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public short shortValue() &#123;</span><br><span class="line">        return (short)intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -8742448824652078965L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/post/undefined/430.png" class title="This is an image">

<p>这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。</p>
<p>下面是一个装箱与拆箱的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       Integer x = 5; // boxes int to an Integer object</span><br><span class="line">       x =  x + 10;   // unboxes the Integer to a int</span><br><span class="line">       System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当x被赋为整型值时，由于 x 是一个对象，所以编译器要对x进行装箱。然后，为了使x能进行加运算，所以要对x进行拆箱。</p>
<h5 id="Java-Math类"><a href="#Java-Math类" class="headerlink" title="Java Math类"></a>Java Math类</h5><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       Integer x = 5; // boxes int to an Integer object</span><br><span class="line">       x =  x + 10;   // unboxes the Integer to a int</span><br><span class="line">       System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>Number &amp; Math 类方法</p>
<p>xxxValue()<br>将number对象转换为xxx数据类型的值并返回。  </p>
<p>compareTo()<br>将number对象与参数比较。</p>
<p>equals()<br>判断number对象是否与参数相等。</p>
<p>valueOf()<br>返回一个Integer对象指定的内置数据类型</p>
<p>toString()<br>以字符串形式返回值。</p>
<p>parseInt()<br>将字符串解析为int类型。</p>
<p>abs()<br>返回参数的绝对值。</p>
<p>ceil()<br>返回大于等于( &gt;&#x3D; )给定参数的的最小整数，类型为双精度浮点型。</p>
<p>floor()<br>返回小于等于（&lt;&#x3D;）给定参数的最大整数 。</p>
<p>rint()<br>返回与参数最接近的整数。返回类型为double。</p>
<p>round()<br>返回一个最接近的int、long型值。</p>
<p>min()<br>返回两个参数中的最小值。</p>
<p>max()<br>返回两个参数中的最大值。</p>
<p>exp()<br>返回自然数底数e的参数次方。</p>
<p>log()<br>返回参数的自然数底数的对数值。</p>
<p>pow()<br>返回第一个参数的第二个参数次方。</p>
<p>sqrt()<br>求参数的算术平方根。</p>
<p>sin()<br>求指定double类型参数的正弦值。</p>
<p>cos()<br>求指定double类型参数的余弦值。</p>
<p>tan()<br>求指定double类型参数的正切值。</p>
<p>asin()<br>求指定double类型参数的反正弦值。</p>
<p>acos()<br>求指定double类型参数的反余弦值。</p>
<p>atan()<br>求指定double类型参数的反正切值。</p>
<p>atan2()<br>将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</p>
<p>toDegrees()<br>将参数转化为角度。</p>
<p>toRadians()<br>将角度转换为弧度。</p>
<p>random()<br>返回一个随机数。</p>
<h4 id="Java-Character类"><a href="#Java-Character类" class="headerlink" title="Java Character类"></a>Java Character类</h4><p>使用字符时，我们通常使用的是内置数据类型 char。<br>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java 语言为内置数据类型 char 提供了包装类 Character 类。</p>
<p>Character类的用法：Character 类提供了一系列方法来操纵字符，你可以使用 Character 的构造方法创建一个 Character 类对象，例如：</p>
<p>Character ch &#x3D; new Character(‘a’);<br>在某些情况下，Java 编译器会自动创建一个 Character 对象。例如，将一个 char 类型的参数传递给需要一个 Character 类型参数时，那么编译器会自动地将 char 类型参数转换为 Character 对象。 这种特征称为装箱，反过来称为拆箱。 </p>
<p>&#x2F;&#x2F; Here following primitive char ‘a’<br>&#x2F;&#x2F; is boxed into the Character object ch<br>Character ch &#x3D; ‘a’;<br>&#x2F;&#x2F; Here primitive ‘x’ is boxed for method test,<br>&#x2F;&#x2F; return is unboxed to char ‘c’<br>char c &#x3D; test(‘x’);</p>
<p>转义序列<br>\t<br>在文中该处插入一个tab键</p>
<p>\b<br>在文中该处插入一个后退键</p>
<p>\n<br>在文中该处换行</p>
<p>\r<br>在文中该处插入回车</p>
<p>\f<br>在文中该处插入换页符</p>
<p>&#39;<br>在文中该处插入单引号</p>
<p>&quot;<br>在文中该处插入双引号</p>
<p>\<br>在文中该处插入反斜杠</p>
<p>实例<br>当打印语句遇到一个转义序列时，编译器可以正确地对其进行解释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       System.out.println(&quot;She said \&quot;Hello!\&quot; to me.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h5><p>isLetter()<br>是否是一个字母</p>
<p>isDigit()<br>是否是一个数字字符</p>
<p>isWhitespace()<br>是否一个空格</p>
<p>isUpperCase()<br>是否是大写字母</p>
<p>isLowerCase()<br>是否是小写字母</p>
<p>toUpperCase()<br>指定字母的大写形式</p>
<p>toLowerCase()<br>指定字母的小写形式</p>
<p>toString()<br>返回字符的字符串形式，字符串的长度仅为1</p>
<p>初学者会经常使用的几个方法</p>
<p>public static boolean isUpperCase(char ch): 判断给定的字符是否是大写字符；</p>
<p>public static boolean isLowerCase(char ch): 判断给定的字符是否是小写字符；</p>
<p>public static boolean isDigit(char ch): 判断给定的字符是否是数字字符；</p>
<p>这三个句子里的boolean代表，这三个方法使用后的返回值是 boolean 型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Java &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Character ch = new Character(&#x27;X&#x27;);</span><br><span class="line">       </span><br><span class="line">        System.out.println(Character.isUpperCase(ch));</span><br><span class="line">        //Character.isUpperCase(ch) 用于判断括号里的字母是否为大写</span><br><span class="line">        System.out.println(Character.isLowerCase(ch));</span><br><span class="line">        //Character.isLowerCase(ch) 用于判断括号里的字母是否为小写</span><br><span class="line">        System.out.println(Character.isDigit(ch));</span><br><span class="line">        //Character.isDigit(ch) 用于判断括号里的内容是否为数字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-String类"><a href="#Java-String类" class="headerlink" title="Java String类"></a>Java String类</h4><p>创建字符串创建字符串最简单的方式如下:String greeting &#x3D; “Hello world!”;</p>
<p>在代码中遇到字符串常量时，这里的值是 “Hello world!” ，编译器会使用该值创建一个 String 对象。和其它对象一样，可以使用关键字和构造方法来创建String对象。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StringDemo&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       char[] helloArray = &#123; &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;.&#x27;&#125;;</span><br><span class="line">       String helloString = new String(helloArray);  </span><br><span class="line">       System.out.println( helloString );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p>
<p>字符串长度<br>用于获取有关对象的信息的方法称为访问器方法。String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class StringDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">       String palindrome = &quot;Dot saw I was Tod&quot;;</span><br><span class="line">       int len = palindrome.length();</span><br><span class="line">       System.out.println( &quot;String Length is : &quot; + len );</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h5><p>String 类提供了连接两个字符串的方法：<br>string1.concat(string2);</p>
<p>返回 string2 连接 string1 的新字符串。也可以对字符串常量使用 concat() 方法，如：</p>
<p>“My name is “.concat(“Zara”);</p>
<p>更常用的是使用’+’操作符来连接字符串，如：</p>
<p>“Hello,” + “ world” + “!”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StringDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;    </span><br><span class="line">       String string1 = &quot;saw I was &quot;;    </span><br><span class="line">       System.out.println(&quot;Dot &quot; + string1 + &quot;Tod&quot;);  </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="创建格式化字符串"><a href="#创建格式化字符串" class="headerlink" title="创建格式化字符串"></a>创建格式化字符串</h5><p>我们知道输出格式化数字可以使用 printf() 和 format() 方法。String 类使用静态方法 format() 返回一个 String 对象而不是 PrintStream 对象。String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String fs;</span><br><span class="line">fs = String.format(&quot;The value of the float variable is &quot; +</span><br><span class="line">                   &quot;%f, while the value of the integer &quot; +</span><br><span class="line">                   &quot;variable is %d, and the string &quot; +</span><br><span class="line">                   &quot;is %s&quot;, floatVar, intVar, stringVar);</span><br><span class="line">System.out.println(fs);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(&quot;The value of the float variable is &quot; +</span><br><span class="line">                  &quot;%f, while the value of the integer &quot; +</span><br><span class="line">                  &quot;variable is %d, and the string &quot; +</span><br><span class="line">                  &quot;is %s&quot;, floatVar, intVar, stringVar);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h5><p>char charAt(int index)<br>返回指定索引处的 char 值。</p>
<p>int compareTo(Object o)<br>把这个字符串和另一个对象比较。</p>
<p>int compareTo(String anotherString)<br>按字典顺序比较两个字符串。</p>
<p>int compareToIgnoreCase(String str)<br>按字典顺序比较两个字符串，不考虑大小写。</p>
<p>String concat(String str)<br>将指定字符串连接到此字符串的结尾。</p>
<p>boolean contentEquals(StringBuffer sb)<br>当且仅当字符串与指定的StringButter有相同顺序的字符时候返回真。</p>
<p>static String copyValueOf(char[] data)<br>返回指定数组中表示该字符序列的 String。</p>
<p>static String copyValueOf(char[] data, int offset, int count)<br>返回指定数组中表示该字符序列的 String。</p>
<p>boolean endsWith(String suffix)<br>测试此字符串是否以指定的后缀结束。</p>
<p>boolean equals(Object anObject)<br>将此字符串与指定的对象比较。</p>
<p>boolean equalsIgnoreCase(String anotherString)<br>将此 String 与另一个 String 比较，不考虑大小写。</p>
<p>byte[] getBytes()<br> 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>
<p>byte[] getBytes(String charsetName)<br>使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</p>
<p>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。</p>
<p>int hashCode()<br>返回此字符串的哈希码。</p>
<p>int indexOf(int ch)<br>返回指定字符在此字符串中第一次出现处的索引。</p>
<p>int indexOf(int ch, int fromIndex)<br>返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</p>
<p>int indexOf(String str)<br> 返回指定子字符串在此字符串中第一次出现处的索引。</p>
<p>int indexOf(String str, int fromIndex)<br>返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</p>
<p>String intern()<br> 返回字符串对象的规范化表示形式。</p>
<p>int lastIndexOf(int ch)<br> 返回指定字符在此字符串中最后一次出现处的索引。</p>
<p>int lastIndexOf(int ch, int fromIndex)<br>返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</p>
<p>int lastIndexOf(String str)<br>返回指定子字符串在此字符串中最右边出现处的索引。</p>
<p>int lastIndexOf(String str, int fromIndex)<br> 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</p>
<p>int length()<br>返回此字符串的长度。</p>
<p>boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式。</p>
<p>boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。</p>
<p>boolean regionMatches(int toffset, String other, int ooffset, int len)<br>测试两个字符串区域是否相等。</p>
<p>String replace(char oldChar, char newChar)<br>返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</p>
<p>String replaceAll(String regex, String replacement<br>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</p>
<p>String replaceFirst(String regex, String replacement)<br> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
<p>String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串。</p>
<p>String[] split(String regex, int limit)<br>根据匹配给定的正则表达式来拆分此字符串。</p>
<p>boolean startsWith(String prefix)<br>测试此字符串是否以指定的前缀开始。</p>
<p>boolean startsWith(String prefix, int toffset)<br>测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</p>
<p>CharSequence subSequence(int beginIndex, int endIndex)<br> 返回一个新的字符序列，它是此序列的一个子序列。</p>
<p>String substring(int beginIndex)<br>返回一个新的字符串，它是此字符串的一个子字符串。</p>
<p>String substring(int beginIndex, int endIndex)<br>返回一个新字符串，它是此字符串的一个子字符串。</p>
<p>char[] toCharArray()<br>将此字符串转换为一个新的字符数组。</p>
<p>String toLowerCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</p>
<p>String toLowerCase(Locale locale)<br> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</p>
<p>String toString()<br> 返回此对象本身（它已经是一个字符串！）。</p>
<p>String toUpperCase()<br>使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</p>
<p>String toUpperCase(Locale locale)<br>使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</p>
<p>String trim()<br>返回字符串的副本，忽略前导空白和尾部空白。</p>
<p>static String valueOf(primitive data type x)<br>返回给定data type类型x参数的字符串表示形式。</p>
<h4 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h4><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和String类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">       StringBuffer sBuffer = new StringBuffer(&quot; test&quot;);</span><br><span class="line">       sBuffer.append(&quot; String Buffer&quot;);</span><br><span class="line">       System.out.println(sBuffer);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h5><p>public StringBuffer append(String s)<br>将指定的字符串追加到此字符序列。</p>
<p>public StringBuffer reverse()<br> 将此字符序列用其反转形式取代。</p>
<p> public delete(int start, int end)<br>移除此序列的子字符串中的字符。</p>
<p>public insert(int offset, int i)<br>将 int 参数的字符串表示形式插入此序列中。</p>
<p>replace(int start, int end, String str)<br>使用给定 String 中的字符替换此序列的子字符串中的字符。</p>
<p>下面的列表里的方法和 String 类的方法类似：</p>
<p>int capacity()<br>返回当前容量。</p>
<p>char charAt(int index)<br>返回此序列中指定索引处的 char 值。</p>
<p>void ensureCapacity(int minimumCapacity)<br>确保容量至少等于指定的最小值。</p>
<p>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<br>将字符从此序列复制到目标字符数组 dst。</p>
<p>int indexOf(String str)<br>返回第一次出现的指定子字符串在该字符串中的索引。</p>
<p>int indexOf(String str, int fromIndex)<br>从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</p>
<p>int lastIndexOf(String str)<br>返回最右边出现的指定子字符串在此字符串中的索引。</p>
<p>int lastIndexOf(String str, int fromIndex)<br>返回最后一次出现的指定子字符串在此字符串中的索引。</p>
<p>int length()<br> 返回长度（字符数）。</p>
<p> void setCharAt(int index, char ch)<br>将给定索引处的字符设置为 ch。</p>
<p>void setLength(int newLength)<br>设置字符序列的长度。</p>
<p>CharSequence subSequence(int start, int end)<br>返回一个新的字符序列，该字符序列是此序列的子序列。</p>
<p>String substring(int start)<br>返回一个新的 String，它包含此字符序列当前所包含的字符子序列。</p>
<p>String substring(int start, int end)<br>返回一个新的 String，它包含此序列当前所包含的字符子序列。</p>
<p>String toString()<br>返回此序列中数据的字符串表示形式。</p>
<h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h4><p>Java 语言中提供的数组是用来存储固定大小的同类型元素。你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，….，number99。</p>
<h5 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h5><p>dataType[] arrayRefVar;   &#x2F;&#x2F; 首选的方法<br>或<br>dataType arrayRefVar[];  &#x2F;&#x2F; 效果相同，但不是首选方法</p>
<p>注意: 建议使用 dataType[] arrayRefVar 的声明风格声明数组变量。 dataType arrayRefVar[] 风格是来自 C&#x2F;C++ 语言 ，在Java中采用是为了让  C&#x2F;C++  程序员能够快速理解 java 语言。</p>
<h5 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h5><p>Java 语言使用 new操作符来创建数组，语法如下：</p>
<p>arrayRefVar &#x3D; new dataType[arraySize];</p>
<p>上面的语法语句做了两件事：<br>一、使用 dataType[arraySize] 创建了一个数组。<br>二、把新创建的数组的引用赋值给变量 arrayRefVar。</p>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<p>dataType[] arrayRefVar &#x3D; new dataType[arraySize];<br>另外，你还可以使用如下的方式创建数组。</p>
<p>dataType[] arrayRefVar &#x3D; {value0, value1, …, valuek};</p>
<p>数组的元素是通过索引访问的。数组索引从0开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<p>那么当数组开辟空间之后，就可以采用如下的方式的操作：</p>
<p>数组的访问通过索引完成，即：“数组名称[索引]”，但是需要注意的是，数组的索引从0开始，所以索引的范围就是0 ~ 数组长度-1，例如开辟了3个空间的数组，所以可以使用的索引是：0,1,2，如果此时访问的时候超过了数组的索引范围，会产生 java.lang.ArrayIndexOutOfBoundsException 异常信息；</p>
<p>当我们数组采用动态初始化开辟空间后，数组里面的每一个元素都是该数组对应数据类型的默认值；</p>
<p>数组本身是一个有序的集合操作，所以对于数组的内容操作往往会采用循环的模式完成，数组是一个有限的数据集合，所以应该使用 for 循环。</p>
<p>在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int data[] = new int[3]; /*开辟了一个长度为3的数组*/</span><br><span class="line">        data[0] = 10; // 第一个元素</span><br><span class="line">        data[1] = 20; // 第二个元素</span><br><span class="line">        data[2] = 30; // 第三个元素</span><br><span class="line">        for(int x = 0; x &lt; data.length; x++) &#123;</span><br><span class="line">            System.out.println(data[x]); //通过循环控制索引</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组本身除了声明并开辟空间之外还有另外一种开辟模式。示例： 采用分步的模式开辟数组空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayDemo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int data[] = null;</span><br><span class="line">        data = new int[3]; /*开辟了一个长度为3的数组*/</span><br><span class="line">        data[0] = 10; // 第一个元素</span><br><span class="line">        data[1] = 20; // 第二个元素</span><br><span class="line">        data[2] = 30; // 第三个元素</span><br><span class="line">        for(int x = 0; x &lt; data.length; x++) &#123;</span><br><span class="line">            System.out.println(data[x]); //通过循环控制索引</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是千万要记住，数组属于引用数据类型，所以在数组使用之前一定要开辟空间（实例化），如果使用了没有开辟空间的数组，则一定会出现 NullPointerException 异常信息：</p>
<p>这一原则和之前讲解的对象是完全相同的。数组在开发之中一定会使用，但是像上面的操作很少。在以后的实际开发之中，会更多的使用数组概念，而直接使用，大部分情况下都只是做一个 for 循环输出。</p>
<h5 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h5><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 foreach 循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;;</span><br><span class="line"> </span><br><span class="line">       // 打印所有数组元素</span><br><span class="line">       for (int i = 0; i &lt; myList.length; i++) &#123;</span><br><span class="line">           System.out.println(myList[i] + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算所有元素的总和</span><br><span class="line">        double total = 0;</span><br><span class="line">        for (int i = 0; i &lt; myList.length; i++) &#123;</span><br><span class="line">           total += myList[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Total is &quot; + total);</span><br><span class="line">        // 查找最大元素</span><br><span class="line">        double max = myList[0];</span><br><span class="line">        for (int i = 1; i &lt; myList.length; i++) &#123;</span><br><span class="line">           if (myList[i] &gt; max) max = myList[i];</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(&quot;Max is &quot; + max);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h5 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h5><p>JDK 1.5 引进了一种新的循环类型，被称为 foreach 循环或者加强型循环，它能在不使用下标的情况下遍历数组。语法格式如下：</p>
<p>for(type element: array){<br>    System.out.println(element);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestArray &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;;</span><br><span class="line"> </span><br><span class="line">       // 打印所有数组元素</span><br><span class="line">       for (double element: myList) &#123;</span><br><span class="line">          System.out.println(element);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组作为函数的参数"><a href="#数组作为函数的参数" class="headerlink" title="数组作为函数的参数"></a>数组作为函数的参数</h5><p>数组可以作为参数传递给方法。例如，下面的例子就是一个打印 int 数组中元素的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void printArray(int[] array) &#123;</span><br><span class="line">    for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">       System.out.print(array[i] + &quot; &quot;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组作为函数的返回值"><a href="#数组作为函数的返回值" class="headerlink" title="数组作为函数的返回值"></a>数组作为函数的返回值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int[] reverse(int[] list) &#123;</span><br><span class="line">    int[] result = new int[list.length];</span><br><span class="line"> </span><br><span class="line">    for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) &#123;</span><br><span class="line">       result[j] = list[i];</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h5><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。具有以下功能：</p>
<p>给数组赋值：通过 fill 方法。<br>对数组排序：通过 sort 方法,按升序。<br>比较数组：通过 equals 方法比较数组中元素值是否相等。<br>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</p>
<p>public static int binarySearch(Object[] a, Object key)<br>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</p>
<p>public static boolean equals(long[] a, long[] a2)<br>如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<p>public static void fill(int[] a, int val)<br>将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<p>public static void sort(Object[] a)<br>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</p>
<h4 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h4><p>java.util包提供了Date类来封装当前的日期和时间。 Date类提供两个构造函数来实例化Date对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。<br>Date( )</p>
<p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。</p>
<p>Date(long millisec)</p>
<p>Date对象创建以后，可以调用下面的方法。</p>
<p>boolean after(Date date)<br>若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</p>
<p>boolean before(Date date)<br>若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</p>
<p>Object clone( )<br>返回此对象的副本。</p>
<p>int compareTo(Date date)<br>比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</p>
<p>int compareTo(Object obj)<br>若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</p>
<p>boolean equals(Object date)<br>当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</p>
<p>long getTime( )<br>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p>
<p>int hashCode( )<br> 返回此对象的哈希码值。9void setTime(long time)</p>
<p>用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</p>
<p>String toString( )<br>转换Date对象为String表示形式，并返回该字符串。</p>
<h5 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h5><p>Java中获取当前日期和时间很简单，使用Date对象的 toString()方法来打印当前日期和时间，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">       // 初始化 Date 对象</span><br><span class="line">       Date date = new Date();</span><br><span class="line">       </span><br><span class="line">       // 使用 toString() 函数显示日期时间</span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h5><p>Java使用以下三种方法来比较两个日期：使用getTime( ) 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</p>
<p>使用方法before()，after()和equals()。例如，一个月的12号比18号早，则new Date(99, 2, 12).before(new Date (99, 2, 18))返回true。</p>
<p>使用compareTo()方法，它是由Comparable接口定义的，Date类实现了这个接口。</p>
<h5 id="使用SimpleDateFormat格式化日期"><a href="#使用SimpleDateFormat格式化日期" class="headerlink" title="使用SimpleDateFormat格式化日期"></a>使用SimpleDateFormat格式化日期</h5><p>SimpleDateFormat是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat允许你选择任何用户自定义日期时间格式来运行。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      Date dNow = new Date( );</span><br><span class="line">      SimpleDateFormat ft =</span><br><span class="line">      new SimpleDateFormat (&quot;E yyyy.MM.dd &#x27;at&#x27; hh:mm:ss a zzz&quot;);</span><br><span class="line">      System.out.println(&quot;Current Date: &quot; + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="简单的DateFormat格式化编码"><a href="#简单的DateFormat格式化编码" class="headerlink" title="简单的DateFormat格式化编码"></a>简单的DateFormat格式化编码</h5><p>时间模式字符串用来指定时间格式。在此模式中，所有的ASCII字母被保留为模式字母，定义如下：</p>
<img src="/post/undefined/431.png" class title="This is an image">

<p>使用printf格式化日期<br>printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以t开头并且以下面表格中的一个字母结尾。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line">     // 初始化 Date 对象</span><br><span class="line">     Date date = new Date();</span><br><span class="line">     // 使用toString()显示日期和时间</span><br><span class="line">     String str = String.format(&quot;Current Date/Time : %tc&quot;, date );</span><br><span class="line">     System.out.printf(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。索引必须紧跟在%后面，而且必须以$结束。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">       // 初始化 Date 对象</span><br><span class="line">       Date date = new Date();</span><br><span class="line">       </span><br><span class="line">       // 使用toString()显示日期和时间</span><br><span class="line">       System.out.printf(&quot;%1$s %2$tB %2$td, %2$tY&quot;,</span><br><span class="line">                         &quot;Due date:&quot;, date);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，你可以使用&lt;标志。它表明先前被格式化的参数要被再次使用。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">       // 初始化 Date 对象</span><br><span class="line">       Date date = new Date();</span><br><span class="line">       </span><br><span class="line">       // 显示格式化时间</span><br><span class="line">       System.out.printf(&quot;%s %tB %&lt;te, %&lt;tY&quot;,</span><br><span class="line">                           &quot;Due date:&quot;, date);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="日期和时间转换字符"><a href="#日期和时间转换字符" class="headerlink" title="日期和时间转换字符"></a>日期和时间转换字符</h5><p><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/java/java-date-time.html">详细的表看这</a></p>
<h5 id="解析字符串为时间"><a href="#解析字符串为时间" class="headerlink" title="解析字符串为时间"></a>解析字符串为时间</h5><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line"> </span><br><span class="line">public class DateDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);</span><br><span class="line">      String input = args.length == 0 ? &quot;1818-11-11&quot; : args[0];</span><br><span class="line">      System.out.print(input + &quot; Parses as &quot;);</span><br><span class="line">      Date t;</span><br><span class="line">      try &#123;</span><br><span class="line">          t = ft.parse(input);</span><br><span class="line">          System.out.println(t);</span><br><span class="line">      &#125; catch (ParseException e) &#123;</span><br><span class="line">          System.out.println(&quot;Unparseable using &quot; + ft);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Java-休眠-sleep"><a href="#Java-休眠-sleep" class="headerlink" title="Java 休眠(sleep)"></a>Java 休眠(sleep)</h5><p>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。例如，下面的程序会休眠3秒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class SleepDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         System.out.println(new Date( ) + &quot;\n&quot;);</span><br><span class="line">         Thread.sleep(5*60*10);</span><br><span class="line">         System.out.println(new Date( ) + &quot;\n&quot;);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          System.out.println(&quot;Got an exception!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测量时间"><a href="#测量时间" class="headerlink" title="测量时间"></a>测量时间</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"> </span><br><span class="line">public class DiffDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         long start = System.currentTimeMillis( );</span><br><span class="line">         System.out.println(new Date( ) + &quot;\n&quot;);</span><br><span class="line">         Thread.sleep(5*60*10);</span><br><span class="line">         System.out.println(new Date( ) + &quot;\n&quot;);</span><br><span class="line">         long end = System.currentTimeMillis( );</span><br><span class="line">         long diff = end - start;</span><br><span class="line">         System.out.println(&quot;Difference is : &quot; + diff);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         System.out.println(&quot;Got an exception!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h5><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p>
<p>创建一个代表系统当前日期的Calendar对象</p>
<p>Calendar c &#x3D; Calendar.getInstance();&#x2F;&#x2F;默认是当前日期</p>
<p>创建一个指定日期的Calendar对象</p>
<p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成</p>
<p>&#x2F;&#x2F;创建一个代表2009年6月12日的Calendar对象<br>Calendar c1 &#x3D; Calendar.getInstance();<br>c1.set(2009, 6 - 1, 12);</p>
<p>Calendar类对象字段类型<br>Calendar类中用一下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p>
<p>Calendar.YEAR<br>年份</p>
<p>Calendar.MONTH<br>月份</p>
<p>Calendar.DATE<br>日期</p>
<p>Calendar.DAY_OF_MONTH<br>日期，和上面的字段意义完全相同</p>
<p>Calendar.HOUR<br>12小时制的小时</p>
<p>Calendar.HOUR_OF_DAY<br>24小时制的小时</p>
<p>Calendar.MINUTE<br>分钟</p>
<p>Calendar.SECOND<br>秒</p>
<p>Calendar.DAY_OF_WEEK<br>星期几</p>
<p>Calendar类对象信息的设置<br>Set设置<br>Calendar c1 &#x3D; Calendar.getInstance();</p>
<p>调用：<br>public final void set(int year,int month,int date)<br>c1.set(2009, 6 - 1, 12);&#x2F;&#x2F;把Calendar对象c1的年月日分别设这为：2009、5、12<br>利用字段类型设置如果只设定某个字段，例如日期的值，则可以使用如下set方法：</p>
<p>public void set(int field,int value)</p>
<p>把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算</p>
<p>c1.set(Calendar.DATE,10);</p>
<p>把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算</p>
<p>c1.set(Calendar.YEAR,2008);</p>
<p>其他字段属性set的意义以此类推</p>
<p>Add设置<br>Calendar c1 &#x3D; Calendar.getInstance();</p>
<p>把c1对象的日期加上10，也就是c1所表的日期的10天后的日期，其它所有的数值会被重新计算<br>c1.add(Calendar.DATE, 10);</p>
<p>把c1对象的日期减去10，也就是c1所表的日期的10天前的日期，其它所有的数值会被重新计算<br>c1.add(Calendar.DATE, -10);</p>
<p>其他字段属性的add的意义以此类推</p>
<p>Calendar类对象信息的获得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">// 获得年份</span><br><span class="line">int year = c1.get(Calendar.YEAR);</span><br><span class="line">// 获得月份</span><br><span class="line">int month = c1.get(Calendar.MONTH) + 1;</span><br><span class="line">// 获得日期</span><br><span class="line">int date = c1.get(Calendar.DATE);</span><br><span class="line">// 获得小时</span><br><span class="line">int hour = c1.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">// 获得分钟</span><br><span class="line">int minute = c1.get(Calendar.MINUTE);</span><br><span class="line">// 获得秒</span><br><span class="line">int second = c1.get(Calendar.SECOND);</span><br><span class="line">// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）</span><br><span class="line">int day = c1.get(Calendar.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure>
<p>GregorianCalendar类<br>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这些代表公历定义的两个时代。</p>
<p>下面列出GregorianCalendar对象的几个构造方法：<br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/java/java-date-time.html">详细的看这</a></p>
<h4 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h4><p>java.util.regex包主要包括以下三个类：</p>
<p>Pattern类：pattern对象是一个正则表达式的编译表示。Pattern类没有公共构造方法。要创建一个Pattern对象，你必须首先调用其公共静态编译方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数。</p>
<p>Matcher类：Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象。</p>
<p>PatternSyntaxException：PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>例如，正则表达式(dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p>
<p>捕获组是通过从左至右计算其开括号来编号。例如，在表达式（（A）（B（C））），有四个这样的组：</p>
<p>((A)(B(C)))<br>(A)<br>(B(C))<br>(C)</p>
<p>可以通过调用matcher对象的groupCount方法来查看表达式有多少个分组。groupCount方法返回一个int值，表示matcher对象当前有多个捕获组。</p>
<p>还有一个特殊的组（组0），它总是代表整个表达式。该组不包括在groupCount的返回值中。</p>
<p>实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String args[] )&#123;</span><br><span class="line">      // 按指定模式在字符串查找</span><br><span class="line">      String line = &quot;This order was placed for QT3000! OK?&quot;;</span><br><span class="line">      String pattern = &quot;(.*)(\\d+)(.*)&quot;;</span><br><span class="line">      // 创建 Pattern 对象</span><br><span class="line">      Pattern r = Pattern.compile(pattern);</span><br><span class="line">      // 现在创建 matcher 对象</span><br><span class="line">      Matcher m = r.matcher(line);</span><br><span class="line">      if (m.find( )) &#123;</span><br><span class="line">         System.out.println(&quot;Found value: &quot; + m.group(0) );</span><br><span class="line">         System.out.println(&quot;Found value: &quot; + m.group(1) );</span><br><span class="line">         System.out.println(&quot;Found value: &quot; + m.group(2) );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         System.out.println(&quot;NO MATCH&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式语法<br><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/java/java-regular-expressions.html">表格请看这里</a></p>
<p>Matcher类的方法</p>
<h5 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h5><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p>
<p>public int start()<br>返回以前匹配的初始索引。</p>
<p>public int start(int group)<br> 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</p>
<p> public int end()<br>返回最后匹配字符之后的偏移量。</p>
<p>public int end(int group)<br>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</p>
<h5 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h5><p>研究方法用来检查输入字符串并返回一个布尔值，表示是否找到该模式：<br>public boolean lookingAt()<br> 尝试将从区域开头开始的输入序列与该模式匹配。</p>
<p> public boolean find()<br>尝试查找与该模式匹配的输入序列的下一个子序列。</p>
<p>public boolean find(int start）<br>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</p>
<p>public boolean matches()<br>尝试将整个区域与模式匹配。</p>
<h5 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h5><p>替换方法是替换输入字符串里文本的方法：</p>
<p>public Matcher appendReplacement(StringBuffer sb, String replacement)<br>实现非终端添加和替换步骤。</p>
<p>public StringBuffer appendTail(StringBuffer sb)<br>实现终端添加和替换步骤。</p>
<p>public String replaceAll(String replacement)<br> 替换模式与给定替换字符串相匹配的输入序列的每个子序列。</p>
<p> public String replaceFirst(String replacement)<br> 替换模式与给定替换字符串匹配的输入序列的第一个子序列。</p>
<p> public static String quoteReplacement(String s)<br>返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。</p>
<h5 id="start-和end-方法"><a href="#start-和end-方法" class="headerlink" title="start 和end 方法"></a>start 和end 方法</h5><p>下面是一个对单词”cat”出现在输入字符串中出现次数进行计数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">    private static final String REGEX = &quot;\\bcat\\b&quot;;</span><br><span class="line">    private static final String INPUT =</span><br><span class="line">                                    &quot;cat cat cat cattie cat&quot;;</span><br><span class="line">    public static void main( String args[] )&#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       Matcher m = p.matcher(INPUT); // 获取 matcher 对象</span><br><span class="line">       int count = 0;</span><br><span class="line">       while(m.find()) &#123;</span><br><span class="line">         count++;</span><br><span class="line">         System.out.println(&quot;Match number &quot;+count);</span><br><span class="line">         System.out.println(&quot;start(): &quot;+m.start());</span><br><span class="line">         System.out.println(&quot;end(): &quot;+m.end());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个例子是使用单词边界，以确保字母 “c” “a” “t” 并非仅是一个较长的词的子串。它也提供了一些关于输入字符串中匹配发生位置的有用信息。Start方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end方法最后一个匹配字符的索引加1。</p>
<h5 id="matches-和lookingAt-方法"><a href="#matches-和lookingAt-方法" class="headerlink" title="matches 和lookingAt 方法"></a>matches 和lookingAt 方法</h5><p>matches 和lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是matches要求整个序列都匹配，而lookingAt 不要求。这两个方法经常在输入字符串的开始使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">    private static final String REGEX = &quot;foo&quot;;</span><br><span class="line">    private static final String INPUT = &quot;fooooooooooooooooo&quot;;</span><br><span class="line">    private static Pattern pattern;</span><br><span class="line">    private static Matcher matcher;</span><br><span class="line">    public static void main( String args[] )&#123;</span><br><span class="line">       pattern = Pattern.compile(REGEX);</span><br><span class="line">       matcher = pattern.matcher(INPUT);</span><br><span class="line">       System.out.println(&quot;Current REGEX is: &quot;+REGEX);</span><br><span class="line">       System.out.println(&quot;Current INPUT is: &quot;+INPUT);</span><br><span class="line">       System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt());</span><br><span class="line">       System.out.println(&quot;matches(): &quot;+matcher.matches());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="replaceFirst-和replaceAll-方法"><a href="#replaceFirst-和replaceAll-方法" class="headerlink" title="replaceFirst 和replaceAll 方法"></a>replaceFirst 和replaceAll 方法</h5><p>replaceFirst 和replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。下面的例子来解释这个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">    private static String REGEX = &quot;dog&quot;;</span><br><span class="line">    private static String INPUT = &quot;The dog says meow. &quot; +</span><br><span class="line">                                    &quot;All dogs say meow.&quot;;</span><br><span class="line">    private static String REPLACE = &quot;cat&quot;;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       Pattern p = Pattern.compile(REGEX);</span><br><span class="line">       // get a matcher object</span><br><span class="line">       Matcher m = p.matcher(INPUT);</span><br><span class="line">       INPUT = m.replaceAll(REPLACE);</span><br><span class="line">       System.out.println(INPUT);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h5><p>Matcher 类也提供了appendReplacement 和appendTail 方法用于文本替换：看下面的例子来解释这个功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">   private static String REGEX = &quot;a*b&quot;;</span><br><span class="line">   private static String INPUT = &quot;aabfooaabfooabfoob&quot;;</span><br><span class="line">   private static String REPLACE = &quot;-&quot;;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Pattern p = Pattern.compile(REGEX);</span><br><span class="line">      // 获取 matcher 对象</span><br><span class="line">      Matcher m = p.matcher(INPUT);</span><br><span class="line">      StringBuffer sb = new StringBuffer();</span><br><span class="line">      while(m.find())&#123;</span><br><span class="line">         m.appendReplacement(sb,REPLACE);</span><br><span class="line">      &#125;</span><br><span class="line">      m.appendTail(sb);</span><br><span class="line">      System.out.println(sb.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PatternSyntaxException-类的方法"><a href="#PatternSyntaxException-类的方法" class="headerlink" title="PatternSyntaxException 类的方法"></a>PatternSyntaxException 类的方法</h5><p>PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。</p>
<p>public String getDescription()<br>获取错误的描述。</p>
<p>public int getIndex()<br> 获取错误的索引。</p>
<p> public String getPattern()<br>获取错误的正则表达式模式。</p>
<p>public String getMessage()<br>返回多行字符串，包含语法错误及其索引的描述、错误的正则表达式模式和模式中错误索引的可视化指示。</p>
<h4 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h4><p>在前面几个章节中我们经常使用到System.out.println()，那么它是什么呢？println()是一个方法(Method)，而System是系统类(Class)，out是标准输出对象(Object)。这句话的用法是调用系统类System中的标准输出对象out中的方法println()。</p>
<p>那么什么是方法呢？Java方法是语句的集合，它们在一起执行一个功能。<br>方法是解决一类问题的步骤的有序组合<br>方法包含于类或对象中<br>方法在程序中被创建，在其他地方被引用</p>
<p>方法的定义</p>
<p>修饰符 返回值类型 方法名 (参数类型 参数名){<br>   …<br>   方法体<br>   …<br>   return 返回值;<br>}</p>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<p>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
<p>返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void。</p>
<p>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</p>
<p>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p>
<p>方法体：方法体包含具体的语句，定义该方法的功能。</p>
<p>public static int age(int birthday){…}<br>注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestMax &#123;</span><br><span class="line">   /** 主方法 */</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int i = 5;</span><br><span class="line">      int j = 2;</span><br><span class="line">      int k = max(i, j);</span><br><span class="line">      System.out.println(&quot;The maximum between &quot; + i +</span><br><span class="line">                    &quot; and &quot; + j + &quot; is &quot; + k);</span><br><span class="line">   &#125;</span><br><span class="line">   /** 返回两个整数变量较大的值 */</span><br><span class="line">   public static int max(int num1, int num2) &#123;</span><br><span class="line">      int result;</span><br><span class="line">      if (num1 &gt; num2)&#123;</span><br><span class="line">         result = num1;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         result = num2;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序包含main方法和max方法。Main方法是被JVM调用的，除此之外，main方法和其它方法没什么区别。main方法的头部是不变的，如例子所示，带修饰符public和static,返回void类型值，方法名字是main,此外带个一个String[]类型参数。String[]表明参数是字符串数组。</p>
<p>void 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestVoidMethod &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      printGrade(78.5);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void printGrade(double score) &#123;</span><br><span class="line">      if (score &gt;= 90.0) &#123;</span><br><span class="line">         System.out.println(&#x27;A&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (score &gt;= 80.0) &#123;</span><br><span class="line">         System.out.println(&#x27;B&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (score &gt;= 70.0) &#123;</span><br><span class="line">         System.out.println(&#x27;C&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if (score &gt;= 60.0) &#123;</span><br><span class="line">         System.out.println(&#x27;D&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">         System.out.println(&#x27;F&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过值传递参数</p>
<p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void nPrintln(String message, int n) &#123;</span><br><span class="line">   for (int i = 0; i &lt; n; i++)</span><br><span class="line">      System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子演示按值传递的效果。该程序创建一个方法，该方法用于交换两个变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TestPassByValue &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int num1 = 1;</span><br><span class="line">      int num2 = 2;</span><br><span class="line">      System.out.println(&quot;Before swap method, num1 is &quot; +</span><br><span class="line">                          num1 + &quot; and num2 is &quot; + num2);</span><br><span class="line">      // 调用swap方法</span><br><span class="line">      swap(num1, num2);</span><br><span class="line">      System.out.println(&quot;After swap method, num1 is &quot; +</span><br><span class="line">                         num1 + &quot; and num2 is &quot; + num2);</span><br><span class="line">   &#125;</span><br><span class="line">   /** 交换两个变量的方法 */</span><br><span class="line">   public static void swap(int n1, int n2) &#123;</span><br><span class="line">      System.out.println(&quot;\tInside the swap method&quot;);</span><br><span class="line">      System.out.println(&quot;\t\tBefore swapping n1 is &quot; + n1</span><br><span class="line">                           + &quot; n2 is &quot; + n2);</span><br><span class="line">      // 交换 n1 与 n2的值</span><br><span class="line">      int temp = n1;</span><br><span class="line">      n1 = n2;</span><br><span class="line">      n2 = temp;</span><br><span class="line">      System.out.println(&quot;\t\tAfter swapping n1 is &quot; + n1</span><br><span class="line">                           + &quot; n2 is &quot; + n2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。</p>
<p>方法的重载<br>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static double max(double num1, double num2) &#123;</span><br><span class="line">  if (num1 &gt; num2)&#123;</span><br><span class="line">    return num1;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；<br>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；<br>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。<br>Java编译器根据方法签名判断哪个方法应该被调用。方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<p>变量作用域</p>
<p>变量的范围是程序中该变量可以被引用的部分。<br>方法内定义的变量被称为局部变量。<br>局部变量的作用范围从声明开始，直到包含它的块结束。<br>局部变量必须声明才可以使用。<br>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。<br>for循环的初始化部分声明的变量，其作用范围在整个循环。<br>但循环体内声明的变量其适用范围是从它声明到循环体结束。</p>
<p>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。</p>
<p>命令行参数的使用</p>
<p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。命令行参数是在执行程序时候紧跟在程序名字后面的信息。</p>
<p>实例<br>下面的程序打印所有的命令行参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CommandLine &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      for(int i=0; i&lt;args.length; i++)&#123;          </span><br><span class="line">          System.out.println(&quot;args [&quot; + i + &quot;]: &quot; + args[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>构造方法</p>
<p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。<br>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0。一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class MyClass &#123;</span><br><span class="line">   int x;</span><br><span class="line">   </span><br><span class="line">   // 以下是构造函数</span><br><span class="line">   MyClass() &#123;</span><br><span class="line">      x = 10;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像下面这样调用构造方法来初始化一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConsDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      MyClass t1 = new MyClass();</span><br><span class="line">      MyClass t2 = new MyClass();</span><br><span class="line">      System.out.println(t1.x + &quot; &quot; + t2.x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变参数<br>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。方法的可变参数的声明如下所示：</p>
<p>typeName… parameterName</p>
<p>在方法声明中，在指定参数类型后加一个省略号(…) 。一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class VarargsDemo &#123;</span><br><span class="line">   public static void main(String args[]) &#123;</span><br><span class="line">      // 调用可变参数的方法</span><br><span class="line">     printMax(34, 3, 3, 2, 56.5);</span><br><span class="line">      printMax(new double[]&#123;1, 2, 3&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void printMax( double... numbers) &#123;</span><br><span class="line">   if (numbers.length == 0) &#123;</span><br><span class="line">      System.out.println(&quot;No argument passed&quot;);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   double result = numbers[0];</span><br><span class="line">   for (int i = 1; i &lt;  numbers.length; i++)</span><br><span class="line">       if (numbers[i] &gt;  result)&#123;</span><br><span class="line">          result = numbers[i];</span><br><span class="line">       &#125;</span><br><span class="line">      System.out.println(&quot;The max value is &quot; + result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finalize() 方法<br>Java允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做finalize( )，它用来清除回收对象。例如，你可以使用finalize()来确保一个对象打开的文件被关闭了。在finalize()方法里，你必须指定在对象销毁时候要执行的操作。finalize()一般格式是：</p>
<p>protected void finalize() {    &#x2F;&#x2F; 在这里终结代码 }</p>
<p>关键字protected是一个限定符，它确保finalize() 方法不会被该类以外的代码调用。当然，Java的内存回收可以由JVM来自动完成。如果你手动使用，则可以使用上面的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FinalizationDemo &#123;  </span><br><span class="line">   public static void main(String[] args) &#123;  </span><br><span class="line">       Cake c1 = new Cake(1);  </span><br><span class="line">       Cake c2 = new Cake(2);  </span><br><span class="line">       Cake c3 = new Cake(3);  </span><br><span class="line">         </span><br><span class="line">       c2 = c3 = null;  </span><br><span class="line">       System.gc(); //调用Java垃圾收集器</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">class Cake extends Object &#123;  </span><br><span class="line">   private int id;  </span><br><span class="line">   public Cake(int id) &#123;  </span><br><span class="line">       this.id = id;  </span><br><span class="line">       System.out.println(&quot;Cake Object &quot; + id + &quot;is created&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">     </span><br><span class="line">   protected void finalize() throws java.lang.Throwable &#123;  </span><br><span class="line">       super.finalize();  </span><br><span class="line">       System.out.println(&quot;Cake Object &quot; + id + &quot;is disposed&quot;);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://1yzf2zstgiyhub.io">漂亮鬼</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://1yzf2zstgiyhub.io/post/f2602444.html">http://1yzf2zstgiyhub.io/post/f2602444.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://1yzf2zstgiyhub.io" target="_blank">漂亮鬼</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-62e385ce9ecac8a4" async="async"></script></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picx.zhimg.com/v2-6576f8c64444c40baa4602979c75d1e3_r.jpg?source=3af55fa1" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">漂亮鬼</div><div class="author-info__description">爱干饭的程序员--嘿嘿</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">71</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/1yzf2zst/1yzf2zst.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220823/IMG_4539(20220823-200421).750ofrla5w40.webp" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220823/B8E86698E2D953CD7245DBFA591CDB59.3y2c2f2kdxy0.webp" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/1yzf2zst" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2562644984@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}
</style><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎各位， 各位来到xiaoyang的blog
博主发布的博文都是博主学习笔记
qq:2562644984</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Java 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">Java标识符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">Java修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Java变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text">Java关键字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">Java 对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">Java中的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Java中的类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99"><span class="toc-number">2.5.</span> <span class="toc-text">源文件声明规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%8C%85"><span class="toc-number">2.6.</span> <span class="toc-text">Java包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Java 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">内置数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">Java常量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Java 变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.1.</span> <span class="toc-text">Java局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">实例变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">类变量（静态变量）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">Java 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">访问控制修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-private"><span class="toc-number">5.2.</span> <span class="toc-text">私有访问修饰符-private</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public"><span class="toc-number">5.3.</span> <span class="toc-text">公有访问修饰符-public</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">非访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.1.</span> <span class="toc-text">static修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">final 修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.3.</span> <span class="toc-text">synchronized 修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transient-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.4.</span> <span class="toc-text">transient 修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#volatile%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.5.</span> <span class="toc-text">volatile修饰符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">Java 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.4.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.5.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">条件运算符（?:）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">7.7.</span> <span class="toc-text">instanceof 运算符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-for-while-%E5%8F%8A-do%E2%80%A6while"><span class="toc-number">8.</span> <span class="toc-text">Java 循环结构 - for, while 及 do…while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if%E2%80%A6else-x2F-switch"><span class="toc-number">9.</span> <span class="toc-text">Java 分支结构 - if…else&#x2F;switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Number%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">Java Number类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-Math%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">Java Math类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Character%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">Java Character类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Character-%E6%96%B9%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">Character 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-String%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">Java String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.1.</span> <span class="toc-text">连接字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.2.</span> <span class="toc-text">创建格式化字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">String 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-StringBuffer-%E5%92%8C-StringBuilder-%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">Java StringBuffer 和 StringBuilder 类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringBuffer-%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">StringBuffer 方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%95%B0%E7%BB%84"><span class="toc-number">14.</span> <span class="toc-text">Java 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="toc-number">14.1.</span> <span class="toc-text">声明数组变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">14.2.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-number">14.3.</span> <span class="toc-text">处理数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#foreach-%E5%BE%AA%E7%8E%AF"><span class="toc-number">14.4.</span> <span class="toc-text">foreach 循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">14.5.</span> <span class="toc-text">数组作为函数的参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">14.6.</span> <span class="toc-text">数组作为函数的返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Arrays-%E7%B1%BB"><span class="toc-number">14.7.</span> <span class="toc-text">Arrays 类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">15.</span> <span class="toc-text">Java 日期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">15.1.</span> <span class="toc-text">获取当前日期时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%AF%94%E8%BE%83"><span class="toc-number">15.2.</span> <span class="toc-text">日期比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SimpleDateFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">15.3.</span> <span class="toc-text">使用SimpleDateFormat格式化日期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84DateFormat%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%BC%96%E7%A0%81"><span class="toc-number">15.4.</span> <span class="toc-text">简单的DateFormat格式化编码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6"><span class="toc-number">15.5.</span> <span class="toc-text">日期和时间转换字符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E6%97%B6%E9%97%B4"><span class="toc-number">15.6.</span> <span class="toc-text">解析字符串为时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-%E4%BC%91%E7%9C%A0-sleep"><span class="toc-number">15.7.</span> <span class="toc-text">Java 休眠(sleep)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E6%97%B6%E9%97%B4"><span class="toc-number">15.8.</span> <span class="toc-text">测量时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">15.9.</span> <span class="toc-text">Calendar类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">Java 正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E7%BB%84"><span class="toc-number">16.1.</span> <span class="toc-text">捕获组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E6%B3%95"><span class="toc-number">16.2.</span> <span class="toc-text">索引方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95"><span class="toc-number">16.3.</span> <span class="toc-text">研究方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.</span> <span class="toc-text">替换方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#start-%E5%92%8Cend-%E6%96%B9%E6%B3%95"><span class="toc-number">16.5.</span> <span class="toc-text">start 和end 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#matches-%E5%92%8ClookingAt-%E6%96%B9%E6%B3%95"><span class="toc-number">16.6.</span> <span class="toc-text">matches 和lookingAt 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#replaceFirst-%E5%92%8CreplaceAll-%E6%96%B9%E6%B3%95"><span class="toc-number">16.7.</span> <span class="toc-text">replaceFirst 和replaceAll 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#appendReplacement-%E5%92%8C-appendTail-%E6%96%B9%E6%B3%95"><span class="toc-number">16.8.</span> <span class="toc-text">appendReplacement 和 appendTail 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PatternSyntaxException-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">16.9.</span> <span class="toc-text">PatternSyntaxException 类的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E6%96%B9%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">Java 方法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/f2602444.html" title="Java基础学习笔记"><img src="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-dg6rk3.4vgrzrx10s60.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础学习笔记"/></a><div class="content"><a class="title" href="/post/f2602444.html" title="Java基础学习笔记">Java基础学习笔记</a><time datetime="2022-10-25T15:02:31.000Z" title="发表于 2022-10-25 23:02:31">2022-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d50ffcd6.html" title="mysql基础学习笔记"><img src="https://picx.zhimg.com/v2-6576f8c64444c40baa4602979c75d1e3_r.jpg?source=3af55fa1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql基础学习笔记"/></a><div class="content"><a class="title" href="/post/d50ffcd6.html" title="mysql基础学习笔记">mysql基础学习笔记</a><time datetime="2022-10-23T07:24:04.000Z" title="发表于 2022-10-23 15:24:04">2022-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/9026a025.html" title="matplotlib小项目--绘制学生成绩雷达图"><img src="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-6k38g7.4z8ybi7h04g0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="matplotlib小项目--绘制学生成绩雷达图"/></a><div class="content"><a class="title" href="/post/9026a025.html" title="matplotlib小项目--绘制学生成绩雷达图">matplotlib小项目--绘制学生成绩雷达图</a><time datetime="2022-10-19T06:33:57.000Z" title="发表于 2022-10-19 14:33:57">2022-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/8710c1f.html" title="matplotlib基础知识"><img src="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-39v5w6.3a1mh3cv6uk0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="matplotlib基础知识"/></a><div class="content"><a class="title" href="/post/8710c1f.html" title="matplotlib基础知识">matplotlib基础知识</a><time datetime="2022-10-18T15:46:08.000Z" title="发表于 2022-10-18 23:46:08">2022-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/25258312.html" title="c语言常见函数"><img src="https://cdn.staticaly.com/gh/1yzf2zst/images@main/20220806/wallhaven-lqrlyl.1v85vdp912w0.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c语言常见函数"/></a><div class="content"><a class="title" href="/post/25258312.html" title="c语言常见函数">c语言常见函数</a><time datetime="2022-10-17T05:11:14.000Z" title="发表于 2022-10-17 13:11:14">2022-10-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picx.zhimg.com/v2-d1098f823452d83e34ce0aa6b6c484ae_r.jpg?source=3af55fa1')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 漂亮鬼</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello,  welcome  to   <a  target="_blank" rel="noopener" href="https://1yzf2zst.github.io/">小杨的blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/snowflake.js"></script><script src="https://cdn.jsdelivr.net/gh/caicheng918/CDN@4.0/res/mouse_snow.js"></script><script src="/js/funny.js"></script><div class="aplayer no-destroy" data-id="6686195784" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"left","hOffset":-30,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>