<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql基础学习笔记</title>
      <link href="/post/d50ffcd6.html"/>
      <url>/post/d50ffcd6.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d1f67e1d047fbfbb2139e6546944f654bdc2966b7a812b4dc95bf0be7ccd83c0">724b48b5ef2059e37b316826ce40c1b628f533749eb5622cb5ace5ff9e3b6552968f610d4afca3d57cb5c6326faf77b08dc27f4381afd03fbe5f94cbbc73c4567fbe0358a3bd35314c46241ef15feab8a09f2a0c7011e462e63bd9bee4241b8bcda9b55d74d1bacdabeaca98eda6713b5f1e0bde6adc3466bca326f9a525952e49bf12fa15395115b75847bd64e605bc7b8684c17428abe2be46f76b5eb45be36c0bcb3ac24bae4be402d72ba5f8c7eab0d2a976898b92f10b8f5a68e7e4057277ac8140ca3602e60522d56a1374b8de639027ff569be1861c5eacfb557714b4b46172f8001c74b2c22e7d4c91965e43818f90a2b7507ee40c8e2e3a5a1a41db99a18c00866e109e69e9521291ab33dd37e74b284e4eb5d37c54d09b1775d65798e717524894206c65b20a9425e6e19db3c60e5167a865909bd7f9c50a2623f5cf5d90184087375845ef2cc316ccf146cf5ff939254768322b4e989329b9901b92ee2ed445b0dbeea7d4ce754918311776eee7cdc3ed745e4390608c47dd445e22be071b46b44bd2903d2ecfae74473ad01a970ca7b3a52edd2b356e243d4f3ba15230dd764fefa8890e6599415106d874af643e089226c888c481267180351b449cd970919524ecaa505ba45e6613604690d98367f48619d636dfe690104f0ad5ad4596848e885ec0f60b4fc41acc11808cea8b27375d9c0a311a24eb6aa5e9426a6521da3165ceb5a91cbefd2188ed246267b3f5e5d45eabccf4ef2b305b6daad430b56a175755bef780c2e90ef1fd3948d53e8bcc96e1473e1062ecd0ad3ad0cca5b7f6f91b092fcf1fd43326c1bb0889f0af5f715835f241316800be581792c14f0fb80033ee569db4dddd4a7b24bd850c2eba51271b62df00448ed0cdcbd556773c95062add58bb5fe5619da5f06d5a259f9799c191f83374d61d7a9af70f0bfa1c95bff6d964f52a30f6dae4d9a142a4f47eac498a74ea17fd1b645569cf86278b447a184d8f7004b2fb3aa0f0c4f361ca44f15165b433e8086055c9ecbf93aa39da03d056655911c9fc15c502a27bf57514c5be74bafabc1c3f8c0f2f928be349d3fc7d2b95079aecdb6d793a099017dad976d61dfbd9b7263dc8fedf524aaf6424d8829e3ea63ef8dd80f0ef9d52e1bbb4db7468fd06c3dfc726cf0e66a688509b2c752a3840e38382241b722f969725b5dcd8ac451e45b17fb33cc20f551a0bf387dc39c856240e9359d6523554f0eff64f450dfb693703df12cabecacaf6a314674b62058ddd6ca2b7d1471d3c9611eb5d5767f83265091c4ae4ed3eab8243c67799cc6d728a7538415f1cf6231bb3d224c1cf7404380482b55b2b3bbf303f4cd85a26db2c6b6ba9e9350efb91f8773876dcd967597e229ce1836bacc5346d3bd2ed474e4fe605501621ac4fa931170656b5096bec8e53a2febfd1b7173996127833762dffb47a5a2e6642fabe5464c86d78fff7a4d47f19221c9880946f67d9ba5399369dc5c92a9b6163b8d046699bb2a309a989bb53b1559f9077d9c79dfb228ed41892de1c56c1313484ca988763a9610625fd6ccf8e448797677baf9c9fd1cdc218fe558cd30e1ea3d38b7f36c14c7758d117e3931206474f9ea543e96ae9232bc9d26813cd8be5c905502c9f81ab411364424ad23b907f849a102a6b9e65e7edad21245fafe5e7710cad44d78b3bfd6700bc5b39efbf11aa7c7352657f56716870f81095baf32a5a55ca50d98ddbf194c18b0d8219862ca4ebc69ac44767dc4266e31dd7fcceff97e40b430913adb24f8471b12401de1151e4a154e48e39c3848f0d78a66975f374cda1eb2d6ed68315246de6a2109d7ab76d5fd03721627efadb560ae9d650742ce7090986caca2d2bb5fda832d21c6ec23d853d55e9da5c08e7d0cdbfa3bee3ff7ef0c1e18eaf0cb23fda31533452312c16c1c0ecc386bcc78d620296edf6a763c0b8f5be6487399e6ff20e818bdf88aa54f107ca3ef5ce34f7cd934455d5fb223321ad0ab98b52ac2785e3f3ca1943414e7fd1fc348534ee9c551b2d5bffcd58c630aadbeb3dba4ed59c251a263e1cecbc97eeadc61f10e6dc44b81b44a5cb8e183957be724c7726cf58e22515259815d630601f712a81500677f230fbb1dd2e106cc10c9353991ba036dc0f501b2ff0e15e4aa7c7c2fd5579cd010a4dea8964a7b077009c03fe382557ae68ad8537d1d30cdf0e67f71836d6c6a18a336fe6727fd1d3d0e9cee1109cf3da51dd8523b7656de24fb596763f35e5c79921c1fda2f06c2968fb48db7b11b33da2df964da2f51a49a18e3099c020989acb0a834b48d6705b132cd1d822320d9eb1e23bbb0fa59c2043536e7285d12da90c66b79d61b8aa498ee671247ddcdddae2402a945192de455b74b1d4374b0814c9c1b6fa239f7e48b22f3eee84a4aabb8f172539d15d9ea93bc446dc30a6108843fd08fad432635143ffc5a79895788cd61da24443dbe768821f086d8d58f2ebffd163a824547690d13a76853517becdffc12df7add62be88a4880bf43d2b40492238b7b56df88ef479ce7f79b086c613c9fb1f2d65c8d11ed272e06ac5c7a7b33167e8ead1853aa435e70aceaddf4e653da631631652529c0fa7b781db45e07863b6c4e10898b9cb64daf26e4671adaf1becf901fb9e6c5774d1b8709135ee3e68c712cb3ad198b33beb7c95a6b1bfebed406a0a8945b3c8f0f697a790ae19cbdaffbdea0ef02d0272be89f6543dd7015a7593cf3af7226a43eef63f4310610e5b88ad717bb8f74740d071f30ec223fa36d3b73aa84faff3f249c68c63e8e9f8ff3ec4400a1d8a4c6c082badd3c60c18e3bc4b209398f6185021d0804c390ff9dd8867a420aeced043bd960ced647c0beee6846517b4304196ff3be9568e164696f486b6eac125bdc76a70148afd23ab1e70564deab37f38bec426ec20b6be6d01ae99fa88011ab8b59b8d45c6a0d70924859d76e608fb2d73c493cd71ead95477a4cb86e14589250a8a6ad0906fcf17e589aaaa54f7cd7cf9893f5384dcfcfd0c503b8bdc4d4dc75c7666c05c9ae2ecb0a3a3ce913b5fd9daa368e365e730e403b3a73ba70e03c15000abff094b75588135aa6143094f0a0c6a80fe882588ed89a1ee240f3e0ab249bda4aff5c56fbeb115537e17437cb3412223ee6696b165a0a781893ddb1f222310e988c9818f97cbf9370fc32c8340157c94c14dda0ea997914e6d2b0008355fa0b58ef1e3ac60c4992716853ecbfa5a30b8117cb1f474da5214bb6c437ed8b5161cf218bad61289bf22990d8f6fd10d5e729f912d927520b81740eafa907e0c6b02b5bda3702a978aed89e6ada15f6ca3e320187081627178abba6bae2b62d2502d21aa6d22cd03d0c8703f38d97d00041339eb9e314fca327f3aeb09c206bdf572807daa4b50f93c506dec0d01da59a2eb011d6301c9568da5f1acf0deb6d39a1497393ea5b36f797ec69e89864ca37f5bd7a5d78fd48ff293ca2f1b0df37d109ecdf728dc3f471a7f2daa2f67c8700da52a03bfa9fe211026368ca251e7bbc7071fb4a3a7a91c526826a52b1c3d215436825cb2835539328e48f471490c6daf4e1c107fe1fbf3b2f9da0abc1fc7d0d1da2bb70c984db9106d1bab1d3c6766203c9b396a453e5d0743dea7211a0c668c1bc6ba47ecf0696873240efaa3c887b7d70a159cdb4a5fdd4c49c6c50b1995d3d75f3e6be6cdfd2e050302897f32e7e23db1efd1d5973c7b0c6c48c22f3ea309b1acbb4263af29bf0047d6792be75622edb7e1ef9747296ff8ded7020802ca5cd98a572007bd86aaddae7033518125c39c27ccb60d94b1bc21c72e7c730086df4f025f684aaeaa839744675c9bdc01cd1932404f192745c51cbecfd94f52a848f0ef261a116d722a6db8c9b7577677b80a0703b7a0d7ab49d81e3f272d1988beefe18818e4915f7d029054f4dce020b4b93d31e40afe4bd4510e46b93f93f59e2638e8a9d19ff6a78394689160e6e48725e2819e07ec01002f733fc0778ed93b7f34b218d70e6f1bc227ff8c485869eca46b737fa9049024f5e7e92e759e8824a938cf0c6d8c9627be381fef436b05603d8047780debaa092f6398e369351876cfd8535fa6661419a0c4bb1f41eec5a251bd460aaf41f8a6b59310c5f1a37fec4a94f4d5a4bf46e800493cda96dc816c195d6dd0cce542017e1b7c5202e06947ff80d7c7a1dd605dc9a7f118fb970cf42009a243342dd4801e9b13663d0d2bbcfef7d4e68faa444023da4d07b2c7d964a5f55a50ea326a43b7f38af508207be2f1f195f54a497efa1f1f167df8577c2c857fc8524ea8dee3464ae4989b54fb016c3471cb9a535f851ebf93075ef4aa669b636038bafa6959311efaa237f13f03f66da04344f74adfa5da24637b21b5004187b9f6e7253695d9fe9f6edcf39ebc79580aa7ff7acbb40f514e22b5b4945f74a4ea30a7301ca6a9542d554b10a83232d212fc578e54975c4148846bd50583a117f93a1905e88742b1e9a43fadcda1bcf07bc183c6635f65df5c8bb542d0aca04c7a9aff10a331f553580f906176add90b28b7a6495b67327c65e8ea6cae60fbe4f9e5425253560c8b3c7db61aec2a0284ac1f38e877f173aeb694cc87e7a4af945e05df281d2d43e687263c8fafecee8dad6474f2608a344ca11b5a5647ff0f62b4a58251159a14def4f6889372c7674ec078eabc11f936fe0bab54de8c76178961178cc0284881286328d0ac3442ae7b39e248b8b483a43ffdf05f15ae62c2f6f34f6245ca55369f6f256daccd1c79e725b67bcf1c95ff6cbaad559ee3e7e0a760dd7f45cace4740c59217f88070d0eabe017b0cea898dbfdb2f6a73411b63b575c98a75849b4341d0d7a3866121e931db5d66e8b637ac489ad7a4f81ffd56f169af2793524d84d6adfef6e56e110598af3ce37fc31d5ea04f15e7ee8ceafff2187c89e09663045117752699ead5a52daae67af64ac1b5175e5cde807d69018c5bd880da8dfef0f43ecf835580b160fc8fd82b209f256c0f9985ad5cb45ad8a417b582dbbd41586352794b6b653e038382b7d74e2d716b319e591e02a80314e068bdb9898774efe182dd014a337f87aafc565c5ca68b3ce41e4237b1c2402e414f99d5e73f48ee13b1c65f5cb188eb4c5b242ccd8ad1fbacb770012d874d18600014eb56fd48184e6a0b6b6a993e33a2ad00c6dd20558585598de1f8e430bc075cd099e4ece28698efe3e20671883e6aacafaec64b536902c2565fe5458edf2116f363f09b689b6937c9d736293a51a2aa6fb9335cdeb00d5c197b49e90e5fa869c2d31e1a182eec9f380af7e227a4272eff3e03b272f94a83732fad37396095ff5a09fc854a738d0213b46275b37c492d90ab5b80e26baa9fc6999a07fac3da828856dda06f4fa156a2076e2ed938ab9bc590b19eb0f553f043441f2d4c7887070d5e1b5bde957c7a790a026026ce64f03883c816955dc661a2889cd48888c4af3abd76e9a20746f4fca143b8181c009a7e4defe158712a58f7899cf4998608b42902e9439c7682fdc3ce34fc580c598987dd4361fdd8bfa893981f1c08862871174fc1557e6cc14016c9fba4808130186f59817f13f338f96b0ce2370387d672eac84509aa32904eeef595831e75a8dd1209d0345d4bd6e8fb1f2464c5a1ce538c686ba198a42ec0b9fad141f27c9c2c3fa8ea682b52e3803371e790a2ab501cdd2cc31a6d34146cb73ea13550019f9ce39876008d9ea37f9b84836c1dd8c4388472aa0c0f88955bd9e16ad33ed2fa343ec1e70e32599733be0b24a35d2fb8cfda72e9000f1b3fcadf29b50acbcdb18c506f10d4025642ff58178b9eb6c9700dc9b324b6d223f108c33eb19b498a7ce0ef084a539500b646cb38956b14146e83b7072582c5f8b7520ec0ee2040b8c46580a75ec377b03f875982776c80790bb16818df3cac5f23b8f2b0e35329fb799036127e8fbf8a11d6922f91a8dd2cbf77f307749d4cfb6ec31ab8d3eb5ae058594240a7c4affa1484a2122dce31b4d5514cfe89e87abd275ef86f0da60fa84f8d6a6de4302c21de6493cb93d01a133eb6e34127f9282b0f11718d4f6f2611c2e413cf2b88ee4b993071d766e34e19ba84db80bd3c75794fb43bd0828856ecfe731b452995a4983107873672c0a05bce48b28390e728c134f95d7e037d25ee5c4372bcc178a337c57e408fbaeaba9b4272f62a2170bbd1494d33f43ef575c740eb563eb75349278100e58172283cbb3563ffdd9f3e2e6fc6ecdbf25c4899a1c3b253629131177ffd27bfd4d2b2d9d9507869c4a8b335b3237d984dc463fef58f87f7030a494fd14cf36c31a526b6db1e586b53f1c40d404ff0b9fa5ee75353ddf22a50988aed5632c1925159ed0b828a612bbb4a9c897fe4a9feb8d32a80abd6626a07e97e5c8b6eb333a8b530a8f6438820217191c20c5e9445eb9a924232a517a84ef98f9e81ab3c3be5aa9f3b7648fb9b1a008f84b7146bbb4b3816fbf687680441cf3fcee72d9022019f3b229e2e942e870d1ab43674fbde7615ff8ef3d006fee4c09b30029a84776d94257fde215e4d6afbc8c0abf44bb89461227de300c7f7206220403c1aa3586f55b47911dfb5413a72fd8ee07a8db982b6cb2f5a88db2def2da5e601a46c85cb9f8bc84c8fd2d46e9537cbb2447a7a6f59725d632c5073cb0af4a102c84ef41297b757475e9c40d1edb5c79c208c420a7c083b51ec71b8f0f3913f4e724ec725c69b683622e6df0f72eea56a0c5bc84d51f1b3f2bb8fb39eaf067c66f1bda1846bfffae7bd47b8f5a9f5fb100e73ba8d550e8811db0521fc89c68eaa18178c6b1912450b4cf5c13e094b2bee604acc245188c8c70e587cb3320a2e79f11a4c4b011d7d59fe6df6f1862c9bdb1f5f814bbf57c3375bad96a5c468fbfab6a9fc4ffdca00ccb23e5e3bced373f0220527b82e68bd6a435998ae98863c5d5debbcf614de52b3392d4bfd536ec0f6e2cb6a88e39b600e3ee34ac469fc68f2f5858d1ff661ab354ecdc5f86872cb6927b278bc43ae8dec2c9b4f1d6bf99ba1f63f85f84aedf6e0821321bd9189558829aed0773935b75d1cf17bd6565eec9d60d4e817dfb4e5533ae623c87cde29914e1f79ec81b126c309fb607498b682e9c3eea2d49dc7173059fe5b5d1153870d1b7db15ff183529d46f64e571f18aef9f4db03567fc8e2535936fb6380bc32f0e46aaa67f2a2346e9ffadaf1bb72c030c9a5a065746280d9bba5bb6e69fba7ec8945304fded64d91c3cd650d2859482bf41a1ecedd4d317a5e94addeb7ddd4375a6f4270e6e8b3b4ee70724604a1041c08cd79623a13c66581bd699f4262c3b0bc9315487ab767bb9a1d0764373169a983c496871e4a7905d9aaca413d092c4bb0e23056d3e0155a61244e5670876cf30a8b9269547422f89ee79084f83a79425298d7a646fc9322d3e7ff8a524fc068d4efec9b6bc3a2d0fce8ec2c0f28f2eff527ab67ac30659ce3eeb912c584f784b50082bfe830a525b1597acd14c7deb21ceebc417eaf6d1995d65ce5a285c18a54a3ef67c47288b555d2ba9c161ea7c41fddff97ef8a476aefa9e031af5d7db166d987a90dcd7026797fcca37059874cb674bac23d940ec31dbf56f0af746799dcbf73c3b86856f841168a0ea476e2574e2d7cc117a60c9dc69228ded2826f424b73a864ce62e95acaefd273ae93208a09f9129c47a5c38700adcb4774081dc0f10dbcc07aca0d5e0c20a4defb61b314f065b804753b16a0d410774f792b674fd6264267a015e9dcf524ba2b52cc096d10420bdda545e78dda2aad8357498956e06479b401574caf9e9b9ffec87bb9d2295fcb38559f20f160e06cb653f85c8f37797c6233c9c4eb294e736a923d634b8b5b3929df8e1bde50f617ed0f317bdd040e7017c6001403fadee8695df104c5b5e4c785fba8aa7b4de7495e16159f352c20b083d4aa9cfef70bf4a80b2c708322a18839a8bb6409d2b7f04f9562ce460b2387b442ac3cee75171e23501f2264d6eb1c28040139a553f0bd225b7d3f562a124ca7c85ba12cf1b02a33adda45828ee2af3c924d7d6e888a9461743e9ef79f97d072574292b8ee82b806684be9831e4757eac823d33332d9743e80083c17471d3b69149644463b527e8d0bb432431750feeea5838e37a936f2a6e63c3d6473cf7457c6928ee7f6a3a6bf05e69bae1c7a870cc046a18e90d1cfe18f3c4e79a3b644079a36b892df1f36bdb0a13c0981ff6c512ef71465efbd1cc43a44a3eb81e0ee3c32b1c43e2a491471cab92f9a8f12b0731760d07c7cea38a04e4ae64131242f4b601be8cbcca4e6380fb5002ca87808acf35170b4fde65aaec49ae062a83fc436c6d447f601d6312130e61f75705359d80cc368753639215d71343dc7a5902ab117da7c87fb172fd7e8479430404feea602316b575644465ff5a655208ff7b6749d032812768c9127dffd20ef31220b35637a08ba62b50be1253adbae048d2ff3191cad82331b90f9babe7368b4afaa4fccfd3b2208daf6df6435f264fd50e71d14679475f94ce040b38270e524408deb1120d9c7addebb88d20fa5ae5ee11f61055881a18a802503e98297f4e1a70274c379245746dad82f5f90a05d51566b5a7ef437e88d05481f53a08df7d83e3c4392e0c9d966d094cbdd081ca174d4547898c83a61d95da697e3f769b703a6ea3383d75759d37dd41f93df28e163a35dabe08b3f3aad04db4c72da2230f858b874f8c11b1bfaa40d2164789eff157c4e374f71b8ddc89d87f9ef7205ffd440505f1a392d7338edd4f187536161769cc5c41cb8cae33e67318f2087691ff8632f5a55b5ebb40bd624199ebea84d06c063554a89589037030e774a7c194d2ba817d624eb569b321881cbd4f3ac24ba43b9d83a63f7861600768a81234799ef005104adb7bfea7267ce827c8477c966403bfb362b4224709a33aaa4fe20eb62d5d2643cccae5f3e295c44860ae4ec696276fdf987185927949495ba17b9a949fe1caba430defaddba23df88ed1e586640e4b0ecbc765315cadb6a21a4bbf575334a73082668f93d5f256f53683c2ffec39dae456830bfe77c89a6cf6a2e4f31831568ca298d61801098fe601ddb8423e5cd4943b819a304c65b0ea8e5a115e85edd15c84ff9fe266e5d936649102f8d9500807f40d3fea4128fa2c68ce8f5bc61a89ea1d055bcb2d72a9b80a6e43b93a81311c716c18cccaa566ef98be81f0db1309559a7f5b4a641cf12ec3b0d1c06f32e5ffb3dd1f66503a4f8ba72b3bf722b468d5d112bf51e18522935f1744023816846db901be85aa4d08778be7ac435e497477e6f7ddd6aae10c088c1dfb4e3d2158a754001084272f62188e7b6629064aacf01e1cb5a7248eae613bedeb6d8efa01a7a36e1756fcf456e70d812c1106350e2cf26cf4f0e6a3752271ef6b93096605f76b1f35ba904cb56c32894c0149042c283626f8034e687106f6c8edc32e16b664037d8d768a01b14218c57a46b5e56710bd23c3341c1f3531db45f3a5d16f10ab2fc2c77d113cdcebf7d47ccfffb494c936ee00e5babf6709ca8c97a0b01809425f13f8412b893a3c09ac05f13e65c30a8797d81ee9d4d23a4f0bcda8254e986e060b0f093b6aa0736f894573456114ac51d930e21290afe35cd7e9cf3815e6766516730d7f0361e696b26fc1d9964a23574a952157fa06787dd6282304631cc09ec27efdc84aa2e202234e70a8508865ab01068d4ee6f3a5ec7aca1b4904f2d21daaf2f2f338cfa8b101bf3f717ffe76d58437614167f2a640e2dee622f2d377436836d0de68be336b864109eb59fd33bdc8e6af7690abc7da7c32cf81d9b1980bfa0d086fd6032daefb4a1086080c2b14a54c7be1cb1a67b254db12e9d88e79e3674937cee31950bbebb9b90a6eebc4672cea6a59fd532542ace73773b3fdaf17006863eef10b51e0a79f52888c6db06f80b46e94c1a04c1e0698475057b841df98574b72f74887feaa8d12e6cca7fda0e970040ae864dce2c7ec3c25a5e0aef10bb6bafef999f5b000ae2c7097c6a48a205b6fdf932a14775eed098cac212a74960cf6dfa4a03c78d6833ab48763ae6f189a554a40a511c3e53958db728538e13ad3988a5cc7b4980d1256cb6a5e50e96ff76bf2fbd5a83890595659b49d3e085b66c0555f59a58fee3cded9669d7b8908c6b7626ca0bb1a4c30a09e6a8e797b702835d3562612f0bf30c9a7a2ac81892bf365e9d679645a55821d5b33105be720768b8efb4a89e9bd6a6cd40516487f4a5f147c50d197d11d67ba367b93a65e4abf862c1ab29a9a7244f2bbe85184fe799c4f25787a1188a65300f79b2d30837edbb466eac0ebacd0a88a4d96282742fc4ca1d5203d5cd792d2bc4596b7a113f295312bf2e24509f042f29065e0d119469f7bda53627a79f6c8509f3cafce7856966c54cf79cf9d569e1c14a31103cd6db038587e626f520b998a7bb5b547e9bd1f84eb0761808dbfb4258ebb8ea6e7ccdd551b2a87329efb30f63065cd065d281c6d91f5c314abbf6173b9ce2737658b9a5dd927506387b95eea840c5a3c00d927cc27d612cad1931f5fbcc591560694b0ab4d08b1ee97676059ada892601ec5cc0df45cad72ff213a6b89f2a846a8a7d2982007a4ee0abca58e6eb49367286fc2aeb78627c12cfc02d5bedf6fed7950645677a96f0bc186970f0c7e0b77cff8dbb2660575075078d52f45225b2a0654faf1d59b1a4dbc78c3354d6b12f86e289bce8caddd60102a9c35026e5d69619c3cfee6ca3a4a5c52d1e98c906ef076957556a36dddda259c14eef5bf662d4f99c3f7c7b12f3455309a63aca99acb8b4d36131299822289d3fa582da6a194552be2f692e18ee8528780171508d44f8bf8dbbed92498298acd3ed8ec63d781d2339951ead006b82756067f8106dbcdc3c4ab403fcc9fa59adea3c35b412d296e38b0dce66eae76e0a0aa27b834a3847d3d1b746658a59c90a466e94c96c24cc7fa0152085d08e6b1b4d3afd664737818a87f3512b1810d865231815896be4bb2730b0941bd60f162cec0c4834db8c20f2637f1d54028df7e5aa7d1c7057ac4c1281a2d0b38f55b9b5336e2d8bfb4581bb2f660359fd8686085c25da843b0003c9cc17106379c655e8549e11784cfc1a1c8fd316cbec0f05640bc4430b1557c7662a4b46264d7cabdc4f0fb86efa912cb9618cd966b1adf9ac75d660161aff1a7079b65fa8c1e9473bc74e519f7fdd00c3f6b2ec90af380e8068c0fe0a3113739593c3734890ec952f6c93cff38c92cfc46614d3f16dbbcf0762eed0023da8d65acf63b3c5a918ba89f8f0b73523a0602a7705041fdeae74c2b8873f914e4a097247730c1eed053b9e15e35f7374c10a5bd49cc3b8173bbeca3a223905bf215c45e195dd6f8bd91f5c76daa18fee188f4ff96d46e25c9d1d84373176cfa352575455f338f54d3260733554e372f23b1f6328ee65819d30315d5f3216e26ab7172c2222eeec931f03703673bb24d2c96e7fee0590153ab75dc5fc5c69a37a5578a8837c9ee1c35e9f27e7e04617031c3c84ea91ed0dea2c0d402250d4ac221f9179ffe1854d9412355e2251404cbce1946977910326611ccbcdf8b03ad3bb0dd02233336a8c619159fb17bf7c9984bffddaafe8fb69b889b059433b897aa62908a97ac2cf374cb7be530babdfc4ff0b4c6f580787ff5b80561d142e240036faee8e164261f73eacaeefd46473cce39bc272275afbc890a10bcae126bebcb396299985080fe1afbbed8649ddd242e72146e17a93f90716801da1138c31eddfa505d063c1cfed4a661a81af80aa12d11826ddeaa7e4934a623d14bcda865bd18624090e50aab823ca82cfc23b8895c4bb5e30965b054085536a13cfeb19f2a87e84cea8513c535fd7077ea6660d95b782d65c81f86b6b75a83c18e893f9c46a7019390da854d15cb42cd6ffcd32d0bff5736aaf568d19cdff9c6ada59978bc2c842dee66ef605e70f520b830243a8ddf82524d2515bccfaed4c04626c80d8ee149ffcb2ef3e58aaf1ab2f34a69a906a9dae5be4001b73994fdae3907af4fb8e1f1aa9a4ce1a30becc9489712c4fe55438b2028dd84266ae3fbe940548f42492fa87e55448e78fd80fe45d3ad4ed0ac0a60dd970746c8e21a7f48243a7fe0273696a7ac30f93cc98230e5562b1b06b1d0f8c6b5b42829fabaa7e524fd2ebb2e985410287683589e450bff405992bd0ec9bfae36ad79e57266045cf0652123386e6e2633a8ceff32f0b524d9a294ac3b98b07b8813211de4b8a43275ad08f89e45841f582d5f71bbcc8043344be72879057a6ce4f902a755ed9a42435351c900f015cedaf24cbeb9b2a756f333e4496486fc2eddaaefc1dacd11439dc12bf4c673324043693596304968ad9f225a8d39909432b3c129067940c1919d8e8b8665dfb46e282e77ea84c569c57b48c33c9bc5add742c7a69554747f05ba972d46e9ba29876d8c22f0b0eb726c9240e0891f8b7cc2def6fb5ea0ecf634b769ffe9124b7915c7b729788b2f8d962073a4b743e711c918f06565785cf08d47c3fd7af55cf8d7fa847277769e8456919ac7c27f49c27674cc84e8e00c15505cd167d9d30d8df459558238e73c24becdb8da69add221683bd83e754c39a8d7cd2da8d961a4f44d796c7289ec6e56f732189a48f41c963a2f2fc55b0dde7ecfda2e018c7d09bd0ac49c12874c5393f85f11dfbc2017464845ce16ce1f3cc16103bb177a5e533efd5bc851f980b4f640449e168d76106c1ac854c27c472f0dc6bbb7c877421d8805b16e1b3a7082f23b4b869a568f4919636ce88d7a62682e3d668425bfc4e127d7f45150f680dec8bbcb5bb41d9f4c5b09259b702bdd0ab6bb083dda0fb03c3c283dfae708e4109840ffd34672b03acc5d2fb5b1ebd03f474555b01faa775af9403c86648d502d3a0ab8d5c955f15bfc51aae1b41ca1c90317aeaf659b56e84c528aa2726f6dff076cd33d04832bbb495d81e7671dc2dd52f94f66fd6707277c947002bbbfb3624ed368f807aaa74037db5bb74dbaa0141f349324f358287703372920c6ab355cd6cfada628a447b39e39e9f0491027d11a4c88faebac8a40e4991a4d349339544abc64b3f32a85ac075698231144a86f3fbfe8ab9db2665b2283a421adb478bd997b981bc93d036f5f529020c80465cc0d2cf09efec1032e3d788ca31f0946d0acf1cced6377c8f0310ce026bcc7d4a53378d5b3ccfd733974d25d875fe911b4572f6cec29e6116a6bc6c8b14e99e85b69c0ff61fda1f3dc1806fa293893fe7eaba8cb473b13473d3212baa2993f2b8a66b86fb451742c8ab20ba9a5a9110d3708dbf3f1f18233b24c61ae673685a724d89844caddb5f5d4645e063a0feb7cd1268f31e6f58ef5f8e8a06dba882f79c82454d8609b0ee3956352c15be8d1580da6548eb943eed5fd0279306afc8f4b13e55f5670b123282d3a06094fdb2bbad56f8d7f96f977e1dcc15e6226529522520e73785d69b798c19e7cc122237e3ddfa0a967786d28fe5ee6a8f013aaf0edefe5e2a8f5edd300dc7c7e2f9a864b003393691802dabe463b6e44c7bc206523e6dde7b51c773c42e0ae0412df3ceb39a42b7a453b555fb91eebc65f8562d9406b2d57b55c80c93dd6a298ddba7cf2776e1ed944de564de264e7e5703dee2fdecad1a49c3778ed8cbc14c6c483dc7b9a228bf3ba0a9ecf681e04ca7fee263ba4b358c9c02e322a5c3076c04d333932b3cab06820b3c568cffb44dc067e75ca924acf0a5e5eb1fb448c7bda6dcddef4ec6e43160fe30fe38f202c014822e2d82719104cbe7dd94c8acfbab4ae098a9d10a45876e692df13df8854fba8b70803bfe145185536ad257a3dbb6855e6040d0ba19e7dfb50e4bd637e3fb2fdc9a2daed10abda9a99a30408af39d3da6faca8ffd5ab20c75ff393c9058b5fc7716d04748beae0a687a3ad8af406133d6bf6a707596a9a1228d23edd4556bf9137709d233be7e26faead90b85d0b7231a96c94347287db15fc0eee00a5ff92ded4ae1d03fee93cbb4931d7cc66e2933e39f0d2d3fcaf75c382e8fecc6a18a9270fa60c6603e98c1a2631bd65a6fe6998f818ae2ab5d1f1e46e8ae92da858e537d17e8021eb1434531c9f19f05fd4762965f0459ed00e569f890831a04fde1d9caf97b3cce9ebd99ff2b7db0b752fc8014c35b525e09e5d136e228ac3ea2f06ce4df92c4e6156c2f9f17ca0e1120a262afe814c279ec39d42c88893bc7417100687adc4d55e953bf3eecfc08a7941e759d69fc4aed231b6396288a339a595627708e92f9281749225931443296af8412fc3828ddb4d1f59bb77cb228a57f5017a79dd46d2ee3ac0d3489fb3fd442ad1b38b984428358484fe73fc7f5f71bc98a527f107c93befcf620bb47563450cff5957caad5cfcb63759afe7c8a85a8ae5eb455164d020c53b9d1ee3b4d2f9e87ff627c52550ed95d9b8b61edecce44368d870939a2fe52a98fc2cb3b67026535060cd1504f6c1cd61bae729b163aba78634bb3b1943f538faa611258d0f9a281ecd9aebcfd6c0dfca76c35f6a2548ba3ec6391ea2e25799e9e95d559ea49c2f78026918bd2ee6973867e875166e81410d1d2af690ad4134b46df6175338304bed045817f971026486aa2d89f837802ecc242d8ebf56d851f869c165c9e5a0699c0c97bb3396cd7235d138fe94cde3308dd62b522840a2cb795f2590914e2ee758d35f5c5dea2964ec41e855cbbe0ebfa03e58e2385cb53a4624dcaff9b8c414f8a68df8b836742eb64c9aba22a888697582f437e06b87a6bbd40a2aa349778ab77df0337c4134562579a082e59b6b64f19c49f60a4412cf5910ea60bd17157acfe9b3a692aae7eab4a2854568bf253c003e246aec6239f21202a123f3cb4469a62195d78cc1bd97410bc1051515a1a058da66c72bd1140764bd49b88be0e15a1ccf122059375deac1d280c4aebd2d9bcd3e22653948ee9def1fb6288f34dcbcca76ba21b5101b56a5c9d44644ab2c95312bb46918c0ef5fc805005c818ddb4b09a33a1a7509cdcd447c48124919be01b98ef94beda8143684c1afb67addd590f5d127e57751172747d84bbf0dbbced5628c3cd1ad7cabc662074c9ecfea019ddd6fe3daba41d4f3379fd0b6d020b169d2b96f63ba26f6242fac56dbbe48596b5a387ccbcb9f38d7019fe0d04b4d6d7c152650f6b3db147b5e8101bc849d3fe716d53daf9fd8be07781cc48feb3cd6ea8071285592ce24def39ae16fdbd1bc5114db790cd98c2593c68c78525d37c6a0709d8d7f736b3930fd0d424bc4bb78af8ad9152ae5a9d8d8a652c4e714e44e05c906c442e2f591a3808ec31bc66fe81b0b352aae341af4215d4b4db25513d394b9efe5d9b3c2da8489aa25ad0ab7d9f28b3bc345e846252ccb74c0a49c2598ddd3c821dde8d94e6536ee6e9794be5827b7bdc003f0799b35fdebb4410154924799c325369ba34c53c0ec4985ea34c5d0239dcfb097b8b81aa955edb175e74b20db93384b4abed01923248c25c445881c27d5db400d5ec465458e11cc3ad4c059286c548e9ab9e56fdbc343abb76c2d30afa81c141833835896813ed48cbd8ab1e46cefd43c92aebc69c65b66e9a7a348c43761368e9a61032889028a9d0a8eba6cc4faf8ee49e43e76aa323ec97ff5f812b2d8ff2625f818ae68025d284de910a59124ab766f57e218043301daf4310a6dd1bed43cdda9255b11f1b1a4e1cbb0ea528c38b8fe50a8deefac7b0804f2cfcf1e848e662d4b63232354d6e0833c40589ba9742b531728a48ca90e5061f91eaad591f6e50219a7dde93174ec75d517606598880db1c0c5f1cc1e0162b26fd080437b74b40273c5f793ef270e561e09619255d613dfe3fa90b13763402b512ce0780277bf0ba415c08d1b28019be41bc38c54b0162f8d079a2d60c6d28523ce8c1c5dea3adb7716d1924b827900e0e63de463c5553cb35979236c45b6bd81a7cb1c314d9093037224e1897dd1cb1b9b33ee5ee5e7b033f12b6354d17b9b462450be23c8cdf7fbefea952cd65b81fbbed952699fb2d18cfe87e4d4a33995e94cdc721ef531798b9cf4a84375a5e008bff599167de97dd2a322dab12087c7b73a5770be361bc8d9a31bdd559cc508a798226ab54b091ddd66bef2b5ca4491d5f9cfa34b5e3c3ce039c7be9a747cc2e1f906f1e434e5074876ae669366309740faa94051b751665adea5b523a8999c48a956fa87bde424ba1a3f4c681ea9700c5ae88d3e2c638408706338af8a345c5ba6f4277ec2f1919e6ccdded7373eac307282e9fef7b9a789277938bdaaf57b6c03957fc9d86618ad369732786ed1bdefc87e40f7c1c598cc0b2471c97fcb33a5513d3413da940a7df9ed1dddc91d259212ce91d4018f9cc107e7fed794f98a24453f6d7ecd70e6c7f98200c46db3e975f2a4c5ca569c3bc33d2f69b40d421b1c6d5825918bf3e3db49111bd45e264e66a9546effdafd6d045daea85269b75dc2dd8db9e7ecafc7dd6c64759b18094d3795bd37100fdae8e94d37bb7fb4ed0dd05f4b24308085c6deb6c2f227d0434cb549959356cffa2d5f2cd0814606cc33c9b4fc35aa46a362fbf49bf78de32048eb97b1816d43e8ac5c8816006cdf4ca6e8f50e8df54336fcd6565fe3eeb4b5e659e71035384996d8d112d2f5e20ffb9c41f2ac3ac74fccb3168353edb2df983fcc951a99de73309b865d4a3640cb15e783a764d325f94b2b4c4e96e87c6601d3f9f27980dffa49fddb7ec01f3ecd6be609da5971614eab34203fbad0d066cafca4274206d48ab77990b12dbab532eaf7d4b9682025804b635a152929c1011779070a87ebc811fec02e481741054846b410e15123df86782580f68fd5f6a5d75664f1a9661737e4cf2dd26e8295b9c360d881b6ad2d1c7a16f3e56131c846abda602401aa8a4ac764a14f4c933889375d4fe11297f3da7a216d0cc0a1c86f674530e83e0a22b6aecefc2e92a15b6b5699579b001449d957326137219bf0a9d10777da5883dbbe1109af75e4cdd25edee632138518d225a3f0181587c5602d272ff2738465263a94426a6449e2b5e1a1efa9bd754a3c07039ea5355d28069543e7d025be39f4be0273b2d4c2d439db6f54046fcfc36cc043e4b6516f395b0ff6f7576a5433c8c862fca21463144a903ab59c97e60a77169d3425c1779c1406310e7af29fe4ba58c9db993afa5508453f0077bbd7d23a2861de87feba24da6db565e820ccb04e195055567525dca298322552c20e36293528b2e52dc15d7eae46b57b3a14dbc5d8cde7c76f27f6c6232a0d83dfd2b7ce2f2df3cffceee742a3e598311180b0908311ef8f29c73efc67d77d03e4446742034817941874ff3ef04beb8c93027d978b03b58e5fe266368f58127eed405fc8da763b8792134351f3c12e09da3bf80e67d2d44220b29bd0f5c248bbed060d5340688825fc39fd2643f841365daba8059173ea8b2fae3965e2465be0b5849da1e0db9787d33093a3e4fca363bd3ab0c56a1bc93072168957ded7dcfa197f04b8b991899df6007a42ba7f8b318239d4f27b04eceab1f3b29a819184ef8e646a37a313dcf6f5e2d13c5e2cd3e494a85ab55975b925349c18168c62762a696110fe7e60eaaab8ce06b809b4522c9972ef35479fa9680bcaf51453e6b5bfe7af4016b13e08b3ff1f2cbcdc9fa53c3f627882ef7a7a4725805475113eaf94b3a08f40b8b81c495e9c4d512fa376697483ad3cd56f2a4f45556bdd2d7b133176e89847aaf7b6f93920276d09598ed48b2c20a4c676e9619994a5eaac9d74c2d7875535293f0de5550a6381cd48d113a992805ae64213feb01be190c3ea412135a6257e0836a23c5b347e65f1daea1ee4f3502e626769c0cfd00bf7cb0d9e414dad8e661c617e5ce1062a4b4f527c09716951627055394453a45131f06e054b922b7b502b0e9a045c9801591662e384dcd2574001f0429612c2b7026d3c20f4de0e04694560c3c5b0fcb6c6ce020a8d2aaaec67d1c6acded396fdfb6faf0b04c14367a0fb83a27360751f8da78a853d9e7121fa9d348ebd12e7d9008fa6da41628df6e31d2304fe83585cae0bf0c4aa6b8d23a3e07b3c5e296ff24e4cdb2a953b7b5af70fb8591d1fbc6c791d9ca318f713d94c191d8dac70bbfaa3f9516c48da6095a0c6dfc1751ac10af77fe8188cfb759bf4220f7005b80e84e1b47d94d4b12765bc9c3ac5b18116ac069df458ffe069a75b6aeb0d36419098b0e81b2552351122bd03ee6a9ac5732e2dee269eccc6c20740db5e2fe7e23fbd7e9080aa2c55be62a5b42a3f980d09e87376913255fc837bb6b4ced5e28a30425977d2acebef3acd2070fee9c42c2ecebf24a92d589b3997097788a8bd744a00c5ec612671904f66b64558fbcfb58ba9fd88d0407d48383f8912768a0146795f54dd56ca123b45ace62e2fc68dc095b23fb2e412d614b37e6001198dd693e1bd4177321c1031d1506af6dc2acf61e1a44dade6e87c39d435c8bafdca31be532fd7d2f29bdd079f77a9eefd462a1355a159c96cca818af782153029bbb9ad6120c9e4dec4f9bf6327d8b893aee5267ebb0196ee97c0c3e1cdf3e034401bf9dea4a9eacbbe711f3c0e1994c482e2c127956854561933dcd173aeea216070f9eddaa85f9ce0b4f167523535b6e173a520445fa2706da6fd6a3265e761a6f0527373fd710150d3548f43e9b4d0c5cef573b7439c4496c1cb7cf49efc34b23541e87e04cf1c2fb4617f143c3a530e69e6adf6955ae44d172226f608d062eb1f13d80214597ae9ce330a6166791ecaac8e5c2b8e0429ef040b4a4b934dd5236c7ae7bb9eb604768cb5623d0715b2aaa8a211715e3636c010c36fc85d35c9b508f15daa81b8238fd57348d5d4ac69772533cce4e17c68c477b2ae5b7c5a4058f5df38a01a8e4dcb3110a1b9fb649660377c6cc12e966c725ddb411608c7a12340d1fb341ebe08f1821e5121542a8a47dcc6bb40dd7626e772a92b5cf332a872ee52b5c04db718ee6b0ba146616c42d1375af65692641c82ee8f1a51937ff6fa5d537f3acf0f8963ed533404cca28dd121a56924c1725faa5fae7b8f9f2670e0f6eea20b7600d20152f761608b91ce529d904bc6f3f7596ac74945788218d27391757ecce077eefaed2710dabc3359dcb897dfae07c468ee2fd31aa7769388e2d4c0714668dccdd7eea1a38f1f7f3afd1364025b9052b878042dd805c2e78d6a7c6c581ed117faf91194f2ee9870ce5830472ce58c23fbec649d81b2718b52f2548722dcdeeb1cc23d794a606ca85971ae5850c822b71858275491134ab7bd8e2c5f3d862f9dcc329ea742b9fd65beeecdf6aa5215f5c6ce2e1655250d4e3ad4951567fcb4c385a25ea659b923cbee43f61e96201feca6204ba04ea3130cae87da2d8a04cda5450901302bec4f97afb56754e2c10564085903d240af9a9c152e0cf9782f1d1c1f261d440a3f55271eae43ada942d77af7495fda722cc9f076f7fed7469b0ed8afc7047ea92ec835b16e5cf8772eedbcd5dd76a27d10d115a209b119813631b8814a6d67d2d77403b24dc136bac3691a709cb1f598a7362dcc6fd1f7856ba941afb0d2a7e53c8e2b465a1f5ccc3acfe9e0e14d3cd4bb6812e20e16246156ddc4226c59ee7e6cdac2a7743771402d3984073c03dfa42deaf6f0179cf5faf6152dddf84dec1812e88ffebaeaebc114a3a097c5d12fa4fbaac2b1834d57d98d5f80718a580f3c876c774eec7256ae7d49d6eb82ee0d470aa908ec534ef18ea78755dbb2016e0abf200d9bbdec53bfdcef853f1ebbe0b5e3ab09ba0df907e32a1df02b24a506f566b47d4ce7d1c1a2b3dac48d1d9ecf0b3373007c0a09b17b8d5265588beda6f57c13d14b892855c1509df961ca089418158836df8d638f7849a1c2afd167a2efadca1cb828d8cda60088ea225647877e67e16a9e0f542fb023b8e2689249f340277d7ce54412ef457405e15dd3cbb1acc605930acdbf240b9e7afb2e57423cb7220c19beec515c51f60104442d41a38bfaa2b19a14d5b6f463b960098746844f98a82e993c31da04ca6eb08915db4ff45135ae9f813ec896b56ce355f17bb24582224ea0ed9b81dec1939fbd96cb1607402b2342145a6e2cc82f4326b1a9a2e0d8be2874a5e6b23f53eaa2d26711b5a354fdcbc9a8c3a7dbe3d2330e1fe553bb15ff1d072a855033a0e2cf7f11e9bbc4f3a6a6b45592db927d487a71ef12d764e80d16fe4ae93a7d08b41389ab35fa15cff426f01e411a375e82134fe5b0aa022a3485d5637966a603a952f12e48f920b02909ca234c06ea9210ccf71d3ff1755fea8dca4b84b6c3aca5a7a3913094c29802ca8b71e57d32bffec3e122b0bb459604d5b02da1ca565ec2f4f591dc079f3684b2592d99d426c5cc0a6cbd701c5b04c581ad1ed8eff563be34fe401da54820ab8352e22304a83478d9e41102ed1394b1bedb364cfe22f5128ee3aee65bc7a5785aae390fd1d6eea3600e099d5a8f28b01d33fa54f1b7248157418f718105f229f12d6dc1c2488ea590a683288d3f466d71bb7dece2054a70d2f8520565dde65acc83f9b752e33f1e6daca633a20d228e688fdecd74589b38b3bfefddbce10c4dc6208c3bc84f143878fc20dcd1c8eb5940c1c5696c84dbf2f08cce93ec46fab50a387b4c5b807679f215214166ef7218927f8176df32244ac52c1a80887a966d517a459a36127bfd44ce34428f76487895a30108013df90c9be2880a888f408060b7fc9d6a19701c1550736ba6664a6f75809ae7806017506137da1ef1072b125593a385655016da4282fbdb07796c6324a341be40e559c503fc6e4e77050696ae1ad3a4b8c2596c1460470e9ae3ae5f42d11516d8e88b29ef87eb193fe390e4573c6694229f6713db03d5bffdeec80b44ca7ad80dd0bc0bb499772bb06d9ad16dc3403488bd499a0bcc9e8ca65f67ce6cd773caab5c9b7c78226fceb32d16ab953a74d665552c3472a3ba3ca3c89c1458c090fe928758d431fddf5d6d95c79c014fd1c4cbe2e8ddd770bb74191663aad834a0163d881dcfb6d8363d7f998977787d4a25fe71b6e54948bdc7044c51405d4819a2eb872924a98631c2d20f4045e4454b057a7bfe4f6ee6ed74430c369473279afe27450d241d9fe9d1aa2078c12eaae1bc1b9118fec1a47269aac27b574e077f277171a4e57ada1b5f99e7ffe6ab8868be3e9d04751abd4051d94d7fe5c0a22957ec47cf71f6bf180ef41393a1303db26a19f17db87ffbb9cfd721de09fe61425445f95e634cb8591a1d588dc4dea40f70c853f978695d86aa30a8163ab611ae06646439c4277ac8548dc3d179f84a2c888aee9d3f480aa47f35a26d3b510aab91b717935d86052f89b29ff978d96a76a9890d52ff37148176c4e9ca680509dfaa238ca3f65c378ea3a974c40706ab516f6e3d82d3ec49fd6050e2c61f054889326f96c7d76fb92df687090c16566bc864206cf27fce75a199d68b42c6e401e2c7d0b4a4f9638dc5f4109bd8ebea042abaaf1ce4ed4df1eac148d7c17cccafb5dc62fab536d64c282da9bed3e7b8a02d6a1540ea03787ac4fd2e3a6aa62f966809eee06b8b8502179544e339d7346eaba09f365e8e5a9e767e479a61beeed73d81a870e14fcb847625343ef796e7d24448f585589b561eccb0c054559a345eec070f170cea90bf9c7b762203468cbdf4be08715875ed500faba2f20b1bd834b2f8e50e221e519e46ade6e371ea4c74e6275b6d9687b9f00068337bbd6515059524442bfe13bbaca5afc66d2c5d6cc91b1e983553ca2b43b18ca832864d2c6de17f330f7ba2708eb0946886ae96197b4717693301b2e22d9f8c7fe61c762e0ceb8d0a5bea1034f903bb441011cc01a3b283948a601bc52a5c8a28878013b3b44f51a052ee03e60f8c50077ee2a6b718c4455620d88779d29354e40de93a900a9d95a0df1a85b374f22d63d471ef3158d583ad868dfe09a3c170f61a5b08fef9e9c6fd491d47707e90869b8f4d63c98ed2f7f2098b4309e350ae0297a0611cc2205a93d73353538e170168b311ac9b14dc6321a51793f9ef543081984c01ee172153d3db76754d79fb8848b1ec34fe0dc5010a9abbc78ed0f16576edc52c1e8c4791066386ae92828cfd23ca5a16988b24ac199407ab979ee9df9902d916cc86c5c95400ba68c3df5eb8f363f47b3b771075dbd8d7cf15034e27687735bd6f8183dde3ca33ad2ef4d30db72de2115199d7d8ac60b0252d26090c9642ea740e7e89961e181eadefe88522b38fe7a492545cd941f2ca0f358a0a13c43f09d982e03fb8cd1d6153eca70abc70d8b9edb6a3ee1d6d6216b1c5c5e4114593c74039bcd04882f2ae686c7f9713bfae694b266abc9a2e7dc8abb494e4b180801193fd9bac41343183a9be026d1d273fea3fc8f3ef2cb9c2019c81544ca9eb7ae1f69299c5f092f95c26b9acf9030cd59e964ebcd727f9d2198bdc3e3c9779a8fc9aac5aef2826ad52d82320242bd9d6b276cd57b85b73e28b57d4686a20714483b7e389f7a552d806b335f84a8a1c76d8e5096bbe3d8d28aaaae282207633d319c3d5fe3c48752fa7e680b457a4181f7e6ab666ec4b8db949c1ae33cc56cdb0194e6e3c09d83f014ebd4dc6d3eb856010238e4112fee87fe32afcbc39de9bcc210f3fb335f693527279d5cb2423370d5361947a03249b09df5687590ccf1219674dd3e6f990e63624d61224940ac6ebc6b04c3af54272d165032033d802c75b32f40e788f55f54e7f9dc16b49613d2aae4be5f84d39ed26712cd0622980de38113a3d7f58211fafa74ffb4548fbcec8bbb1ae0a85149da0668fb3af83103dbb7c740f1a13a8a0785fa76aa31449efa92040557ea04f5e15e7e32926aa4c8f53e58176757e0407fc065f1855a56607a3dcd8df989ba4a04aa8bce7c248df1da6d897eaf32a9e9851ef5c88d51e48dc85f48164aed95cfa0220309671f3eec486370b2ebd90182516ded48162205962b2bbae376c5acb736f4cd38d940bf8e3d3fc9c3185d4e19c3fbdf57f451c5e8253205a43244a0ed1cf263565b21ecf6a684f2bb6c6a42c7a607de592191280504aea25f1ef789ab71ba3c32ab549d5b3bcae9c61a451ae72892fdc2d6b7b0ccb02912488fc9d3335e27f86e149f53c73858748defb74c85e4e4e35b4d7808a1c637d522698fe634c99c5eefb08c0bb9b82822d0afe47a3eb260c967602a310b9c7a6d848376e9f6d846634fa8c7b0636e7e71b9e5940fbaf55ac5def727105f6622f6a69f329d8b718cda03378e280f6bdaf1e9a7d7a7eb0024f55c9964ff72a3279426aa898d9c0f5712558cf12a625978def0ba32f13d7e66decb3c74c08dc9b63156778cfdfadfe81f23c0e6d985a34dc31b81b5338d6f4839220b4e68f37852177ed57bad7e2a1409221245cc80587e4e4db274810ca86d54b6181cacc114711abc0e7d1ffc86a63eb756372292dae2b3943377b9656db05b6a7d9c0790ff0a925107c9653094d072a3c4a1074b4de81a8801d1030dce13b410c3c2101092a958d2f783adc5399d73cadc3f79aa1e4a57d31b027d2b29266fad247790e6f6473a765a8b6a2272557223018c2529120319f5f50cb08d1d7cf86a6a4dce9a50889d7462445ef44a549ac41eb686727fb25b0331f052e4f193267bb0d8337c36a49c534028e0fea41df5b7bf03789c3a66751c9db0f1336b9433a30f7dfecc706a9b4e6ca0cf713fc547122f5cd74a59f6d47f337471f3b1e901bbbbef237f6d1b43c8f192ffd37fb26ba7e02925f208fe697142fb2b795f10012854ec9d7f4a2c9724ec8889ff775d290627daa2e4d409e910568ef5c7a1090384dd003b88eb3e54dd2e2159a690ee95680ac8379f35503bef80d3c6e1f363eaa349c854298347b8db2286eb64cda967efc1b120baefba3ef125c9e6e1c417fa4b927b3ac69356f132154630e1d4236f74d33ecddda11ceef9021cb65f8eb6b929ee555f3a320aade62ad51492057427e4815673e636e88352b993c81b09c5f56345773f46b364251c9ca86cfc06f72057cb01435bcc845915a60b6ecced99e20bf88a4bb390c087e32c5f333a1fd8838d901e1132ee8086c0cacdeba0fb1a173bcdf3cd10b6f3dfc8b0e2c90f267dccd867047d9a2bbec929a3243013c59748f46af87e3af0be1129f24576269caa696ccc7f37bbb2961a04b5f9c6bb9d34a133c665e927d323d5259aa01d3eef1837ad31a9b852d01a0e485da8389b9b91fa8f8b325ec5c1bc6ab3523a076892fff1b18277b7abd3c0fe28192ae8b4be21d7303316c8e8659ef96e1ad15d8c2d12b7e15cf66f8b05ea192fa2cb2eec375a07676c667c78634dab2d3cab464cfbc9bd050e3d795505ecd32c3136140f48e6134c64779dd152f7452dd56ac32bfe3f53b84496f493db6cf0734cac02c4b31ed65c497e2e459023c9786e25b7f983e8bda7685560df14a121a72d6fcd8130ad305cb860379a9c197ada899600967b057c034a35fd3249508b9397531596203841e74520b3e5cba95b085d89b6a54f9088da64be9aeac418fdfcfc0e714b39e80c52156f95d0ee3f12e17c7c5ab17dd1c94b52d915aa0e5f487e3a058ea37338617449697f62a80a171e367660e42d50ea4ffd2b8e429e5b2b188a6c05055038e7ecd96e9fe82b8627ab45079ab0a8c8b34a81e52d224601b8c97ead258d4d78a3c21c339db83afa25de80ba615dba392f23190836e6724190899a41d74e2886cc9621c09d9698af8c18dc37747049ce8d2d6bc65d733996455eb2be03514fe986aac9b0fd1b7973bb9ef9d5c030cef5867fc85807582bac871bc490ac882c4099c43a9a14fc2b7f12df8a14f5dae430e6c989a28c2c9858220577a0f34884912c142886bf9c141c0980b0184fd090e367551591cf463f366dabe8b57ef9a103169b08aa1f2598b2bd51041fd419cc84a5914d7ec81d876526a2fbc86b7d984e79eb22177cce5afc4f190f4bdb6026f68a35de849eb8009ff2d4bb80920915eb721a156af7feabee4df234ebda9460124a92b2e4ce15ec66659b80c3b589ecd205df332ed9d17f7d4bf9397bbe674f515959af890375762759c6d2a56d64ee1354d0fa3350a1bbfb14c945aaf61cc6dec88fddd86842cec1eb46a8043e31a763d1ef720ded17da2aad96adf10c37ff3b342822ee520f3005de7632f41387faa8ad54d1817ffcde38f4e4d831998287e5ae01d424cc52f724c9ec170b77d51ed0061f70d5c2ba22130b632d68866f1dcf4aa331019425a967ccb198c26cf2faf4410527040bd16f09baa2ca4f84ef804767239221674795fa1e75ec272c497c747e87f2d0aef4b8ee70444ed77172c01316a6dabe1adddf246c5654361acbe4ddbaa2c742ceba9162229353689ae8644db72521da0642c98bc8435599b62669ccd8fa9299a376d5b07fcd8ca157614fb53eeadd51a549efb05672156b6bd1a00f3cdfe2e2080a9a0a473a3e0d02dc931e68dc2c79fbc748432c06c8a71bb50210fca16ebb790f433b627d61749f44b46a188d1b2a8be4f521737040990e1b72b03fbbf1d777427f6c084e9e57234076fb8c56d2fb0d2cda71d52dc6964c6e6345bce24e3503b992346d1f432a466a162f9dfe4afd94b62f8e36ce1c56931a246bdae9e1adf0ca8c0e8597a036739922d393694ac0f12cb14bb894aebd28aed7dc3c6a003bd35721a65ffc09c510878fa46abe08d948506268b1fd79f2dd81c141fc874af99ec7fcf5e1b84f24f9fcb8bb6291d19de7116e3a0403bd3415e77d85ebd4114de7a0484cbe1eaefd6976c0fb1c9c1d9745ab1b1677afa841581095ba6d4fbd35d676009929e994304a38f8cfa258f8e48ee5bc74ab3c5d5522a150452f31f93cadca26a17450ae656d6aaa9eebe7c1740f16cfbfdcf6baf9843358ca6e839856b50524d418030894e4f0f91872c8a9c79271d7b316a54b4d0bb3d55c0edfd2eaf1f39827ae934949631b4e20d677a6853d4c59d4da79c2c5e4dfbaf183a79b5cfd36d5ab9361e58df29f0588584afc019c59626cd232138b3be3542ae4f4fa86ca96a23b4ab2fc8bb8135dcc8c2aaa9bc93829ca216ed63225b32b8cbd1c8c14c5ebf04f5c5dcd80a9aa700d6cc16c0ca0bfeb4b9fafc79e2648ee75e3deb769b13d938a04ffefb95da9d2a983f6bf4e4db01c08fec94f683c2192168a5a210768980d309feb700b69f003684f4d724ae84e456dee756456722136d9ca97ddfbd687b59dd4abde5d5b8c3c63614463894b9ec9cac2d2fb1f52e24a66039517c91e9cef882079fad41da8e3333f1d5d377d655cc3877247b74eb2a23a91d0c8da6fac131a7f088dba7991b73ebcf118637881a586ddf9567ab356cb8b2c3b0f93aaefb8078cded0da9feee09e921a3fadb641a9c0c198c74ec17fcd444d21fa8a1544df3c874a01a1b47edd54e5593312adaecc3db1a80a37697929b8ce2ab0879c89fef97a240f62f2404ea6f26d620b08891348a76828256a41ccbe9337f370035ddd8f39990ca85de8feebca5c3df3fbc733270369a988ab290c7183efd872aae8c0d0e2b704fee13bdc8df10961ac3867a28410d5125a2bd9b3e6ce49558a6339137b71b1c64431a5c0b67394b74fa70c2c94f61392fd4d6d776a622daa99b1548db97c026d3191b1c3030e7c08fa66a5b36c12ca1fa4f041df2aa709bdb5cb5be220b9d69ffd4d67bd88684f64de1dddb3c18859cf968af5458f27ed3e1bb7e9da6b8d053bde28f748e389d79c277b9d9fbf53d5df0277fa2dfd1e50027e8a7e32a914448f59c9680bd9c4176ac342715c22c4bcaf43634d23658eb0e4d60ddffa55fefa77fa43587cff38cbc9d3900a3060ce86c5dea2e4f70dee5aa7fdd044253b3cb6f0815095aeb5e4ce83b3a0d27383656736bd486b1350c17d9ae14959abd312a8475ed3b5692b5d08084fff8d8899d5e051e9bc6c7899127d9771214f21d3267e09cddc8bd28dc2a673c326f00d1f6ef5aaa86fd0d28582e4e39d3ba1d27683d35a2607704d0ee1ba23a750ed7da7f0532d9fa583dea32b0037d290ca5ba5e416601e0bf38bc37a70339771a9d94e190286f2a1c9d7274294b124f2eea2abf5cf2d5bd88bdcbbe517d9b1beb6d029602f6c9f1f4cdde1d18fe84b30d1563dc3fe584d9742e404dd33f63b788b173f0f97f8ca6b71385be0c9787f7bb25ba921839d623bdc887f262df5fde95a54c6de1f8ad648eac72516b2de3203ec55ff4a84215fc30d21b3784482d734d5d8d1f58fcc3f159d1aae92df3157ea05835306681ded57237083342820d26e4efe296756b07631c13451c3b0b9c244abb9778a61f64809a617f6077117d84ab5169657ddbe9a06244de95ca818f1100109867e3a36152010369b81916e85540ec59f233c5645c81bdcab01a4bcd7c10cd10c68eca8503d4dd7e556c88dcda8e5538cef5d327f4202600ebe877cc84187e13e1a06d920947a1daddf72e58f1303298b793360e73cea1696cc5c425fa446028db14a1d03f75c4bb716610746694d94ef7bfc0e17f7b52b92e447e047258dcf640917320eec331057f71aaec95b8e7a3a9049e076d03ce3b4001586860f393313bd7238eebafd3f1784cffbe2c8e1c7ebc61d828019577dbe2b4d6b45fbb329c574cd91cb961c930c532f4ae5b7f5d4c5e662e28fec81fa284f2e1c328395bd10fb1db2dc5e6a3de1a3c26dd6c7f9404db4f75c79e6f77e922ae941960c96aa079874421575ebace1c7ee540ac6fcc58c11af23ea8cc6723609b5bd443b3978bcac5ca162076ff22140188973a97df070d82eb65d9dca35dfbfd6cce6c91c6bcaeec64b5d5ab8051238bc20c0686daffd3189624d85e1b3f16ccd2ed9ebe318598446888b4386da7038230289ce4df8cda2f1cdad8e5636c54b0771adb6973e73b914a87e83e3e9ed2c2d7bb282f9dc6cb53223adf98e629022930c5cd59098e94494b3fc1720b57693118132124047904ecdd358a44012e6c426e8cdfa0615af37c54b228e16626bc7fa23bd620fcbf63f884347748150fa82100cce3e9e1898670224d614073f7757f5bbd14a7eb16542151f912006ea10f945f942e32e6de8c4169e3755f0f14701c33e379102fdc55ea8b6d678c03c14cc6da64b9d97b7843275aa4fbd303c3c80dda4919bcae755e22f6f559c99b7328a04ba6336b7a91188bbf857e26508db8b6f538ca36cc21f2b261709e54dd68b8af23fb03b41d874a44f5da929596a8f2b42a7a2e6cfded8d0c5b3eccbd02094b3c628f62ca46292b9bd9419b88732c9f43dc9bfc177b4f7baf9d019d6025d82235427bc5ab52db39ff424189f90e17ee7e2db76540793f4c3c754c253ce6efdb51096eac7af8ef6a610612ee2fc6a6c6750510abc52851aceb1e68f7e14236b5e1eff3b147639b4c7736fe0d9febae922a08017eae657cb4ef123eeede12e4f950320a5222fc043cb42fcd5a74cb76e39f695527f30458177b82d0f1fada267ccbee36e3f9409f0e9e41cb97596f4dee27ddce20c64e1908f644206cd85efd497f1c075db92b682de4364c81655104b95066bb9c816e74441332bc1e9fb2ea6a7ec89b748ee49a83d8cd3dc47592de6d062661c248a68324a8d4c85c3ca883b6275a40d9d02310ba2f9c17a06b77a1010baa4a114fef29e355976543f74a866bd7f7fd247ea227fedf0bee68a34ebceb2572195bb44851c52694443618dab66c95bfd59c21c36e90e611b994ba3da9502f2ae41db094a5bd28da9f1e72f154c212b13d22b2418534f045763b5d0520b3bfdca07deb456b1bc547eef075ccd4273bdb025ea1ce66465204b15a0116479ccb2f420da390ab1f4d10b6764847bcfe2f33b22eed1b6ce2b2455195de4b691fa21d27203bacbcab6aa00e1f54106cf360db9b8a8394c87a31f7e64cacedb08760f05055a477b4f066f4786c1876c8551603e59a67aa5ba155ecfaa041bdf1a6ef510f80292c103d7cc0d895885b8422542ac5793c11d6ee8c67a7a3fcfa3e60c7bd59aff5816b58a20059a9c9e1b395c00bf2b2dae9d9c73ab3a86c29cb6e17188bcc8a298d0e9b9ee27bc69daff40912f861814ce7ffe117560c14f1246a6dfa53fcdd9ebef83746f761f4a9618de3159afac1ca2b6e87cb40625f663ed8e8eb1e0314f4f4bfa8f68ebc45d16f039427b0b51aecce5fdd359a3c790f38c91fbeaa030291a761877605c925f0e1e60ff4a7c818e6de6cc4c1f75304a658bf8ca3c636b650cdad4414c5ae43548a647f0ec50681c65228b91c476d350b62d56c84f4d53d3b8e0c8ca5eb42d75c1ac534fe1d22967d2dc287765bcb41540bbab0d81df151c22e8bb852a7499ac890cdf08998452f18def3ce1315943b4bd24845fb8275ea3fd92683b7adc17e13eb8a8472ca16a4a127030221e4fe22a3e106ce9e0f177eb04e5540f82186ad0fb726f117a7404574aba7e93e03baf2e815542fa11130f958cd9c9b3bde6a56975054db93cf21cbf8a0e2863e3577c238ce2902c69bd04fc71e03789eb82ec4517101e49bcf3301bb6c3920d81a0202bcfedf1b1874c0944bb4b2aa6035bfcaaaed44ee03fd6533e80358ccb4205f3c56649a1d003c0d7c1f4a1ffb057a93e557d12365b2e2eb6ce08a0e758e3b5080a2211bbaf01714644bf84f7b72fbf8c8cdd91c8409dc5bd06283aa9812f9bf3155035f9e35c4929739c9920b81f53ceec1d8a4d6ce909b9a1f816239c83a37a1aed4f8b94b28a17f71ad9814667314d41fb7677ecc86082371b770694ba09e971d2d49274f612663852dca0437b7ee6b00ebb6fbdd9fb9fc7e687fb33605f013ea069fdde23b53057bece86685d074da90a2b9c21d8abc9a8705a479d0088ee2023eaea18dfe908bd1396d87238f29afad6d69b33731abe267ddac50e061d0ca83af11f7d8d2bd56d0d8a85da29bf9eae65f184be696a61dc5a5875461c8f76aa555497cee3d7f61f32b7d92a0dbe07a888d953a7d51c57fa939dd37c2909850e43bf83720c8292ecea86a086b2a8dfeab3226f3e1299d11d1f982321318a71b39be119ef5e6c50ed54709a9abb8eb5ea5084fdb8f39c5f42c9a892dc4f2c77173a45ea9243d404644441258bddceab705e70d3b38e76ccde4522a92ea126a05e883a50708d190b37f118a9dd5959ff01ff2aaec5366947fe58959d260e190ba6beb1e67c515765478248ae0110c4f77ce956cc104e60bf899d51a19f73742f62958d83d23283685f00e1f670ed0d96c64efcf9b262881ba09071ec3091c8c9c666f3ac25bc985808438a0db0d10106da6fb50238d4827677f135bb3e189ad9b70be5fb9e4c3ffb3ac93e9308085e9d16c9dc6603def6c05c7ce846f1be550801bc1473c29febf7d68065d98a3e0d186a3eb0f2ac81f5466ee13dfb889427ca4d13ca32bc93779c41e026afecc0d622904e6679e458d3d235ac72511704d550aa6dc9026e21b19ce8ce2c64ac74257c86404abd4ecd26831399a8fb29ff0e9d9371fabe58aa479aeb7aafec9191e71cd9a3bb92e312bd3f2507b99a61db620777395631bfac3acc89ef7fce9c5bad7050d561463c7ed3e5845daa397a1245a1439e95dc09ae73438a30a0a068433bc29527d937395a5a2259a9a9fdb7c651cc750d74061701e8f51fc625c1fc813ad7ffa9be329080bb054b618fc0f4a0c8e94f5c8a8ee2d0767465517d4a8d72a1f5545b60e8275c0abda40a635262f51e67966f503f740db2ab2cc5b1aecce8f4b55b95c30ed1f084341e60fdb7c8d66df3064917c15e6a1dadf01caa124ea9b50927d65e577724bc6d13cd5e41ffce021402dc3bc40f3130b635f62ba1bc2cc340f8e5951881f65497e65137214fe621916e71d418ec6b45c4713910defd426a8e1ebbd1970710cc205eb605d7d8e738b59c88dbc9946778f98146c0c1a734033fdcd55e0fa2497e0007276b8e6481a83b29700c878d508664e81609b91d60b4cc6f3d4e4d7e2806b98a37fbe3780a77a12e34d5ce209fbe5d0156e8a9edcfa92245516a1cb9dae73a1c790ad0e5dfeed93555842ca14e5b2dcb0ab090a25788584d97ff71f6a8b9a652cf2656b8102db3cca152660bbed788e6ad86f4c433c9c6911872da8a8b0b88a44e9eee89da0d4d41c83302dbf8452b281a116d504fa29622f9ee8b1caf8d8168a4625d5c9117435e5f4cea7b32b684e01046823dafd44a67b4c59db319c515a47bb51058da40857503c0196b1a5c0db81a34b91dbc359a1c88edef1917e9de837a723122e52b95964c9ae3dc8ad4795f6065f8ed12c7d462374c5258131d1315c8452ed051ffa8c34a1b80993952251744212d1933edb189058f8e221253f39cc1cf6a2b2092f0ca1c2b488540b9ca772afe3f0ba52d4679104e455373eaacccd8d32db46a3886b02c21d0a1453e3bdcc22ddb949fb1ff70c532607e35aca4d069f289b36c24376ffd9d9aec0defaac7e37c6820ee39b00361f8f3945233981c44086d72d15f7b5779b894c2847264eb3b8c79b25c321bb1d4ec3d0c8e4d2fe4c31922ee8a55b40f30f8923309275f3584a667f45e197aca3a3e2e944d180172f109d75223ea4f8f9da6ea820b6ae0ca573977ea46eed3e5b6b597777b7ceade0292dfb5bdf87e6cd1515e57a8b4a14b257ab8dccecd74dd7c2bcc4d9e56b93ddcd2ffdb09dabc96899dd11b5ba7d0995035d5980e29a735ebe915d0329835f245b4a9ca127eb3f6d9e263b23009be6f87f87921192830a7c96f66adb359187f2ee2375e2df1fff59fb20861990d39a8c7b71465086468699e8f09a7a955eca4bcb410c451f96040439c68a97d9e9ddec18a72c4f1844463fe38a34d1a8536588589cd8d8c0e81bca42dd948a3260545e9466529a19b6e9304cc28ae0921265526d89543dcaa67b2d0d603113ef2ce76d37ae01820c24ecda69ec8157be25a0667e7b364ad8b66380ebe376ea2c5c5ce4c4bdced4da42733b6bf9875e239a9144dae3247d8a388f2c336720d0d5860725f1dd146d7afc9a279dc2cba0328282c9dec02a6293f0eee78338775b52ec967255176cfbe9590f146be2c91366c7d08f86713f1656d85e5baa88dcb4b422f9a27013a3064ba7761f6999caba19cfdc83fde994dcee8470cc68de7a7f0f77b8face266470d38e0680749d2e673d5251d2d0803b5204bfe2f364bc6b64bc6bd7d0b2862c9f9dde5c32d4eec95eee709a2cfd825c91d9c77634ce989e0d55455392f2bdf5743f54c3f35d8b3f6521b32f5843d04be164473d35248d0cae663185de55c6bb7d9915217ee10a0dee0419d885db922e8b1a731d22b773c0bb1571c33d12b9e42f853771ce8ea1aa7f086ced6c31d156097449ad449b73de505e16692efa0e38690abbfaccebccd283f9efafa951d257d3ddcc2139c74e1b6de0bb391c2634660fc1005ed94694da4c941e0452b2e5c74feb7899faa6a077aec5d3767dae9aa7b496a546c6abebec37bff0306f590bbba3d7e77c2620d41a01d2ce987b049d7196e1edb6985af915b14290158483b34f164c8d0d61f657375d183c70af8447568c1414b044e899f65d372f8912a5a0e24ee91f19420335b366232652c5bdf74d0b2ac855fba281541520550140503fbf0aa142d5d638914cc5b68556506a61afa5031b6667a79b89ab0958e31bc0893f7086cec11a37353b244a8de1602921f727c19170718d52701afc7b77204023be733dd865170e0097321a3fb1e93730916f708d2f6ebc8c4a54021f6d9ddf191a3b75e5ac610bdb7a37432dcabfa81214cb60990bd439f98b662dcab866409c836502775bcf87d14efcad09aafc85203736d226a61c040dec70a2d4a461c560140633fbba7b0146bd071bdc2b368dc50329e245bbda747d18da79f60037332a9485eecb879ac0a8d4697c196eb47ce381507c9161e8aed6fc17874eb073a85b481bdf935b5d2b5a689a7a45c7aa4d3e57352adfb5b49bd218f3f164e3237757c9e0847ec862a7589996086783143103cfae625aea913a889e36a84237a14664d44f32b405dcfddba4383658b751dcec596ab4dce8e28cba4591af6117ff0b6a9a8d70ab35f1e00402b047b9a72768d8f892dce20480d857b0765f0d5a631d8b38ba2f95686af14095ddcac72ef9f3945ae138e9c208ed987c41c89aa13aa8d110af7d6cc4b1e9be555104cb6861d305a661baa2d0ebeb925181676f6d87dd7cd8b5da4c9cab7a60c40304c79d822a962c077f65f7639ed13c32e7b8e007baff2435e76640102621b1f5875daa8765bef9b5a13e81f71f03433ca4e16d47d97926c049af1fffe7ff9018267266e57335c83ff492ed1c5e6622aaaff0cb4664be2916df9cd6951ba1d2cfb3b6516da8272ce7ca3360848eef04df2e3e3ea36c5489eb42f5cda7043219c42082138882f2ed739834f8594054225d8c0f3e9808ebbce3beaecf58cd6d50020050d0f36bbd529f6c25417cb61ef79989be2f7ef925de6571cc7163dd124b575c745e6d07291cd74cd9d78507407f880212bc6ea9d7bb68b2752755774863a7048bb1c73c167ea8abd6d02a5771b45c2568acaedfc7a845b635de1050399e63a0993caad95512f8f78679aad01036d650a7f191c8d2fadedffba35345a4bc578c0c921f5ebe79098df30023c158ea07ca01981e94f045e21ab9777fb0939a91d398a4dd292720f38a5d60af8cd9ad664f257ee71f1c634ebfcf4f68a8b64cba101d18a083465e56cfb7ad5a6bdf53f74ce89b5716d31fd85c3d219b02dbbda8c33bdc530614b2fea6d331ecf145425f2b1fd7c4ba63d008d5211f656e11eb2694bf3a5b08e7d917b830707daae03fb5edff2a356eb81adbee633dfc9fe77cf2846df9d18f0fbd5da7980ba7f5cc10d39ac0de7ad1ae194b183f30adf7a937eb98a823a6780388e23d919bc04995a34e254a5a8321b60679ac98769823770311bef8a9d4996cb7b074d5491ede06817ac12d3de6b9b12b1b57e88c7cc4265fae0bf9c6b608a36a5b50899dfee20a4a4c1282c8782e8290904fbfc9d365be39d4908a265d94811e35f36a5a49fb6cb59ebcf68ba215582dc256a2a14fbed962ea3c15f589ad0ebcfe9e7c21cc3c9c22dd31d29445d8afe2f20e31d3c9d1b5ee383658fd618a160c17e48378d910d5d903f01a469fafb02237cc271a06c35a5706e4bb9a10e77e3aa334cb5068a4592efd4dc78bac10a38586de59cf4d6d530bd0915b78ecf1d5e4d30e782dc1288f44358cc6adb9779bd6c85ed6e9799841c4f1bcf56aae5f81a4fcf2403142d3b8a4cdb4f505c7f40d1c9c3ecd0304558e70df9b17bbf252434d4726d66316e25a4d832838e7d7aabcf1f1d18d8f93de9fab6bf486663c0e240d725866322984cf87deb281918e0e1716f8e6418cdace04d60f86aa806fbe80d89feb319e5d47ea039759872e26e9e76c91536dc8fde209c72132de97cac06bc31216830fc076fd69f6622ba56c5c350daac917869c319beb9097cd31927d6e5182550f4abf8f626cb9c9520eae6f052fb7964d9d6d412066f6bfb7e22f44163186f0a9c62679defca1ef596a90d27c95c9a6653c3b31e54df6fbf1f7679f182171277624ebe8fc634f0e410c0cc2f0947985de085fc7eaf9dd32234e3b51621f168d3d8965c2651d18f0bfbfbe534668c49af98f28e6382eae609a884d9e884a4b3272e4b7443543b9ac79bed7a777c0449d1704f3eaac8d61f424ca78312fe67b67b110acd3e2395eb595f3c49d659e8b91b8478649863134254495e60469e2548b3a00af19815e570c49609ee89c10dd65ed9e73347e13fdb086704a1cfcb8a690620d067723883631e02af088b197f9efc9a61ddcbc344bddffdb98c536504897821a3735a88d40cb8f1daf59dc72a4e0cb03c4caa15c49525583babb8343d2743d8dad01c452cd2d0f865c581683c1898e370332608211d4ac6ceb938da940cd90d0528007b7499fc52314981c3f5c95d2ce8934aacca2782904dc88cc680a78e6c95fa221e2d5b9c6810fc99466ff42c0c61f3a2001f1a6576fc947c9ccdff691a4f3377595221c80c6f9cbdb40363b1cb8c0332350e8ca85ac52ee1aef7771072b6c34d2db3cf479ad2ac8c94aae19c2064938eda6f8f0937de7cfecddb3ef952177157202dccc8d7b2de7c6e89b57144167e1a3fe3c30e44bd90c47ba3e56f967e670d20d755a8b8e59e6133ad87e1cad4df45aaf0287a54c51717113e322a6eac8c9d4a2b2174e5fec70cf2e53d1a3a3d375983a229c0d7d429d21ce89f60ff346d1d682382e94a0500550d41f24b273c8cbf1b5cb035f0739b150a9ff49dfcd930bd3c4238db8a71df6e43d72ec6c70f2162924fc3451fc118092d46b0d0a7b0807df468b533461dd34d7644f4701407faa0e8db95dd6e1ba2017c53c64562ad43264c725a8292fa027da801fac87724f8f51352bc78a25c1f6edcbb2d356adb4f5b611e6761dc7483769cc6c0df459a6ef64b40476c040587798ccd14192b943d26001b2c7ebee2f868133d6245c234da5fa8812a78b42d924d9a03b224596a67a540b37c664ec3f4373edefa385f05841f098bb0010352147bf3ef37f80067dc64c51cbb1def4b7280cae3a7f20afe2b6a196d76fd0cd57dcd657a15acdefd85ec4135d1d0f86ea3e0bcd22f59ceef81e995a3e2a7b35a5f7785711e74f48c36bd3d44195b5fc3042312595e39533c882a3697a3223680f43e3adc111f44d784a36453c76f7b16179d1c4eabee06ec17474c10aa3b54e605383a7a6a61cc4d9375d595371d1597cfd52cdb01f3936db1fef0c09a35de540dc67724bc18b92fca94d09ca8ebf6085be98fe0ef210046eab82ad0b0aa7a28e8da9a9304cff801e169f238700ca3dd3f65051ff8c9ce91fcd828bbfbf5f6a9fdca4eca252eee9ade66d8bc33fce8ee10a9a5aeba2435c455dc4ef18bbfa03591ba8f7402216c0525e0e453c08f77bcd8db05f85608593a3e7ad59ca99cf9df4f3230efadb3cd56ee260e098d2e2d516e95598e4139c6e05e010190e57fd30aae328f13c1be88633c7827aca5dbf952a0126d5db19468b107fe727ec16c39e2dba9dc23c5382c014053987361f58881619bb108bb23fa40702abe156dfd90037490303c29b28039403c85b9be96e6dc94304772bc02e325b20bc043babb69f2a7e888fed2c81aa38b282fa4245eaedeb72e88c903875f3b9e0159852824a7e72ac89a7f3459efaeec0898e47c7cfee07984ee31ad8c560c177038c16c7d638da8f9f304ac5c786eb7c9e6c99710245416d0f64af9093c734df6076f17e55b7d94a75f10573da095db3736ee7946712a79cfc08fc5e860f4709751e5eb3d9080155173ffc8cec3ba2f7205cf143de42084faa47bad3459fdce7bac7c4913b74028bfb5139357899974c0453f366d3c4619aa45aa89b23db93584865f5d7ad96f46c5d5f56f43822bdf44ec168c6d12356d8fa39871e350c5c08ca6948c847b7dbbbc8096764718d1a484ddb6a253c201678e90b72a27b0197528f498f14bf15c54e2a62f6f8c455aca1aed85a06c808a0f9ee7ac21f27cebf872c7adb5077838bf56a8df61adfab4c5e23fa9af415d01813b3fd1cfc72a9862d5fcb38c81195a16d976566cdfd5172cc696091c5e5e08610b34b6c7af0865dfdf45bb0c9199539a8d99eaecbe747fd03fbb367ac61168507d78caec370a7f2667328e94cc790c6aa40b20faf5bceb5e9ace0cda20da6773f64e871f8b13fee27426ca0b62bb76d4ad58f8626abe4abecb3b5e92b69ac03c4bdadc2ff67bb4d55aeec1c4ccfa2e726395b7f7107a994ae7de8e143a770ada47420d325ef979e97157ee2f0bd8751a300b1d1ebcb7f9e7c2f76228413c617ed3b4590a23053e8c1fb4a7d62f10e91783a7ecd4ef2d943772abeb369b35d3dbb907c744c67d4fbdb3d1e05edb5c13ea0fecf2671a891563acb34fefdb8544b01cfbbc53f187fc77d142e4952f6ac705f9263b718934a824bfb43d856e7800e0ff05200bf264708c79dd4692b0af16e1be434bb57b1af1f13cf0f5b040fb846daa9dec15fbf11c25a8bbe7062dc5e1c3d102073bae3def208b18b9518db4e49dec2f1a2f456d5b4a7ba8d3ecd12efab132357138027915fd69e4a055aa595746f2ed05c2883c5cee041d89d3f81014d8807be7d82aab459be474fc208ee68d6fc10d38529203148c96e17c4460a791166d6fc7b597a31221e1e80bd862224ff58224c7cc9252fdb7a17ff89983026afdc4fada013023d200f4fa8b6a43aef066fdf8cbaa59c43131f26590c8d8fcd45fd09216ffe7d15c9d98ccf84086cd53cba47409b8181ff798acf04d35ee21eb277ebe861d66d77e84a0ba20c775f87782449acd36900dc41df5f731a1059d27e9ff3d5eb122da2e9a6092f921f083e1ed336d7f3894e7907eb2d56d0c5163bd8ca3555f4f5c3847a9cfff43e2a7bcb5486324f85b8c907d959dd78b49ffe04e10b2af53390e4b9f4b04f39f1d17d0b9425c1b2047f4ff7f870d1f78aa6eb5b0e6d276d136f5a99e59d1a97cf361e6aaecf8520d44d3913188f73e62043a1a0633c1acd6b02c74958bec05a4ad65c5966721ba4abc6216329e0850234e8d6888f1239cafc0381f32ed04d791a8160c0e58901b4fb3381d8d8e54c2198e8dd974a16392a58d5d27e3821e41ac2fc762fdb22d45364f004ce9cbb7a3bb12466c56fbef4d4a3c7ecad6676ca0400f41c686bc5db5049ee6cb96368af7673cf4263007b3de19cf10c2486801354f9962f45d21e1d8383439588920d655ce7d0df5f95c33dea42afc558c51dde2a0105a0f8df2ea1afcffa73a9cc8017e22b95492d949914450038cba2f03f39ae144262005f08212ab825334260198b43c3396ff3fddb168240c7910c60fd38bfa35199533cc7859fa7a9c24171283fd1b7d8da5dbe14e5bfaee1e46a79d871c8975e3c61e79ae796d8ba0e330fb1a40c187ed5ddcdc76285939c38695abecac5ffff0a7febe2c25a7641f3adb8c28115d88a8354ebf7c91b7ce3f15872e1dfa0b271661f1019029604112bd837059488bf3af425f39a4f4d8d1fa7ef74c4b627a24bc37b5f869e3ae1e31446460f05500f8f7a5451d700dda4abc5713629efda82c75d6e1ef3885e53d0b0ef3cc6f12974bae4ee80a49c03dcbe2b8fed6b946b1e4e172f7e5b3bb825100d68415253cd89dd31c12776e15ceef1b1d03d1d2de4a96a230b9ea2f961591571272927b3f72e1303fd4bb2c566f8c721b69251d697a5a5831165ab83ace035f1e78f90e030932c98ffecfc7e70339a4650c2f72cd9b886dcddeea43ca49098f1ec69fa0adc65d8c16bfe8f1c28727f99873483cfe7f59798af60126908d0b2c9a5c6e4a55b52ad86a4155d25ddda78ca9ef20deaffa5c3e67bee383d921bcf604e2b95705f5a9fdefb9d214748e1b24cf20ae2516d7b90da05b1c290aea7b17d8fa84752d4248c8728539f24bef5d501774392f02ba5ed8f3481cff5988139c4d9f159544201fb2631584b79ebc677df88b4333010d20583e9733ffb356d454f90554ee7a7ef46b289c9cb15cf73488a20680d667c2cc2d5b5cbf09a0b7e132537db9aff56d98885cec644d359ab1d5356e85a7ca2346b806d73dfc255262faa4e4499c7814599cf9aa0280ec7cc7c94213145bd9aac63620cb0bccb6d28c4425307adcb005a26b13af54fb8713c21ddf218e463aa53db48ffa7f6338f31ee8ef8b7222d815ba1a3201f73e23565f610947baf24b91623f6ffe493fb4156188e09d2a1c06bf0b4f9a91e37900a8e9821f34a64238777554997aba37b73941072d30125ee188b0c4e9fe89b454b5ecd5b832f1040533b9b2a63558d070bb48b367ae8b955c5a77dd04036b0bac3e05e58b8eed9a4d5981bc859ba2cd16334a34498ae7fcbaeaedfb30712a581d8e8afc709bbc2c9d68687f45cb8328667a67aaff6911226dad5b21d7e533389adaeaec981808ead6af0f2b64cfd180f34891682ba1e451ac24c5c746ff8b158dd4477fdf06d549d10736b1f179e4bffa620b93b708c7b66dda24e21677078a75770698a53c0a6c6578be88ac75ed8fdc033a95c6722e5bb3975aa94ab85742ae4bef3c7a162feadd32b95698c190553f469582992c57432578054dac678b2fdcbb3d7fe8c3eb1a8957731b341bbdc6d49e4db380623abd658087c4ddceaa28dca7b2188d781fa6c8f8822ec671a3f94eef767a0a4e7b8c56a6b77510c2dfe9bc517bddcfac87997317912ecd47a5d8f6a83ce3fa9f9ec12c1f4a24093b0bc3c30b601a6f09194d23c5f6ae9210cddb2586ca454096f747102b7d59170a3c9901429ca2d58627eaf4c41dbd707f70a028812a052e234856100aa55abcb6e7498294e15605e7c223bb537bef065d05cdf5b402b65af79c48270494a114794cbbc2ab1b84f21b6d7a5752022fa8d9957cfa33aee523d78cf3e2ad90c6418db3c61e716a9112266d582b33617a70d0825f33cf6f3131c326e04aa3699ad9837788c000b274505d67d035e2580457cecd3a6241b139c180f961eab3fb5ed7d8b9a01a399cadeb8840f365c83f4cc2b9e52ada9dcdfe676a11148f67eeaf94df00166bd52e835aa2fbdf6d788aaec8bf7f4f9fef94db49d951207df29186b2eaf0b16b80bec2172f146c5a9c4605c1d831967d4f5a8c4a73d288335c49032775cb9716f7377b7749c1e79c7197a0f5033ef10846388fa8f10b382c884252d1dcf609bad1045dd2f0ad0d0f09c125721c70f11806a97fb90f0765c1e044683a3b80d6f074b15bdcf0b547db6aa7a75dbc513c3f6c036ea4df7496bfb52718291e8f9cfa4e748afd1ce98681b83b4808c04a64386972191b457c49f1cc69dc4a3502754437c8f627af37919a93112b47b6b402e477009965f73b352a1c2f1236cdf07d8fe24a200ea24bcdef4bdcf66db7b94e4c5c086b6f094b738bcd555465b862357814112d4d032d05dcf53a86ae3087d4731b592fa2885787740e037d1150c8fce14e4f50c9716413c704628fec718e76c2be228dbcc709d946cb22331c29ea17fd5fbe2ac53f6ba4a93a6c5d5113e1a1e678d7bf2930f2d36b0d8777caf966303655f7c2b5743fa9a28dc74d9133a2833ceb312678d5f113e223b855789e9d5d9856db9b3efcf027370290b97ed1fc99b21d4971ce0f57ee7cfeca20cbd70ebf919d211e4b7c65375ba2e20e8692424c3c003f28f05ce957e4a64014c54402554653d3d94c08fbb9d9d9c9f8b6b9eaa0211f0fa832aae17dcab5918ae0ff74d6e51d4716c931388937ab2e1dcfc839054bd7d4b40a3c9eb5abbe1c86f65f21fb8d4b6dba7be96e41a6e398349af59b4af4d4e6173f802cb6ff09701625419ad94e9fb0d75a7b66b6c132a6e5b5b3c4e5f47bb991f2f034dad74215a218d811551cdb03414cc00b0b5ea324894c3f78c5c8af3f688375ed52a104751caa092b7a84e510b6c1a6b9cbe5bd14e685dda33766282f99a5dafadd3cd5d2e2ec63ef0f5ea3642ebc4596dcc6ba8b265d8d98d3246cd7fc1798afb913bf581a08c1eaf5a1fc0b62dc041b0cb61cbb90d3d8d0c7b813c72821c0597cefbf960f064507c3139159d9e72fe14b872921cf9e947ec75a3f68ca8de095dadc87818c9bd2b4dc2c77072b26baaa552d3c645629c4561cae4d63fb2414dd8ac2c985529d87158050c9167b9c5057e492f04dc2a99771eb4b77755b8cb1f517d8d54e8fc37702edd88b085b880e33edc510565ffb649130c53f45992b270d9e485b8b64f893e6796a030a70da0e02f9484e3ce2b91a75d9289ccfc89daf9e40e2435d0b6858c2da96331813239a1b3ec57853734486ca1ed57facad0f459489309d5b64883189055e407b9f5090f6f91d9cd84e95e78fc2595ddaebfdfca18e17fb74fd7be47eb844a4275633740bab9884747e4948642edaaf970a6e073ff08211305668c36ade3cd55f031277f82bb7ddcc4ce9b7d505582baf3ce554601806c9313cd2c7697dad95d6c6fdd963f275b9b2cd1c7dfb4d5c3f3c7b1f022602310b3f29c210a99b3a816cc022bb8074c81816ff8699f8128206c091d27fbf174b7dd79845531fa80c4832acf769251eb05ee64a690e3b7a1228c2d91520f07f2e9965c2480cfdb04291a9be811cffb7262c2b9f204eb6bad603b5f9ab36c7574d536f7a506e84555b2890d0c855c279f29835aff22b01285a5439954505db68dc874cc6a63153bc70fb185c979dba91eb5b630b5cd1861efe317ddcc661dbd9a3c125d402fcf6e67e075492d67f5042c318b8c6dd89f7abd5bd7050813788d09921542ca136a83402924f74a27b1bc8081351dd9289faec857ba16c280bf2a99df85bf9b610359af405a84ef4cd291cf83b9c0c3b84ba2f4e2c746ffdd843d52b75dcaf2a4fbbf46375d1dece38be14648d9fee03c4da0b225072e24690f86112a90babe348b69b218843b886bb49c3e7cc9fbf79cdbe9267178d923cdc6ce544e24ead95111f8d1a2623c8bb0fbd246f27969aa12ad2241671ce3ac0638752a26408af7b4c64196993ce2f034fb0226177c19f12b08f824e62ef15ffd4ef288c97d829b36c15a1e9fad908563d32b8e2afabc4c06bd1a34e675f1f295c0b11179ae403e4b2a2f7a0a50a958d1a4c4d86b9ebdc86f3cba86fa4f639a2966a6ef8171597a46a36e5b95906bb62e34b4293c568ef7acfaf4f89cc523ed480607b7faaddb0166d52c920614e4cdc358e9754e6965a9b3b404883f08226c838c9a365b61d8148205f089865a7bd05cc002da4da2356fd7c86e92997354817517be13e6fae62500bffb80cd0946c81bd9b90fe455f32134e7ebd66a522b63a16e1774cdf3c27a63c27c6b6c377c7ca1d4436571b940c8d5f88ff6650871082394fede9be0045f01c25b7c8259919e2e227467a5ecde58b3f4fa2d7709642d0073b39be4fe2772588a88393082b65f4514dd81289fae7aa5fc8e17b52dac8e4f76acca6c2ce979727930496b70c61c2c521b89c1276ce5a53d2a750a5f7b20a02712a4de7b8fb8fdf03d92f22bdb0d971602ac1f460e5f38bd926dd857d41b6e3d3000dd9400b16ec474ea8445f80e9acbea994503e58f56f3da4f08f8d250415630bffcb64adeaf2f21d2135bcc729c021bfb32a5e177454e71fc9c40a57073acff37f9c4155f0a3c243eb3e27bc5eea7db28cf293113e3ebeda5d495037eb7edf6a3e0a76f2883895219f8ab89855debfd7190a08019ad4d298eba7ff8fc91a38c83f09378d45e18731939ee779d21e1edd3834e96c3b67aa0c47c7fbda30d1db6619ff5b7df39d610efbd4a83677eaf1dc42e86d05b08930cb985aba2f58f25bc68e319dbb8af34781ea5e1cc1d5fe2f2c30c721eeab25ca8544b0965fda0fa9bacb53ebec9766d39dc5b73c2c079a6076d585d6a185fc3bdcfbcec8f86d6d0738fab2dbb79ca2879e4578f99686dc547e441949a058d354898aad49c66c09f7687dd5faaad33e0fff54fdccdffd46cbf67fa2e1e40e98582d728e3364af6fe9d41be1f8429a270dc53faef626d5851f7e99d3b214a869c553be6b64c9ae8334379616c9c6ea4df1547b358afe441bf24f522aa2a8b05b1b1a1299c4bdc1684ef3ec9eb219a96d5f44309713bbd10a00e750fc44890e7c358c775afc0dd2208e4145acf744c2ddcc0102ee27f8655489ef9aff6db78d029a8dd4a11e513856be2b5de5bf5d9339a77517359be6c45bc85e98464daa2013e19b58971d29d23553fc0a78aa61b7920229ae2bc99f9cf95f91966062e5a925d5ebc2153c1dd66554327b17b38c841e5bfe0029a79fa399ae48fd9f82c37d318ba03427b0feb60e966217db10ab6a207aa603616363932ee35957cbf6e90c411064631c2dc17ae5ddd424b73ac8f56d7acd2d5cfb86da41dc7525fb9aa95b469b8616633179fe00bbbd553e84b033cf0e70f9ff13a7e1b171270b85e43d91e4d335d956dcfa9e57dccb103bf35fee7ea8dd32eca3e64b3c31649eea9d4b904a085da8c74ae7026f5fd48ad24d81f404baf3c9698638af92e49aa45cd4748f8275785d8c9619f46e1a94810d4e598e8e5eaa9b9798f83a842e85e3d94e074674054133668f72d5e80368be085748d8722b0bf25f668466c250c0b24b1c7a5d921f854e5e4f630146a4e7cf53d7f3911be84888c4a09bb9722c698a5c8bb8ce17a376647e99788ac92bfeafe6ddae16f92fa6d3caa47b5a3f208f293b989e1c802365d435e46232c94eaf00a4f008209622d0f18dc5d72606ed6e9d1b2638830d2cb0a4d769f5ef94dfcd12b937f8b26ffa6a354c4e8c50178dfd1b8999a55493a6b12184e1595b9e27ecc63706bd8977335c8e6bc1d31c42151e4ab563195cd3442d31db1684d598f771e0b5bd229b5c101a45947cfc7e9e730a59a79e9f18ae589e8690331ad3e7997ac4d7ce430fee080a0715d05415f656182ba3a832467645d5a33ae973e91781ec0dce80d2808995e2a5d29bab05666a61946ceed8762720bc6c118274c818d495a7a53b53eb9a4e03b583497cc040481b59b37dc835a50ea28af84be1edc3153dd720e67a47a0b54b710b16038ff93e9099a0e624854e7be780520538af03ab210aa028cf19f1b6ffe18e56a8ce8338d061d4e1423e05932767b52968c371cf2b6ffbaf07f51b54e860a372b696c2563d54a0d6ab6089340a0ff9b5e5e8be7041c69b59219cc91d18d016f18a1da95b120f39fb22fb4902533084ab58d1f22cf00eb8973b081ff401f9784e212287f7c78f397d58a3f5712dda0aaca109972ab6fde0e8f280cafa9aa84d1f203f532e910205d86e33288e18d75ee6ab92b63f4113ebb3c9db82fccab817a0c3f9c4ae13d1c28e5329c101ee0697bd49752989dc5b3ad48b23342b00825edbf6c8a1be59e9e56eb75a55120a0ffb19122190e9ea8e14ea7cc6083c20549bafd9954677e1e4f3ae0aa1e9f4d0c3d4c124373eb2877f5faf6c60902eae907eb32054b149b1975ee5da2d57dcd149ff217f07a5eff03a823f3d90d75bb011dfd59bb480fecec03716eecf4e551f99c4bcaa7e5b473e5401cc3694e57ba7948c19ce8b3b8cabb3238dc6ddfda183543d1d08d767ae98f1ab8847d03a492ffc4affbd41e2a466860c2b94105b098c58945a5ffc587d28635ef6c906138a725a20f449098c61c35ad763f5e3054e48f59e9b7e067522fdf4a9649b12bd2615f0c8617d881310ffe634fb24c596634d564d0bff51ea4e294490414ec4fd90083bc0ef345bbb5f2e05553e7536a46b6782dfa3368fa250d32939a87c8d9aac744e0d35cc6843da4ee6d549b5da178a981caddef9cfdbabb181e0fe4a4956c81bdf9f482235146c1397e33356933e8a0eeb83c2d91c2889922473b94de6c2f59fe230af4d43758f759c033f0f5ea9cac0fd849886eed01b0a58a77d445ecae43c3c5930c208ba67996773878a2a757889b0e370962485ca95507befa440607126762a0980957556203754d675ebc57672a85d01d4d2533a7da2c59a72225eeedf4c1d7bcd58cfcb9f11e5966a3be0199ba8c9b19da4a92a07c5bd8de3a234d1324998b713b9d5962ab3438f3cf3e6d0dc14c362fc644d2b90d2d57cc4d7de03c042657bcbaf3d8807d04ee66e366d82069e04bba2ad7d5a289eba275ff23c4a0c84be9945ac912e3ff2deda5678b742e01dbad01d0b6a5d1521bc2d94994197711a7225b6dcc617de118c9d6c5c95741d61ef78c87efd89a9d16fa95570d45fb4c697078a7fa9245eafb97838bb4ecca3d9c4eb783d5a6ce78037dae95f1cf98e57a10c088e18e59619bd622f708aed8775321c3ee5c52ac72631fa8663306a0eb7905425490000463c4a7f390e8813dac7163f20a527b17bf2df281efe22e1ac4b0509dbfa09ee3e037109ec061006d0a41cecc7d692da6715d6d40b64cb69e20398b90003b3e4dc15855cb6b5299adf8a10442b7b770b41d7027331153ec51a999a84fc88fa2f7e7155247f5362da4bc6575eb37da89ff2f060c9db0e7d32f34c56f676c7a3af7ee851777a8acbc9a9a6280918ee3d51694bdff43cb5de7ce9b7d255676ebae62f4729617d6d53059294c6d359213cef8e76b35b8f3667771659366d16778ea5627dce6961b5df6131d1911c6dbc87f6abd31dac87703777953600a523c65e594b15ff079a6fbd8db32ae3b1e742b479ad231e9a1120d35cd543b38c7a42303b9730e1704c54de38af7c04546a45d4a35a4d2a0d61f296f1794b31b43ea4d70893b0b8e118844cce829fe9c6a61285ac340e4161366f1f3bce8f44b53c929903915ebc8ee961ecc8e6117a27e0d1aedfb2882dfda1b4ed03c2163f6ebba16e12fb40550e130f3fc99530aa5d7e30651565462c7f8f580b8af13ccb0ee7e9d850b5f0f4ba24df0e2a0ed623c7f5d0799d696ec031beb24566241ab39eb96bd265eaf5eb92c69f7dddc2031367be53101868c42b44d0fc50be998439174cf65e95519c34dc9187cdab8cb330a2a8f233a1df791c7ed22a2472d7110c83f83f0da63fe8d96f0fb4113490f7b156aa99d36ec96a9981ef2d475ce0897c705c3cd4df71907098156ce422800e2efb80e28b82b9b584df9092c8d077439ffc5b219c6a2657a2533570573414ce3e39a796fa1b10f00d28fc00f395ed68a392bfee550d2d40efee92c23cf7d19a4fceb18e2922c6c160cc22a90c99a908be4feee8e01082e5b37c8da85fa31cfbe7720d87041631609b08e073564c56c7472c698409303b86af1d052c230b10367c6f6b2dbef1d637148823fffd8b9856a56343b0d51a776408fdcddb2e6734f3429b5143eabef4893acb162ea2375a9087c9a40110c477fd1262d17e85bcc3c1cad663b484aa46df9e7ab29b1c0a94f07ebaa0707f031a9915f9c42935703ca45c16f40609cf26dfd460900ee95bcf9ab5eb77b4b95777122ec6544bcba468345c8bd5981538802ed2f08d2439fa86bb1680895733a74be941d859936a1894da1361fc47e5f6a1e789b64a765e08dd95680402dab31d630b1cd7a56c0721cdabd2e13e055b557505dafc67c035a5ab1c1c1b94305ad3cc7fcb0920a81f035a76aacf6eba6cbb63a3fc22962d8f37ee13cfd0119c351ca11891c1d94c7983d88c0ee953192bd06efa22f33ed3690be2c8493a4ac1d393a864a60e46cd366034ee386085e33360821410f1810eb568de5e01aaa1ec0026519350ebbfd053aed04f858f6c37d7fae4edd18cc7627b6323662546d3a3f6fdb33346749b1c659dea7fffa9cfabeda4ad60fc35ef5e11153c693ffde6bb805aa41429bedd3dd2dc543ae9d18ddf039186d10d65abae8b0659dc58eeab594889c682c7f0f68438a8ab53b5ed677004c410c7e3ae41c7dc53f051cb85477cb23679b0731aa2506927298affab00ad5778a0113d7ee4966a51b59da3ffa0005d90b2cc67133c40538234d31a3bcca4d25d972d37b3fbc8d83e91c2030b328caee150558d8e3c8f3aaf698773976b86bcb80553dfe416856b5bae7f0827d43838e3d0ffb6b54d385f5314156b393b374b9d0c86249817f049bc540a17d5a82ef4226864fa7a642f442b02bad2697613898b159a9b5cd6105b06488c2ed1187d439f21e346d204d876d6599b55efebcf8db61a461a2eb0fbeab85bd61b08044908e67af84c9977080ce2816dfd8c6a8586da7bf17389fd35121026f4c26b3532812b67be35c281de5672ef2fb76258398bc7bdebd88a40acb3de030b10d4f980569469a8e48677fe36965f3db4d1f7a98470a73b8d7f9b8fbea93e1d3de4f25cca1801b76df1c6542f3af7ad4f9bd69609486734ee299cf74e287783c6dcf2ac73e8b13b89021bd8de5a5538e77c1446bfc8febdcdc3d49e9000adc67db70f73b58d1f7d66a5912cd2fb25cd7e80f3b4bfe73a3095c624a020b705de24f00c1489b0afae570815a51da4a8c76616deb279114d0acb81ece48661c415eed972eb48e5a3782c0c4fc45df8a90a0c2c812765f259cc486b071cbb6e52fdf82701eaee2772b4d43e1215084340b7b844912744a69f79b78c817ba776ea05ac2ce59e2d155d9af211b87eabca16313e71c92046f574f77a02e2d5f9c3de91597b6d3ee2fd01194b1d6ba9d80487392505c47a3b4d83da5517bd7c8ead4888ebefbcf940312015c9f23f29058d49a3780b551f5cd120843f5aa50e9bd539c8102e6e0b1266473d18388af9cd89a713de5885c5497819c3d2d614e6bc993174b8932cbe84f6d5fadc7d38093e24caad7340d730c4cb04daad6c20254a4ecfa3d5835a3b229040678a6e4dcd629ad872b7520a6c0d60cbee3e25253e7f053bfe743a88f184d3cd0abcd3375a61b6bb540ee61b10e3922bc842eaa5ebdb35bca2affbde7103d2e7e101070af2bb28b71f54226edb2bcb3ce1c37bb718bcef8d6fc1bcf475567dc94b986c5720329086801816c2bfc64b2f2d5902072c0bff112428691b9021217c0490448184e709359995be2a9143021e09b99a458860a3d2c7e2c1d8125a5b74c24c62578f8e74ecd51dc8b8b937c7466dce7af3d206d54a9f822232cbaf0b91f81f3c4671910a6a3eb589704ae14fbae3d4d1e498fc7f5df21276730b9cf7b1955f77fb5268760e78e0600a05f558b30be82f4d964f2d5ce3f01aa4c9a3531ac2abc8ec84577981cab5b0e2c52e807effcea0e216ffff26b39d3bedcdc389f71e97a87f12abc23e66ebb5f1221040e719027fac548894898848f98458bc85835c6bb1062e5675c2144ef316e5e0e266241e2d062e22b9128360d4dce28ef52859a8984ec3d84349de4d4f3033489c556c4699097b3ca5e67850337863bc7feb958fbc75bf84701fb35c41b0afde73a6a9e60a587bedd9cf54cc26c3f306d66cd64b3a2558bf768b4ea1db18dabc27e730993cb3231c95dad5417063d9cae216d257936cd9f8de108db96b949741c87d899fd43ddb52776089ec79e4f2e488e865a5a25b4f2ea519dad991a7df1186680972612ebcb1134d22b301faa02e0cc8618ce160deef73771790dbc5696fbc2fb77bf1c4e3d10449af158fac84dfa70da635e1b51fad39a803216dcb40c7b027cd12eb8c63bc435a81f80c8fe9144dde06d7894b5d926661482c051f441cc647cc6dfe7c75afdc68245ad979132d6bec74984e9d62ebd1d91aa87ac3f1527fcd5d2902045720efdad9093639f93a979f0357cf9347073df84435bc7ac628987c0990cdf4e927fd0e2279ab5388a3df722c1285c1399c3fb2e8a2505dde5fa1b96c38287fa8d739736b6909ed8565f68b19325aeeccb7bde7a2facdd9300c3371042999871f1521a2d5cecff3010cdb700bd4f536f5d4454e62fa6be4a7ec22d78b3bdb8aac7061907dac5f36f2894b330104ea1e765032fe2dd2cbc8566d2a5c9b76dd93de7094090af23c78529a5bc15eae240e4f0af6f974b6fa53261f9999c7acbd6283479cc93607720d482b5d8836d3c756f0df2866fe51fa107108ea0ecfb1ebe4ead82425316b2e862e13aac93d872d00bf0cb0878ed7dd843c2fe300e7f9ffe108c2d75b399d13233109be71d61221fb10bc04ff823b1e82fc91b0135df3a4332e788bb8e80ec43b5d92093ed2cf3df8dc36a4c5a85ae993b31bdcfc807fe04b62831f8bc0635a5269d571b6ac102a47fe3afe498628c4b32718f6379ff13ab06e6c84d171905320bbcbe3c9f0a6c54f236680edcccf8bfb6672339dcdb21c26d5d83875d5c7398b437d8cd696447e0ec710f05b8bdbc1e9c9c1319af63bd2d5ad52a25a5de3160aee8b81175208846e9417df8fb26769020b55678b981688d8104d2ab584aad8a03f8ef65d378c4ae4784508ae39868fa2de131f9f49dfc770b9741b04c8d5d87069a0d7fac4e5bd2f0ee45b9a99bc672500f580cac61141906e00f081d9210adce4c4100d13a156322cc3a3af9e2aa7e7d99911f36e60698e1f78ddff916cd61df3704ce226398d75284fe9a83a051d7d6706a30ccda45e5740d496af2e9dfcb060aeeb6079587b3209f9b5d2fc942610d005760f764936e28c814ed2bfee53c819b5164298bc7133397aabc539ab145e919596e27784762341fe54744994686ffec901db721d97b1c382b2e90eee12dd1a3bc4432565ed0b843b9fbb61583c7bc50196609e03ed04166593f896a41188c56b59756f4ca318a2c6a4b76b353461bce8bd95b63a902ff8f5e90caf546771ad23440b7348b2aab1da85dc0199ebbeff97d82c876420af0e025bd00bc57b2713e8306b53570662efd4ed11f8f1bc60b655ed90ba807b368f9b7c1ac5fc0c3fc70d9ad184d033e247afdc85333a589771c3bf453b74b41332be560e05fcc202b84de8be71f97d0238fc2c743ac85d0fc06fa0d503ff701af6dab473c4e1aed627949973560cbd277e75b48be4c182143a7b2fd4abaee1258c0549d14b22ade33cc03697b861ef3a88676fcac0991f144602976b275e16b5592aeab3ffd2c206a9048d125eed9d4a4604ce27fe425e4b714d0b4f82c3d4f49e183f4d5beb82936bfb5791b8d25904eb0a3d63a59eeec7c947d1504b5c7bc32446969d805f517ae4534ef7568fd9504040665e7c38d02a520a76eb32475225c5653ed9d7e08a5bd6f93a40305c4134ccc7889d74def1dd698879778fddd0f6c25b33be277fb7d01356bb8618b7dd70edce7aaa66d07406e9ed94910ab50e118d4a986c9a2ccee4d06de04ba54f7dbce701fb9db4752472742b7b7be8c77fd8dbbe8fd96e0b0cf34d230e24f1fd9728a2bed40fba88d57ad9ea62f0400b6fd2b6dd7f54ba1dc1374edab943f7ea1c5db2b8d42aa96ed712adccad1ee6f10d4b82f30fde36b3a34eba85be40ed68d448a647c52ffc101080f860cefc92ec7565e4e825fc9b36daffeb7e88815ad354529d60a4712a87181dea072d96a49a2f2f855ece71487360aad2450503b37912620ecece6f9cdd040ce898ddce2d04e6757d57f834c9b2e727a8035790eb417a74baceb558f9414f2afa0f080f7954aad3667bc8f946e21af563488a95e73ce79b5e52b6da63bae49ed224d6feefe971510b1d21cfefa24af7b286f77e334177cc5e7f784fc16ff807b9a844ec8c448666760c01fb59d9c6cec9bc7b6e661dbe098df32ecff23b76bb4aaa3119d33b05dff3c369b59c362953815700bdfbfdf3f51c889859cb7253a38b5d95a544306975db3773fd8c392e10df7ad8f54dd331e3a3c1144b3aeca3853553f409a1ad92f0eb66456dac6e105ca678a8f9fa9e4774834db78dc98361a200183e6f012fd0cde50636d1a3f2d6148bd77c6ad51b2482af8b1d1c0e2f382c537f70ff6f3e9ab5483d722eb470d2228367ff4e5927036e6ca3759f038f07cbb1c9160df8bc6604d3cb38c7be931bc52dce4163930cd35e15e04c19b86e51f40ab80a79af0a635b76f0f2edfcc9b4a115dcb1acae1e2a54331ce32d81c09fd151f4614378d41c1a96bee1cf668d3986979b049eb10d1aef526ec1cb0c495076c9c6e9cdc5a797c34c29eb2b349963aad86443606838b0221c2af58361a9cb0e117d8f7142722d408bb4ecb5469962dab24ef8d5aa6e80aef371a98679bb160df123e0f05c716ad83c5c89233fa8b22f14bcbff645f77a16f21d5b0d1b6cab2dd7a916c9b2b6fcac4b88fb657ce7e7bfe087d117ca8eed2ceaf2d4e83234819abfb40d7ea7402306fe15df300e50dc7fc6f3c2364a41beb486df3c8568d10ea5f5a93275a0275a76fdf711577e826e30f62744e1ce01488987aac589c446a9fb974c4075acc98e334539dac09d777033168955559cdbf8bb20efdb4a12d9dbf22acc5621ac2936d82c205fa80702da8e92502ec3ae4c79f1a9d2962fdcf75bbae6593d971b0489994244fc0783195f98ffa56458e51560c9a0e378d0f16acade55343a95f3a7faf8010f1a9d4e1d777f1e0bfe3881f306c5fdd765f233384d6d0c3f8048c624124937e8a207feed2d2527c29a5b6d7e9e08e348470203e236e6b5f38ab19366273652779a49b437b066d4b671a0aa19ba60e0d5a38afdf7f09fd7f04f3e44bea7a14aec3e38dded9026d98b179b56fc98f462373b80892bf7dba494cab3c96164aa9268bf9a11d0c3e092b7ebb2306bd0217dafd92995768ffd34c955138c78ce1bf8effc570965589c11b93bce0ccf936909fde8f076f08c64c3077e654bfbf02a65a5a15f952cffb744f4a85da3d5c7c290869995008f645b1c9feb288d1c851bd066ead83d7d0bd6ed00366706a8efe8763f2eee576860dc0f1865f68e62523d1ba531aed96c4ccae08840440bc1acae4b5dc822a97e9ae934507bfcf4fd5c2690acb954dc3ad410fcc50c38b8cd41ff78f498ef149aa975a5708ece3d4a6a44b77369f935331ffc6ad155bf0a8e6c3e0b357a2aaf28261832c6f76cb6be7e11c17a4848c0e0be36b41b2c9c512551dce8fc4ca3cc2bf91d0acd3e6055da0bd0a8681e272bac3634f7b058ad3422c91441105433c4a935364317ecad3e65e888e8cb78f574f8fb88145af87747f8f5bd1058a9403dee6e653010fbb4db4f4b7e364d998916bd1855427a15c261f39186d5f52bff9051b8041b8fdd9524c15f0b34a6dd01f93bda4b23c7ae2a04d2071954f44889224238ea7f4e525cd26b98890fce1e9102331f127c8d1cc81752a8252f98e9c37a1278e9ad9a5f58f8efb77442b84e6d1cd6616158fba9919d7e92890b265bcee58cf354183f9b3570472af15c2167d36ed9f95a6a3f8c19aa0090999b463ec314db23a3d9059d6e56115acb123770b5377ddcdecf16ba90c96cfadacfe4419e59821f7c72eac39592cd464a0493b01d9cc2cae144a849b702e1f2bbf7328b32a0a2d9408fab86f780cd0783d8c580942774434c2eb66ee685b206c756caec9b836bd99b2f32db95ea4e0a495293d08823651cf2c2dce7b131e3c96539aa788a08c5d011d399551154c51f86bc3bde7b15437dc0614d04b17c3c7d042e79f59d544842622cc9eb3f1fdaccc8a5abd36e5b6c279a5d269f91bbe4e2e0a9569e79cbbf388bccc8745ee9cb9066b445303a75ac07f12ad22f3b46c33e547645a138eaec82d72824c77687b7c83b97f36cb4e631f6b847c039e9b0e24692e09a95ba7bcb985031fd0266cb2c1b9050e6b1d223387103fe6a2585a32a7d2627a5699cc8af25b969af9b5573c72a6167a359f43327ea3405157affdb1ce7be51da53dcad87f6eaee3a2682ad04dafaa00de88027b7ae9da78acc2e6602ad5818f61ef30a3816568689744a579d7fca1ab7368130713aa1654b1143eccc828c81764e0bbaba6906b1bee89f19871f93fc7b94ec335fb6129ba43d4154c6bce757d31f319ec845229ffb94eeb631b5e0fbfa7f8c48d631e1111930e7b036407ebbf59fb370771b7daa955b94932969d8d190f5ead6e296df25004b6b97ace45465bbc1cb32d3dfbb8ee96abc95da1e4d7ac0621dd15d3b3f23806ce21a858e99139a343eddada60384daf309e2a35b3923ccf19267435703f219ace90e614c818b4724175ce90490f8d17184cf337026169e14f706ba0929ac9031c938f38e5ace4457dd6d47c5edd418327b72b17d3719f5e2efc2f740236515b5bb69993054afa7b4b282c0e9e0210efccf767f17326299f7efc70177a278f4952bd52694efed326f0cc4cf985334ea9315f3879a0e2710cd5e9dcb07189083d53c1614e84e77afc538b1d5cc30e9b262bb1475b06e147b9360e42c96e45514713ae98fe74baf4329de1d5a540ab308c25cee1cd65a22d324e166ea4f0ced6d7701124616defe0c39d51e708b7d77ef8b48ff86a63b2013f6f47d1ebc75631d80b88feab8e6e2f499fed676d0a2a35bb548617a59e98e522ae5dac4fb3d0e4c84052c9f769139923a5ce0d8c335c05ec9e8fa23e5155dc1c0e5333a501570c910854d40848901a08459a609ec6f1897bb07b90cdfcdbab594712cf0acb8007ae6ad1de61afb877306c98e38b42be6ce448ed294917837f53b93b2abb4fdd49cb3ed1d9b0d544f1d6bd356528968ea0d44ea83d3cfbaa842aaa9e3be45b83538ffcee387558167710063ec766871e7736d0445564db5c2c40226cab1490252a5fb9018048221ea4c21f2b0953e90912a6210af26cd5a1d5c9cacb2b0b29048ad4a516e616350f7fd5c22ce7acf1bf197d3dca085a482e6e643e9b744532fd7be313b29a2cd78069a5fe0d170877c7d0d6ab3e0896ad8c723c31809ad3a97fab277ff475ff5061c22d9cbce479f50ceb98848ae4ea78d4d84c504528003d4b7d993ba9e0c9957fb3a119a87fe7cf028e3670ee19998b2c84ff4cc4bb2c39ad7ad7f4f141d99df95c3d35c5451e28fae24cded672af73f92924ff6821880f6c87b4ce48014ad5b4cce3510428f53f79f14c1568532a9854a75f04029428fe743a5e86c05c2fa21178a7f337ea092318ee36004cbed6ab401e325a05dac504b7768b1352cb5cc6eb9b94c55bd76a28fadde61df515f25785ab3e1b4ea3e7400c35c8894dce77673efc12fbe03691af326d89cf2898fa06c0cdab649d2d09e85484cbfd14f97eb414f10f587e287d98b8db8915ac3b1c3afa41dbabe9bb931836d9fa1a535b7b42b694072a13f33121ab1bfcd4974e3fb07f7b8b653c747324f195e71eaaafc6bbebd5c45fb493fbc18879b6686290cb0e8d747ed05352541217b87bb2471caf0be5d90f91e6dd8fc2daeb9c6a5048a45e715bde967c5e0ae62d53653581f549796b905bf69174bd0492722ea48b557810f9b4a0a30c3d5d3e4f0ff9cb70ff855890becfbf548a5a3c449125898daed609bf3952782729c48dcc2c9c57375e1dbc05983f84e1fbfa93543099941ce650f7fbd9e6342b4fef9f3362c02e52232ea6d3dbe6e2b8d730c475cb041c072a4f7bd7e13fdb61b055da3fe3a543984790016e2e12072275420c846a6dd64485a34b9ff1b3a24753b95c1dec90dbff6919ed7d6a70d3c5b5a6709e5d77605cf60e0eda44f157b98fd5da1c160542009d5a03248ff3c92a88c1cc50f674cc9dbc911586191cf03f870888b5ddf1ba55b0da93a0711a1242f8d059d598ee82c0589025b24e2c6f9ce89848b1cfe96beff600d0dc23e1d60ba04e494a1531f82e567360cb591a996419c3cfbf44ef613b98a352a3c99d01e9da5e9dc67f63ab48b6a1fc36b68ea2291a0339fa421689036e6cc433c99e0892a00a45eaebfad22d75c2d05e7470a992b81dfec28a438a36d58e43a36f4e9c5956f7ba2483d9b9c0b5375bb206c8c89204b03cdedbd3e42755bb4071647a762f31b3aaf811c193e4c22aebbd2c91035332b7393fb2361cfe53f9e1769177639d9dc8c72572d17ced9bc9b4bcb9f3b78042d1c531d2d82b6789f1d8a215ab3b2d03d594329fbed8f9fb2245ac6676aa6334af8eb1b7c6ec3721204bfaef524cdf324992eb82524f07b63393101155f756d635a8105a5f311183c98b8392c4a6b6b5546c9465cb834dddd2c19f6def9e079c62a2f3d15264da0b2bcca38a5635d3dd4e3401242cd2e9cb1df94b51611e4499a24eccb59cbd68665362c06c82aa2a7b5ac3383955a415e5441884f86fbbcc69b71cfc9ba78d3b2d7b6684813f5b61215bcb851017763a3867f77a9b94e56e89d5c36365bc66ee00a59ef86dd403438ff833a940513ff20085d85444bd42efc5e52baf56bed7ee3e61ba4e3989ffd41067d1363a00aa695de255c4bb248cefdc28467bebd0cadc520fa886c08f8dcb1b7c901057d20502397db93823a8aa08835d9aa568568252889534aed34ab6939ec2751a83f9c720d76ac8839ee805dee33539fbf9cf168ee58597ebb55d7239dc0c34f3fee8ba60d40e2989396b1a336fc6ccb1a3b939bd32b4cd7528eab6487d81d910e5b07cf57cb5987ae948a02b68559178de03a60c66eea2f5480351b7f3696f1aa4dd1aba31aabf2e84a5428f1390e823da07c0d0a1f195e1a988bafb40b76a34590883a4881a689fff5a146819aef1c856bfdff8daaa417365a978e0d7f3ccc5bf4b98e1294b80742ee9daaafff611a37c4966f7b8d33c51018681bbd31d9a0fdcd08dd9e74ba8c1fea6bb475c8cc576a3f444fe13da966ad6ec2b18a735cf1282d4c984efa9193c6cd5e70b663bbf2ec90a5cab27471620a3f3a8a8894e299252f647b4ae7c5a2cf358156aaa6d14bd786d127b7497bf79ba4859f5f3473294eb2f16f0d040001f9c95bb1a4ed226aa424d784e2efa11f7f80a2b863bc9fc58277044703bf24d6b16563a6da67b5a621a03bbbf284cb48884c951389109f66f1951faacd3482408fe26c1936e2687fb7005d0575df63a97ea1f834111da298fd2ee0bf499444f5a31bee5c7ae734e34165c355269e5462bb760c977bff0eb5b7c854f8debfe3de42b6b245f157a92af76b2375452f1c888198a1922045b5bda5c2eab0affe4085c7dfd1ba92c43cac713a8aa1571b54180a89712ebd3bcbc82eacda0b18401f1c11cdd39a100f64701ef166e9b8e230a8ee328b592feee52b0c1b94e6d57cd42be61df62cc2ecc899d3caef96e5d4303b90e401d0669e8b7cd3dd9a5e4a2b6ad453caed673ea21a865e5f79f92c11f852444140cdde6968ab868a1a33f04e3c5b80895dc658aec1cc32f60e525be09fc25f7e219d2abb6dd40249c688afa2897dc4d2437bee1d8db10430f46ccd286180af85d5fb77b37fe4f631a2c77250b4884c0514eab4d7b7ea7af5973f174bafa43a3ef36ff5699415c05f4411f8d0695bf99cf1136825d556fa9cfb8cc931bb61c483a5e2187d2209957d0c20f1a52adb70713b0b477fe685e704d555b57ebbc4a5bb89cfc4aa58aa220b27be93981317af6e6b9799e0558cb687203972dcc86b51b71df1cbcd7c2262dc644645c11d04075e947a4a9de53a73185b2a73eb37dd1a8afd10944bc211f1c5f2b6f283be32cdf1eff28f5edfd01f8aae5f3691f8a77113a15284f24f1180dc69a9ed7a6664590e1389d23bee2a7eb6ddbcf342ca7cd80838f8ed62bd173775e57b94cb01f4ff530ce688c35c7f49373451a8b706464dd83e6ee022853ece3f07fe1d15144a845198eed425626514fe4f30e78d17aaeef36ccc5aa58741612b10f7a6e3946222f3cc3efde116284f4b79f62762a1fac15bbe14a9ec44cf33060a2bc8bb800402d53eed03cecca773ac8d4ac4404df685f7428debc2a95a04179c464ec381b3dd3f3fc892f52acc66cf80c7c297d1074de4ee81a8e916e1f66e5b824cbb55cec3cb7027ced2cfb5126d1fb217b9de92837e5a93b149838cb7f6a71f3bfd120a35a5f83190a159e4b3b25390c2fd14be7edf0c584dbc84bd49775035c10df8174081629dc7ff04b6e9611f46eef638d6e878def2addf1b495d1ed9edbea37efd2a7bdaba8a1ef0dcf921b470aed395b9ed82dd039841216a906f6784dda2ccb1b99ea2a91a2c150dcd8c0c5426334db9680f727b307c51120f8b3412e1ba2c879250f67e392321676de0a7e956e8b48e976993e7efccac069a5c2e32e52f5d2c6c79c93199f183cddcd355abdc78528e3d1a883d365f471a32b276cc220d6bcccdde1e6e14cf62372e30f750748cad534d51a10d77dc41e18296a2164ede4ee370cabb07972e033dcd132bd5ec859a81c648e88317ec62d3a5d1674aa1ba6ac5beb70cdba687e31d819a117c9d3717ce6d9d074ddd2b83fb2c9523fb86b44904bf135fe369922cbd1a74861daca34f9a44d2626a55c0808ae476111043908b9df67160b554a8a9a0c7e6a8a3f021ec9d50a79d776808fefb43d150410b87e4119c5a2e288097472991e3d2f49cde0967fafae2f2932c517bf9e3f5e21e1c0a3a868016b6964917ce17e3b1ac4d1f02a23127bcf237deb19fbbe761b0c7c03ce814da408534cb2166c1773662a3f0cb20d6089a2623e14020813db6ce33e6393260ed9aff271021c428f4b44ece85bfb0695cf48f884a77db71c279b954cb63adf06d969ce43869997c3abc99b0305a45a8a7de123a9e5df454e8923ed93d35a7a9721de3098cc6f812a9ade89b3f0f9c9305a6a0f7da93a22996a3ecc589d41638b7d87e802ff839fbf429d5ad7de654e30c067c27d5d1aa981052c4507428f8793e31a74dd30c50090a5f09942eeb7ee23b5e26f89bcdfa239c62a90ca05251b05f2f3950f8319c49c39488f669410958531fc75a1bcb6d814a78f9f236aff895cff9423c02e08c389288add6c152504f136cc0300cd5b80000203018294cd6ec7db06a529c14ee6723eeac994334cf8fb74301c32b92e4453a5d62e2597152534c0451a65f34809ecca93ffc99a3dc6b171d8470af3ded09c6c82e04b44f45b64f9dc7b19ff9f81ddc63314d3db32c26c5e636e6d2639308deac9497e2e69031589d8bc9ca87a5b5bd5b34daa515b14f4f97055381e34c23ace0bd07b060946f23e3b0917c9a13e3fa3f13347098ef2f4195c9892a3576d0633274a6e96e82a5c410a1ea65ea15afe6d05f0ca5c32c00cafd2fe1d8f38e5d7765e1b8c7d0884d167055180baec1d8e05794fdc12fb4fbb0dedd12d4a8b72db02b25aa96f5fa3e3c587edd890342a13b3335bdd7045aa34333c0b99e1a8d0e247c7111d0eda4697238e73a6a0f61594d0184f2780ffa863556c5c786826fc7cbe6bd990c3f6737b86b244a234ece27389ba27f7c66962e86b19d0fec57222e8741f55a06f37981e04c563d4166f0ff33acea9160dfe4d95a4eab8e92b4a5ad63d5ff36b35d40f00389ffb51917da6462797c3027d5f0d6641045a0d6b87293263969e0b793016d258e3594884376db322843ffa71cbeb31847c7ff183cc960754359fe9e1dd0045ed714105a05fd74e9297450ddc6a1b0d64e9d2eb78bafc2a761f28d3cfe68aabf2e90c8909f2a8f97dd3e8d2408f82acf8a0a3aae94b93a841535af389e859509bc88439667ed86d55ea5c5681397564703e6d2677e5bffa6c5af77bd99db3094b24f7cef5dd5ddf0d26f1a3b26eb05741c8366a669f94f02e04cc83432dea021f7067aa71c729266c5a6c5663f40dba4b6d327c0974a1f471acb765c71ad01188e5e82e192f06ba9ae47105b2fb0054878e06e8be2105131e4adeb41142ef3aea7da85fec5098050309693d4306ce027e268dda97c193fca90ee010e4a5f86f2f52260b3d7cb609051c840f942a1a6c3ddd4df2c7d490d51a8968eff0eb2c361444dbffffa1f6a373c8aabce713c5a1a7c0b9483e1dc24f2a7111d8ad805132bf691c13b3021db5f07f354a094bb1be52088ba434862645b835e645fdedff3c7e5f03972909a46871b58bcb2de11f26cbcad0a886a97dbc978404a62c36804563c58d70b9da2c71a39de1ce1f081b30308db3f305b74d03021314ae8df135acff2020b68a27e5268c12210c9104a8436cd4c40b3937d4adfa04492da0b411fcf04faf296541462de1d4ef46022d80c20ffa23fdf858c8f1c1d1ac568bd376ac983567a2f515482c58ec94290b4b79965159bb4fe3dfdf84ef5cdb63cd644732d61087301f8b9ab8d46ff9d7193c3fe0fbffd6f6f03b5794c72bbe4b1bd95af2d68d4a9e87be98637b630296b1b52747cfea6caa88ced83288e1770cff5c16e28663243cf96b431e2d4175bbba48c1dd758d45d918b1ab9d3be03cb5cb2dee42f2c88e6aefb5b1c99d5e86f31f35f11e861114f152bda6bb023bb2f2aa796e7d74fd6947f2070aca7ad3403b5ded3e629a430000525ae829379e0acce644e3d173b64cf76cb13618a0ef0662dae2cd614dd18602d1b0f3c69474c32b95c23851fa38afa2eb3927276ecfc25337c5158d85b981b7c5c0e2528fe1c765512560d3cf7bd8d9f833de1973b4d9cf9cc22d5a3015d2b48367b8d9d3778e9bc8adc0badc17a63a8ebf60fe0ad078e34ac44c6898784d799879c6c6a245874719ff0935198ab186e954ede7227d4c03d3efc3a20d484ed4068170d2f4c21e2a58eaade7a212b5881724cbe87d3ffa2ad998577b6fb952233aea0019145ca954308a6c46a945e06059095285e98b5598ef5f9aef754c01031dd0c41234e3c877329fb4bcb5913535ff882c55359f61c6ff8b31293f00fcd79c83dfe9fce1c8e2e8b77c2bcab6eb83ac8e54eed7b2ad5fa3bef52b5f7bc8345edfcd4aedecde298483bd8612be1d10fb56bfc0f4786691b5c7c931d156478c69fc7778e7a31cab5a22d90a514640df67b2116f78c6c60a51bb87753ebddb70786e64a11695f7b67fd2f0b86670f97b107d70e8b9f87fcfb3d11c20da4ee4580abd6c019234bb2067b130ce7f218e87cdfa355bf8c08170d2534fcd33c5d88b28bf89a575202fef2b9451e5d586f5e0dfd0c713930b843dc44136cfc049202167b23df5da1b3123f90a8807ed8ab90900c73b686a5cbba0f45d8ef4fae1d3cdc2f270a9a15eb39b439411cdb5833b6efc73b25cb15ae36ee7eff35bbc10292fd6618e33b6a3bebc952a1e53df98448f995415849afecf4eb49204e5e50d7887ca2d8ec5d58e9ccf45c12d732487ebd5aec878e182fb9a5d61aede6331850acd4f98a91908ba13016489a72ebe1e3c36dc25c0b8b2be1556e9380e6dfa6ec166d3bb9537b9f77576d55992a9736b8dc1d4ca8f9a9a5698c17f1b910e73b42e979495e86f18e0d5e97c631be369ed9f6318b5fa700a4b29defb2021a8bdf6519d1a37fa2266582cbd4e498b53cb8894db2c9d819cf0257adf075c525a3e64f591a3d3328cdf5a32342cb77b8a3c62c5293b4162d6941f499760b3e4b246641bd9d8bbbf3dd943a8db9325f4525f285636e0934919102c8108451beb7073f5c3cc4ea1fa5554cbfcee7885163afb4063bd401e007b948df68e957afa2237dc09d9b781addb40eaeaa9779ee9a831a4f25ee1786584a7a0254545d9682d36dbfde8f5eec95455d5cf7941b9ade69510348fdc930332f9d85ffe666c3f883332f32782f7f61b2cd67787ca9bb229c4ebbb98a388549c3c1085bcb2a394e0c65457b9fdcd53bcde62753f9f92cd51487bf8ea4de4c50ed289f0fc5435ced26cd85de56eb446fe8bb809a76dfb26a7927128e4731c5e4ef8f5ee4d54cbc8cba1d7e310e0465c83396cbec6a73fa095b68c1e6cd8a7e4cd856cd93f33ab084f0dc25734178e0fa8586aa820bb206eb05658352ae011efd7ec846b28a142079f7448ff3447f4c850d5c3e4152832bfa2e27154f249866ceedbdfacc671de13302db1083b0fb5bfb3b4c331781b605b74964987f05ed5d380297187ac2005afa893c042dc0e6f911835d44d2b46084491159752192d68eeaca52d2a9e968ce6fa52ccd9daec94ce4358c14e5bee13d55b53794c9f69be12019df99f38355c4ea3e8992029557eea4be1732a9a0c48babe98af270d142e40b24d5ee11e2c5ea425ea3ae032e31461d86602b0ed59a7330db6bc9183224333700dc2c8ef2f42eee45264f66eb7782d3b8def96f5af964b41779d1eca413bf95af318c778599d18a7ea5dcf45972885121fd09f92e6238b95adacc25cc7c8ace22b58f9d1799502a36e06a33ef0c1d28d26289e08d369fc1e97fbcfe384d25632b8a1786468f50792275c6ccf9c102385fc05bef3ac29a6d4a1d544ff1f254011846916842dd9b320a313be5b4f4c7f49d8a8cc872b96613dbc5124e0a9eeed800ab54b353be133666e69afcb5e58706d034b4cf0328469f0b65d1f0300d72fcf20f32cbac7a01d46b43e45a17c90378cef800ed07b6a0c1ab2f80c96d8d8d9218c05c3daf34bcca136bb0265167ee2ec0679ba0a25cbf376cf892d56036033c7a2b1d8abafa5c85cb774de3e328946b16279c3dd119173da16af23ba6fbccd11c7c22b6a9ac6d52054c86a7b852c6cbe514932abc8a44b8b84c64f36401d1585d9a3f4cfc9e4e38704620bcae7e1bffd87cfae1104818c879f2975607eab64fef8a578a7d092c8b9cb09875461a54d3d4e7c49a5f4a237ad1882ef4e33d7a00dcba43f95aad07117811a2ca0471a3ae31efa82807983baa2a6fb6a279c0f114aa29957d54170783a7ddc162d8430dd4b3afba4acc026ec56c6042ffe417a090e7912dfa7aeae16956a0f573003e26b8226d926d55212addc1b2770b000d5ac9a9f8ef38f17f32f7e2546b7546a5f51f1ce5d770307c928db8d625b7c2b0c09e805958163ad041b04572e7c860a04fb70aad3bf2154e31bbc81dcba81355238a1db40ea6a66c6897ccb0b8014d6a3cf793f4ceee9bef55bf98d6b5f828a2d301dc4849c1b33219d25a0d1150d61d0c573ae1f917c2a87362fb19f7eff622199d4f0605aef66e3eb9f4f9262c40d7b219000db8ab4f9412fbd1803ce13774f5ff44e9d4c690c7b0a9084133c36a749856c73f59813227a32c0f09dbbc0114416c418b9a751ca4e5a3a8bc0534cbe034b52f4c544743589868a34b80a5725f1179f075f04ea5cad0d22f4cc9b825439d94755a4595e78f24a7bb14f0b6e14fcc52adef2fa7cfe273560a83d42e451b32b1a8dd8e81807a82af741cf390cf29ba9255009bb6e7642df7bfcd579b93b8627196f95d97803f96dcc41fbb8e0b10e971f63216c96a86288bba3dd068fe588af70afa872cd3d43e21d0fa75b7a8d2f4ea7f05164b0dd5e45841486895cc4a92be8dfe5d4a64fd3a375580c5f30b6b97e224ca0efa954367ac4ede32ea76bc027381c126bbbf9a1d64dce19eb11e36f256dc4df304ef164ab2f4df92e8c87a0af7ec2314e4ddbaff79b52aa348dcdb8185811c26c95c7fb4a84f3e84c718031597448d86954dec81a798eda42869a441af09ebd4273bd0b6e94926afded0ab17f6e093020ec48e3e63fa1c1cc97bcb01c627845cc9f8b0f16853928cd50d1a03e2256427e9a19d0e8e9b3ae8b80d6e3658effa5f8c07add7aaf5d71763cbc1f09419af3f97b28df3cf6e4eb054c7b88d87177574d837e8a2a47314f1fb4902bf07c7cd62b908b79a2df95f124033bb669d9aa9ac2d4ac0dd67cb3b2fb4ba4116a0465c8dc80911d2690353d0799a5e9e72a801203bc66f3c0fc8000219381cd36629ced3f8e6f6cbda9b2aa40096cfbbf947592ede7b95f02e3880fe43104825fe46f5c1f8c03c5486b4618b347d45cb3e905ca386de69149e78ac8654e2a79629de33d43066812e9085c32aa838d27615988bd47c8810bdbb83eb35eae742d4a7de92f9e23c4a5481ca3af2a8763cd1b1b093c0648129f64bfed527f2fb0ef4f61aca4d2aa9bf0b190a461a942ae7d858d902186230713140a75c1da0292b8d12db020a2e0db21a968df2e5b95d304ef6996c18d21516cd59d831a2cdda9851a385e92f757959fbcbced846e65394d3bc6ec45d75870346bce284373d5e10c82ae02bd69976314c982c081e53244e2fdc8ffac61c73100e60b75d9ccd933feef206b2088140a916cf88826e7df7bff5392860617ccd56efea68b3499b333726375f9973f6b7dad0e4f4a431a94384dc773b6b93fa972ea5caef1b7650fa4954b88cb64e5ee36478f151ee9353ec8842cb3a195a574d1da5765282800d5fdc2c956740c35c6f9444cbe18994828f797e678b0c8124ae07fb1d2ed75c7dbe35816b8ccf898bb56e1f9bb127f6f33964581095e498304e82db3c5ef3a0beaff55c5b7017093580d4f42e196c2a83780b39a95894e3344af9e02e4f74c8a320a68bffd107885dd0581bdc9e648574fa044fb44f950d8f711a66eb347afa0f6b86f82c84dcc6c4e650021f7270f71f8f0a208a8403c82dbfe762e057145d9d861ee6d2ae80929ef7384ccd1279b2d1afe23a6e339787f02a47730b5e7ad0cefffe1556b74ff80345e69d175e4930c39f8bf28b248dbaf15370da8cf9e32965f0dc0801c1c2da0ee28887c2859fd3437632b2d82cd869e99710749f3b1b8a7de6e1ca6dadefc79ed16b44d60fb44b37fcbc74582b4494966e66b1c3201094725d310d683ddbc61e2c602883e920ec55a67a325ce2df5423f8d06f3c85d4a1fd1abf4bb5180764bcd0028026513859bea35daaf0820aa59b8e6c5e1460fb46a837b534b8603c667011b26cab92aeba41b6ed5658b924ca270808fd2061d6d28acea6ad1991f0afd399aa71b27086746ec20b7655454d4eec8f00aa768012703ffba8d167d469908b65e3f903be8977ad7323f851211a4935edad6e65347aeede0dc851caf140d4ae357aac795544ded0ed10dd96d193c7b5d3af5a21885fc3b9a1516197aff66caa1364a062632a17e4cf4e6722c758c30cba8cc412e6ab870bad6db881410bd362ccfd0d0dad05e858bc16d574157abefdab9ea754ccdd3ca64ff196916ae95dcf49402812e5df53a77c1fb15461ac76891d85c7135ea2af6bc95d58b0b41e37f9ce5c44fc7d23e17e8a6f035c8c936340019775d214911051df012da4ce925ed5dcf5f848199651380e31e0bef0f562ab7b39593bd90d2302eada873664af3ad2232269fc236f38656758617ba223b35f124493292cc3a1968640919570037e5e2983cc4cdb2b39e433d7d7b7b12390f8f83c894fdf84b59bb15cc693cfd599e59f0af9f982c8023c66fc2a6ebe3da27aabbf14cc136d7c3e2040e9b7620c6053730707168d38e8859d0ec5915534d39c99201d9e411009a7ed652cf9aef283c53cc0cf8719162ae29c2dcedaabd81c52b1597fd9965904df0f2c510dd5f3f4ea8ba272182ef4248540e1275c2e3757ab7bbc3282d3b0eebac027d8a1aba9fae06b99908e918b118018b57529f3583bdedf12d5c7dfa56147ff7b136ef50c53cc3513c0594b9048874ac430d248a674f7d0858a331cf6f943ef7ec5ad210870dbfe3ae1aab644f5ef76a5ac1ecc3489fd20302793ac63eeef023db4f944b179113b440f2c1c96ba99e493fa15e58a5d1579f5559937f627d60c759dc030ee84b14da8f97581a15402df2278cbc72d2b00147593f331c285d4df99bf24061b0ad8548e75c3a72b6ee27ccf33548563fc2221894961f2fb3debc1fc6a9626a6563d1748e93bcdfb1698130e6603d00074d8ead166138a852e8ff33f731c0c80c7201a74229acdb984a2f6265a7df17ec250d7ea1d3a6e66e914f349476f61ee5f11111f2344044957b140138266bf15733467823928521831affcf6a58e7b2776faf4965173dfb3c65ce336fc664e6298cf5a4f770734b28a523e261721460a4536953e21349df0b5d920e7aa6d644778292402806ab33b5d5cd23c4e8c6abfcbebe949718c407c1f5419ed0ad183d411691402cdce7617d4bf6c390aa76768a5508cdd8525eeaf19b9653e6e1b9d615044634efcb35bd5da00b0b47233d7aee0a424017e6ac0efb0d4a728ab265a2c9d12da04c1b003f8e8f8e33a332c4c5de6f8a99074706255ab433df887dec68ab254cb8f8158c755a74ec03a8a8ca8aa0ef0f625faaf961cd5a18af7690c040a85f1cafdb752ee81ef815f7d330f37fde8eca479016db9caf1ee1a726c33b2b25808632b5d525c2b4093e1458f9927e507ea20f192bdafd5f15be0049addd92d9813833a0270def86398a8a522b535482a3191df1e3dcf190f083151a8d48416e6c2143db73530617c5093d9263144dc7d4c1bd426c4290b180f6e96af7037ffe53dbd8dc3e3b35c613118c4609a6df60fc4d72104d707b2acd7c4ba019bee19ce4442f0954c7568c39efbb1209e63e9db2475be3678bbb88c277d965b29fdb640f8dfe2f17bb400b83f3169c0e376e92e7b0b3c560e4ca14cbbe3827f153b763bf04efba3b98db1139f2215732d24b18cf80c06baa555002acf00818c74a43807f602575e2c2b588dcfee99869f80a55ff4137058c70b36e6da37284749673da6e1219fdf0db598ce470798073a93351dc58c38385ccfe5cfbf80249c049772417cec15b7041f869afe0eb9a29f6c063a054363eca4aa7d4f6aa011070167e9efbd39dcbc5d46cc3d0b30b8eabd24d10799bbbfd28b0718595fd1abb8eb8706c7405a8d6227d9a7643fb7c185a705e33a7d14892e8b6e9e9aa005e579d7278bacb5ee6d47a2fcf8e03d599d658d69df4e3bedf330ea940ade1d9d3dfae99f873f9dfe7216bc4642ba26613e0f6f6394a052d5930c7dea7b9941329e9bae7ed5ea58faac52ac438e3a76ad86f37de71cd357ba87a2b5ca27c12fd312c9e9201522988842514403c773ec539d52acc2e2b6fb36fc4c0485766e21cc4967cd7782bbc52a5d3138ae5f0d791e26857c442e406776f0eb9463a142ab5ef7cd2197ef1fd23169ed6574ab86204f9ca19cf5d88f6e702a490fe8fe487d8cba854eea5ad24f7d09d115ffba5f723016a344edf0c7a476e42b96650d2c165379c8c5028f34a21f24a0d810a62e3a59e9c5f8400045f88a9ae481cb7eafccb95e97c2e3f71599bc4f20d667d266f89d93588da9c0619e1c2249dbcddc983d941ce00df8c13788eda7dc85779f5d8130cb0a15c2dd2f68a50b547d78a333ed60b4818203715ad2e9c92deb7d25fa2e40406e1112f6148a7c12b08106aea01c1e974117406e8bf48039ebfd79a58331fde4437e7350fc2c504ad80668f12399d8ef38f693e3200d95e9804a3212ab8d2a40fb4e9fcc67ad879363808158322134f44b1269ee858d8358a3653b7f57d8398113afa386737ab35a585f93baaf438d31cfff529066238572558336d1e8bc94562f85e1301b89f6d5a7dde8ef3d5ffb1f66b3e8466d49b74a1e3defebbda40b850b1571be14e51d76232e1a56bc8fff85ab4cb0c86519850fafe2530376a417c8f2ad97485a34c38ca083823804393f2786072c9823f9192d5562bf21e9a9073550ba3bb41cd10987d7dcc0e0beab20df51b859ac9080568e205dd545da1e9e518c20997723d2286ef2f34c3d83efbfb7b90840e17748014870bbff9516cb1fe6a1e4c9bcb005b18252368dc102e0f65aeb1e9db74884126d03bf39f06261d0cd94250060f67ada28dbe3fce6b0a5aad70ea280fa94d8199c03d36c57b1c69dda026944170f0c1042e2bf9000bb2f8357abfb9e009ed5cea2f21e37b873fde676198d6c8ab667f79f1468adb1be40d31cd6a28e16a6bd07929360221a99a36542a83a6d5d8e45f9c7c116186262676a369dcdd98eb187a4931798f1e1689e5aaa36121ee07be4a4f70e4c6e1dd7a3f0ba55f730014a807a2a579c3008d8c7c9c94076b799c8116b5c4b663aad08d50309ae5304792c53991d016f7b1276d8fd4534bf3281c65e21371f0905e1af2d4bcbeaa79427b655de5ce6872eb29d54b0f1d722f27d95981727bea5f09b4fda272fa1c52c58f0c31de63e98b5425f462d6f97110823cdb064f1b495448fe4e841d563ab5848e266ca5e89d53c85e58346a36161633c10c68cfdec9a1ff6db7e14d46fbbdbc43adf1c471a51a6683e66820fc8b4ef020d187a7bf3b749e1e9b2a9be9780e7146697778a3710c74d77c9ea644c9698310b77c6ede9d125c0897aaab7c6686280fc30273144af381c6aaf85d83013972de1e8e31835cbb5a61f5e6bf6142131df7092e66e37ad07e30cdc0214af0bd1662f293533603c5ae02f443c7a41fa6d96c647b68e402a01289802c8af4b4800ab3ebf0855433f272ee33ce2ca4508527c5a3224a61ce773f5840e09003baa65012db41f2b936cd9d4fa678980a4a7f7f6132a97bb4fc05a33e613d6711a763e20c4c7344c781584c848b005758280add471c31630733937f56478f4d721fc5714d6ec9d4ad17a68f1f3115b790a02234f156a460c7c874e9dad3ea3932d93fa536a5287c99570b2e1deef102a6c5ab334230efc372713b0ec3d3a036de8dc1f8b49d73d584f6c57adb72f0b5e95b4d28d38c14abecc1b94bebd460ffe3665004c66ceb8514646bcd22d05d29227b47911b6fc2934e5457292f5f05381472210343e4c7e16b0bde862e045760469def805f3a7a1bb671517eab9e8ea131f1766f691e642b3806819053c43ea432c023c97c240ddc28dcb37273783048e366a95f0481ea019b34c15b25c46ee183162805b73add8b2e45ce3e141f96ba7be39991665e4309099a333ed971a79b46508160388201e04311838e8a5188de437ade6a64c7c33250d19207ab104c9fa7f2a08574ffb479afd460c7d6fcc353bb5e128af0a79ea5ca1d2f60a187c3844bcc8e81cd5f9a908004a6cf19d1910f61c83e00e680cf56ac4fa09e4afcde867ec9fa2ea8f29a189a4744223338e5017056c56ab65226e937cdad82ba034962c477e9138218e2733e40fdd7a07c8b70a51b966a259c882a3c2047731e732b44887e07d9e63a076bc1acb2199981cb56483cb370c9f27f1d9f66c08fcf55c7069c99ee6d6e4052850f43276ba7c86b7b8f9d0100f778643c200b14b02942fe1a6c89485b8e00e26033413a5882fd2f5598dded7c131837a271f4d4e6a4e11c39e3a9deddb0f9f6f0e3b822b537efac834758120a4d61d8e6524e50eea3b420c3ef7e3bacbacade4ea08a4b29389f411e0d0d67c071f315bdd58d3191f2fb499f63fb025b611b052eb83b7fa0a401bf9c22499cd741f9eecef43f1fe05988f573a81bd9723a5a6e5a0f37b1e39cdaba35a5ffb3d35335f26319c9515496edb6bc2d78a69de9b0eae0e9d06077e9460be232f62b489290bfc7e3d61ee0ea293a5fc2056e55ea469d87f5d0b526eb9dcad634a090adfc504cc34a03cab2d48c3fbdd155a885a1a3844f5063895b40304263d2133cc22aece3ee9d2c4c1e7011ef86d11bc01e1b588c3910fa435a59f6c4395c892b54aea43c27f8990b1810dda33f69ba0b138fa179d5ab5d9305d0459c77c4cd1f2f669781e1a2f70a01644d586d07ff67ddbddf178ceac59d78b93577db2209d748483d414abb822ebd41c16e25de92f5ee7b1fe7d7b339d315dd0bc68ace4a1e6d2a69bdcdf862f03c168f722fd8655117af9f780022dbc6fde54f5b679abcddde1c94c89a0df2df6a5120635ff81f2e9fee35daa9a4e950fdb7afa1d90df495ae28869b3ca9db2e24ede234163d642d270f03bce9a52d75155bee12a6d4fc22b7caa3d391539136ab4d19056dd0b42038334aa2f1763ee837771c11793b6f8832866fed77f1d0a3e86084a3aa1c1ff5b4afa0a9ca10ac05a7dbb1493e1c73c4418fb6a56691d396e051fe08319881919cdce0e262ef6d032b0557395b26657002570730cd695e85038bb9660fa06725f4142fc98ac6f7904618e2c262a15549a26ff0737d271140ab1cc0bbd10142cbcd842c861b644c1d663a55e7940a96a8649cc6cd6af9b834ed27dd96944c866fb2ad7db23d8ff6a3c3381968cdcb0e86fc0e0b4cffe0b2f3f4873fc33dab49adc5cc335b47acd83c513b266289b8fce26793702c438976f9f34fec1ab84e9fd96a9c8df2c7bacd1120cfe90091cd91d6d7e9c7bbad8e456aca4bbd3a4a054ec2f5e11be964a2d53406b3622365a1449a36c8b8ab395bb033ae6a40cd0c36dcc668836556867f12b11478da9e837860d9aa71f0d5c7433f0eaf8619b1ba33a01fd612db65711868aa7c7153d1811a2711f53dbebcec50741f7729df9db24bcf8f284f017079fd7b467609ee24222620dda94ca6ea0e63c903b75c72b87c5d51c068924e164b2c6213d5c39fa4b62fa828568a7903baedf08a55001eec3ab3f0d5380dcf257f5a75684a77a8362e42f309cc4317821a4f2204c06b3f3da21f7b6a2ff91914858fab9efca2b26285ff9a6b1b7b36a9ffd36ca679a477f7fee61b211219f78e21e6e0850b5a9184216862aa30a85c2bab21531a368ab162abfb36ac1a124a2e602adba5e8d056667e5108aea332f8c316bc029098821e7eca72c2d695456785e13da2c2ce475ddb3c0688ee4e074addb7c681f5f5634328c40107bd8a06ec300b160b263cd22ccd564562d353e962ca74cd16c96e8d1ece317e6a3619bcf33be1a5141346b59b75190e32183c359dcdc30e85e40fbcac8dfd0d3b22951a38204e447bc87d9dfa213e0124c2c9bb86650add17cdcbc89da64cb9ac71af43fa28f05e05e53e270dafb3e12a3013b9f7258c05094b65115efbbb866c3130d4e71921c07017f3847f648ef8c8957a23c8f9158a2221c648e681cd318badafeb1364b0e2d70ad6bccc66b2d0df0c56106abad9dbbac28aeef8140dfacd64b8f2d1ab9b748a0b00cc5879fc1005799a01e42cdc03f30a3c5c8c752b98e1606b558944aa057c3a1ada92cedb6c20345e51dfe05e6125e160f5270b0fa29074116d4d58fb63057dcfb83330862e6610c1817e81e5e350c1b8aec858d73d735008eda5c8afbebfb1448da9e4a49f4993244b2de3719850ef4a3526ab7490fbb03001b2dfba175156b5620a6c1543eab51a4fc0d5c0f658429857d231eaa9b6e9acff504b8a8516cb95c5943dd3fd2f406973f5cbb308c23f0276f10e5cf0d65dc8ab1c4d24e9d4c4c19072ec4d1459fa5f53633b123a7162809536072f8fcee0d584b53f35a0b88aca888a24a92381a4f1855b9cbb9197984278fc2b42e0b06efaa166fc6a74d6112f81bcf4281f44dd0b0c0700442c9a8b7400a28e87edbee22ccb8d579f81fa9095db0e79bdc7d5616d1d2c5f61f9e75eaa1b08264be880b18f426b596f0f2676f58f8587389d7982f45f49a159052fa9632c975e342205018f04efb4a346dbf97de2ae38ef4e6b45bf9a6adfb7f2c20548a2c347d2c50ddf79cec8790bd405036b2c92059430a373e8b41499406545f2dc179235bc2569ea9ed457ca6ad30a95b3d79c555d629e2444d6e7919d424f419c78376631d06605498542f831b151d3ed801fbc68c3ce0c07cb5915c327965aaa0ff93cfafb44fec674215db35ca2d76954fe2dff8552765907f572a5f67e40ecc4593e894969ababbb693e9a91d0064430c6e5722d06e8470780beb8f390b7fdb1b67818a51d07c6ad01f823c4de21fc36ca3d6887862f6870280fef103a3f0d88cdc3fc42e3e854f1fef47159d93328f887a86d57edb73b8a34b2dc5588bd5883c2174098f59a1f232e4ecafcea67e262f0c57b9b1f2a8c852f08673669d68dbb166b45a3748199eb9a12b847c62252fc4e5334cf32f7de9452fc33e98ac9ff33d58e20f80ed0af5c6c303ae429cef7f917883b2859e2c8bb3e79a2d5e71eaedbad5d049a60d8ed20164fca2ae9d6ef8815c3a7898a48e37dcb5dd011a1538998d20a2fe7102538accf49d2c142092c43512146b53061f84282cde641f3da9ba52dcc697f9dde5bf233aaf0a6b643ee63ff23f8ebb10c6f905f656b55090254ac01a54b7e647557585575c1bdec5b14692b2b233345b9e190c624be766f15f882a1d78752bb33ee81d84a241cb672bf8814b42c7b4b2d4adbcfe1baee389e516344852363a0d6e6f306115c9ba04488848d3b4687ed6c5ab29279ebf1e18237d0918777e39ebf53a21ebd93b748315109fff060c60e8a04884128476cfd422b6c1d8277eaf5c18928ae7aab33ccde76f5ba6d6c26559b9a447cae139e38598d23ae8518abea5c92144be39ec9238f9216550ef8a8693429b9fb5a2bca65c717742a93b7cac47e1fb9e55cf816c084db8bbdd7b9487875d713ecb746fd642b7a09163b6229f888bbb7f817dbacffa5985567ecc24df5f8c7829cf300e11eb2ba8ff4afdbb123eb0f26786756eee683b52fa0a50ec97e4924c23dd7e56a0463052bae290579156fe09b5ba5efc201e5a124735339aaf3f8297ed49600b55822aa35be2ffe5bfd5a2db75026b80cee5511a465dc91c493f03ca879d0038ee5bbc45d8315453e074c72dacddd7dd3f0168d9323993c49be4439a342ecdda1b3f33179c96429bdcf9ef603cfde966644123b0b632d856bb6fe95ebd5a13f4c5bdbcadb76bf2fd73dd299324dbe756cfad70212109f905cf050c6d4f6d8d826aa1282b4a4553a4ee8724ba4364f7c0886acf44eae453597b88b5b5b55d70192d5ccf50cc8e9f49ca8be149ab0fd9d7c870940ef4ebb984498d9ee7525ffed9e03c26a61ee26637f61a28cdf24b3250d37e5c8c8df7c602fd31c33e94b89213ee9cbe52a984375e2981d4bf5be41c45bc334db7e11437da9d21dca3afdbb4e7acd6df8359fbf8f89cb1066ab6c73d5b373de4042850a3dc1968d1a245c07519093a0c4a8bfa01d11543178a9eb2fa7edb446bbf7731421c692fe6f19b414e339d5761fbafd935395f1472d52fc2118cda51d2b5a858da5cd68ba96e4fa4d2f66e4893336963f687fee01bdc517c5c386a40797ab0665dae833a2ecc12b0d16d238aaa4f529fc4b95529085fb5f29afde7b7df1399c3c6c71f0ca74b72bd992d91f8d577addec8a1400fb545c4ff2f27cb628a5d17a7f0a4fd3fc642f396b3ff1d0fb98aa38ec31b0b57e34c32f952a2b210510126666ae8674cdb2cf2c57a1d279044526bb63cf08992950c6191796aa039a980f3878f3d9bb31e0c8a97c88968272f895a3e0b43bc3d29b0717038905af52a8798994132cc1fc84bd52760959dcde58215f6d311ac0a920f6229f4e03080b5bde266c47b1e7aedfca109297be4fbb00c46920bffd68730f4ed9d14c25ea5ca1200aae2e7b2750f0a3b73dc1d6fdd44f8faa3f3514e40392efaba5bdf6ffd8c50f667a7938ad01dfe3c7db94d7dd57d61dcc40fe10e92a5957fc5b7cbc4b3ec48bee871207c1a564a8ce4249a2108933bd63baed71c63bd7912bb83f50ca66f3a00fea4e549f84a1bfe1dad319cab4c1eb13be6ec87b7faa6ade58b9b822b699bb216b9d9ff8a5249f71794e76a0f05a55fae947f186a3bbcfc2f199e820744cee2748f1dbe295d8b9a1428484ca663509987fff42cebe852729b2afef4aa6aebfa5c815ee66d5fd87968f57f56f59fc4f6f9e2e34ce9ce03b90d2bf71363c1b624f1ea003137264dcd14979495a0319f05cf77490d03da1e9721f1aaf1846c6556c879dc6e02ea3758ab14a8531fc6ac95bd4c98193c3af2c80a7a272decb3f759595f32fb65a75a33a7f3e0d00ee515012cca690224bd53f3c71d7c7abe2eb25b4a6ba9e73fae38697115681b23bdd6d0baa53de587f5fd710a89f3d27c7cca8ef579abce741f73d5d6c57b58f7db8068932aff3c6e840adf86609ba2a28d24d876ab755a1cfc463855a8f086a0ce3a1a86fc78fd8593f189f24355ca052700c5ce7e37827d903e5bf604fa3d8605c08c9ee3f59805c2660dcdfdc26c12400453a210de0fd72f342acccea926a1e26393653bf694c4038e08551c16556df159a2fde768940af659117e4489f1dcf1c519e17dc50f9ded5426110753845811a848192bbaac1079a87f71f876c172c8d7ac7fed0f5f56b3801b0f2a9d5a9a380072e96cd338201275dab31891f75d60e5137058ed279dbe9bc7e3327b9077afd371267d73acec29ba15cb6916038055a07a22692f682fee101c0c7502ec23a687d83efc2e316ee1db8cb9d73f2f244e43e45cca587e95b84df497e14fad3204bfc4c563771beb72d75374ea895893083fecf940f838a14a273496553300c9e92f360d71e1243dee59ced6331bb36ae83fee2545f1b7501e7b018befa75f0619116f226bbe4202495c1f06eefd9069c6d717b2008081f4a00686e6ab0b8e9bd57e514136d49c0b371907f3b402141cee422abf9a3c412072f07f7fbf5cc4227c0648491014a77d0a749b782b481d389e29030530aeda2cd8f2ea6bc3ce97cf9027564ef40a56ab86c99b197c31a640f5c44a1589ddaed89aec143fbdbc6adb2cec4923dc9a6526260b954e5f084c513fc0e0cb1496b206b1b17bec3f36fe17e05bad9a366c87f1aab543bf927528f2d65d6fdae0607564617d215181f9072779091b3cd15ba4180205e2ec2a845c08b09e317d5bfc51b9d124091a9f4dead04e8bc716811e7eff6f05b5ac206902c1c06740f8c6a1be4ca7b346c43d7575dd89883f2d2fab2235ebe5627e800be78763ef279da1d1ad8bee3e43d086a232fb53c3e152c0138e29688d1fad83c34a4009e99cfdc877f76815ad5e0e7fc903edd7dcfb10b1f02bd64fb812aded56cca10090d4ad08b3269f733b9651cb84870abd2a566f313b0ce18748eae8dd4d8a71dc6a8fcf754f67c941a48f5829b27476f4d3c0ebf1beaeacc0b9f3f3c35a8c67b1945d33a9fb0e57eba14842e4a813d8751b9093141c3bc90b761bf01548813d7ebbd8b8ed3e081e6ebb83848d228cc6fdcb87a82c22c2e6c7e4826f9d105c54db57c7f0e5cec9f71849115ab35461e2dac1ff74b5a924bcbc0a7e342183da7839bd80a03f37a1ba18d8c18a97a4e659661fd68849da17822f341b931c7b05389714b5b596d87ceda00862c642bc20409a189af3b6b9bd6c075699364a85c553a61f7a7191220ee6bc9da027cef0323ef8eac1506111952602fd215104de1dca47b8c5126fe27e715fae3556007b9bc1e6b7f3bfaf16d4e3166a1dd976b522a54fc9310d79c14ee8833de78f5ea1875289a8030b64dce477961bad0e028bd0730b6d74dd6571fe64613b7170e68a7532fe5b9a74dc7aec858ca856088cc62d9610f988f33677abaa7283a57a727348e3c39366228ba53c9af01a720108726413fa52c2d12a50a05ae477d4ed157b20d0659c20b97861a7c8415c9e15da5bf4ce012c4a3237af0b5b38730ae1074f2174fbc0b4b58ac83a753e7f7bed968e561f08fa88f9fb63737bd5a68a69300a16f80a65ba0ae6bd426aeaf96a7672c37c1fc85d45dd56aca6bedc86bd0bd3cf925a1b5853874dd9ab03aaa2cf2dd37d9a782297cb0a1d5c023f721cc75050127d3d900d4efe82ade517e1be171adcab04b4d5240b4c671b8f13a0229f7ac08fb00fcf6cd38bb6187751ce62c5a91af5e6965172ad76080131428b9b913a1d1392f5c575ce94d6b5389432e2dab9fba1de3459087b7b39722596fbdedfc92bda9b32a5dd7ff153c7fcffc06bd8922bec5ec46aba6936cf5c794c7aca1b336a698ddd938dc90d21f819d8c612d53bc01b09a10c302656ad1d41c2aea7c5daaf951dbf05c06caac0d626f84bc632918e760369926c9370189e80878e2b8d42d584a72c6a07ab577a4de9ed114d96a3540db4fd5b0dba239bcd9a2ec9981b02eac15c118bd84b53c4b54a99aa20fe1fe070dccc9f284609e51c510ca8c1a095287b83ea3b81e210465d499f87552123194c8e2bfc03b5ca3a7dc926d4001c250278eea170afd9c429467614bac0dfa13bf3551292a5e3a2d421349fb1c88497fc9dd5e5b8f472e54d26a8e08f16bfb611f4a1b3427b4c6357c35372183eaf20d80e764d8ddb427d9f0e1963bac385fffd7d17e41efff74d3b3962f1802972901c70675408d257b004033b78c661bce5bf6ff1ae66b8debae6a8161aa64c05dbe79db91ff4fc3666b611f6f56492644edcc6f73e65ec7bab2afe797a88b4714df94f7698e6447d7baf6ba05b4a4f53082a2f048ba0b855cb27c9fae03760489762dc4ad817d100fc607fd40a2ec27d8cf229b96dcf3d3203cb3bff02e728fb1ab8b1518f70e88b25080e588098ce603a2336fe0377908bc1bf0a0bf6158d6440730551247c64e620f57416fd0def375d4488a417ccc09d605a27dae72ab5bc6574230a44e3773306ffee78274b285ffd75d80bb275286b36ddb87c8e0f165b721173d587a9f8ca12a17a7c2798e99500bd363e50d6b76bf25e94685db6709279c25f892722e2373a754a5c87f0474b90d03d92cc5a9a3c9986a9b71b7bd06de9bf51f47dfbacfe191f4746b8bd842e37f1cf4cce02a9c83c63815f6cea07073aaa2addba770b64bb4b95fddd1358497a56d8215d40157b1959f45a13a632c7558e8b08e6a65d9ba4e1f0c590d4a16c46da3f711b4a897b215c6fc18e3d3eee079b83ab2708270e7d08f6626d4539930032e140a3f4160ba3556449d9428a2f4cb930c80cbb48c8d307d89bafdedd4e1afbb58c74589d70b5a5c33f2c8fda66867139116701eee92fbae65946a135599fbe3c0fa4dac9d2aebf777f4a1452123effdd25ab3233fb17a407d3ee0d70b42b9e7bd8b5a43094e74f5437c4e3d4c079d322dcbb5507fbe3e3e6ab07f13bf38f2fcab87d3c2ca273c462c2ac891b616649083242e29956ce18599282d6012caa17fd1279a136296f9291aea3109f4a1d4a5fb30e5fa7dc79572998d6c2866ff32c3383aecf97ce954643a8acd24f43acd1d202b3465f16ad1df774fb88c8fd37c201207499b5bd230d3f0050b662ea035466c8504418a2a1f320952a412e69d1c29d4ab11c98e0db8f4884a5dcf8e0a7384160d2a7a50c91fce5ea20857aeeebf121eeb217295de183db47ce77371395d4a3786658c970d5e2b8a3484e9082d5b225a4354d8e75682d206fd9607eae5268012bd013baf2526e81b1abcf3ad69926a58c595d56ef580c42ed1754e4fd753bac93c0420c2bbbeb63a5c1542c2b871e462d26584d96feffaddec476c1ae38d42493eb5c356fd5f5097429fc6ee134d017740d5ef27e42c0161bb6a297546338621df7165891a7d76477a0f17168e52ccc097635bab5679a7cecfbfcd2d0ba3b9a3fec5a8702508d14a02c3b3caf4919c4afa92aed7a07130f9f5d4d48b03d059fd9adc615adbbf78cf18ee876efd64b013d6a64a1bb28224dceb82311e39f6c2fe9f6da01b33e7785bc597e5e5145aafe8299782016ff3e96d9a96115c6b4317b073e38f1616799b787e7cde330da25dd40dc1792b3e706df6c46b00869d29f928f5b2c28c8432ebb401bc75048ac8d108e426265701f57a5033a2fcfc46647ed8ce161c60055028190cadaff649c6d5b0a337f6ecfecfa92bed43eb27e431eed8fc005424084725e619b7c6e8d078fc918bda96a49672a32f081c1cd4a8b49c670ca0cdf37bcbf8202d1634fe7d931cb1b33c3a10e829785a8fc771f8b8f54496663bd68b343a5afe8584dd91dc5d17eedf072ea5a28fc486edf89230c541eea6e05b5e9d6110e9e2dd3f2c867a3dd5c811d6a292517a50a6e045a015c0b1d17cdbca5fc1f25361b0177d9abf3a69f13f15fc8809f0ca2a05955e63cfcfd862bb20ede7732af0d4f2db939eef45f083d27d23a463a50e7cd66ef6e8f754f7621ca638230008c40a5c74361d42af70fd6ded780985ca3d02aae11b5178b88f0c66dc4d0f5a7b130ef1c4ff076387ef1ffe1e7b23d7e9d4f19abad1df774ffe7d8ed1b55ddf919b905c636910977a38bef2549e1618a12e12b78c3a1d198db5e1a4ede83756c2315ae8dd231237e06293f964ea5c9ca07005bd052d582ce7d00e4554fcf12d250123ade1acfd13074e16178e2a406638b005e23a6af82965bfd4ebd87582b63da54e5b1e429096c8494ddecb95262d316650e33b8613a358e995707dd4ca93b33cb32c7c884c40ed980d2f85696d9cc34203dca7cd3d3a5ce3233a2902f819ecc354b3e57b43962656da6887d3129de7d02aa0302e007cea7a3af126f1563cb2d747ba31d8a5a0e75c5ab8cd6545e8449bcff1e5157eef2d524ef950471181f3da27f3c8b2a80ccc8aa58430d18031baf17f023e581e93b8adea8a619a6716fd4bc61c33f0aa59798afc3db1bf58d764ec16d90f6ff8ea57a2312f316589a34de8ecb0c708b8ca02c200367fd462a84117adecdbd88b5a8715f11a75297f609a6a6e8f3370be564e6b4abfaaa37ddeee2d9c7c452e38a1693fb1b49889c70a092f3b469e6dad6d2d8597561237be917af29b602c39cd5b7b05a505d49c22ff39acdbf1899dba3100da0622ca0ff001ba9cd2ddc0540ae091e6e411faee09b79fa2c27f7ba59936659cebab897f5c2f987d86ab7f210eb6e1762be7b4f3fdb7936525ba03ff8a0e090bd248e4cf8a58060b8635a4bd96714e740f3c352b7a5e63c1be2d99d40295e0d57573bd1210165f43f11bc74a0ddfa1231e10152b533c115f20e18aaf5a03fa3e70965bfe534920456fe269e677e6724bbc905af8c25910660fd841c1065c0554f5679ec16031aa2b46b89bf21a3b51f9110c9babfd577b568df57482aaf9e268e0632abaff1939f25def281073fba665c2988ec27261b3403f6ba20d0bec3dca10e935063b2429c3565060a212ff43237c1bd851aefb9f218ece40e4c1a39ad761a2a3b70cb09bc008ba10120e2e6a252c23f2a9a8c59285d6398ffea366735cf43a012a6f322f5085a2682e4e54eb6397fbc54c1f1ffcda1bdce8d92fb9eb60ecb3d5aebf0dca83b2e9325943ce6a3bcc36fab6436ef885adb7127ddceed193e5e972ebf7b953d46d08e39347fbb4ed044fd758c0a2426513b6b967692b5b91e61e19e1577680e8f4ccb55f76312c36a2ab17b929b51ccbb45b153c3c7993b18afaf913787c779388fbef8d42b2aa6d519c72891c2917f6295fef99564dec7e22a888c1accbb1c6e9371e5a95bf2779dccb7901ac748d22efb5cca84025e116a8b37d42cbaa29d87fc3e75784d09a316d38a75be023c73fe4b519f493545481334e4b36b0ba3c313c3149e40f6e1c5c67554ce5901626ac0dbffd76fabe9d66772884b58f9be78275ceba721547d300714c7b74e002e763cefab57a89946b643bf847811b3ec14882a8e57fb926a49d8434f311d6845ed08e43d00547e3343b7a73846b3278a8f99ea765e127785a98da20c032dae81d350a329687815003dbba138a8b8e5ec45030156ce1d31907e70fc111e0b97f49253485860b6dc3297b675bbdc796f75b3f141ed0a066d254cf07c708526f0715f5736b250b11ea484c6924da00e273bd4d29fe7807a4cb8aa5dd993362f51d292ca487f1b7baefe1a9a639266c74ba8d32c711573ae088884a0919fc8947ecfd421ed77f43d62f4c7b0fcb8ee37da6b4577f9c7f1217021e6c252e3df1ee2efd63d039eaa4220dc7a962f5c5da10e43e65470844da7f694d0faf2cc27d3dd4d990c6f3d31c81f56b02e58fd9431af1bff4ee44f2a4dc436cc9a3d52d126ece489e1c8e6c13661e01e4f16e50c4835f9686384e196342d437d5e8d4949dfc54deb671264c5b2d42bd61f1b392535a1d9606e157bcdb365bdbb373486444c9b8a667832890c2eb867b52feef252b214ba3694582f7e7bf10ddae16bf00de5da1e6e15c9ef87ff7889c36f37ca62706b8859eae5b864995c28cf88cee5d7e8f83db76b32fc01945bc35fc0924ea87ba894b43f04e8103649b7cfc090e52c4bbd7abb26fb532830b33f3403c78c52d403460adf61f7c705d7ee888e557fc3532c83833c7c92b77b1cfcf46753f6dda651d24ca69c6fe9c51b1781ec247dba946519b466119cc94a6a0e1f2d1f81d78a6a4d1c3bafc130bb0d4d9cf511f162200c690c0106c6eca250b0518d3802e7b7e29e5ac60a64e3e2b4e98454f77b852c3e617bab3ac795793a3300fa24cf1ef26b928d531e39004198576e8df88ce1410efc5778d3139603cb71b314db292fde99b8012244f5184c791e15ceecfd851aec12f33c76a2f9851dc5ce3934fbe9becbeac5c7ff979b229900f83a3523127d5f697687e302ffb3fa5c41afb63ce8a1ca8241d92e9b16fbd886a70e389a94ef8c2650acabfd860955a418dfbea48cdac96d02db001944fe665c9535b6506b0f609616e66fffd4c892b2997b4afbadd863877384899f3a54ebce650c91f683c5100502579b130f112b1127b2e9b0a3a0006ce41909f21c547e8a5925b9a094ed9d01e14ca9ae1f7eb5c3767693ea6552f75e7dc4e08f70d2beea7f37b1928226562c8810dd3ba03cee2252f1744f627171dc88e09b4c99303e1636c4ac4dbc28688d8b0b6779e87a103c7b3f46349ccac80b6aa42e985ed170131535433a8ba412b0669e52be8f3258c434a955f4b08dcb65b679f696d09dc9713fc0ad155d863141c058745863b002df810b08354bc78589bfad6509b90d8b3d8ee2b9748390ec87ecb7da035867df87c52146a6b66ba4c441126a4d14850b436cd8e75588f659cc60ad44cb8841822832594567bd0275138038ff74d3508b0043b3bb6a8f389400fa775068ac6ee96a52e679c2cab38c341e29dbbb0cb32b9b195bdfc5dcb1b7d262336e8aba5e467b2a4fd45ceba7e494014e5dd9465a29395dc1c884babbd41d24abd0db6e85b5f16545f93fb3769bb157815a8db9b294ac7b9082a784f38adc0fbb87809ee121679dbea917534daac7ad3e57dfac276658606b34d7f3e42c4a890af08324797c62b7634bafc628f5e4919c061c3175accff8e934485021af8a34ffdd474007f01f53504c89955f72c1f010a174f24739b47828efd0badde894ac3e901dd5c5cef307c7190e432525c262e05b16a5425c7e28b5a813b599cb78133ccab3c2da8841cd67e8717e566f28032aa68c9a9bc05e15acb888c3a16f8ee1f0a178ffe6127dd53582522fe61b85c361c1b5324d9f31d722f09611bac63baea07d09e4ae57e9c65f9047d978286fdbdf04ca2672fc3009d726d6aeda202dae6e4bb136f4af79665beede431546457202e4d0629fc812b489b935825de7564261c01d296e38817c33aa95c2e5b3f481f400974b40fc004026fe660a95f23e1508d00e3a2c59f34c23619ee06e2c7e4d69bc89f5b1958760562ceeddec41b7823aea0924a910c08dea1983f8ba2989994e6d2c1dba69558cf79d2d611aabce02f30c8f673f8e7c904c841a654d4411627625a03cd58e5e1053b430c88aa00786fd3dacfc7f9585566df5af0aa508affe60cc3ba8301478ced4f54d1b8d406ec723d6d8dd1ae8c8a488d9fcf4d058bffbf0b648b4638a24165a6a2d5e74e238ab3ad9cf1b9083d821ebb2a986b34186118d60f83eef9d7968bf6ef7a77d437220f08c6d12e3e82ae9c9f576047d05879e5361179da72daa8ba9de3b31c4e3bedfed72ca5ee508a0295db8a53dd8588cc1923f4a08ec50d3e0d98fd977539e1987eb3b681a7fc37caf7582c9c25198b1e1206cb5f9a246f602f6bc106bfc629d737af297c445de99d99b6155857dd746f7fbf0f29d341297db0f14fb9b88090a0886dfc7a10396f4f5a06aa1e96105cfb59070a8a20f02a3120407fa9154ff8b7a1314f0aae08841124f904cf3bd221243b39afae151143756ac161684fdeda1dc5ad16a64ee89b8bd29dd1c68698759633bd7fba3be267b3f0db4b1f9e08ddd4f793a133a5487877cf018672b8ede0b15d02ed4fe45ae7dd7630f97c17588d81753ada83bb31f0393af6d548f2d62c12a5bd7ed167ca3f9c0308aa42565647d9dc039421661395786dfce387702fea28db938128dd514f4c95eff6c9f6a69627d630149d29f8e653152a9d7dafa226e2462ee72b8eff1df879e20610bac5c076bab2d66bfe84789515e848c12b0ba616a931ae1699b428172a63f94bcc3cfeade8db452fc4d45c804af1edbf10760138ce572f1ca5471c0c19243c5aa98280323d9a0240eae1ee3741a594ba2d4ad751e733ea5556363e8cde9c7b8799138a1ee03ec67f8c0aaa96bf9c271d0c55622384120cd9a03736ca69a721a48ccf5d8deea244e4a29823d65ceb48aeb9200193de4ef4861d576836097a93cfd28e5f62741840278cd8a7cf7eca9a721378442744ca3fd7000f7199e8cf1b5fe2ab37d87814adfbadc52e590ce77d623f9b1c275e0fd9eb8a634138bbc36ca8744e226d53a1ffcbf9f690e4bfe11e8f0c03f584286591d2d235d201774de6137dd38ebc3689776004c2b1c3756b9079c387978063f91bbf29f04c7ab1f77c0902e3004ff9f4227e58d571194f91d537f695969432a002a6b917549644969cac03bd68437c69053cb0bfe3939edcc614fb0ecee013e13b41d5523fe2e350eac276b5aeb3e3aa57d4ffb4978897646294a9f2dc45f2126ca22b5a6ac1a274c507954b79941662dfc493f5e0f0f6e98054b8d4a8c61e5651f7968f87e9f0e00045460a637c992f62deeac785bafb995f15a3e8b510d82279de408974ecc02c865f8eade71809d73754ecf82dac7d0a5a5d4984d70aac7f760b8c7887588ea9d0cf470ece539f9dacd8b7baebd79ffbeef40a4c0a68b472134546225b7acf363aaec62fdb44a85abda1cbae426b2ee02bdd44934f9e49ea8461bd9ca1d3caa3811f64af29933bee6829b7f63b00a15bc65174f244f1f64b22d32fd8ef3c86d80592eaf09ae4a02b7583ff60bae1a73b7be3d52e32bfebd64d5071a95f339e5e265db47ce545927a0ea7093ce71725d2b08635c0a51d00f22849c2f4cf3f6a1364059571efc5bf2080f032ebe4d7422af9629f204846d92c3de0c9cc9f8db551b6d4456dfdce40c78e848c3659c4a40cff03427c1f56103b3b33ae0815863e5af105f78f70ff2ec80fd65c6b9c06ce8627424f2775fd2b142ae5a4a07cb09b0d8f3bb2ff6080822904f70c5d625d3668dd0bdff1a6a2f8a3edfe1c0400bf7d9d23ca92ea741e9d90c9109ab8235c5fed34b745cfc1e7760e63c756bc9247674fca7e90cd1c69f8690c754315858265804782577a02483ec714d450ed7e6cd8d4eee01bd4df056879933849286217f36f4774670e1921983bbeb72d95ff09a1e54522d23439f008059e92a9f6b80cbf24e76552ee7da24d013f466dfecd4b47eeb86e917c75157fe1ff4778357a129c9d98aded9bb78b6fb3c68c04e0b76d9b30f46a32cde7d485f8a54b3aba61394109db86a8fefef1c9255014e398d1cf03c7539df2905ace6d9470ac0d82bb09d3a7364f9e7958070556da394907e0b320e7d109fae86508b2ee329d113c11542bf15b7ba1c01232dd0a9cef64f827b8a9bcb73f888290da4b27b43785f9e4782acc83f3b1e71626e0db596ac44304156d94960553c8708d7bfecdfe7ce666bb83133bb1b2334cd3a3efaa50508524810403e9d6245ab5f2cadda6ca747479cef31a35383de75f855b39ecfa2318469d7d9536e7ac9e7c53a9ab2b59be7fd540962dce77278d45b0091eaa5b8180abb002430d7a218207e54d4f1b65c46131dbe94eebba1dcd8cd6f0a625105240cdda7ed773c091f1f5baf7c5da15b088fe06f5cb3cf438a8d6be885efa1b5abf501c9e45710d6648f59fb6a7408982b45b832d4d3439c42b54c6736b91a173e08710cf8951ca2bf0b3b018c859a6081c980c8a7c35085d712b8b04011f9766c727aff4f90571c741cfa11fcf11bad6ecc92628fa5955bdf7c9217015b360f4ff5c8c9d58a9591c6a0aedad3635c6d6f53a52f26b27bac117a59c2e90e38afc1b2e0577792ddac9d27f314dc037b76422ab71afdb67592d9c30b87ab23e59fc4d7274388f28fcc1cd738fb348dac86968b26f0d577ce2a7f1b1c663db3f2036c8f0bc3d7fe7fb22703a3bb90ec1026e7b5d6d0b40589c693ba8bd951f131ed2e94b591f18fa128724be6ef2ed6b6d214a74a4142d62dd602fe15d088a92f37cf43a351f99d6b328b16dd06938de3079614acab51f9bd21e6c7efeb5982ca14a338f0ea503371b0b277c8ed69b692ceb5c50b4f02ae8991010a1dd7a461fcc2dd1c7f91cd010d974b7b2050ddb659f4984afcdb12acae5225016ff35e403cc4a916b85aa3e18388932067e5b46c26ace31a79d4d698642cede34e823d0981c49e3429ded7e78cd05ada209eb56b2040e0351a5f1ec4e160704f8a6de16f384c3a573abda31e12edf55a84cb3927b42002d04d6dbe1c9e59635f2bf073d404d4f2d66100e8f4fd2f542f1c2a6cef546070ca66091f9723448c2e07f420d9d93dee75a44c8ab2c3e2a3445c58256672be4a45cff1d61d2c10603ac436fd95edf06ffa9743bd6b2e80f2498eaacff23a0e27c4ada8a11e38befa28f05a37bae844395c513197a18dba1e12f16e845ae02b6c640a4fcb32b50f4d1de832d24d9dd34d23851501c6d64cacad1f7e5e9fd181c10796b3dbf8dc09fcea985257b7881c7b6a9f0b676bea9909b57da72c044fbfb84f1cb55cb1346f88131bc49e78ce6c586eb04bbec4fb7ad71f2aa6bf206e81f6a8e0243eba074de40ad5d2530e722d05b83e3ef21dcf1d4fc5f3b9dc2e7ad598622d55930b23c51a1a65284d397e5d19252d06cba33275ba3a860e638af740c592cdd9fdc617481be8e18692a71d8b2a5fff27039e9c0072c239715ed4a836487b7736c548592bb686901e5a0f4d9abe770a24e00307da27899a489704c438d12ec76e65541b84c9d186cd3fda77dbe610794de6c65c86766181b7e7239e69c770124749f1ac874e568b058cbc2b76e7b64d58af9746980027da8fb9ef37270137780d15c142a176d4bb3faa42679a0136a44ae7686e21b84abcbedbf91ac697370ffc2a80f1feb81cc24bcf9e5592c8c182dccc71e21f24f328582ea56a292a5796dd0ac85292cee5eae5355af39dcc1abe3e7a42968386d21c2d481d284ba900f1e8c7256c5928063ea47e4554b8806437cae9542bb6f031042ca649a541f0bca5d400d50360246c645355bf53b4810e8765fbd1e70f1ef81f06db4d67980f50952b55faefcfbe03bb852fd619c88c5ce898dae88c1f23e8a335f7878cef2ce60f2fe7bf1318986be32d7313e1bb9911639ff1538c621fa07174eb54d64524a373feec6b69c4e3e23a4baea49dcbd40367b4928ca442057d9b308d5170116601cccbda15774675d7eee019a7824b5e7728f2d7fdddea70817ea893f1167647ceda26fc3d4a8c52b24e782ee72e2b8a4258b19aee3f7282a814a4b2d91366475c4ee8a88aca450ddc48625457af2392e55a7bcaf2587520575ae87f5bd1ec4b55acc8e19cfe5fd44b3fd2833ad56d05f9fa1795c79a1252f07b406bffbfadaf2f03960d9cb25deff3144eaa45c8792d5c16e1490dfbd16ad109be3fb5da952f8646e28d6bc39587c22175ed20262c741b279f31295f29342a2ac6b5c39a37dc28cd1dec96da0075b21e759ffc793e79771f506a3a1edeed335d3a614ff164b41e2a3cf3cba054c08d3d994aa12c429fa9beaa58d530d69633c1c3282ff4bdada313860be16fd4ceca101da04baec05606b0cea315dda117ab1295eda3cd846afd07292ad96342031399f9ca6469363a3ff9a7072ce7231692f4d06495cb44356b324df4314664489539c38e4c19ebc83b2057c5f3729154ea5c561550e637e829495f61d16eef087ec385b7c352fc0e91712a70ff2dfedef9dae6bec8f5ff697605e94b05cf02e53b0813f326629f5dab98b378e93b934f1931bac5451932a0200554b966d28ebfc24ce99b5acbd0558d18f3002e948de4c13f36e17e14a215e86997b39b11bc82573389850dad423f48abf25d9b280cd83c6de558d09a494e501918d2f90871d238f083c25b7e272db85a17148fa1d2563eb7e74b795d1e0380a9a36f3de2c1f0ae3c6feff21af68c67d92ea59a902ff5c438419b72dd708646d2870954b731092a081121a6956e50ce93f544b78b245b3fa9bbb54f2b71e674605a50ee6608ef15394a6fc3968105ae11f2a74038bfa1333e82ef58f7dfd412a74cba95c030473b08f9dc9a51529aa04169c008b0e3da96a7b2d74067391235f63ae3da2310a665c37704d68ee1be9b70cb7ffd53c2e11c5aeb20b8864b17bd4731d6f64875d3b8c160bdb8159dc097ad99346c18461e3be3024fac4b00b014f9daa0a391a7f6ccba5a21ed8d65d0e6a104949169e70bbd35e80ef4f6e92d98f6682d54e6e02c4e8cfd0a1b4f5b128d034e606f14a39efeeebfe54e3f8cf22922e5c27768822cc05a675fa73d1a7ac20a7b806d23031862c4d822a36e628dfe1dec9782f5d26709f0c9809c9d9009eb0e8348afd339f752a402ea77a8ab67dd260bc3e35a8b4260f98253ec2f2771e74dfcba587f1c1d510c608710888352a18ae0d95518065c3e2da712b75317c14c2693e4d39e1f582b3270476f147d7d0a4e85891a1718612f973dd22b66a8e60d69c987f109cbc7bc06a5b7fce4ff3aec8795d04d5f32f233eaf4f211816babce5529b925523910e22d86225d081c3d5b67ac12f38031cd23dcc3889b23d3dd9671edb7b0dc0182fd2965d29a0412b191427273d42a9bd1778da78445d4a6d80f36376970f9faed15cb5c728fdd02cd7c34bb5193dc33436c3dd9fe488c6336ac46ab2a677b067b6f5998cc0e12e7d2467c29509e7a6260e6f2d1491cf2a973cc322ee3ab7d4f8d3e3bdb30d9b0d4a981fb90187db514306b69ad016c93c96c2cd0fd266f2753d9823411374d9386dca904986b980abf00ba2fbb306af97116a972538da75919b773566c193a8ff30bf5cdf58b3248d52cf47037f750748808e22a72733e6b45a00b058f68ccdd34fe6247ca7fd13c267e4ed6426d5212bebfdb2a9394c51687af2de05ed51b9b32e2c848a3ef64d541f311db024b2758f963c58d6d9e8527cd4c45bb93ada57f920c7f59ef1e4b611b3c9e038299be0560808eb646368607dfc2359b6add0cb7de1ba87b577973fb7697f6bc1b1b7ce5b4bac852dd1448e3c45156bfa708fa0e807df7c73db6467317c542fd4beebea9c1e3741ed386c314423fdfd63982f478a94917fcb21f1d19041fa791f0d820376eb4b1b69548c2e1d9ea771c00ff74ef08cb6df377f954267565c26adc4648b9b00abbe6cc6d3de15116278af9c7e58a889752ae04b2f16fa70c682cf48e6fa3a190399162db26967e83c5361fc690b25cd8c3ae85b5d0d0dba605a682c16fff1744af3f14e67398a2f4d912b9355f35eec5400e34d4a625ec96f1c139bb2633317ce194400ae21a0d0b92ebac46e7fb62c06772987e600bc61faa92bb53980811c92c67b2ca9673583a15421b910a593b31919dfcb93a8a6a74282173514e16932b42d2ff3bf3b6cc31e196429dfca82531c45404f92cd59390c158edede923f977917779b3f7255353be59ee54be1cc0f9cbb406d4dac558d19a9957e26a3a1414bb8d1aa959b96eae4084c13c299ac4c52bae1c0e8d517b06c50ef0a97aac31edd692001970e225a7b8d81073ecb36c5d9996efef721d8061a4b3771af38cb543ee543f09b4988dc2905eb98aa879e4fb94256025589079c4e762df6c2c5b26b30566b859f62d8cbf43799c749bee0f4a4e10b3d168cd995d5ab399b708c069624e7505029b438b50563512e50148a4f2604ca1b2fa505e7e13b6383fd579ecc94d9b7cda9ac6b29894d564e4ac3c573c215fbae5d47256ef64358a00fab851521263ce4fd6f9c6903c93471a40abfaac3809740f4817ada54c0311ab0a97b99fe310b25037657a19db7f3f8918a5dd2233504e39ddb458e5215cd7d25ccc47cad327240697b056a833a635f6f852b004719ac800850347d0be5711e7abf809eb34fa3441d4c60e5e437bcec1bec4325984e1023c959ebb456aefccf73693b0ba7fa0cf7c8c040f1b65c89a81c94fbd469aa3a3ade213528b64db580c456ccf1980f32fa695b26d90953377ad9ffef412c88b06da788b3aa58574d806f27cf28666c73bba3c289deb0a5fb20c863653262e9d1cb7e4e8faa60e715e6d47437466cf4c7778c88b81a2fcb0416ac7cb6871e4dad988b5250afa1a60a4c6b8f2dcb2a1fa462c709ed90cba6482271d1545fb01b9b8f9ddd1d2bb2cd2ced64c979fe856c0f3e069565d2f2067bd60319d7cc4500fefd8a451cac688348fd2ac780368cdba65b9ee421df11eca850c9f6b5efb80fb4aac3973f922c529da680f643b670b4786e59de6a4ef512e3a9cd23b53a642855dc5b3aa22a3d554ecea00602cbda2eef4e8cf17b6653d90c6ec5d4f12cb940e939f2c4f42808c6cf02bc05845ea37c38b0d09493cda65ee4e936ddb026bbc538d76a0d76d2483b749b2e7b4de9489edd65aab6017b63c0e09ef3d7622db2e62e89fade335dbb5b4d44d8c806c0a6aa2e7ce58015f3c2b1deb5499b5faf742f876e46d99fad4b135a0d585f10b58bb480bc0a7a73139bb20fe109778f610242418d2a3bce905368f2eca8de0f22b494a8bdb139d68826d6578e3989d531feba5f98fecbfde24e25b3ecd440f8091bde55bb8cfc9fdf5d4e0d299c0bfab7ac2c48f1d5f5c44a0e45862ff62ce2453d02eef06dd8b2f3c3e92a5147379630f46975d6e515d201fde8ab74ff01e4429cd310fbfc44dd795093b7fa212454ef68c17a34355fc3d27372a7eee011032bb2dbcd2fb3bf91a7ca444be0411ee6178db2ae65b5037d6a785694db9110b122c27170589baab096d7a4a948bb9a8a895149bd7a5244de55a7dd70db4a096c47f2926b9e5d6d3e225ee2c06dcf567bd8f5b33ce7f8f52abf8f628d89156bbdb07cc0e0a28cfadea08d6f0106c6f94951ed8b415c37f1ac08cda86f6e981c8a29f4680c853f480aafd33d0be5521975ed4d5c9d11913f8338b4998fca40059a9bd93b8ce6adc93ab23cc206647777e8bf96377e8668de053e665a46cbbacc0a711492e2253ae1f724e295e6ce4142ebb2dcf2e80e11828fcfef2d7fdcd9e2d58ecc63260306f069044ea1875894127cd9a5edcdfd6ad14db810757424cf1a30f43dc0b3ef9b44f0a401a56abeb7306e0391b396e2ac9bb89ad2ce918a3793be02aaba61324e3d00f3c13a95577567a3a3ea535a4a66c43ba42bb7629bc39df57ae8f3e5097af657641928b5e0370b9a7553efcd6798479a759be5d82fd0c0904a7607168b79951c428a032c29ba2e64b7c2dd7f388674d8ea242e784ceec0588cb0c959af478e35635bd5794c24a8bc7eb4fb5eabcc50f0d14ea470b46fa5dcf1668c61da3fdcbd5fd5055d2a88bb9ac25e657334c65db638daabf27f02a26821f10ab7cc870c915b4b85b54c853ab9a26c004b35740096b52fb2c00c2fe576fb86364f009471b7e84e27b22ed8e19565d1196c7b654bf6f507723e8908842db19644a896ebac5b23f0ee34d75433e4e6913b08b8d215b04c3a75c732281b575c010e39efafd7534e8d8dfb3f89ec9d6595a177ceba5a09fe54c0bec1269e4867aa6f5a21a69df33e5cc5a9b13e7f6df1b542f41d0b717e8dcc4565b27547a02e76f8a08ce1034d80abfea744acb2561ac13dccfc200901b4ce5d0e71ab8839162e83b2bd32b5fb05352fd8e61b0c3d98190190d663455b19b554540a725d114c7b9453580fabefa12dc05b3a27d01e73804a2e471b8e93d4ee6a1e716b3b775dbb0480044a4348d9e2471c275e5e19c0f2ee32245b5b47d85cc272f84443522911d995aba1438339563387112531e05236f4207edb9fe410af8e45b80678ed568f363aa8141eb78a9ffb8b13e3720c652c1d56b2017aee9543273c08fdab8eaef7b38faea2dbd4fcd281113463682606b67ef29f1eddaa03efba8dc0213be0d91d0bd5519dd35e43f737aa8ecb45a0bfebae7eb7cdeb2b96550158fbf71a42f83394051275e44cce638183de8b97c08fee090cd7147b8cf9e375c84e157473f7cd9e7e92a21c65b17c2dc4253d320fa24b31484f47b3314bb102e44e12afb84fd2ccdf9dbc54f5c4af8a368ebdb851cf34f8c7006e05fb79decc4ac9e2c2c391e1a23312c81e70d409fde6d7861d493a0450c7073b920080f1b979152fb036075f7b9ab85f5d46edf91042eb35cce7f9ab718138c2c31e2e0c5eb177c34f74e58f595d7f9922a8ce2be992d8616a59e5f809bfe100b25641158787dc27dd3e758eb1d4f8ca44b5aece2b0f11792c1e18ad09f45c82b0af5a61fa67966562b802d3883d4246d96648de34e295313bc790e89c43fab6ca482d2e19a183b0070c166740f59e4cd36e2a65e27c6953e73b52583c662d020b3bbbb3d8f7f8b5fbaad2de3f95ec32e69e5b7f5299b00eee134c253e4ae996e0df31decf0b93ca3e6f76992d2b4441a113356a25e743a56a4ef03e8b1c95b918a02b4347fccffc648d07197cf6535b101acffaf9d84f9c4bf78a9134ecf64db72bbc2d0512048630f2653bc93b37aed78ce04c6c1dd3077ae6bdbe6b7fe3a73c056b88431fefeb2ce95bf22e692abcdbcc8d258ad6ff878d901c64c6acbf755c63b78e1ccd9752ccdfb66ed5e009d6b4af3bc0491090380bf06ad6008a8568a5cd5100a2c44e35581360cd36f9742998aff6c507874037ae0e812f3de484d5b8a905b063665f51305e27bbaba880d00f085e45d62704da2fde49d2d8550556e52e74a78fe577e8c5ed2d70bf0bea385d881aac05b8681a468c61ab511aec94f2a8739a8ae63c80cbc287faec2c86382142999fb772ed9062f7c1f356df42a173c55b4a140df71f5136f04b19416b1a8bd8bd6758c77ae2d360b4a5ab73b2d6629c3b47279d64050439477dbcd53863eab92476418cbc38f3962bcbb07c420bcdb2a5033dc01f4f9d9fdc0d5b9eaa7eb5384c5f55a21f4d6e59cacbf4f33a47b07a11b1c1acf95a9e5792b964714e788fe24872cc064da866a05c0b7ac43001e5f780e80083748fd71c48c88eea269bf6fbb920f8eff74c9ead64ed3eef9bb6ada98764fb3f0b8d448bfa5cf52d474dcd59bcb100c8c8899faf4b36e416d22c85d96a9efeab7a48826a61fb4b6eea717c7868dbe98c4bd04394091b97c3b1d3dbf4df1108c327222be4afe2b90770e7a00180afda90e5d1fe5a8a1cb92d5c784c78f563436932d07534182942b59a1e992bdd12edda191b522e4e2a0de1b3cffe3b549430743f3fdfb751f9bfa0dd1e0c74974dd9ab9553f2813271accf35cc1f3c60cc4e8ba3ee1c7163089f679a7444847d55cb190fc720879757bc2b40acfcfa3da651cd7c308c10599ea3b742cf517ad183be8eac4f17d9a23b1725add25a46d42a153e802dd78a379ce69af548f5680c649b666ff1ce285ca48ac6c44462e8b2dfa2e0b8c1d508f165f454ea93ae6ec512dd5aaa2b59cbf54945fcb821d728391f5185348def972b2e7772254d92853ae1dbd156f5aacc9b899ed2ad0ddd21c2adc5c5c0f87f0bc447d4f3f9c72cd7029b97f841dfa8c321cd9bee9a245839cbffe6700c0ede71b47ed5a9f5a3949e96fd78b20d2c72930368f525e23fdeff11472ff6ecbbf2b3f94dac71d9b48fd3da8771033456e428a7858a5315c3a1152717d55b1f224328459163ad479163d11659ffc49ca3c3997e447cf05bfddae4c1f7087a3826ba6bd14df020fdb55ca76a7ddc449253668bd234e0214c4f82f4aede01bef35bbad3878dd373302ae4ca5b564bea04514b358198588cbd8426ca5926c8082715d9b2cf465a03090100a541db6b8de35d6b58d4384dde85ec7d42aa77cb597feb07fbd339dda1bd4a4c4cf75c1416f528bc5a88b74fa6a31403905162e9cba78202e1aea7032f4db8415798f3b1cb1747c4313666b2ecd0149937b7b4b19143caa83c60ba8b295d61603a8a575fa6f4a4d484551bc96c911e157aa789e4116e4b40cbbd8c181808daf9bf7f54753d17a3e7d72d66cd165d59bc6808b116ba80abd67becec0748f9093416123ffdca0b96eb6b096e1af18befe40c720213fb7ee12dbadc1e1ccf030440a794172719086928f5eee63dc0ad8ad0f0383ee5e88fa24f3bbf1afbbc576ad10a3964c1cbce02d5cdb24120c93297a97cd78c2cd59b2148198f1e72286ec629bb882fcf5ef911f1cb303607281bc54b0ca69603048e741996004ac221b9a2f2876e48778076c228d6808d64b85662b091fc72b27ae321b9e68d520d108878564af375d764f1ee60ad543b7f869faa8388f824b9a7e9666ca41d0632eed930b8b31c6f293bbcf1eba1c4c1524c34b5d0a4e778199b9dee7f5c0053ac2a3eb4c78aeaeaf6c910335d1e212c341cec4c9f95ab80d96d1440cb0311cdd981354c68a48c4f4b87dfbccab2b42a614ca99111d1df4ae328bb55541dbf52bc78c20090cfa6c7c95ed5d23af42dd819150d462210449f3b1601fc6c7e50293e796f5a940ce2d05d1f45e0c0e092e6b5aa13d88abfa664c80984b0a4ff0b3bdb18cbac1a2d1efd819d044e4e9a2653fb8514a53f08314b4de9f8ca33d38b15897e277d6efabc79ee67805672071367fb268583baae7ad41e0dab376272b5459063afdcdfbfb78306fddf885fee02a135d49f0b4c5057debd53d04c0bb2aa147af0626baad81cc28b851ec0675cb28a0280b4f9a3224fb9a683542dd8b1be3d2bda4b3f6ff7eeec2488c4e874a98b673e10fbd02e81d742c956c98dbf554dc93c169bd141949a0689c537347a4885176e0395caaca08f49dbcc586bb262c5a05e36d9386bf520e350e998e37bbb5383e99af621a1e184cf3a86799ddf56f75dd1b6b5b59616163697456ec1ee835e0a837bafe7bf11255f0532f618493455834d072ba51a08d41e73b2c4744a25f0dc86439be4cab2797e868a7a8170b039444b3fd4f78f7cba1811de38d4346897cb01a88eef7457c327b8d7be0898ab4240d067c970dc3a080566e3faec7832e496682ec2c24ab8b93c33aaa3afbaadf9f4f4025016464c8eb4370cbbcaecd3eddfeecd5aa522018e58bfae2461d0497188faa291063983dd539a33a1199d41d07a02cf05102a2e087058542b23665e61080c651962e19cdb6cc5cffb95e9d15f401588587fbe700e55adf1550047b546f1da13f80b180f0c3cc2ce03a72f389d736cc090b63102c3a1e3b017bef6865c3bcac214dd2d6900f8ef44d372fadaf5d7a967ffd3cd199b3bf850db66a7c3c15b93eef839fa4df192cede9cf0b4a14c0caaf06cbd41bb706be5c327ab7dd6fbd592ef5d4a18fd7e80e4ca34e41e33412444e78eead42322e2a5dfd6d38f5a3506d7185d39ca4039624cbae52b2b8018e3b84406e1923278aba16969177282b7e9934028c2ff7a416c09c9ed9eb1b0a4dd7fb20de75d470ce29e4c0378d500c3221829d1e8699323e30c06f95c889ef6067a31df59554b835a6d24d9ecd3e2fe48d91a2de415829e8403977e405ebe6ac30b6a1682904c663a640ca9e25e6ca3884b76b7c4b35f0cd4ebf4712abfb82f65eb0f4cda8f8333d36b387084118d5b9285a1f64419656beee513e6738d5beefc99a22db620ad53fcd480a25e4f39c1066762c7ccf795216ae9aefd57d442cc45afd0e3572c5f438db4d224f28517d68a5154cffe7e69e88389690bd8e2487d9d8b02e00a61380518b1a27e1f275e8df00146342fc2d901d2d8add6778afd0b22ab324ef7f777cf16ed11303bc8273a46aba60d83d623d305980078352ada4cf8ba36c37e483ed079b9a41f7296325e1e35483b1a3a28a000967884c9aa597be4c9d536c1468cd3de72f6e5cc8bcd795022dec75d61f9ea2b647b0fd9d05ede23001d328af3f64a3c84269d7d02191f076f7eb0478798655edc9f202259e36b6a395b3d2293f99639d620a179be7b2538e8b6dbcc0cca1c0662f1ee36d5d6a7ac9e33bd74e63165604d85732c48324ffa33f32e432cd037b6a24713937ac70b282cf7d64a4b7fed01724b6acbb15af8762ef1e59f664b5f6ffc001c1b20db178d9ac118089075388efcb3f5bb00b368679b551efedc79daf4fd5b44d672d4fa984577beddd5af15cb9b97940930a7b29f4b90561f0cac04d48f0f3e84e4fc291f4b7bd21924e295ac6e6eea907fb94e5383bccd73dd180b6a515c1909e726f24e6555cf70feeb2130bc4bc47078429b80d1ac9900344c1bbe0e5802cf5598a34f734755683f553c9cdfae09daef7bdbbd8b8552ccf71241e4ff21b5e7af69e11261d000c4144c0c12cdcffc1b9930e4004dd1c4df31843ab52cb391e37b6d0a69d85334a19620d59db280433d353b6869f5639ec30ca62b4766047bbd4d1908b961b93137f96d399f005898a72179e9f33cfd11ef570b6202f127d353f76bd4e9d7f9d39b32e1fdaffb153979e0c100f1e7b694d40ce1a0c85311846b7c98e90af5f67ea83108c69fbfcfa6ce26c9f5a82ff5b34e69254bc588a7e1ad3ca71a0016b828d69055166a910a0ab71396fa0b0b0834fe64876b9fea6b82074f2891ec9d94c34536bf67ba89d19fb4e575f1c77649c748ab9caef5ea4200c4c784ac761713ff8087d9fae534acfa02572415d11e3217eceb3d6af9871f3dc403aeeada908ecba88400f748a9cb213c8a3920baa4997ac626718c8bb4b61d06abe2f6798c6896f78c40f10f93c41147c3db4a59910b8068836b8c8ee1d4970fdfd66c24ac031350168d46fd970e298927e34ebd429c32030ff5e0c34f83b0784ccc197b2e589bf2e28ffdcf2f2178766d165c66593d779d645093a07275565e3589d54b12c7ce044c93f6898966b74de23dc0023cf23c20068f8c6fc1479fae38b9cb880ec3c674254e54351fd4de5a0c69224bb6365c3dcb0938734c17edd34cd44bf2a1c165f64f7e36749c02d8e26da26b49aa6d2e3324668743f4ea17a6265b87cbcd43289ec73e68a6e6eb64725685e36172ffbf17571ccdc4a3155a1309db69901928326997dfc575710efd56ffa53d010185c92edb7d24aa36dae0dc693fee42478550f98f588494c75b7a2448249ecb39ca8cf1f51f2af6752591270219557417b6d19f3426218cb7b2513f002a3545d67794efdaf98f3c0f22a3d69896a6a933a6a682c596cad2fa83f31dc5feb9f7052f573e96ad1513acdd0f8d1158e30b8b5a1185827e6ab090964f768dc3d53b299645ae6713fdb8630dc46556fd13ab554a8f48319643b9837e7fe30523f8ab0d3de71529272fd5794c7376d3035ee0c7e62df9a9eea24b354b9cc349bfee4dd61ac40296765c3daf142f1d4eb973e0f90fbff99a729de8484d2fa9db75147465e6a2dc6fd5a3f053c958d5099414da317acad538a715c7552e42c152a50137fe1dd61d000eb127b02aeee44725cd1c55270ebf7a2cbfd1f36d541eb5128ca00370c239891bf468f48a81995996b35aab2401e0c8c3efcb14a48d926a21094613cc2687d125999629ff88ebb98f57bfa922bf37fc90390c53c5ebfb335ae5fbe249646adb2c8841eccf266a6cb23be2d37fb250b776fd04df14682c8235dd00cdc2b34606d7cd8658e86a26d4d5dd05210828d085a41f648412c7c6bc1d0f6ccac8c982709a306e29167f96fd3bb177ac3fda9cf1644e3c2544a15e57a4c3fdd132a5b7e6f33316a50f2255ccb4752449160d8a75ac93779d7978d012720c79f0bbce28ab902003ac970357d177d5ed45092ceec02a14f37fcc40052ec5015b0d2d8edaea8b2880b9eee33b6e9b27d740613348cd3b27cb76298f0893cedc7db8084ca713c1815da94a51df0c2352d7940c1c233695054be8a65844822eac35a17486d2ece78fb080d7e77ff3db9aa09cc3372065d1551625de347484d9e8c0e974f69598fef36467846fa1ed5a8c61e423dfa012020dedb1da8e219feddabfe31ea9f5f938d3646084e356dc4b9061e9071f2c8ab64ed4f9bdd4518e9f9cb41571969c9e51c810a8abe66dc4869da0f4aeb4fcd7b234019bd54d987df1e71eca6420ae930b09caa54c20c8d8f0de350655bdb02240784e56b8e076c9358c595909b8cabd683438cf5971f739bcb5e56ee5fdc48d065df9fa3d1e761424ac710b1ccd4fe9ed94ac28237d37e97f6a087bee9e00bc5070ebbc51263cb3d19babc519a3692b4a290ac815983f96195e388ecc3644e138fca142a7455d6486f66d20e9cf623d40fb3f873d92236b48b51add566271c4ebebe2e24c1b81d142c9aba5c5298a82a6641871f29826dc14c67f33001fb1045bddf4e8d77a29b3d47a34d82a0fbeace7b82e7d0a9e3ca10a89837687611c318bf61e3d19697747805c2b86807df9e064b3d951ba639cf0318701a8accfe03705b619c1c995d9cfa57a63e7cd4272a23a3debb61c4ce2a19efbdba68d2e309ba1602e7a5500f469a670b81a9c8967cf094aeeb9c99d0928fb508f305389a91c27336209a12192d4e976dc5328f7a5d2814a1d252efe7825174d50cfdbbe52f37aa6269e39a07928fd55681827c40243839c013a84b6f7801c7e50ec562879f71b3165762958b1d9c9c7efae2bbc153d7978c472a3d414854a0460a964a83bfc7bfd961fc029ecd10bb3cf09b0e1fb973783df6b509d2323e8ce21c0cc5a18b1ed716ab3693f309d74d9bdf0401c68d30616a7a87e51c5bcb6ce5731800b7d96de81ba56145349da654fba4d533be11f243999e581e9d067afa43d37d7c4e6d1485d9638f0eebe0519f54af6ff62bb021134fde4be9bf5b15c2b30ccddaabdb5fa5dbbd0a4566d7608c23f58f899a021fadfd85ae7d045dbb97f3a146c18ac1f2b47668e978841ef176d68f972678835f129a887382d57a094135939dc375494a21d0689feb6112553c6c45f731e4902907cea94c036261b0141dead2e6cf0122533bbbaf17bffc722078e7254cbdb26e384bb15c8c1d18a1132b03034fa5a34dddfa2365ad7fadc421360be26f2d4f117cb6a349c6330ca8629b858017c0996ba17bf1dd17f75d887ee06a0dcfac91cbd35ac9049903f929ae1cbc212e62045ab11f835d81d8a3367023d88ba4c2ddbddd6dcd27d8dd00b74637b299d52729839e1f4d62988ac6ac5be7db18c87cf0ceb206db85f92f9b748802a76293bce9e4ce4bcf05e07cda5e7353b0ca01e48bd9b0c2bc6b491b0881e90129ffb2b81bc79a3ac2cda71a010341bf0bdea358528179b52446d04e1a1348669ddeaea54cdb1ff0696456e25b88a37706faa5250f7709840ed478ff94dbf7c11fb5d2cfa973267c12ae10016ff6a2a8001e83fe43964ca51a14add0043590468fc5f7973e3f67caac5f07fb78916877145a723f9c64a9ca19fc999337259ad7e6b902962c62b7827da8aeec8148bb34ef35d9dd2778df2fe1229d0ee851f9606fbe3eacad49098ba8c7e5bfd9da4d86f02dba49dc6077f06036d12aa3ca5fcde9d94522d0b6f7ad500e444157c6615c0401a5e2e6cf43a6f93ac62fd8e32e76d0fe15bdbdbf04d79d28c3450068006fdb54a1c52587fc9932bc94547db832ef18a65cd4900b254126116b39b01d25e76aebca6f83d5a2ffc4d59d39e7a601264c603a2e1ce0136fa0f42d59d1f4e798821be4ce2809d338cd3abf3122440a39fe87288dad4fb2e9fb6f2e8a0ee7a37326bdc4d01377d48dc15219081df13455c8224f4a04029a2ad8d5a231f9bc477fa1b2a532db5e7c5036006e345cce0aff4dfe46b3e6b5dee85771b500fc611319b36cfe9843340b1d5a1b8d801d9fcc8355319b46cc64f627c4a9c75a61dab3a8fdefe07bf45b867d0c34a586de03aa823cb0c67cc7102b70fae5b8a7b7047589589af52e1fd099fa5e141a3116ffe64134bf496fe7a6b6f75e38f1ddd44921090c69ceac3928e0ab0475d2aa768e158ff7a8c5132975df50b29cad36f6ef6fdf6b68bd9ba03944a5fc098d754c9df8f08386f878c165f93550fa9e2276c7af71fe4eb5abcc0f6381a6525f6e3445f544b1dde436a06f82e5f2f40a4a07e9585442cdfc53d71cf32bf10496009d0a5ccb40fc1259eaf0572defb8d76e5842e2b348e7459d2788f103c75a55a6e414e7f4ae9122205a7ceab81774a6e7ffb5a340b62891521860f8b4a092cd1a6a3b1525487495b5ed1e33bc126445d7d0f2787247e1f363ccda4cabd214aab3e059a6399afa194b45d0cce1489b38d5a4bcddcee13141652bde72e86a79ef4added993206c82f7d810667e7bfefdbcecfb1a608f8b73058cc79505f0f70ec269e3b44bcc384fead6172c51511f644c167db35eb0b00f59bbb3ddd0be7946a0472f7e22bfc9cf72f79f09a75327625600a87673ef4f5041e7048e44e65344b1d8b1506970f9a1ed78c1e80266b62678ca2bee71de7f74d809008b26a5f34cf8b6f3dfb7c336ce6e62aeea10ce857ca2b74eff86bcb152d7e3995c523a9f6e3acbdb3a7870f84c629c576c93a35ee6d4145c3f181736aa20d5a529bc8fd5d13922db271983e15e5cc9f48f1712b26c428b2534c4699189eb4d2528888c1cd8f2f6fe2f6360a892dc3e3bad20cf3a0080096acf663804b915146cee0d05956ad1aaacae2075b08c547913e33197501fc1bbc8f84f91d4e4cc10a6f84040309dcf6015298c83a57785b32f815f1ac687b8f29f2c963ce5fe2a2aa0fc4852bdb515e23b796af4f9d85d072046dd4ddc0c2016c9b2bf80454bdb5642990281bdae727f1db3173d5f623f51b08d5dbe2a8863bcdd8514ce3e98ccd23cbefeb8dbc5dbd8eace97bcafe9e74924b3bdec7160b9c6af47ad87d685c65659fc640839c32d340bd684c4311f50bb29c514cf30e22a5c057de18501d4836ff726a889cead1ebe604e7125c81eaf84dbffa22e9793a1b5c6a30c347bdd338f56e15c65bd259f1e8c52e093d9d7904fa923d95ad408322591bcfca89434335deb8636adcc203b51421d545093ec90fa7aedb22ba5e3ad66d1daaaed0acaf0619d6330a7892f460723892400f51db0115fc670509de7f97c89651c29c460ff43e119fb6660d7058631134883655d4d16ded1dfe9823d4384395435b746dabbb9cab2dfaccdace44629b6a0006726eea0e3491b213608cf827e0b60815393aea8ba3e32b448909975cee0e2160dd6ad08c5070fc7121162d6931a1f0b62897eeff2f9456e01f7a2f7395bf8dccdfb3ea828c72e560ed6ebc65706a336e32866028e003cddaade56e0368321f67d9d4c11b74bcfdcfb3cead50ad5edeaac0a96b4d348574d35d55b1bd9f93bcb959ae1fd7ec85dc6a2ac475d95a286ed17523e540ae7486bfb519f49f19bf8ec9405009fae04b0f7633ae1b942780196402395300b5622e171eb8a5b0a31f31279877070e4d66bed4c21d8baa6a4ca7760d25ccad521c143e7b73578efd4e5c62f7571a25e3a4c61c3bc9b063c1bebe1954eeb16e5c79d9feaae49b59010b85496c3453606a5bcc1cffb2bb69a3fc0809026673b7440740f5d34ce4b18483396781cd044915487f369a87cb258e5e6ae01b065f1b391831fc19aa09f71fa5330eba1a754c6e7b22a0f401261e54c13eb3b281176dd2396ca2791e6ef7e2b8e01b54789f46f7d7d5b9fd512203b8fc58633dee50e482abc24c4065da6696b1e927907e7a84983155f1320e822f99e11012454e4b870180deaaa5b346fc043115693162a3880f7cae7385b6adfbeb8c228144d22cfa443518736f26a2696f39bb05756d094231c9013950315b2e1d0f76dfd20bce0df63b64c1e10eec86cb566d7bf151e66b9f53090ee8fbf91b76a966289f0f001534209472537574574dc6c975a3c0f953d54fffaaa1180c7131ac4d37491137e21f0ea77a165cea48d19d3b26f55b3784f8899fa42cdb3880df8c73b1065d32e835460cda2ff1b12af8cfcb95c80554c7d75ca7da274dba0d46e895d802634fd52e72ad79950c7c641307ba173cd58d98666c0888444fd08a36260355efe4917b6e8db327b31ceba54f54b3463dbf9c9d66288b1f9bdf86579b71185f0ef1f2bda898b6cdf61aea70bbd6da2ce8000ab913c6491ec6fbfb2907f3f424888558b727ff3f99226b70bc186de8ca4c00d1af8fc7e88f251c1c7a6363a3496c800b05288aa03fe4e70a9a6466d6185f652d139af04e3ec5a37e914aa808f529d56984a7da15818c985fb9379dd74f26471133ad39f21917d82aa2991946da66103e4af19bdb155e5f938eac32d5beb667a54a203f44bc48139c05c3f6cbb1a4667dab5dc529efa505fcc9d62caaeeac60d4931fd38c2f3a88f0a8e3a5c649d0241710fcdc3eb22a704fc0794b38bb7b9e966f009e1bf350da3a7e3baf972b362575fca02713b270a7d8cd4311623f14d0381ac841fd9c5e08849375443ef21c11f32bef5339e5d21b583afbb610e1dcf203f02da99e1a06452c55329f804853e2fdcc43ab1817258a8bbc5354baaa0dbce8ecd09b2cbfc7150cde0d9802eb17fa623a2c1d0b6d98f20aee0a02faeb5ddd966b1f8e9cbea5ecba7d35316cdb23bec571ade68deba1018eaec8c3aa789719f346b45dba9d6c69706745cb618799f8ff590faf24b47997d522e6155cf591b49608a497920209b521c16d96b3ad249eea16d8e532343e7587a0405213f99dd0279cd901450c10c4e1bfe2a94cb874aac6ccbeafd5d76c61528c730d095777b87846b8994e13e8a07933fd34a7bcfb8fbceb887ed4090962ad5547b1a8fd6f330de8dad4b74fff5e291359c8883c58f57524e291a9f2b5a788cb6073afbc805744cf76879c8eccf6b78b8882bf33aed23acb61b6b818f05e6eae27d9731867a0096ae4f9b814dfce01a361faed40e4099e20977c0c9528b1cea76bc5dbd2079d92ae3babe2c115aa91e8c7811ed719cec39f817700461c9dd75dd2809aea876026c4b7dbe1ad4e2f6f5780ccf9b99b71c141d1c2dcd72a2c18fefa778dbb45e21ab83525b686e6878d7a455adef78a941aa5fe4cdc99fd660cee02224f1902aada1e35eac15ccb87a34718906c2b38634157129a913e675a85491c83848a3d2ff25d17bc153de1aa78620c0b9540a60abb1191d2c2796ec1323d837130b9db92379311b9bd28ba22dd9a2bbd64818908022d8e45336e764ce3b1b927528801d76e91a41b91690fc5494c40be79419ea79607896e5626727e1d6804d9abdf3628538c6da29993c81aa98883759fe85ae6d8301ffe728ccdaa4cd91223012a9ee6d7c4dcc908880495e349e68b530638e361a0892c2901a212d906a4a86e737d23f0cb6102f789d0da8e272f4f7fa0f04eb1a78e576ee9da8072319a3899c9cfd177ab383f9dbc726b38aff5d254ee5f3fab8fc0158122dad42bb8f03998cdcaef1e1a43c1d7c81e219d3409c8b6a5f8552a1534401512d1d2cf042be598b688679f9f8d7b7c57217cf12dba7de33e78ea773000b0d1e172cf64a1d385210046adad4d4a05e58d308590d9253ba35105c4a9fe5cffdb0cd2a08206f55ebecbbb5bddbdeae53434b8cb7112c9f69938ad0f757bb8b82ab8520259e4700195776e6baa429b30de52b2a4ebf30adec406ec30b5070f6bf99800f148e1ab3c784711d2936b8f13088547b08eb0616a3c47ae137b336c30f9f50497ddc6c98a4561945e78715373a80ad9d03684013621766d0bc3bf36a5cb8161e8dedbeac09441bafe67f48760aeb6ce5bf53d80ae6ccf3968676cd6168c199bd1c5d588ab5c9d8509de596e1a32a4b9c9c9895c54b733359a4cce46009c29bd237883a5316718288c247901725564b603232c560c9e5b2b83a173571d47f010572b79ab268b01825fb62771008ba359012af4113cc7b43debc5ac3d5ca3ee0aac0800fb95d996af58f31aab6823fce77ab37c856f423c9897dac67e3715499a203f5079dc049546648e74b477f8a51326f3a416436eaac04e36fa575b61bc0680af628b28d4872b75ba1fac767fad24951085cf8ecb831ee3f9b85ae95c27a3ecd1e68380607b9d2aa46275f81c9f3e5745ad7cf487f685f98c12d3e17d509da9f16da3ef4c3a5c0dbc97f1f4c191e6339a1f77f3868122c2c910454512a2ce722ce4013540de3712841c94d4bdc22c44e71142742f761b870afd745d98031e55fe8626d7d0c2535ac1be964544c7df218903feae2e400e96bc16ed75d39d84839a032618a21bc9edb67d796fbc1c7daeb73fb5bd97d106723dcb4d3afb3d804936bd415f91679600ba5112ddd94f172368f3d61c3ac2918e69774e28ba6a59d79af31af3d2bc1103f4704fac61201efdfbe45960ae8951dd11b51a62040828963c0881c2012c7f66c78498a8f7331d5e2baabb0d376dff8f7d06356a348da484251e4a02d968af84c077e2c5b851e2ff5622285e0727c9b74e6f06e9a396de3b8d0b86ef3d0bd0f69b9f62acd60626cf8c03e61da0d95df45d007ec11ff044720ca43088399421bc1bda9e489f41f2b11a4c1896dbbd807c666d7b36c228787ad20ccdcfa1a6abb63615ca8fe31d74ea549521fca800af6caaf20959015b6995efcf12d410c5f392358b6afde02892a5a8b2345df0fbeed6d584a97b1e42834fb7c006e52396859ace259f04223adaea9d50cd64094e1b67a37f5007d627d408c39392d02b4e7a3728d1df1ef498595fc0a2075ac6255158a659ddfb1b06107803e2852b512a53de09a011d2c825815be881a89584077c0d2956efc42012cc354fb989e7a4a4f111515034cbad63d7b96239159b013f98a6ffbc85d00e8ec6582e8079ddfa59ef824907aafccf273e035a9b1d8047f62f4b8b53aa70a481f60c4c4c3b535ff78d7c5f7bdbcf18bebc0c03d917e4921397f06ae8f3eae1429deae9bca61ff7c239cecc282499fb314f182b5e42ec4a9ecaf4540c2b4269e7bacdf36f781ab8758942d9ec99091ad8075c68a4a7d110fb5bffee84534f97b0ab6fcec61accc591e35fc5db33a408c86c87a2543c7dd97c4656574b271b1d46bbb2522de90a707973f25af4400da439fe7c49ed9e8bed9b31de1adcdd3599050c9a50957d24d0e5825c0142d4d6d1586c60d04c98146681839ddb49167b55df7bf2ea84ef0b86b93a17e2222e264029c5a82aa67b90e6bc64556c8d3e97b7266f0624ebec0569d23338249f19f2891312a5bb419288c2c411035def232899ed44dc7ad44bd7630363522704176e5ab1ddc54cba8cadbfdcc7b64a99a17f51be952e0324c35a611018659051ab32b57dc11f9cb2ec2012df754e7fdc5519be96cb8d859f5991186e682e4392a459daa48cf31f41376a202b68d4be0b9fb5b9d331fe8e302ffd17bfcfe9483a52b9a2267cd0233b18d04aaba4f19cf78a46cd7e48f668b8a6f9e34da379cd77421ed025a02b047d4a3a253d1e33aa90e3793d94d28548c8dd0d4df79ccd7a2a120adea9cb3bf1759b33c7fcd55a3659eccd4ecac9f0a66f621330ac6dca7eae56e2e558955fd2126b4410fa6a9ede76c0927da8a3fa24cb343dc32a47739e26c14e1dd597de3c4efcfc0f07c3fc7a4e8822bb9d309f04f2d3284c7ee547d39e0e50c65b4de8ce2b743f8d569e5f57d08545462a6d8f27cd63406381d7eb106a917d948aeaa7853487dd5ee60cbc032119d88023bf645db1c39c1a0624effbff8c72d3eff52b2756a7894086d0fd42f2aaf7efaded81f2359019ae3ce967e19dd861c47714ae19400fcf6f21e954ed06a8b6f7a316412fdc166f0ddb62abcc79a23ccb903a8c0b245d1dbe245707bfa9758aac4820a564ce053d4690f20abfcb1368c20d14d09bb934748109739e1ba1c388709b3dd222cfd42e2491ca1fa9ebeee3817fac78f6f4fa1041348da40206a3c5276778057d82382c322d8d173c91454e2b27b958349514035a6d025fc6f96d04c86443745c10bb0a6a18c90e8a965023c60bfd6f2013553b1c316e749abdf91b5fac900e168b3315309a84609abac5e0e74cbbccf97bda20538ebfce7cf43c713f5ecfeed8a1611d4ba248c035426a5616f0c503f1a119f280ae647347bab1402a3a8bf56a390e257c8d6e6a0ca81a37ef97c09aba47a04c3cd9949e46b02379b38614d8e7e2931fce6c996fd3a9d906ca0e14aa069c65b2d9828a3d3d0dc4eb8452d7c7e0cf602d28856b2df759c3d8f64476d950dd955c88b7a2740436b7447513918cc90123de6008f6476ff264b2bd9d4ce9801cc0625aa33f68bca9ae14a9476f126cef5e3f54db9b5e3983b42eaad07b1ca2b3bb47324eaa8c7be95bc6f5c6757cf392a56158a0db3fd3051387a05b392a5c1fd3e4c265b6ecff89b175feaa81c545bc94358eb3454a00f6e954e2ea4cc0823d9e32406b4cf08c637ec336288b2bf38171a0934e7b8be5260d6e3f56375a3506571d5a6c282a1663c4437e38b39712dc6320a8c0ddedc34496ca43bace1c0711c660383aba9ba266f4fa6a01d309b934ac048abc5c7b94d1e89d2ec56989b00844d05dcd15ef996fc6cd2ef0f8699e24e3056d2b7d379029a9e157cadfefc156d727e2edef8724727a06f121c7291ab51607be7664e99f352568cf56abeabb3c7a5ac0445a844a4ab5ea905f6eef0e7935e8be9ab7d9bac2eb7f20883709bc103743a56efb2cab5b36f6d713c14b4d08e83eb1efcad4f6e47277c19e3ad6ee1d70e64d1012f0ee34cb4f6edca1f110069b5e384472edc7ada9ce5ded49ee1c5b7732d487cec561eec2cada0a683238b9dd4f2e8ba3883ac7c85e46c7b51d87e60804bac2a024da65141baabbffb805c460f23434ac11d24604b2cd5ff9e96dc6a561c4e33ce333ea2f995164a8be4a79838c5617a9ad16a122d0389c07acfe51e806dcdec427f09b3dd8a86bab4dee8f7911375bee1c45eb4cee3fe91eb933b009a0f24f128ff058f01e2d95de1c46829c3affe59df17213aca465ebce860cd8756053f685e36ac7b23b9863f0245d24ea766e1a8acf55e85c855c8309a87e79f46c57d584ee7fecad4744a5f8a2b925e98dea503983d7ef17cfab80abfc0ddb8c2380969f0336ffdb05eb4184b3bd49e39ee6e52212709c0531804e7add557da7f5e204ffb56fc74f7aee7f183469852e50b361817d742a606a0e5143cb9189110e3e6be3c2921c0ec9b30f751847835cb7c5297bf585bebdaeee62572280b720945b2854556b84bfeba4a2b69f321b62de55fc93de534c3e5c9a220f8c386292fed7038c5dc66a63cfc05f1cdce7d531a0e12f84c94c7e9e25454efde4d6d2fedd2de184101df487731bc03569903b8a6b627874fc965321d97d5e5b71bb6ac5f5dddf4b3bb628d5b5b7434741e026718b10524bebd4a90b9f17478085db34390cc48a6a3112c07ebe80c2909d1e95b42be46d01505f8c54aedbc3b53f9416d3724907ca4f54c2028377258e41d6c3a829caf8badb8b64560756df8761f8b2944b90f96cbc770b2b70fe30f3487b83d85a30ec98f3f1e1d463910dfcc251cecb19236eafd5ac73684f580a7565f50904d392fb09ddd24c64316d822efe6530495c93f92255aa3ac9b515ec7387622d552118366aec98ff08af320ff7f50d53f721abee318df7e9db2b717dda1ee2d67c25f7a552787e64ed6d614e390ad29e2cc146e729f470147648d80b89b9ed9d53cd44f8b12936981e5e9c6e3b3cc32a308cc8a8948462e9a62926daa1870a2f9584f9b8b37a9a8b887515d75ca87e97a3b5a00ba9f9e616617bea637f1e46600ae63750d0c67b962a40ceeca70278873f8ad78b35ed0391ef98cc16a2794d4f82972e57726034cf7e47fcec072f4e7ca05487177c56d872e25aba18c37c3c483f9be349192c212c7777b349c653616dcc1a1d95c73849aac6b9fd87424c898a2584e2348dfd17e2c147d530071b83e0666519915085603c3998a79ee812c968ba478cf6bf0bba214254fa7a6c01cd24400531cccd0ff525a1fe629bcc476f59aa89e5c35d393a42af9da0e99ea2d95ef05a2138e32b8563eafe71ab699c75115d6ce78deacb4f9d251e09e6f0302fecc825a14088c7220ee9c3ea8df4e7e9e44027695df33d1e2fbf4a0d059406acca2c6eec9e1a628f8fe4e02f698f93fb0f9192ab4eceb3db7b69ccdf4c04088ed848591a5b4e08af3010a77d8d3c29586ef58fd2cc2e4a29388d4f8369c58dfe88e03de62c5c3442c7c741c466d984e38f155ce028a40c30c5429dcfc8308a82eb525ec4a3d0c67162cf3aff55a167ec2cee8cf6daddbae670e207023a0468f43266cca8d6975eb08df9d01ab015feef14c0fbe1b5593100d55aada00e60a273d9f545bec5b4350fdc3669c889374ab57f511c563238e0bc6deb925e9eccdf4b47b54320010f96c84218503ce9ac2d0e0aab646461be72263e605ead258e56e66db5753c473b24e7e1b406dbac3ab6056f1d9f8a7a83da836e4cb4023778ba676265df6bea745c5bff39764e5d9cd9bd201058d8847509406f1efda2da31484bd773b98ed69c9131b05b273d13cf8d4ac7ff96b413221b720f0376059c046920e5aa6ed46e42285f31465779fab58a273b3f491e083244054d1c2050d3f4e98ea09467f4cd6104ee7703d0aa9d4e340953bade07906072343f1930a3005a0afc2137b02f17342093943c0ef4e1b218081d16203ecdd4240de0c08ba94960a2dd6f3f2064b749c3530b4b56443536dda1f668fd8f2c4607a5cac7454425454c7524e5a1bbf4a12886a56d3c26a1c38f7e200fcefea4c0a356b28ef2a81a6be73a93fa0ef60ea8d520077c48ba7a0472fb0e7dcadab9832ed617a15767b53edcd911aa0a9f3f85d2f0a1f6eaa814d6091f5c9167df3ef2dbfb75010df59e734cce88b455e243033a93180a6ea0663ef1be601ca3115e08caa3af6b5c47006936fde9eae5ee838d52c8ccb125b36a67f6ed5509ad9df7e935f8e3bd86dbc21e38d282daab4979b39f495f68493a47e4c1a6a875ecb80c1b2803b9150ab86bbcf0a014fe12e6e9c5e0557cf4356bb7a786aeafaa5a22e1b550cc824eec5ea28f1b2a6e3f6285af2c34ecf13d02f2c142072ae3b6616c2f379c3a46b1baefcd1bb94ad46fb47ea5025d2e8761b026d55db8810d5d64744e0c9cdee1dfaed2658e05b0364734c2eb369c053f425146bf48bb1e2c2db2b1a21c065c04f0c6326ab03f7ec225f3f14e993d9d94a18d98595a7a20c76dfbe6236e2bf09669f8d8ae29901230cc464c1ee7c8c1b866850f20e6d955a0f52d9a1822d9cd48a563c4fc7147032757a10305bed91fa5852dfa4b528b698ba6d0d892821ec43cfc0a601431883d5e52afaddd20ac836d8dd198e2e929cf4feefa91e3e4b393fb829567909628653398112b43bda94f9fe5dd9283df544a43fd14549480a37d0fbe099c1be23fb7962e386508702681949b40d8b12d21e142fd919e1355dc8dbb12b7f601834ec9f9b6a11cb3cfdb8f9e1517ccbdcd5af0a1b45f431f99f2c85b92a392dbadd64e502a051f3cd348ff674cbcfb6b15e1fc1807f933ce1253335e283ef00bed2d521e2448f520f8bde9a3ee2b2a96770555bc956a1f4732c053d0ed3bcc139b661b407d119866911629e69c4f91fa198c2955e30766547c4e4e7786b61275e0716ff9373c6894f96f20faeeeb5e9a563f9fb1f9befdb5876f381aabc2acd78cf6b55a31b6024d32ad1f680166694ef341e22963b39665f1c39c50c8cb755d214b2ed15829b645fa0ca47e759389ddaf22cb928dfa31a63a606c59808daa3e63e9e7cffe85320651ac5e9baf595fbe2185f82958af622550e8940642f48cce31762fec8042da57d217eb57d97eece885f988e124ab5b921b16a91cdf425559dd4b8498c5f0c1a81fd7128291c7a051063e608071c3fb975e1ddb7c1af5e7b68fd72f60e9dca41b83545f0c46dd03bb1ebe6b90faebfdd234f0a37b1ed5630be8500a2c461d94f42a106384bdbcf5bee078b5caf813c2fcfd675aee67ca14f59878d56d920a87b368159a16e516603b81c1ce4eca39228f5378682bb4c1af8d1a85f77f7c5d9fe541171042d92a2a8d5dd3d5b66eee4843ef2bbede291913d89c1ea188a40f26e18c693198ca085c8c869e3d563866cc469e02444539ffefec51bfcacf1d82a883b67ac8bb87fd2cd7074685e1b86d0a970eb68310a2704c31b0563baed9644d8a6016ce199ea1f39689aca87f7155b066d6ae263f55827b7a4bade1062df4e0d6e2aed6f5d7885558a3b71db67c6d439ea43c35c9c0a6fa82d3df441f54bb0a1f5a674616a3b34faafc47213cf6e302a7e2ebcd3b47447e20c8939c7eee1005a5516c08d4589f6b34948dd77632eaa3b6af802944a0945b61e1fae457645e8ad820c8e4d151d77562788e8c0d71fe2ab05ea703027e92a01843ce64ea9eb9aa678e403fd7521c7b0c7550bcc999febc6cb04d8f9315d82eb0aa697864640946db2059741abb631264d800dfced2fe3c1c21fe2995b5bfb4e1f4f6c0377e66ce26924eb148fbb81864198acbee8edbd5ba3a9a98d28f681c045995a49dee73556a9e0d78715807480209ea39b52bf1085f484c224bfd1a6cc88925d4bd2648e1b037be78d923c822e44184db1ae39ad18f7d0855248c07250e0282e011e5918c25a9c1c0695684f0b9a5b11bbcb16c042fa393ad2f18a1479b37106acd36852b633e2be22ec11efced108e080eec77fdb35b73f36c2daeea42f6feac64711b174385dc702dcbaa5b03a77065289b2642528c1a5c96fe4f3ca0ced52cb6c7b67edced40d1870331417daca7ac6944d24f1a135b96e4c6d65ab69f780727f7ddfa1e9dc693305c050419e6c41f3ff2b9d37dcd8c12dd57c34d5be64d377af033e22e8143ae08556a28c6f58ebf259e4763de59165afdf852051113daa64481a1aea500180f0903d1f786244826fd8c5bb474ff689f3a2a7c328b850fde23c757824bf2c93e1098092f9bb24fe86a0077782751070a6a99500552210d0851e99fe4ba5ee1eace1db513a81f15a5210a5ffc7bef159fec9348a5196fef9fb49af6c05c9f215e8c10baee2129c64fc178157b830e70dd9f29f76896011dcd1bd058900176451c269642cf68d9a15604565f6661b85e266ec23fdb7a3c24f555e6a94b6d956acda055294b3a40032b9d6a02478789917b85abdf8be99fbfe0c4d47bd775ac0ce95f65579577bc1946c62b6058f950cacf7312ddfe2b30baf7f217f8ea97e8b770f4f4382af598722d3991c418cb48a044c30bc6eca77d049eb3810af568ac212e04183c43681dc3b81b1b73c3a94d622901753f40e807f1099c3a8a37cc3b6d9a9d39d18f775644370b4ef6cf33d07b77c93ab1a4dc8039019ccb9174b9fd6e1f18db92ee63a5b7173dcfa73b6a025293a898409eaf32fb77e815bcec2e0fbf3ac7e4e578566106a3d1fd036fe82faa3cd50335b3dc18fc3e8526af05dbc008da8bfa211f5774b7dfe1b627a3593ed4882bd9eb192918ab84ebb9dd5677cc38684c1a0d26b09b2238fabbdd5890489b13e8423ba05a139377bc1c75d9477059d2d194a1832272b83507cef3a5f8670acb75759b66f89e38a6407a747f9a1030cf7d928740b5c987378f477131a05a7ca02eff086f0913c99ee5d1779abe238e08fc321e8755273af093b04bfb5e40ba8b8cd843f27410cae3d91203b7be7027e2b5b4b580d2974ef239885a8626de5112c55ec744e4c66f59c698bf27cc36f511b67a05aa274fd4d458ff5dc5c56ab2cdfecdb999ec613ce24a416066dc2b5b96f4c53195aac59289f22c09b53d67220131dd8c7b0ee63aceeb86b9f5c0e3778eb306bf313792852d75b0f65beaefcde5654d3aa3d5ada07b296a1d7fae33efa504ffbab94a3fcdc9a502999e14ef8f2b2a608c4ff6671ae9d790a7b33a0308b150c5e51b2008a4ac89f3b98da904f656dfbe05d5f81a9df626de6fbfd6aa081cdb445bd23c7a79d27c5e002122450ee5938ec1d31680c9deed8237577cb1781ff45f498de3dfbce15e442d0591eb20301112a9347618819573ddd2c4c2fdc55c988d8c34ac6fea039c309bfe768cf289054d8565c405279166a708fd6120f35ae2df29843ba11d3f5116b4ae6f5b313a0849a6cf0c4ed1f97e45fc18ac0694ffedac7cd9be7ec4255e65c7135ba5081cc469732df9f8eecf7789fe406e412e9a19340232a9d78f4f807afdd489de7edc6e31867b0fb80951e5791a9c67c59eec654cc07b07ee52ce00722d3f801473e8bb6675c49637a1a652075ec89bde0d47df7d3d0b32077265512aa60d33ec5ec5bb12feafc8fc4c017f0d122ee167d8a1e1fff76e807d6d825d3c780881fec8cb65db822a01d63000665c4b307a69d0696747d4267d7128874d7f42bbe3f9e8b0e6373237643446db2a101ec4a2face21074166f377708a98a06f6d931b61a5a5e95af44896df4d5465048c531ced0264edb90df1e25325de0e3e3f8f099972ae41c49614e7a7d351cb249d72a3e7c0f9ccf800d6b0f3c4cd8cfdc6d1df62bd94aa05f555cafb8c07f76c9c9fba133819a4dfa6837390b8103c3a6c8b7ad692615b513609a14b90741d8ee22fdc8b2b75341528e335dc588040d8b776ef12dc153aeb9b0b16d9d07a1716adb05bf033980f4eb3ba6a67fa41856d8f6f3b44e11cdd1cbe95ef6e93095bfeeee4dc74fe2a30203cd839e2fe0fb444692194dbfa70c0703105f48329742a10de98e15fec033d7cec8cc7eece99bddc56e615e895eef3c5cd5d4a77b27b1e6ec063b9e372729d582631c221e9a237dafc3b3786402ef697c9595b3b42ad3532ac237a7da666e5d2092da30d957e183579d8183c7c1a8bdb908d4b17b0cae19ef4b1d626c23bfaa5b3cc7ebd73db17d1a241f281923ce63e38eb5c49466b3ab7736739384becd1aa2478799c06db1b54c9ab3a1108bd88033a77af55d33bbb3717908b86fda51c043fd98e2a2c3c3fdc74d9275d7893969c5650010cf15670489d92977c12578af7e170f30b96198eb45c02c2417d1aa9ccbad0371f4cfb5873a391578c7f4cafe1add82272f7fbfa2ee6841f2201943bda18dcfd8974d66606eae7b5d1495a00917dab431f9ee5ec73ba9bce3cf06572df703f41bd3cee9e19a7e3b1a2242e4740d21744d07116fa1d6651b6e7ae91135a0682e4e66287ad4d93d0540cd9a9f95a09bb48f5c842aa2eba3c55a9f503d4fcccb39cb64e7ec71bcb4cd68b8d014eb0461274780c43941876ac5593a91365f898cfed05d5353069462b5a2d407c660931fa8ac5e620f4f027ab8f222560a772d06808bb780acc4a9bf457dd15bb803b67cbc1776853087fb555bf0fb5852d0f4b248e0c83044739b958adbb47d61c7852f0476905c57e7a4a9db9c2cc69bf3431e8d9c80e81b5806bc384da6b64f952d76ce79fa4940f17f5a569cefcae7f061742685c3fb6903b2f6798e6fabc2cd44d01e1d572ece6ec0bcfc8df5ede0453681ab871f9f52c91d86f57cd42dba9703573f331260da13948165dbcb5adf29affdb7b38ebdc974ad029fcce892899131abfa936e56dd8b932838da63002e97402149786d7929c19f5b6728bb85285f63aa7690cb555f27e2d31c2479a11e3ba21c42c4f07ff31ba050440e10772659c8aa6b84c9541517ec5048881207706a1817724a09db2a51259005198f531dfebe0f508c91503c55de57e92a54284b23a8aa2d56c1db400bb57cc86f095bf4183ffd74c147dada7a1db1877715b9cc455453c9005c2593812dac85b68cb6115f2aed034660fd31c4ab2c418f410d0af29716fb5e8d5adb33652b53c196a4d4d1110629da9bef9e2901a2ac45dec4dae673b8ca6c83383d8fd6c8f87d6ef0593059161292448ac46dabd0ba5f58960873a4dd66b24b8517d8c9c1843133772ec9b6b609399cfad2436114ba554bb8c85c07e74fe931ba625596b7399a164920f9a78f40486e8921cac1786a30c2f9a2f03f69d4017e6767cbe954dc9cd78c815a27ee00ee2e9e7e99f5e3dddd00a6fa72eaea5131b444f8c2172ae1ee486c40f4c54906058a0aac35c2a7e832dc4a0264fd74aebee7696117f72a057eaf7a6185d1bbc7416e8b6e3bcf76c974a3dbc3c7561f23c6086d94175cde24ab79d221c8ed80de0f4582cbf00e8baa79c8ec5d5a5baf4f8838186e231ecbf4d4c670e1e1dab8dbc098c6dd4a3ef1deb9380a5a7e263876d66f8022af598162506a32fefcd664f068b259af8624a87c9cb9fe2a7691e71df764d7913ae8bb469e587361d5d138147d4b7eb6b7e9491424812e0faa289993851f990107e5b00e24629beb22d23582d6b5e5c46175a815dd7123f598c9cdf61ba8061569eb324095532b2ba135de1c581448879a10270f40c9252f57c293f5d93152200eb748b0e2621fcc45461b48dbec99c100fb7530164d10edb73cdda96a4ef09b27d32705ff01bb947f4ae8f3e571a4213be4ca70708efd4f1df61f289d5ddb8dd5afea9ba123f25598dd6776405230a34ffa1b1d72626666cb9bb922dcb8f6a472ee6360cef1728790ec452341c07bb00e086e4485218491010aa3b67cdfd6b0fd55035298d44d8f8901b6092d39e3d96491553287c645d9904e19c5b0ac715e9024cb6371cb65350b7333dd03fc20dd6210b3eb7bccbf05945c2544f728835bc40eb3cea1d8e8fb880e63a120d0db591c17b1e445706b25dade6fde5731c22d519490595b7bef014925e6ecb5a6d89d81c7547beb51f32f1dcf2f10b35b1d5d3707aad10b0009aebc06f9f43c16aff1c1e0ee54ec896691a341656409c2b96729549deb2de421fcf61e2ffbdf604df9571431ae45fe8d6ecce6b657c4e701aada56ccd406ef4e39d21a9616857cbf082f5d40693a00a549b5311ca1a78c6919d19e98b96ce8bc303e74aa82ca08edc1c6249313102158ce502b6e6efe1bef585a1071f55a4c418c668db7c548bb0e7e59f34da7aebb9ba6a8b6b4c6601c471d9a548f715fa3e0a850756a7f78bafb504fbbcc7e00ae87b47ed85efebcfed9cb1afe448572f599462429041050a3214a9ad7dac0524a68e74a8a66f72528fd7f50673894f404eec7baac15680879418fd3e2a5a713d90dc4ac1f7a4128d37f3411bf5c904383901e60b8521fe124cfb8d952d6623ab74bd0840d4f97cc2ffe5f65a971cdd13b6cb32bdf6cd596d1c7eba5cc5999830e90931398e89975a5057431fd8045c4c3a4de754c89e93238a0f69cd326acd3f3baaaa6c38611293ea2482c54c2f934601dec778e86ec59871ece92c76590d4d7084cc8b0d44ea33d3814bb48bba9dec4c8106a4ff0b4c122584f8930c61943bd1e3a5cbd9710345a55ef6b00ea69a1cd57f47d41bcbfad5b5333b385c381974ea5d8f73a8053e2625c43df5eeeb8e5a84b2924c881959d92a58e02f3e589ae47ad47fc60b6bffd1c3b1f0a25d935bb1930bcc25f761f0186a3947c3228130eb710d02577f2425fd92e0066d69985edf11b0667f7344c21a444bf5e34a294008003aba3bb0599ea0f966ffc4ba38bd7ada97bbf5109d41535e20d9b91a0d01a61f66f7c9f84e1d33415987a8e9bbef8054cf5abdff4823366cecf9bb87f31a239dbef36d75eac2974472cc7f98921875a23f6b5864dc16870eb459e3d72d1a66d092c991d63a8cf2cc592fbe78658c1ed8248695d79bc7db420e761d1db92006959cdfb3887a460f859ea18482ce1a72eb4b02662281e9b915eea9038dc31031cd232744a6531f9dbe70491a704ba6940712dd24dd800cd6ed8683393965ab793c91a3a460016f52ce5672ee00fe43b27b90170dc6f7ea0dc4d28ae4e60339ed320dd84ec637963a8125f245b8cd39151e53664bcce69b24d3d945bcc314061fbcf1b7e8d0059d914b3ec1ab18bb09045e3448895d6bd9db708bfc5e2b90570ebadea0d98e7eb5b71bfa4995cfcc05c4e48b98e589cf10abc80a494e4716866f6727606d6d3e73d93dbeaf7f6702ff0ad256f24af779d3b04d76bc42862db855ca4b3952e41d192c6934e85483e6b4aa3afb0a32d049162d00f323663e32951b22b4d39bba2b7b4bcb6c86c57e547c188d9a744b9b8b3b224d74325d27fd140af26df5f7d9227085e58cbe92ede451c4003a3ced4e8bc2b78c2300ac1b28de5d10eea75dbea115aabb0ace504959b7cc6b6c49b73c559b9338494c651d82725b44cb5276c33ec23a9633d3d828db932e83f4ee000c4c4165a4c01e1468ab3294f76e06b0c11e6eac2f2390ec13691b8c8763094f5961ea7e06d73e581459b2641b23a85c134dd435c49a9e35bcfa0dd16a8533ab2484157b8ab48d3c46acea0190d742d0b9b11cc750c5b477b52212ec3a9321cdb0c5c7adddb090626678a877b77ebfd9398889ba3b2d329d71dd6c56a0e827b2dcd0042635417abfe161011a184a6f1746d903c3ce20cfc5453142c7e07a6e3fff28a4f958115289b7842b49200e6eec67a87ea304bacb849802a04ae0bde4b57cb2598a54d5ad8ef14a6bdf0d9f1cef481b8c9ff86c42336c27d36f00fb59cc51ed510c1532a7d51e4261cf7b2f7dae24a42a0416012c1ab31520a15c0219d44f7e8613b858b03b95b18706518ea2ceb41d7c9ad87c308814e94ba55b997ef734df35075562c7f44b69a331225d9ecd48505440bbecbb2a3c7f2cb83b85466fbef8bd4f260d0db3625fc001e2c2d28ee5682bdaa80fe23a2a04fe6aafd07f87a61204f323ac45f6b77f5edbea830e7fc11559a6a40486eef375ea1e1cfe6b3783a7935da7dd6031c31cf17b3f256ad2f6bd52415f88a45ab48d6234ff1b92c49f562dfe9bac42077f68d08037ed045f9e6e6dc5b9dfcc162ff1462b83ae977fc56e29e846a50f425fe96c87b937039185f9bc517e65345a538cdf768e4246ac1c6711ac345b13558579e1dffaa6c73182d3fe6451fa1d9638e0b1bfc05bb803d24e9aa1547018b87216ac6be6dbddffdc0c1d8bc9fb0748448f3818c02053da75c5bd22a016aa82b2b6852cfd4a3c7b53287d55dac6491c79d26eeea276a8c0dcd08a905c06e64b89332388cdadb26b3b55c7da0e5a43f59984c768c2e92a444dce7d178216ae471c25c595b12ffc0e876f376f15f40c3d34d17878fc01c18df3d34334ef66d7a8e5288f120c7835cafb9a8da4d9833f5b6e4b3c0bee955633014a5b197f9a7a61e50bf22aee7ea46c9e26679670f4450ead22e23ef929899c4018757589d269a1fc6ce14438bc63af7da1999660937da9ea8ab310abac992c5d3bf16ddb357a9af346e1164d1332f6556dde4642dda52b8c82d313ca141527b92eaf99d7fdafaed02f0e1a70e7ed874191b3d1895328791a1a8b2eb10ea0592fff6fe4ef4a6312afc569dd5f3d482fa56f9258cb124a7497f1b6bf18a119d10bf1e97fb438c9f74d5a765615153ef93e487978c5ce4bea6b4c1f006639b3915dad911cc60024da7738045766b0d0923d6f1c44c8deeb893d43c9ac618e5e74b37767d2b8074b5b5ab2978b5357ee73785c042edb177a405e19e6a2bfc1fc0830534cac0286372def17c71c2c1e17c1ae3ad792321419d8b2f61eb653dad4756161a6e8e325fb896af93fb9288928a8aa5a66f7eb2737716c7c59353bfe1db764bdec4ddf6719a8569d0ded2741595500fd8d82e1435556b067ec99bce2cc15a3992ed9351579558feb7be1d8f63ee06f43db16518a1b21447356b2884021d1c2185d8d3498e759c9ec38e23f5fbeef699e46fc69a746abff3a01e0f8e1bdda9f642b01c8cf908cf38a4fac4a6a1376227647a55285d13d1687a21f3e4bfb90f8f8ddabf1454f52c1b9d8501494332936a87c341533609d2ac4a6cef81b1573493bb7a7fbc6836f1647470bc36804d66a38735dfca6dca1e93e11f5699cf9287237184e60db302c5e2d5f6adb60567bdf9ae68286f235e216d16e9bc3a374e3fc35e44d8433d9d00461cd461369fd6bdb74e9c2565fcd6311f72237fec765c91cb7239ff59808a63891a55050f60b5c4a7c110a52f36e9e0b7615c0d719473a436515bde23a2a431a36e94c73f7431a920945203da92ec1f6d77a7bf8a2fcb105c9f1aca72df707bdb5e32e067f0c42e5931010da9643443ce9233ff145196963c7225f5b779f25b16facea62919de8323b0ae301b2afa7862a7e63a75e83e5a52d32ace0fb638c98c80509b82addaf640bb525fb4552bc825137e7344ce4f64f87cb022e550ecc51c06fa749c64680e5c050b5037ad25f3bda3fb30403f64aff58198195f59c9897dc83ac3dc0983439a9671a63b0f10d2faf09428933123975c531ac433fe64eaaf16ee5a1482e167d6102717a5112151db5d059cc45207baa253c1295c3b910a6d67e5dfdebd72ae326a9269c4fd57d160fb47625af0e63e774f0c88e6597477f77fe7eed3827c45bfd59c15eaaf1a0161af77f0df8300c4802b63bdddba12544700391956cdfeda4209fba19ad2342eb1bbdf326ee497f55a17af5f8d5f491477b5aba28ddee29e27062eb008d4ac0e23ecfc2d6e0bb781fe7abf3ba978d8be7d55c815c8eb0c6dc833777289597450fde10eb3604ccd4f4871d39981b51b9132534f103f26cc005a6851e2030731c841fd3b108c70bbe57f5e1e7f89e9b85893ee3a2bf75240f7c230bc60a6c1cfa4ecbfee20431adbad6bb3feb3c27a8c5df23027c08ce4403dbe4772f15065fc369938fb2d996137e8252e461732f69cb87e36bba26029eb4d7999cb48ac3563fff8154cbe4e2dd81a75b3561ba75634b7fb210a20cc0f63ad0193b41680af416551640f7b4361a9aa2695b187d3cae5be2c6ddc1fdd3aab33a9967a4b41dfe95317db91dfaa5e61eebd9b6d9726ae51fcdb3f67d6ba91bd4f050272d43039220b6a2cd3c06801926f00cbeb6469fa30f658275aa918b6ce81e819768c6cf68fb2529d65d776d2acfb17b2b59564209ff5fa0062b3cba6b499fa96e173212a8564bf4c552f528ab66818bdc7a31e82969e4ce6cc66461931e4c08c3041357662622223d160d7d6d42562746e03ae0b86156215a042d9b65390910b0188b60944845c9b1e00f42b24cf864944efde6af4b69d1278b8d6b387c7a3b5a9cedf091a0e359f2444f671d45f24b7feefe54798be4ce0698e10e209880148747caf719ab525e4212983956a2ecfeab3094d8d62ca7f695d4a93b7d530edcf49614a139328e05acf9e2d65573d928afc668dd8ce287a53f67cf343dec98b640f931abe5dbcd4ea77b4ed488f9c32aa05ba65804164ecc69ebe0e28f0967697854c657b0f121cd8ebcd447f28d0646318de71b6fd7c6c5ec24bf2dbcd9a93fbb5cf90dcc57f37b822b5e174c690ef301ad4d1ad050a5435bf74269f67fa334013a9f33134908c51b842bb000a62ec135e99622b5713d8ed8b502e184d1cf6b856f7518bf841cb117ddd1afe238172b2d13bbf397922f8bc809ca383f77cf851a32fdb992eb8d2fc53ad6c39c8d0a61618bd2dfb808877ed51389f5c43782cc4ebfa0dc7d3908bb2f0853e51aad64f75ddd5137be392846e619c29926605a955732ff4f7c61788dc08ce8898b205b937894c84cdce96252a3f174c21f5e0d170d39962ae93a06d905bb1196022030c52521860163bf4e9c490d8fc6466bda20d7519fdac0d9b63627758d4aec60a18e8a76cbcc08002282eebaccc181207a5d990f052ffab7e66719f712ebd0a3f6333dd38ead4aa1b3d0b0cd4f840c5c4867351efb226bc3fa682856df6a6b0480ab6632d0ae41fcb7759082b2082495bce9e6a6805697086ae59e3fa0b3bc8853db983c1a66cbe78debb5f6b01041a47c68507b2a4fc5d50e4d648abef6d7ca9a099a94e1d9eebcf827b2de2867bef89ab69ac7af66c72aee9b246da7fd2dd062d27bf5b807ffa664f5327f98d9b802e52ea30c0b65013b3412adfad16b4ebfa1961a989e37a65826da7931914c9bb9ccf16a408e1475fc3b7db8eac1372acab1bd6554afbbe7e28c344eb03e296833ef8c0ef791d8835c978ca839254e164fd4c80f13372c89d062a01b90875b88ca3142a2facd4e8fa93fc6ec5be6008d4e1458f3418538deeb1ab14a069f293245255bd683e296e9fa988ff1deaf19c94ccdbdf8acd78cc1198da8de5c5ff37a7770a2e3b30c2401811b086f2c53b2beff1e0f9ea195581a8266fa5cda1eeee313226196829aa556827e3a39ef0fbe805faf15867c8b2a36de021ac7367f785eb75dd978ad5537e54b249e2aab6f1b28a066835003acfcfa83a42cc9c1c3f0600c6f9e711998524799d9e6b02906bdbc1d33683fa21ebe48d535ef1266c8d5662ebbe860a1892d601c9ebf41e8f7191375ab597ef57c8d8b100e8612517876151ab4158cca2e361f34211e26d17694a76f7c480f17f3b7995152d1965d800cde2e0ea38a0045e0e9953896cd605e11472a7f15afa00224133f95ab3bc0dc3b22ed017d7d4423ca98e6b7b22230185ec550b3cb9f18ea53758c3d02003031a4b01a17e45a3989cd1f5d145386364d3690e4c11c75c4e5c9780ec2a82cdc71a65b022163b7190f2dce3ca8c9f13d4720defde7ba38c42f92baf84c1f04906ced3bb6e8c47b4fe86e4f27cb64c6b77ed3475200759e81311500ffb55d220a92bfdebc8971c9c1f2075e7138c58515267e5325597191bf4df52e78d03083c3f1ee41aefbcffa2ca2d4d4f436bb6505692ba4e8330166c71f8e50a882422595edaca1202e86cc0b656d995fbbca6db51334cc2dec4b232a46d60752e542982bb0a99f5288b234d038a37a46dcf31bfb36ba8d5cf67a54c8801e077f583ed07fc343898570907f4a77be095c16e96f4498a0201b5989a908581d7033e2c8779507273227d7fd3e7a6c8a5a8c9ac63c09a5c85fa61ca5df062e9be057fb32bfda0ffe9e8324d70681a6238f019bbc30f62f8a467ee7531ee65cf360ac1744edd91dbc33b0205d713c19b37530e8094d5a75723b86fbe22db0793ebe4f844822ac3429eb91dceb46f3f1e4bff34dd5ca6bdcdff6706d983b41a4795fc053dcbae40161b419ebf101b02d470c6c071d2f5df0638eb176e2db50e1f63cb938464f14521c97770419fc9668458c4b437663a07674680b1b600f0048b25fd6f84aa8fb8ffdb2cb1387fc0d3f8f818963fd8684daaef22ec3a7a750ea7d20d5f2571ad51fe97cff22e8d4d923eb7c3a69a21aa02a61d44f8c0a7464ca9e4aef039931d0fb00fb48fd453ed2c5b9b63914705e9b00be5678052a38ea8b04f4c91d9a2ef2cf2ede3f90195b5be4ecb4c0ba175b7bd25d23e88efec7549356fac83c5dc8c19de8228f32b93f8d6ba9593df3aa86dca1db52c05387165595c3506275ddda6a3970108db8f1344f30231db9d684817cac1fb483c1c480625ad574a8432135e40b7d95a4bc2c959a95d1401d9efea72028a117350ade2d4ca54f075606203732369c4aaaabc5d11be52f5de4b2961e852e6add187c8321c0889f6f3afa7968df18a487fa795cf27d120c33c518e2ba1079052edacd5bef5fc76de5874bdf18118066d05ed44bedd7e8b48d6334196d3cc5c9dd9e2c70c89d6cf06a4b94006ea62613cc883182bcf0794b44c0cad29259d9885c61bda972ca2bbd99f63935efe5b548ff815598a81bd8fe3723f6c103ffa141ef59775c4ca662c3aa35f8da8bb9c99d6aa029f6036c49d9cbfae89604d7ce6ab90f192b5dc0c058ed6f4a9cb2a5f30f68e97783be620f32dbc589b606790bb12987a49d25bb53bab2b4b625490afaac7afedbd987404037f9b1bac1f4be5029ca7a4f818d10cd62bca010346860d44432c7a30f950c2fa06a436a6d2c0fe226736efce7b0cd01dab10246f14ed5c70b50bbfc7750cbd3b1e255c87665124d947c412741898b257ca93ebd4b0ce1fb4d009d8cfe83117f7c82990af87821dd50f4589412b262bb14bd39bb1ade9b133147c5f9eeb1f73f5916f9b3d7ccb4f8cee6d4942792e66cea661b32eb9029b361d5ba2fcf3b1a6e3b44be78f8d5d91724402772ccce97373e8fcf9a28edb97843490aec2488725fad4aa2b151dc97a48fc3fc42cf1a4b514ca5ef4d96d1878e37ff00787f1800203317b027a1fa575754347e815ec835e9b6d10acc476c68ce299001faf39ef1549f31f842458458310beb933e20e627c64f5977615eac54ae90089e0d65f0025631acb63e1bb1ea66566dd1b6846f35f24ad9cae2f13a747105bcf90b301529725430ebc04efc77b3234fd1de4f172d3013fdc9f39d14d13a95c763e74f8b3fe0fe6f35d41088ba1ae8ffbeccb91b0f9ddaedbbcb811f317f80f4eece4c329edeee3dc867ae432a98e117399697aa33b967ff96debf791839a2dd5364205b24e6075cd5f0d0901d4c4d40dc8669dac6b99911b7adba692c5ee9db7e3435723ffd75b56322527e23a76674d1d9c248559753cd574d1d278ad4db5830960e8f5c84f4e46ba80ea65072c74bc10fe67ee16bddcb024cb59def5e2096ddd8293780d9f47ccf6547cc82676a020988b96d5c01118b54372af34ec430bfe81106a879848ee73d9495b494157b16cc6def6e991a67e5e6c1df5aabcbedad9bfd3d6548ca19c4652eb7ed1d080b6b2b4c395c906f96948a2e154573eb990268d21cf8ee79621cec954e624186ad0de84103e2802554dd68f221a191c7c2a3f512c222f62e4cc7f42b78ab31d17424ec9e052fe44d150fbf50bb0288a7b2cb9dd5cdcd44372f6fcc283d964d1c6ba51197a02605d30b8a89806a0d3f634d24d4b4d7cbaa7b127981442e1bd73e888d10d59e2edd62376b73b76aa347e7e0728a539fd2d9b0f9146a15f3ae626ff319d35fbebad4a696931e7b9f546f4fe25954b9f91f67c74f2cef46e952e60690f0cdf90cd2ece5386d29b4065cee9acb7dac9c182a2427ce5e67e419e9f3b03d8e7c9c816946dfb44adde46c2f46404b8e2ccfda077764d3afc537ab16703d7e47ade850b90a3355a466fa400f75e469de755ca241425ff314a1c662f77946b5f869680711bf2784466181be3c2f6527dc21b59b2d6d651af4c56653a9ed65bacfbd3256bbe6ee6d0933e18132e1d2812c9b75e6d483941328c018e89c359ee7545e6ddbe8c0133eb06b1e7de3760f3f186fc73d71941fe098cec14f572408b0bd9b57356b844c938c594e9c8b649f71a34728d174f3ee09e81eae608fe438bef8fec4c74aa946ba501b8962d36b7f3d73971f29fe8282d5c2091ffe13ed04433dd0dd902876f8d6b210109469c7a2dd6b80eb6940db46bd0a99da1f6433e62002a9a00006d490e4c645e2b543d33cedf834213f3d3c1d2540b98f6f8b0449f774c2d2305d4bcbf5949c87880da8de4e6b95d91161166154a255563a3736e542ae38986d99e62a9f16081ddb8ce7081a8c7c63cd79ec3a13e1fccb7a8175147a579b788484d369f170d358ecf7818110e7d04e39b0f5e5f7d426e28acd912a6b565e037c002ef11fb070bd64266433a32b1b3c64d931cd1cdc1e85ab2ad4fddabe4b0ed65b6410e3acc54a685c00d0ca2e3a7d7411055f9156196ea4454142d5ab92b3ebf6dadb608967850a18c1148a2871ec05a5fbd4d0d760370b11514edb849a852a2f6c90926e15a7bddfaaefac5e9a224f0a8902257098fbe209efdf2b3727be405aa179c4339e47fb1bf64adc5fae4c9df4c51e8984d12246d12aa86857e889fa5b67303d687c34865e0785c209d2a0fe643059346711ae5a56738a96b2cd82cf5441f24a6a3c6e1e9a6051ee5f3b73e670197eb2e56990f181ea7fb152bb9266488928c0aea886ff981d6981dfaf8f74d8c79b6ee536a59ca1350ac28f9d2236a3041920e1617c79831abc5c4afefa2239246998130492282db2c2cf86126d5951f1e7730e76efa76e5b453a831a8878af57ac4f551f20faf64d4f2897bf6d03ee83b85b2ba43c08d6be68d2d973f0e03cbdb59e3adf81bde1c5936108bd057f8598343fa8a05fb852925ca4cc16409fa7451a04a29fcdb1036f31993f7f4f56edde09a2678ee74a9771bfec21d469356c93bdfe39a323ada34beb942e5bb9419a56ffd1bd2e8965d0a98258799d073e67834496172ba05080fc350dc274df9651c1284e9120bd6660586ef51c30e4e9b837a5ea2138c2783403fefeed092644f10e9eb2a503830192b51f511031eb9275a46fd66e1597c1b7be3be4660ee35a26055b28b0514451ae92c0de21c4ccff11f7342f37835cc1b7433574a7eed2f87b576d88fe9f98969aeb3e7eb921039ea926dada4030fd436a5fcddd535ff01af8427883c99c2f53a5945f95f4413ea0a6061f452e7316a03d544763eecdfad0634d537e930a6c9943eccb93e0a9e52dcb105a27bf31caf2ff2e30e43e60155ee74053e8740b04e8200922c3f4c27e2b9f9309df1e0aaf1c31904920cac52fd6dae025cc81d1715961085932f289ebb77c7599e69923fd8bc8330010f0a56bfe9b96bada5ada5a9dd3bcaf87a09ca26081cae6e969efb68fa52dc8b86999a1b9f24d99ecd882519e9e41f219e69ee67c01cd28dc2d5a1640621bdc0578c28569ecbdef0e8c5e7deb1aa218205e0835ff7faff0f94d6486a3f2cd2fcc166894c39eb91726c7ad22f9ffbd60d42231dfea0dc519bf2e10ae6ff6f64817b96c6c5de114bd29452c39cf6ba597c984ada4235bb695b24907a04cd5f826982d559419daac04434baacb41b51780d992246c8b3895437872538bb1c0fffc84bcd19b03474a2248f7cc4e1fcc3146bbe7e4298f281b0664cb3f4c2986575339537473f68d6acc9deee1ffd242a8fe79e364bdc6dd835163c13e7acc3a1bb6af92fcb94c3824eead1dca867c9025b479a475838ac2bd346a2ea9bdb7ef7ecf847073a778bad3303d1a0f2905a93dac961ea5fcb75e2d1ba05ecb8cc601ae6ce87b2afaeae47977afca729f752ec03be41dff395ad5eb4a5638195624b24914bf78be95ad83e4b79518a01d0ae9e2acaa283e60c32d9b2e899e8a66a781a42483d94873ba3a2e20af2e3d57aeea3cdc23a2f4fd8d5fbbd6ae328e344168d85ad0c16efaf09ab9512bc0741cdfc276face1d91d6f60e7fdad7539c7899c252c258279029a0575ac7a16de10bc9cd48c8f2c9b4d82faac63fbf2ddc703a0409596a58b7e57a1912e7bd37ebdb5b36b624ed1285398e2193affe266945fddcdc11ff5dcf6b020e9032a4c46b95fcdda162d8110adab75a7d6c4bb8a6776cb906124a2fd0d3cb6023751275cc4d09cb1a7096b915c8c0d9a60bb9a344568b8c9d4772ef89503e082d0c4ffa5cfd2595e725af95fef12e937f65e79a869c27da7a9b081f9b1163f1d3fb77897873a0cc6eab11739c645c67e43a046bc0531f80b9583f020ba3db876249c6bc79727278038500cb17743cf8dfe650ce44036069301cfc6034fae819dff648303217a0e0ee146b945d210f00854e3663af3d9f279896870e0d3ad42c4309968e6cd08d34170a25a09d57ba4deb9f91e721ad62ec1a78ad913c87816098d55f9c2d9a0f9ecaa6c27a6c10ba0c7f91be67cd32db92a895affa27604216ed3101dc1f5dae04ae07f7bc0aa8084b89f8877bc2a648a5488f83ce17a75dc1997e05427a429a3022810e4f1425bef0be37a0264917085c7dd17bb984aecac5f202bff68d1db7a50b6f2703ffe77dca34b45644b40d69a374ee849996ed47f275f1af20c08c33f9e5ff8995faba39a44f9f9e7257c3385cd796a8dd06fbc680c51c0ab43d958546c91b396a863b9a2135354bf31180c7d5bcffded47b3780235784e553967f5d8acdd143ed60099d2d3ce53a3f9b58f4de68c25239232fbe52a6175e3ce0f5c5a7181b4c0d9082a753e016c23050c24984066c023eabd72f7ff8f2c4f47c478a4481ff13177b8f8cb0458ea035534b7739395810d9261fe30eb5edab6f0b159311194f5b5c226b20cb44340e4f38011aa7587e44c048d3ed6bbc1abcdb29272b51b420fb980c7a3026a0e4a3372ed35b1e44341424670b94055f4b210cd47d05f1cb61479d34b8771da1f0c286ae150423cddafad512e43729127275165347f92301d0b66cb7ed062d9a9bca3027d331c92f343c08bd84debd9b7f0bfbfb2d2d8134aaaefe310cc55be5555067de7e8ac10613eb901f8f81f57bdf13ac913e6c3bb15273214144ae00936d7ee54c9eb3880f6c84d100d17a63a4c5e5f6e9f909516bcd3d5aec195707fb03cf767b9d4f4784825874b07d301a6fa00d29dfbcf5d760ef75783a2a9f78f7445993685bcbcb5aae1c8e29eb39b94714498d8ed074cec2bf9fce9c6bfeff1c591a1e1fec2c7201b11f253c092a50477a0249b7c9f356f984b346cc8dac52c424e8db1c556cdffba7cdd5d59e46b9013fadebd5c2ed5af4ba838318ec771e5fd69a7decec1812fc4581df00ab340f5b108e9f8ffda18043ae4fc9db2a45cc48169db248afe49ab5575c95229fc1b9401e057a89d2e34147975684d39f13f08f312c82e95fd32d46279a51c918d0e598b25087725f82931f251e2cfef0195822a61d54667bcae811bc7f111ba4c3c6d21835f138c2c87ed5e95a90162945a641bc0b857739e483116b2c7df542258dc6d42f7b2a9b14b5c6be5ab263e90d4aa54c92808ee06e8a476fe2052e72e070aa928228fa47b1baabf36e14eb6e17ad4cd4b0dcfcea5cc2862830b00ce4d350ef007f1e4c7ed6bc38b046517d9358342024a2b030df914eeee22071b23df4988d470aec0ad722b3072be2ecb5b3a1ac171abfc20cff7282a87a332461c7fd00bc9803da2e7eb6a1dd67f88d23544f114aa68c569a20d691e7161e654113bb474c99a9639d09c1be161cfd1a257e7d53da3a697f5eda01de96dca81eed382f10ff6fef68e191152c4642d212012207e49f1a2965cc2a461daae9bcedf6140fb11d477a70d3be018eec7aa734521c26d127f0d600074ca03e1dc6fc3618a49fd2dbc908cb0818c45128061878a928829f234c0e6b476fa902b6b8f0479ec11b6555f122f8228a00178ef9a3f47c73bccec1a62bb136567cc5b68710263ebc74d3f9cf617af116b1491699c4e6506733334d41e479a3109b7f84feda1907bae4b110329f2ce17a747701a1dd951d7ccfda07fcbdea8865d06c30c5e0757c5c9dea6903b0e943bda942e6fe2b43f8efad6c953d55d51c1ffa18bcb3a20fe2e0463f8e82be26f7f87f386b3082ee592cdf1513492251cfa393111f57adf3ed80dc9491fa40d761d3bb125b3df09a65a7d81f090fc9f7f4b4866c82700905fdf15564ab58616a1bb70b31dbcb48875cce9e0ceaeba9da6a53dc90211e906185b2431794380fdbb731f85898716a601181f0c03ccad2d445405f54c0c19d3da4df3064f20f40870e82144c6dd1569dda915b0a015a03c54236bc990a4e65adf1393c842df5d87fa3f4c4b1de7121780e0d87c2b0844eaa90826072c77c675f8c0075d2d612ac4c95a8b4b605907a92820b1f65df3b0bcb50b510c481062943d392b8b304d9680a542fb48b85113e8d3171378281d9d6eaf40c0a832a8b0f2b8562354babcdd4499ab70fc5fc1f6376e15786ccc994b0a81dc0e5b89412be4e24d19c31e2c33a2946dfefa456e132373e82720cb11e10840c29731581f8862c1382ec4cbd891cd70e6aecd79ddefeee110cff00a2fb69fd89a1020e361063c4650c1395b9eb88fdc8e07f3d836f155befb55d7f32ce567a0c42b1c554d553eeca102ec1f0bbab95e3443869c0a9fd9b7e15031ffbebb33bcd37f7f6218857e1b5555a9e4ca533ca9f0053cc0963fd12c39e484fdc58fc2de87ef4b721c232a098f4cfda0becfaa378023422e102716f419113d7e7bcc2b9c6fe5c3fa0cb6bb6192f0ae1af9fb30409fba8e7ee168efe8eed8892d76faeb019ec55bba65345708e005ef8e2286b5614d59958d26f078ef118fc06fc96ea147c5574e7e01dc43e8307e63e3bbd72cdaf7e4336454d11464022cab0bce405ea450b5336d36f2b4cd66137ef58f67e99c6af82ddf6e100f38a4febf5ce61d533d6b70478c70960b0aeffe5b04fe0ee2c3f6d0a275ff92ce6ba2effcf2163db8cf437e2d3266398f4003d85213fcf18902b52bf82da54eeb41f0d92d4111ffbfb2c8f00c576809c547235a80289a89a2d48d82c8bd6aff845bce57a98e59b183c9af5d5ca818ce638954290d69a5598acd31d43fa354e8c74c4e2585e481622402baaf888c1a4f96752603c4115b44720ea6857900256348980509005185cf8434f8b0476f8ba241fba79af0ea5e150226bf7e59e757089f4e042ec2d239923ca49725945a199bd275122eb32ad009b7679b993a7d4fe87f7efd4d79191a163d57de8eae9a604b175a5d809607fe4e94a3814eaf1e9957d3af62aa0cc91bc419eb4632fa0a8957a2584b93bbfb93fc267de89ef55e82b7709f03a6d883a13f9b3f463f931011a00c0f64f79d7bb875460c7c8d64ea1747332a4bb5453ce6c7841317042fb54ad86d467fa0d7b93203ced582e82c56413a08afe4f11772aea579a16992850e3589fede8c06dab88767eec732c553c4bce8c99fdb787fb772ba522a38072f284ddfd65df3f9bc570702414e381810f5b2ab925ff6d2297a79debf21eca79e12cd3ecbd90ce98e34a8d8b99045bdbfb3c372b1523b295ab63c64d9d4ddf8d61f13413fde252e3c197d63a38a124117a366534b6bf6fd2ac4ab92391449b73c03249937407d30e2e4a4a5cc80d4508212000d91dd119dcb71d744be7ba9636d4a9f87a4faf1fb196553ae5d8b953b5925ffa6624387d35765fc08d1f011588053b2bbb10bd0552a2c7a2135c6b145095531163dc641d771867e83beb09232dc3dad0215c3e492869eb2c062b2168a1d43c7fa8c515336d33b7b302eb646b9c7e7b693959a35fb65f5d787805da5189efe35e5e14c9510582cc8ec80d48f5e02218621c4f7e3fc8569e67e5d852fe4d943896062713aba82c9b2a3e449ce80df99d6c524eff9a1ec882b023537de0a053363e3a338060f3a71327296449a383d8f312a464568cafd90d349b50dbbc90278b59fa9581a5c667dbbcf69b22b2a74ffc41cfff1fe0be5ed81c7f47c47ae309896801f89d1ab0568e1540cf75aefd684c34caa3a696943f78fc7f7114213bf1fdde92e34c208d9c31e2884ff1e179a1df824a3518398eeb40985542c595c273d00d8abf8b6323220eff53b541cdc1ca4d6a886ef04513c97e3699d3970674f0dbbb629dfcecc723c3efdb564277b3e1484e285b58ccb5607b51e36a09530325c01c1d495d248b7660f23db5c8d0460075058d9714e4098ced2a3ba48c29424f1de5a8eab9e7ae0541727f1cedcd5894ac0f1a304be77da1ccf9acd0f6315cc9263714fd89f512a5d2fecc4d886038f292259af20527f61e15060f5b9595429bcaaf821c6af9706980e8b64587dac8e82ce7896735f9922d965ab98ffe6ab67bc8c936c51809c3309b932e8b24c6dc05948c9f806b6c411ffd90f79bb3d37083286f310356bec176f9f239c8fe7abb23ff16a5547ef515b72e0faf622216375724a2a0dca9944902a85033f15fc8835f074c56e2ca4b73fcf3a6df7f9500eb730d3103032f8f33d5eae4d20c02053e3c8bd050936464e4bd5e1bf8f93579b481aa1e0bc07d22d6b3bef810aa3fe6687405175139b77dc325aba527e1456c72526abbc6eebe31cab50f86b29450e627bb2744f24f36b2b2d086c45f138e708701178337dda0707f0055bc1faba69ada985caf49f2d962b30020bfd6a73b337ed87759877a8cdeac29b54905a5248b6bc792b8fe4770dadef3484f2c4e6efb47e98897ff4092095bf40985479400be21f2d3373446bfa6db76042becb6c77dd212e9b9dc0e529825ef5441e424b09f417114720ee10a67ef737c043312694408230cdd91372c60a5c09b9a43fb9bf9b8fcd5c6c3f4356716358f437138674c3647522cd69b90ffaec06eeb8cabab8a3c58d356b6b0094b60f1de199197e1d58891d347f581b7b5576345885659d51347d01e212d75c6ac3d948a10f1efd9dc4002a388ef7a79572949f33d1b98f3ad9307b70ff31a49b733ad7f4821c35e1247481ce3a1950b32196640fb164c9094b3ee5f046b2feb1094517992dec8a7a7e247a7bc3852bb549880aafb7ca3cc0d482e499dd31ee3a1ec5c4ce58f12bed02111d56edad118c8be26b4aa3dc9b553bdfbc0dc790f011a8a6dab961e65c6d4c988118e594b9426d6a88b4c61bb0d7cfefac1f75302b1193d14ea48b8861c4cb42960a7c16ad5d7f01c688afddefba2fa4cabb98d92f5ab2b5eaff2e96528bd0dd32395fc8011fc358e92129ddda893b6b4c5b82d8501b8bc25702b1dfe5f6a2b56eecd3fc5c9738684a2b12fd5e9e4dfb59bf2aeee324497c9f6311e35e8f83aba6d5097375786be61afae73e65ceec5f166e7628e63d39c8c41f5d4b6cf3aa8dbd13dd9320c79179990edc1d69cf4a030084681b9fe2a0cae3de49240a2e1ab3e73471376cee913dada60db37a84911325503b719aba79e383c18a3d6d212db8f2c6dba049dfea6d6c2206d38a352927346110073723bcb08152cc230fbcea6ac197826d540d57400db8f8fa005ae6321f4da790a68fbb6b9522674fa9e4351b384c30b0ccede4e4462207c1fc6cd98f1853e2b2827d1e622395ae91db5477d8e536f734f2d9150e45bb625551ff39f86fe2952b09207a60e85aa91f869b45262207132d40c8af5d52ad1863d1bf75def3bd13db5ce61d047d9b1763b80555558035e71803248ab9dba2b4fe0b199709f1c8812f2e90139c4fa2711e417b1c88e0d6c36a23b1e9c26487acce61ef2bacd4074e69fac334f5b57198c65666ccdd4ee74d76c21f3d2d600bfddcaf116b4d16a6194e7c4916cecae43337ada7764aa8074ada3a67b9db19c41f1abc5c686af1ade9cd3a0881f9dbc29f40cedef4dd602dd2c36f981985426471728d5a48c05070436063bed9a99b436ee91e9b971af61f592cc5dc1575e575fc0e48cfff6805f0929f4902e333fcdd673acc3ca1c0a970ba5805f85af0e6fb859d81ea80f43f4b29a9831555f6fbe8c22a5cdeaac9731c666a8a8fe42e8986e8c8c504cbb6de3bd6ccb28420c834522efd0c8d380dc3c365cc94aa7b4b175601ff326d67d8b175b74c120e4af386369f0a6174afb541bcc18449167c0c56a63eb5b7f3bd82e7e1bc22d055f4b3f03bbc15c79c7bbdd3d4de6f9e0b8337630f122e1edb1fcb79c81231a0db09dcf51b4c764a60dce7068518ff3191e902b0e2b9e96aee4ffefaa3b7c19e84e5ad88ff870890cd2132d31545a20e16b7595994b1a043b99e03b283b0c47e674aa18277f0c279ce76219c4959e9b96459c0c679b72e0536e14ddd921e2c2aff4493a53d00de628e890c397dabfe7fb8c4542767b7a2d25f7e107e19c585769d637ce89d62059b132b22dadf9a27cd07fe776ab5c7c2792a8d1810dcdcab67ee45a69e5da15babe45e30be52654da3da4ab10e7c400544074d7673ddec38a058d699542bb55db3a960c9bf40d9d93b527fcd94a2d97b6c24012b59769a84ed38cdd5ce666438c2d47e3d1c0f6d536c15a9bfdd115fd6490ffffe1a21577b8dd64a5aabaa251f286f8550947262d268baf9c5616959920f0e4a2cb37269ec10770053b2c1805bad0a3854a8009598d877d7dbca8f8b49112738491472dd309d1a4e3f45f422f1c92a5a487bfef28d8746ce13e1a99e0b965419f06ad6fff844631ea40ff2937b0ef7f40f9d836a0f031f2c6ae6c9c4e7fcf686902f232869a22ab83c9ad47d87ea74fe48bce16af2a6a9793c5bb7908dfeae404034b4b5619985c00ea4a6986b6da1d02aa5e55fc4d35c221da04d8bbe5896267e9212775722aef1936b1be9b4ee7ae9cc623184791432e434dba241ee052afb030f2a4f8776893726fb2ca178a5bd66e9edf3291e1cb0e1c16a9fbd052124ad5cb4818cf69407e53eeada2c9b274ff56042be7b97099fd533258d3f3e53e53ba5500e1e419a0dc4ed22c5875c5a1cb8c520caec839fe60b7c6135ee633f63e86fcfcc39723bf1c8c27b0984e634ea61979d5c87f90668620506c174adc0d8fdaa708b560282702f2269eafb05ffef0f0306621dab618efcd4f81da12e5fadfeb6af0d2df8cc093de1ffedfc43bd07c42a2409899372751ab3013d47c5383729310e7ad73b97a8d99e04806d887ee97896aa5d22ea4dac3108762b9c883f51a0f6545a6dae0927ac18731229d5ac2c40b05f75518e18b273675f79d227257395238d2125ccad36c8247874e39015504bd36bf34b0b3be3e607781f720eb11cee5121d10e845a1e7cb9c4e025351c958f45c21c06d0c5456e23cad08ae29d263b2cba26d2bfe5cd887236e1e92d66896a3b2a684f381d272c96b098bd015e3d49d92048c13f5dca5e8d67b4e6ba6724fe921447465bb0a232a22a9115607905703ab20a116dd456786c4f3d7e2b3b914a55717ba522c542bf3881be0e7749848d68f7ab6b5602ab1f3292a3ad49a22d5f9d11bef933ca12adadafdb74bfa69e09bc53802f1219d07e07bd24b49e2db5032ad93f554990c57f9fa99605d3d763c33b1d1f0d4fe0dfa5a796b162598e2374fd655250de5978a4bfcad35b56faded005ecbdd2cb2991403436e332d414757998fbba352d79b1ba241eb472522b8c24f490480d991a71287a8fdb081159f434c789a429b30712c5b0efbd28bd2db71a9890f8342b316f7a45b2bf7f218268ce19276a3617de83dab0d24f47bceb6d9fe59c7ddc139c6637052ab85aeb54539c27a4c0cdb3227dac062bc3dac29598d0d877bd43bed0fdb848cbdce272e99a26c188a8352a16e5386d85208edb097eb78f54d4be51f5a66bae5c4d040b0002d806fbbae01c9856e5aa6279fc97529ba9308cdb00a6bb522348b1b076e7daa49f80f6efdcb143a244e3ad14f141a70e3fe0d20a060343e8aa537a898bc1d17e546be7d6bcf2171a196e9d0e4e1f8a3d428ee5a59fe451fb597f10d16d0da2538b4aca65372f6b3ec2101c264c8d7f915b7d43bf0f14cd2e6404687ae38ff84d04614069af59a5b55eecbbe8622db7e321c97663a6e1b64eaeecb6cbdf200bc018d6e0396ac455ee25ba44738dd48c3f1e10d017930808d790adb68da3d2376e04de6409c9f345c2d37f30ff91f60d8544be136548c23b88999768e99e76e0316b7cf7f8a3f66fcb37f02709ccd98ffb825784c013b1ce7c9b92a914b9330d84cd50608dc0a2fa203b39bacd6e4bc1f926e7f1caa427b25a5df38aa5aedfec689d7014e8c80b71eeafa085ffa1d2736859239a4508175cb234686ac357dbb2b0db94e69f5ca615bf678a1e9878e5f19470f15d71d340a067b5f785d5c709de1015e0c0db7161e7078d37b44d4c7966d41a48b681ad7b45ca82fb8e49f8f7b8565c2bbfd01321348de4cbe5ed448408fa2b5c0f930418b8ccb125268ec4e9800b44716c4340640ceb22ee64af034d6a129bfe72f24f933bbc864dc8a10bd678b635e1aab4541ed74cad1ced9207f793c30ef150299d904bf920a045c2ad3491b257a03d2910b1bf555acad9ac2e0468a7c604d3b95bb9889636d79a2c7013d8682b215d88ac22d1176620cfb1217079a0fd0b6f01c46fc020a4cbfb03508ffea749562b2eed6b203e47aa4245d8f777fc9bc7a61f43a67b02b4d2ce2d2166b9a20cf71627a976e2d36ff99b2c7e4332e4cb9dabce84fd20602e5cb348346e95cc014c52f63192d774f4f090c2c7f78d01743afd508b8a7293f725bb8a8c667ddb2f93ca4359aa23c61e2147bac5c6129d69a0e5ffddb483c43240c0835c240b7893abba254821427b558e6808d9574268f8dac2f1aa26570f4f26fd684a0c47b64d895d7a99e87669780adfa601168029ad66ef804e833d3419f6e84700848916a9acb3a105a80913026ba5b5f2b7b32cf6101fca12e7ca2853b7a587fc01e46879972120462e8eb033a9134567b7fdb8aeb07cdc969e743840ef7eec0a672382f4c58d3c60bb6bf07b01de779956da8c5d5c548a491174296fc3b0903d65527fb76ed2be1ef6daaea3e425528363b1d4c72b303d2ff1dd36f931e9d2575759db0b7de0b4139ca0cbd1b39193aef60fb17d8dc0602935dd951ba1c1a9a2bde0b280b389eacb25f5d788aeeaebbe3f135df70aaa31e5fa0797863d3a8358709027b13089b526b79b81ef438cf04468446247926efb4da08cc46628f0b927a2580c913cb3484154ac915ae6c9042958b73e657cb8eb0c43474117b454bbb5bf0acc44a54dce12879783e3f1477f7b77c029abfc12071e268431f6311ed4797254480715d37addbd670ca04d4f9be593d06b33cc8e91997acdbe0cd91a00c17c1abc568877a2627dbd812a840f868038d5c598ef266cadb4bcf5001652f5b84afd0307c0f714f43a1eaa9225c7f232ea7ee271a013ec4ff872de817a0bddb888774677019b86cd9ddad1d711fb6e1bc1bf0eab06477265351287cbf6541b5c0d4406de79fa9bebb890fc0724999a029116d9be2f1222ae121fb425e4510437b3fec4f3b17cbde0a703bc9d8a3a365670bbeae23fc10ae9933b1771d6b9a42f71b0fc8af2498b1060f68a2630e57a997736f01a0262d4a5c20055a5595c70e31c8ff19f12cfd0524f97c259977d7dc0aa8f7f291f28f23ab5472abdb0eeb58ec38609c0d90c8ba3e39609b45c27614a6bb297ea055daba8787247348426c3a5eb8cc2bc0bb2c00dde07b70a690f4b606f8d3590b32c36069c315326b6520487f82b190c901f7da3374e1365dbc0300f3dc068a82268ba74e06bc6d0d9f2aedf9abf7895ae43bbc331bdce609720f6555a59e5af92708959f3ef73dedbdeda1ec0c34ffcfd307ee8213bed0b469d6f94bef9f3e7bf4c8d2e7c8f99dbe5e20c6aaf6fb33ec8969aa85dcde48f81c3470df2485ca61162a98b9ce2cb1d289e6219a9984d8c2731d7d529c0863e8ec2fad55089bee570e1480abd1b985b373a43a4123bcb10fe8d0d2f96489d23006ae1df197590063782bfdcd0e01141c29d39e85c863f94cfd14b2903cb2356b66d79b2ace70e7a14746c7cb1b6c222e9b47aa663e917c12007fc530fc098a364e45617126ec85ed0ab8f715b2c7d3ef7fced8f228c7ce4b262e1623f0f61ac531e22b4ec173cdb307cb600bc48abaa916a71b25d25d954f3c5255fdaa54250a7f38f5b67dd6c9c31732bfeb81195d7af41000285e096b33cb0f0e2bce201d3900988b119bf57df2dbf8943179cfc479f69beab5c48a18b427a3204c590d514c5a9ddeefa566102145b5111a0c67115170e1b393ae376fc8572f095d83512cfd393af5cb4c063c65726e1d13f898e271ff92aaf4c92c6cfdf76ecb75f66afc3b2f26c1189813ede4665709f54c843481e39a30ac8d2e7247a03000a43b4cabaf2fda2b4241dd5caf3ea6bdeac9f235a18b6888bd4fe881e4eb2b1e5c3d7220d9e1dc33295294a3a2a9322fb240456d4177b0797258826862e1a8dff8a16cf81a83a019b2e29aaadbd7e849b5764e746211c881529403106705ca4154647f8dc974319dfce44d6ca69b4b84f830ca48c0bbc8bd76c9fb0e6d06209e7e857172da42ec3012c0c2647c42fcd13d900894695fffd319180c66cc4a1e029e8a7eb45390a8b3346440137dab4af5564cd7df3cd972e47f815cba4e4f6c1d1c77fca1fc38cc44b42be5da7dbfcb49267e3d500216fd50d0f78b4de1818b8ba9a7c5cf4e04734d531220886112c0b30147312c8c67d76097400b1d5c1a23c72c2757c0163a15c985ba65a51cc33d7e981e15cadab54f0724439ae1260049f3794091adda9ac7149137f764c9c5a90fb5fe8585e6ba34b53010a8859984a5175515163bde7b3d6984ed985ade527edf77892fcf797251c4a8be7fbaae49d1d3cb7bdc752d25f2a2db3cb3a2be7e58ef9b821c386167f364ea1d8d9070fb5e9492bb83095b923f448ca0617a71de5fe082f2a9819ab9ed7652c6cdebeacccb63a372300566c70d2b64fe88848cf112f70395477738c10bfa174280180e5dcc644d32376d4123c16cad4dcc14f77260961098d45d7440e75691ce85cce5cd7d8c73af4650e4db3c86cd9d75ea2305783e0865e0d3d4492ed20baa1e8566ed1ad05107ac48efeda3df4039c15a85556c5d3a5dd117807da50c81465aebc6d2769fbd81dce239bfc4829461b3cefe9f397a0de4c43487081c9037c6aa82a2cdc5d437cfb304113a5ec97aad85a10e670409c1e717c6ead7eac949ac65a1b77cb80a26b2673f7abc7faf0ff22fa80dc3704cd1fac60e96130bdbd8589f78e073067b44922f71fe063ed3eea36ce81378fa5ed5283db681cfbf8d00cbba92f914a7afedc8dcb85778356c545f2a59db9d24c52e48c8627a143b8aeb6e3104915790ae0b27bc245facdf39681c71162c7c1d7bf04dab78d512df4820142c2479a2cdcdbcecf86ccb8d9db6d574be6caab680ac4a8e0b56ba22e5a074a34493bee68f225bc18b58584b1af2f08635f241372d1cf432cb2830aaf67d6c24bb0a58ed9445944b6451ae783da121f76c4404c40b7a9dbfd695a9117a6f9e4b8be58b8fa3a372870b07f1cb81af1954c86849be500fa53953b5e8b14c81d298a9c9b2858cff1da9fb5fc4d8484124421a83e5b95ce4532947f08fced0c2e860fdba178982dec58e485699786ff878448dba1b52c55dfcb51966dc930e6c0c0bf05a0b9b3b195b4b264ab073353919c4fac03209e0a287d10c5a0e509e4a057328e46a97ef6cfb56a703b803b220a9551e04ca5772d398c04c2a05acc50bfc0207d4ce72f23cd8f8fdf16a780752430808be1a123a78bf43705969ea35e5c636b146107ec071fee599f3fbd611b1e66291860ab7ddceec90d8e034ecd3500a0e36d5c3f39a1336bd8cc0a9aaa1d68afaaa523d2ba89cd071a12d53e7592e850cf1236ea7ab7d9f349a9000d934e86c5505882e71a029f10f89ad13d42124fc02698a534c29d751fa05e5105e7d755a37c0c4144c5d4be17339ea72311fd2c31cb7b1877bb91cded8c0ba2deff8b638ebf27ed6051f3c0d6dd1d207c7fc58c501b2289129cfeccb19b35fd38243f0d579a67294bc174325ebef4340bbd4fe3ad4f853bed215369ec1a456222609c208d2659ca7e1c28ced620e64cd5500ad162392f2c14834ba5ad6844b730a13af5bafbdce16de8465221773852b8f4a6719fc6e55f15a3f2a876df8f3b7b27ce7f6a3da15ec105e922ef5bc650d4abe97bc9fc7dbce2db78629e3532fef4fb22c6035c66abc38951fd59e6ed43f97830df9a815eeeecc6ba1f6e412b65ffc3e3bb0b9a056a3491ec93f2dcd7bb290bca0573f3c1aed546a408f2e48b769f45f16c13d2b5084e2fce230e34436ee012d027a198db6e15d1f01b59500b3dd20177c75bfdad4902fe37d757ac24ddd9a8748f87b44f038aa220adfa3630922264fad1c5ec89807609d5aeba36c7eac6c3e22eeea28023e718293a75438703a5615ae84384cb80c02b16b44faae147a697ec44594ede932074a244392716c149b257899894df12e6e392eea6dc299adc893ac8da7e388d6933da896ca5a1665c6f0c855b4c0e1d3c26887f1c89b0ea3b64a316b114529fc0c592120312d5fd21af4d568c31cad31d7cf191e02cf63ec9479daa44324fc0b382a09ccdb59ef12e090561847fe730b28ed6be5f4d62f10a101b357fcf85ae5b40214deadc3be29a9e336067b8ae727d2fa2510acc8a7131ed8b22730bdbf46f7ab4f2b6d77a23b43d8ff49fd0e3de2334b206d0e22385ff73c9392e27170103d50abbbdb8169faa870835e8fb42ca955427bb9fa5d9d17379e4ba0046681f21522df0391caaef10dc2284882dbe072f8c92f111d6964273ef75c616b2ac2eeb01ac2d2173855f6231322872eb7ffb7b711c145f56518946b03933945a7d57372786645021b973996807e4c4c8a6f327c9058ba77ca07a785e63b11782126a9fb804613752e628acad8d0c5a9e712b65470a9cec11936e7b4041e0897d3fffd22901b9b7ec1ab005c4baa8d8e4a9a19a5ec62e75180491224e482fefc288bcc4a7caecffdfd7681b5a21207b5110f221e798fb2d2d06cd2d8a14417842787afbc8052d88ad651943ec2487fd0ef1c773f59d29a96496cfb0dd85bb37d8e55055c9307520fb60e12c15630207db71ccc385fe5e1b60a1118a434669aaa9c5a51d2c00b3849218445bd1846c59fe563b299ee8f2c0ca1543fe17bd586bde12c994e15d3e1dcec13344b0ebf759e01e5891ecb65e23e7f8da74ea157afd0895144aab7cee9ae7739ef60991133f8f28de6d03308166a1165da7495f7a5e0bef86c1acb99abff9ec385463a8497a9e2dd5c3f2d985ce3a8ef4ccf8eac4fb64e0d9738cd313f0af356c86eac98471fdeb6b0ccadeb5002ff6d813311cd226b51b1cba18a06069c9e061fdb1d09532c10c4a498e337d71212a13b5b80bd52d4399807c444bda9c3807a16af2b8ef7e327296c5d3d076944ca71bf1f19e383db93f5c871cff07e7e6530f242433b36dc7b631d674b6c895121e5159757575e95ed5b0221caddded77c17f23e14dba00db8720dcf0464903a7427e50b25e5573e23ed2795bd139ce8c3aafc66e3e8187606ef8f2e0aaef22f4e1f21bd1008335613c7cd2430a0ae3e65990715b31259891a4afd6f1a53dbe7794c7ea12363b9d30b02755bfb5bed432c212328e361f16d83d1e9c43568c49a2758da62e614618d1978241d9b849b7e3ccc9c12f2f50a94e26dff166f41072298918d038192a2b5065ff80dde6c017011b9a0183f7c7df697fa5a75a27b353a25966ba5c5b37d70a7031f34474d2eca5a5d4cf32cb28065338b6a433ff94e7abd5ba1d9b889cf82071a027d2054b33bb4e1953129c93fb7ac26fddcabf19d501a28b27c995a870aa7e7fab7cd4db46a26400ce65fc66b739897e630e3de38eb3f70cda469fbdc878ce54d022722350eed8cc1f0f4c058ed614204b3e1ea4a9624f7148fa587600a88422cbb98e88bf3ad7b184e56200ac2f5755e2b2e569193eb5155e0da4fa61c9eb6573bca58894db382604e538dcaaa2621e988807f2b58c4bcffd364a8277c78b12d6000588feaac987c61046deb1050f46ef4198fad2fc333a207b95649c08254187e46b21eaaf7edb2ad9626689876b1065cc457a912cd7825117a241c78a648451360ac512db0b1b08d654e986f60e57ddfb27dbaf044eb9c91d25569992527888c0f33ee667d92169a3391b6a920d3fbc5a605cc8f490f0d2649e51725f4338839270a362b959a98ccfe08edd072d43e969afb06d1e7e40fb062e0d150d9bf3613b0f76bc4d0c0464750945353bd9f2385f0f281b3c4f90433d612abcd454e79ab1c7d1a1cf8af70e5f7f6c29d7a4e9a55748ea9d54a6bea44a73fd82ea3b472c9c67db3aba349674be3edc598ac91f1058784e28f473a2ef01f37de06f986ff042be785be89b2ed86b93a16a9ee679ecbdd98625bcdbbc2390c31b6b116366c43e568beae0bb2e2ba55cddb4a2a227af5df04335fb7eada6fb14a4febef76bb7f8b6a371021ee4cda81a3c20a60899ac884a619be2c9808d439927681d99652b08529304f086f126a0c1f8bf923afd36b414174043ddcda23ab4fd0b271002481704996ce1548038989c213a3185efb624cc6bf9124ed5086ceb07015fd41aa220f72557cdd3f38e70b088803841da9650ba51fcbfc92b5069d43e9f0df23776bbba8eaa4f9d95829e1b0d44572e35c35023c9b2f79f5ba7b97158bf18ed734c1136a24474a5130ded6a0bfc04e7bc3142693eca8a45e1fbb96e6234363e59d0c5447d303eb8f91d2f536baab9791abe253aa0024326802015aae97128f4d56022417d9c04503d0a1e0a3c9e0ee4d2348353aaf8998100991920ee3282e022f343b9339df355aa6fd6278b5f487b9c82348b7cee95416d03120d70648989afea714c87850c161d633586edab15fb2892fc31b6b8d4f6b5695a2bffc68e6ea871521a986c2c003c82afb996085374f9bb16dda9ccb5621ad3cfebaa06c0b6e472a1d0a6ef6de4bdc59adec544a914d5bd752a539ade5d7a5d7142deef97a970800de34815edb3d3e6ec59dbbf39655d594d6252ef5c670c223f0cd8189b8e55f42231981a238bb5b1490b87e6a196ec5435d2e8b9d7584460b6d162c741f0ab8d2684670c043cffe2766181c954539b13c8fac6b643a43a200f5364f7a118b444ccbbba95c795ee73afc036d18714cce49095e70dc658b27fac1b35466866e9ad029c2249004e9c0f05070a2e7d156c5c6ac327f1d4cbf394cc59b2c2e7e6e80407514465ecf37f2b2fefd9e13bf702b8d30cb7d9371cc45cd602b2335a7158fd7ab1ce47f1139ab7860f8e211c38e23d775c716cf71f90c7d712a37b35dca0fe10376e07f5fb67ff8d25621b16d6b5da04cb2c9f8c700979661eb72c99b764c999145938ae4e92db7080b57c5d02c2cca326cdf4a0b88fc02db878e590519b53c65b37b8d3cf9afb9ee60ba30dcd423ee074743c81e0918b6592f242f4dbd8357962885382c1e78d4e29087ac110b5ff5aab884eac01886ba281312e02d1c881bca73ba2314dfd84cdb33f8f4848a91770e98737e8a494fb19bee7963c78c857ab6fa563fc4eae7bbb986b0ec55a78dc69f7b10ff667adaefdd8ec30a822746519c8ddc121870ed35ec2836527498913c77b87ef772d526af566bb035e2106ec3f4dee4a3e2d0f288369b22e337e39491c30a33a83224cee9c78a620acd0caf4f6083d41250113f1f67091e4fce932bd547e4a815b92c6b1e3e189ccb63e73a7d22b6f728ccf2424e1146d98fc66d2df515e639b3bab3d1db258b24cf3bcc960f2b1f3f9d714870234aaef8ec30fc6c17c16c65d768d3c32936e681f926e2f651e8a48ff2ba22f2b17d4ab3f8aa34f6d517330c95122bf8f2804aca8014a3e77806055e1dce2d50164dc6d3075f842e90b2f92788dabc57290f190d4b44b26ad20913f9394d40bd1ee642eceee92d9cf6f30e6e88f478afee550058d4418fbea8d05e240c98dc230439121525d3d1e4159430c8f806a2c5e40ef9abd8205f270cef9e0132c0229660777f965e4f2f7ab5f2328e6d345507f92469f29cec30b105c169fa91c3ae9f0cfecbca0314abce794c31df7b39febf5882ae932430455b32e1ccb39a9f7b0aec396cdeb2c40f7df2a8c034736d72d3f00911ebcd51c3aab82e9f78f7e1c3b038db8bc2eaca226d46c4e2c61668cf4971352ccd5037cb1a97b387f76ddc35ee16384f6d8b2901d618e142e613537bf4cf643fffd6ae547deb390ce81917170c89624ad47286c3abb57d4fa7ce4536af916c64639393349114dafcefd2cc4ae1aa2d57f1f5389cea1ac4fdc03bb472f67c6b2ab752665aa764106446aeecb0b983d6e6f845981c3004e5b01373920631fb9633c6f7d8705037f926f7c3cae7dc27d1b8617e9ef47655431ad63e82dbdd0e49e77f04827ab611f0dbe5a34cebc9147d691fb73ba0ab2c523ee12240c16b4e05342381943338e6160d67bec502ddb7c4e21d1694faf350a74385cbe37ba0d3577922330cbf07d3ce341d4c7a2f2cb81a4c2aad575a56c114a6985b1527b33e945414d6f96290a8f8c608fdd014953e4205b974790a36291251e0e2147184749aaf2944dba2efec9742726ed0337bec7d1226f73dd9a558ee6be3b76cd981a96ca2593d1577752c1863d905175a6131a87a5adcc2ad0d4290d0eae76bfce72327c384f42cb5d4801f4a6421b557ecdfb67d2cbdfc7cc0b56d60d9e7f750a7cc463c3da4bc36407fa6e3dfea60b042827ba5128ec072ac1240a6daa44a4d6bdca9d0cc9d7bec7bc46f3ba147dddb446c198038d1338c0ba6bf3d32a9c3760c0463f800a96b2d0a7e7cceed1b048c991b14346ddc3905ea57b68823a96e7d3e35f59fc71c76fdd01ea300590be80a43e5f7cf0c5d1069ac5457dbe1e0c5073b9c442499e975650ffe3dcdd20d6d5dead8de47d8ff11bc2f5527ef9504c922feecc5e1af16a01a8503bf381104966cbde51ef6fdc617b1799ba0a099b587710310e2fbc83c2083d92c453ca88af96eb5205063a73d0020f1d5fa105c8ec913a7efa3013f946dcea9ec6b3bbd8b7b9964d3c3429c972048658ad7a12f2388cfb78011bf94d2c80a318a5dce267f650064e9e30ee87a3d830d5ee27560b2ba2e29715cc7cfa06ce1eaa1c9e1dc31fd9e0968f1ea9d7c6843108e30d7d6db77f4773c94d9ef44794523b3e5972a606cafcb4624526399d9ca0534fea1b1b55f251936cb206556561db2dfb811e790ba4521fc0004b44eed09e67aa91c6c7a22182ef7972932376f90e978dc029ef65732bab4260c9c33aeaaa1bac1a92c1e4fac25791aea9204fd46a4ea307fbeabb5bf0217c2844452d143a767b0cf79f2155a17f0689c8dee88900665bd54493f2ff91806e995543dd7a7177b6eae44ecc89fe7c81225ac914388b74ea89cb64ecc4fa5a492573689b747a171e57c78bc9db296d5da75af44fb55aec341b4a5092a72caf4188412368011e627357fbfc351c149d396be2cfd5c8faca14afc18bfc121428d73c1402ff0a27cc46cc5c77b6bcb1c84b07546e7e3f7baf5cd63ba4457f1f16385d8f6d3d7d54c929c8e4551c59bbc322f8f8260c48ac8e01d8145a9906c1813f78d38c91ff496f1ba5632e2f58d1c28493092ebefc414a6af5f15e90d1525c125c3287a1c673c0967ba37d31a9e7e956c40b01fe637d1fc8f83c9b1eeb8a0497876bd1a073c011c4e7c9534083b847dbc1fc49b82217cf5c82d352ed3387c16cd44557fb4126da7b77df8d367bb18ee85a8f43c06107799f63ec20da71b2995098ca76abd235a13f0a62c479aea2e4aa49f505a2796d66c13f3b94914b8dc4ecfb9faad802d4c3b05c7422b5c29723f4e06a1b3f3c2d4482394bbc990e38e4984fb0d3deb59ce11436a2776e48ee40fa84ad8c27b8c3cc22383176178b73c7333b869111556b72343800ca2ec983b65fb4c23e6ef5a382a0424d1bf7e41b6aa9ce76a31b5ce62d5890ffed9139b4f6faa015341cf1d9c06e36831b687753f3e07381ca37f77a289f0aff4521e5c49f812078d4659a40450660dd3da1d949fbdc5ddd103b36cc8d708bf14f260fe7673a7fbab649f3c00f4260c8749801f96c9b0b7a4e5e3632a6b6563b4864c1b345beb26c224e16ebe52317707db0c87e8483d4cae74ea8d4abb264e1ce99bea08b1cbaf4135a7a84bda071af42041b3f978db9bef4cbf8d8708708ceace17bbd1d2966ff68eac0dcc9acdd383d3286d6cdfc0f3623b159202d65b2da9f23a7ac30722b4bf95a150437f94ec9f51ee51a412447a98bbc75f1e2be0b35d218025a0dcc993aafe4d447575cb61b659bcce57ecf06166b2a9a824cd06d9babf4facec418ac01a55c3204db7b3016185f04f15560c14c31edfe1661d2e441b27831fbdfca30f45c6a737f5c7cb56e76d6830ff23b31a7b8a334ee6e8039794aaba78eaa571f0014e42d3b95581511e1efe8363d0936bb7e56d743d27eb7e67c9a28fe275ff799e8e322c4e431d01d21ddd2d5c55953c7b52b42174f324e0cf9e8740e14efa4f6af0a641048461ce87e6392f024bdcbbf03902389638f112a88753af985968b161a0f039330a20d29b9b2ce7bd7d747b655db60a8da27105ceebdd5d19ae3c56fdf9aecde775bc3f794bf8422ae251f28f2ee558582f2923f0fd4ca90f7daf746a885850fc7f4bcc81ad5b9208f12af78f302ba7f81b3ba8d0adfa8e3b983f6397f79474908a96cc7778173ebedd17cbd46351d6c8eacd280dab87aa1771e955c9c93477adfd7e97e1b92d85318b6adcf6bad4597829748a2386f1a67e231b219fb88642a5683f8ec256d7d5ff1f89ad61e846d044f70f92c1137dab2a467c6174dbfd7c31660c9a2988cfb32246a24f22495293d843f1ab2950ab35ceb1baef1f5df3c8b18b3d083978eab8f81f0359a4bd86748c80dc782e784d8d7574069bac374b968347b829e374c128d51a151c0f17e401236b80ce5eb79d642348db61142ed778e5549bb78601fd9b1bdc2bac9bf658b5ce52bed8d09f8decd583a7d6c2d9d59b4e492e9c27d1677c726f0662cae0751f038e58acde4cf8f0d6cb09a843f115a382f8af6ed3933bca0d0d4ddfa7e34b66cf4da293bc4de8cd53e1e5080f8059316d0fcf232bbe0d69a0ba543df7f8ce28a2c700d89a417ed0dfb4a42c7a534de1ab124ac5014f0f3a973ed8f77473c2052ada842b9a9642925ebf29b8822f792a80c1acdc74c1dd6dd9295f41405089943ad74ab055b63581c3713a9b3d54e674459b910afa9677cb3746f81423feb3b5d2d1b7fd507f9f8b2a60dabcd1bbe935c977ad9431a945bedaeeca979870cf450af761e76702fe52b5b8c8f30c0623b4161117a09d26f44f571df7f4d8f094d89ab8764230beef71de2317586c6c6e84a85fde783aa03b09745cd0dbaef815a3cf6fb0f7487e66307749f3f5cfb0f916f2d80f8fd2ca6b9b839db3894489db0b9e3e129446e8fbcdde955fad0f67b27caf2a5838e00c5a0923a04814310eb08b1fe1baeba28454f9ab4310295d71785a19cd3e13afbeec6299a0f218e76bb31b33419118666bc7c61cc52ed938574d548b8174e7067b213c53393a72e250dab39ee2b2c558236ed28f46f7423b63b711a5ab10424d42fc2b041f917189266bb8a7d5234dbd96df45ca90f36bba7a42716969eb5c273e448e627e5000d8a98d14dbb3020ae82a75ec41d8008d59d706185ad1414a999ab6ab8691cc2fa6e77bb803cf612337c145c2c15c893168e0f3b9ca64d05913680585145243a6d406f687a836735205b164f3e908b65a0f54d045f31d0bec04c0b0f8587e191a86010b269d70933d230ceb32af9eac754f9e8d713091fe222fea1c56de184d65e81060fa1952e9f7b3e28548c1a9c7a9d36dc0862168cd3013a69da120185a2dea871c0f5760516ef3b9a3963f8dd70b639d5c075765808e6d4eb52e338315efd73e233c4d55fe8dcd85f8967cf7412ffa0352e5a786c3c83da3ffdd8893c313d43176b9b54d62d4cb99380cb163134de3667d112e81d3abe2c89381f88ee050a5c1684f99e6194dcc7715b61e53e1d1eb8314081c5c76f536a6b5e878a428b0fbd4a7f5e7982dfc4d4a28218df5a438246e9ab05f22c8e58de01e8923e0e9aed8df7bc91f7d7124f614be914921dd1877c746855978a670eed2269c965eff06b5323ec5744ee4527d9c7ece1a8087aaf02588fe68efc9c0871ba2849430bb4428e90efb242458bc3d1849fdb74abafb1df536d79380f4d4975429a9d1e94d06fe93fc62cd4ee428d80fc0fa8b5d84b8eba6a78a02df02f4ccb1ef8aa18243ad0b06c36dd76e2aad49ce1ed563482caa477124b920a139872d9ed802e614e66808d8b9692f8690ef4fa575b1c1badbfd69f781bed4b49828f789a872a1abbc5105bfdbac8db9c58fc5918bfc35f6bd6645a685fa6a2172f790c982432a855b53ec950a6a2a74ce607230c169cb15ee40f9727b9a44444151fb1ca482949f6b32afc1cc312df2843ce7b4ab1306ece2eb9de6efeeb87ee19ee81b067de6ffb34e8c970655e4ced0c9507f8db54fe2db339339fcf17e8f21b95b4178aed078f6957e8646cf7c51e8b06d38ef225ce8c69ccb68bc9ee67ffb91ee042862b23dc60903669aa936ee2c3b947a8a039c1c0e7af28ac645682a5ca05ca4dc922e9bbbb3ef200f3aab176a77fcf96c1083c058574673f039c9818f3e870b5cfba994b4f5cfa61b0e9095e3f2f1cbaed8722bf3498dd2223c7a3b636f64b26028a44b95aad3536448c93a23c7cbc9dd5dbbc5341f66120c0f046fcdcd83538f52a79d1bcc5eab2146bd5411099dace658a854123d30d751ad34ef2bb5a538dfff3037c9353412745250fd181024af1a1b72239354ba07a68ba97b027eacb7e7a9c666e2c5aa24da67873ae4a8656f94bc07d91e8fe349601fb9e8584c29fa34f7a58f6160f77335d8f89402f24963a1183c78ace48471bdd745fe8a01815e1b7f6e9d375fe417c202530d841328e4ed3fb75639fc5b7387251c15ecc01ea0acb2c07a462de9a457226eac50c1d1611ad20e8c94c68f9be64d074b6de3696814cf4d52f99f573dda68e252375c50dcaa1accc9686df24290591b4d8b289aded750732a91e98dd3cc51def51a37974d5487c81f6e608a2c8cc7a8863fd0126e552aa783ae9071bdaab5098da926ee3f4c39fce701850494fbd7413c511277c31128193a4998b040057781400f59117242d4761c4bfbbcce15b293f4f77c46b5c5b7cd318d487179714280bcea75f5d73b17cd46187c541662456fe010cc984962ee9e55b136d014057d268f15a11c0e7c9427287db0defa190b6324666eb8c1667ed33b7cd71746afaa66f916eedb4322fc903950012edd4ff6a9f5380d24784a1c120dd0d918753d6ba1b5a1ce1a9c057099981ff0d78e24cfbb55b4818b92e55cbaa867e5fd5276b9a5e79ad8a581c04616886ce8d305b8437ca1283dde292b80280bfd2739be43a731596b5cd2f673788516448fad0620be2d280b9568b38ef4415eb66394888e96261fccf57600eabc7c5e8656c860fcf515604444f1d400ba2acb7893ddbe333b2d82b0a33e784b5ebc7fc7dd9dca4d78d8d0a85b5016e8cb2104603fc5b887cce74985efc6eaabf59218ce0c63d211abd2746942b90181306e7ded3acb0047719a474833fb11f95ced2dab2fc933dde2950b6c110bc185c9bc6967e9fb7e8c4f0c558326fee7ae2f37c478bfabf318e4b1e4af537d8904c24ecc606f5bbcea19dca1ad5774f86fe1daa6a6955023c69b4f5b48969433fa7efe40fa83674acc8734d3b3a588a400870b0603120ba82a5adf0cfcbc786ea7bf52f4920b009b7eb3406e28d1e566f1bb204002c628aa89244924d8b4324a90430ac69c016c44b74aead0c4b61436554ddfc6744b0d492755606bd0537f81bd64a3b1c1fddd2aa2d8054ec76fa781a3ccab72b1974666cf862415d7b7d39a6374f7d0f8c12754b8048fd5d9969f8263b471f373901f441c884e2afb85e8479e3bc0c0af1023c1fda291927b21e460ca0c6f167128e86f4ddf89ee8e6cefceb86c7841c93ca27fcb72a440dfdf7d2f7d7eab5e0c61dec2c43833408676f9a6c5f68d048d2f90bc0331bc1df8c1c62511c1068e8916ded5098cf053f4efaca02ea50ba47484986bc2e5e4f7ca1cdb72a04d2b90fc0aac7556ca10f3a2cb3e23e21d2831c2ca5f9a57dcdc0987f70bc4b0973b2981906aa01f51ebdfc3b4e8872242e39d73468e529389542ac168e3b12517a85d87bff64e08344d80e5da050297059426f6d1456cb7025f4f9051ea048d2691f57fb06702302f5b830faa68abdfc5c5880a5aecef5fd431e109944fe1e6d65cc4b26956e829ad4a117af1c31252e3c9017f423e5a94f80aabe045f5f8a3ca2e6be7ff1795980d80769fb399d542d0ce9c3e924dcbd3c40589ac129d25ec4f5a5c735f75a928314f5b3c267596b53520e6a0180d0c2544b4f42a20883f7ba6a1bfaa06c560f62dae59ac10473b9b85363873a657246a639efc0e2bfb4209b7b55a6b40bc215c5cd46139ddcea68e118284a8fb4a5050c37b4fd6035e58f1d89f48c30b90740522147993b6d38527964716ee7ea91e2e31be7abe945eded2dac7a20216d8df79c162759c7d317bf078f8446980404168239d8901f1ab6c69fe111a5c1aa511811e1ee28ea71a0ebc552df52dde57159fb8f6c421db51012543d069fbf5d5db66411e29c0ce15d4ea13d9365e7ed17ba72a5fd57fa03d244b31be673ac46725bea29ea06f3b68d58b471ee6de3a33040a14b015a4e5f2a7eaf72e7ce2936b4a5f95ebd6f9ab23fbd34b162720b9aa69a4fc3cae63677283d1ddb4651aa010271c4ce5fb5aed3aab330d03707c9a54d6dbb514115e64c58598a383caa8d8cfd09791244ad1c0cf310d9c7cb3385df656e3e09c82731b371358221fed691ef9aeca2d42ba393ec7aaeef53f8799da018b2c1dc6d893181d1cad56e48e86843710b68841227054fea2b697ea7583153f7e6d54c24e9b82d71e9ec3459428ddfa2d9b465843bf377831393ed493823b794ca862b8acc94d04fff9d47291ba9f1f82f95d80c2d56c5ee7314a58b3babf7d7e147ba64efe12db22281f20ad9dc264d1385815434796b3f2d96a87689fae68c1e881edb8c55281e327cd4fa5884f5c21cfbbd2e79d46cdfddcdbc4e99136520e15b02f57a274512091e03e2e44f50e5813acec7580b4a01c18d4f88c4cab9313ef4a14291c591a0c599769cb60dd7cd36bbe64536ed97e095bed2791d4478bba11022c80f80e696c623b4466d78e4d0d589b14e149708a8ea36b517fc9b21fefc16901e9dc32bed97090e55fc46e930283c86904ba87a881fa1aed269e56b5496c927aede10437616e8edb421ef8f8603043eff5c6594b991a0e407c75215cd335aea843640a11a30bcea79affed39a322231760bf70a87b67dd80a6df66711291643b661790dbf9d693759da65c2fa0dc1a5139feeb8e2e64c3f3e3a4c01d69cbba7fc03ef16bfa43019a229502c141a2a4b7beed09ca4bdc8d20737fa187d37b38e5705970629cfb73d66522b2901f42687371f0e37e10af98de8fa88d9fe6124bc8491ebb7925c110a8f00bdcedd5e677ac522305d2bb15117d450b78e38a540e9bf46180991e5b0d72db3e660e7501b62b1e2da4a3e37b804c24606447946a4dc65ae2fd41434aba633e15639ef2dd42eed6a6c4eb78160b2e79a605f978ebcae6e4b61cd73ed8bbb84209d041a3faa995e18aa7ad3bab742c28de1ea6528f45c47b19cc4163da76ddf93b9b5514087e61dbb223398476605b2cbf792bbf284b355315d28397fa4a8e345baefc152a20225bf3da56e8c1a0c3e91058ccddcc23748467d93988f44e1e36adb5e50d175d00ce21185499873ef9ed9aaefb405269541fedbfd4f589139f5d94447a49ede16a03d441b4a94d2134b1deea0acbf1d6d8ea9e0b1783cffff8bd0aff38e2293862e88e79d4c4bdc729f49a13184644ea9cbf10b8d00b45bca300a9c0e4a6c03c68f235226c2543aa039ce2761ce628165f56a074d17cbf5f7dddc84b8362a30b2c62e0e5571a54b7efa1d61218da66d39037b1fecbc5979512163e79e32fcda37ddd9eb0403e8fc2005fcaabedfd77d43cb67251f74bca7f88a0f55bfceba424e9add23224bd659a56b10070e4efa0bb6407d6c368769e9b73c2084f65df5bd886b23f2bf2de4ca0a657c2f543b9d76406c1f6aeac5977947976e93ad7058d2c9d077d1d78920ff0f913b05ae038fee2dbc0b34c773898afe80367f5ecbc621dae7daf5a9e1bffb07b238baaac221ddbb306841a086d7d7136b5c54101335e854ba8ca071affa5f1225ca31e451184089923f19d09d5c8f251475b4c6142e7755c7315a485322369786e2aedddb228ae940954296d7363a9e660d02d1557bdf37b83891b38231f3f935e4795bdb43ce180625e0e7f96abb298dd39d24bc07de3a717a1bfd33d402365a162d785e02303db7e77f4e58195776a9a827347b40758473a5c55c61d88a024d075a52af7740bd4addfbbd0242444597837524e4b9c463412d6a6902c2817b10c48d6fce94b7a514a043d8f563c40dfd1a6a3bb1e8f3bef620f36fc5a88700b7aa82617f11adb4525c71f38a243d2b14d7769f2523e1e89288fd4b3642327eb03f43990adacf217b16f97880d34aac11c794454ea4f416e9b54a249cf6a5a32a93a9a71eccbcc11f3d150dfea224006301b1065a96d88c3ce44058a8137f45fa4b81ed8cb8f83ad57e579e1e358d40f1d85e1e4dfffe8fcaa4f2be19fe9178a0dd87aa35e3febee25c66d4224aded79bec7b5c24ec1cdfe674a4e1d862784f80272cb41ef9fc89e6cfaa4bd029224f123ce83102af49fd542d6a310d86e2b8e041546a09de70944ea961e4c406dccc05f349b2d0612fea2a74af241011c0069246cb194b9f094df6e5d996f317b05d6ee8953d623a26c3f8c60782f8e5055ebcf15af63b27371e59071aa60933fe5b53fcd3fac41e022fc6f741bf89511a8f171307d5f0e41ee8e8060481280e014e26d6b4dee2db2004858ecffa468d905fbf63a5841fc55cd9b43c92977fe01cccf4806b46be7ec862ee961a6820d9d9a33474baaa98bd06192d0c9447007b8da43ae49aff3909459d09160aa13f719b801a265136d37691e8231b11555a1d33878402f7da238b8ca004403c1336b0ad1784332dbd74296eea4f181e43afb4cfb5814fe4192182dc5550753498666911bfe603ad3347c7da59e018aa2100a3311b2aad15a9a80b8bcbf627ed0fb4d0b7c3404f7f81fe65df0f0ae44541f3dccf72069525a188c4c2e8faf7e2a6ff1d2e148673b87046d3c2eaf98db3e9f45306f773d5494a73af85952dea9b4f1ed9e0fcfe16d9030030cb97260256a335b99e426225f38d6ffc02636a4f46c5a04a01446a34023fb33ae0d16106a22cdd6838dd6f9a9890a6e7fc79a0b4ec42e3f2eeba2614298f6f5285617cbc31b88bae9986284b5aecfc05b516381d4727a8460796e22ec0e2a2dfc55e50534c702079eddcf43c9c34e8ab4d85d1d5408222bb511b7e0d4ce01bf03d9d73087ff4cb230e239bbe8ef7fbe3826e9e2242ff3e7ceb7037b28e81203c2cf31d53dda25a5f1810a8d7d63a4aa6019bd60e9ab0db59442cfc1f8c1f12dd51d66d7fab5f08717c498b1765a235e4d58766f50269f784a272e8fe0f3c2160dad8e1e5625bea99df2d6b9207f4fc96d951b69aa9dd935f5a2a3bb48ffc3df045fcf5993a1baf847bc22d81b9b64fbad6a26e5e57c4bc6de143104beea77d2636913d1c4cdfb7dd86bd27164c998333b34017594a5affc3c0bfd81995eb2a49c15d2ebe286fbb2e06d3a12b94ace0710aa37312613a8a4fb082ed4fdba436bd507b227d5e9ab08bb3b8561f5e2b452744601251b8856eb61a27d095e0b52a3c19c0ec2fcae1fccac49bda12a56e65d44def24eaabdccfc375ef9689fe60cccb2fb6493b26fd623c8e214ae071ecc41fa97f678273a87f96e921acad67e500714efe1872cf2269b3e435331496034dd50a180cbcf5703780e0645dabd580503706629cd97b05a2dd23526169631609b4be39810d968dc7fa9e83543c1dec29ae12affefe8cdf4b320018cf5aaad01567bd92d16aae0bb22838cd01c0fcbf7115f6853062ed2304b8d4cbe76d5ed9bfe17b66da3e2dd2ababaabec199e19afaa835e340e0d91ad838156e42554ed3a8bd5e9de79a5ff6135c3298754d810d0c817a051116d582c082302ff261b1783fb8c1124932eb2218139069614eb3126cabf848a28636dae0a4e831307e99059c17e2e1f923e898626ba30863895bf1da29ed6233075c9774ffd3bf275a86f6df80d57cb26b10324a640f94ae3b9b9b9c2f3808a735497b1e64ac1f779731d2f241894cb5ce82afdb0bee93700311c1e2bb4bad947ba4c278f203fc6e45fa9acdb60da66c24b10a21d65d305296c9a5d8a729304c27966508d7ffa3e143b698dc547c9584ebc6d1afef6c815139db138660b5100860265d8e2708038f208a5b4dfa7468b68869fac12f532201529e66ab27d541410183dddf6442fedd184fec686c89286c5ff728ec493109a7a7666fce07f1cce79cacf5beb80d69ea5839890776a214453616e352c6d67de65a2f351dd8f71d1ca5aa241c11bf6877aa20882dff68d6f5c80827c3a3f09bcb295f64f78b1277b98c7851d39b47ce1acbf7f01abad12ebe493510cc2160d0181f39c80659d31191d60dbd38706ec62e8606e91db76d72851fa23c23bc5dd95481d1b1fc98e3faea92ee568fb4bd6118e539479017a5a6455664c546eb4e0f674a78cbd040212baa0cd2e77a8e62f2b19a37182314f31c52938d489cf39e198c6deb7d85bc60d27579f486b60175e36c2ad605b2b516632c939c8cbafc7d749c9d4cb91c949ca5fe141e8978cd8126b1f03daffb42af20e5b39111fa7b770512decdf090a9cc5950452f58e38185da9399df1d31fff8c17405d88114442034cd071c7be7fb6bd3ffbd24b92f3fe74b9d5323c853a04f6cc04e109005eba9b9d955f11c4d00136d1c24103f094c2dda0886c38d8adca6e14ee31a00190cfcd269bd869bcedd46f55c2bf9fb263030dae6dbc706ea284bae629e191659b795310e8f921d890b2dccd588122c8ebfc24f4252ccdc466ed1a1b49b3711860bd0bd9c3728919fe02b1bcc201dd03628a5aadb986e5240f0b93521b7bdc41221e7022ece06bfe9bd1dadd26ba19ebf70b985ef58555c2701db353c3e8652ee5ba0954e8ed1c67dfe8a38768b488a9e2ef14d3dd3fa8ed4d0df832f9ac6234dbdbab8ac566dcc001e197f2935c0f79f92782ae295a3c06eb798ed02b1ce721665ecbdeea5a6995151d5d71ee5eed9dbec8f687eafed32451f108aeb8241e21e1c215f42e90a975af98b18c1479598440b44a62a518b49e54142e7e2ff68c95d9e0d84d393878417919281e254e774cfdd1ecba42d6df1cdab6ba2979e406e9230a50842b614d59089100211b34ba9272269892ee6c1b5fc48646808090b04c02f35339c79db830f3ce4b3126b67ff138e8f90080e449e4ef2ebb1114b9fe78eb794c47d4ed50ed295dc18f0696a0d214a42d67f065f534823499e3695a8c5b40adf0b89dcfd9843d124e81bf927d6433b700408af325ad3251d2c5dfda98d159ee5f97e55e5ec332d17c0807e8372ec157e92f92346ae0f35345f0ff18b4cad5fd332822a2108d0e5fa14346f1074aba8100e9f09827b95082482fe501994a9c4eb63a7af7aa8219103f4fd01dbcc354d8a807e116bd6d8c0e2bd56c25dde1f5e98e05cd080558aed6258d44f78c96a4d33a599ac21d6072fb438397680b8993e13122cae08d0b49e363055ae00bead666800b055e867423dc102daf5811c2833b73a5ff749fbf3dcb27c1ee67fcec4840af156d34257c6c456a21c179e7962aab0929e93c7f4a1cb34e14c4246d2e788612215e78a537d3b2894a618c3f7005f3f395b617733a43ef51a3161c1d0a6572439d648dd5d4ff25b0897fc57c6536da5996f22f5b30f4e3db5f70a3c6f3d26fc03f2ce74dd924847492ca715c8bdeaf22e8bb0d22ecb61df9943827ae3ac35ca47fab659c254585688f27a89913db472cc8779e68135fc8b5383c10e52fcaa8e3b230014d51a6cdda0a1be27f4c44425ad3af9c1cf067a91fcd859a8999ef7008a8395661c6c2b7b72940519388ee746407ed6dda2cd5f2f74b53e9a48f92084d2ae7eb3a02c340a36f9f99270b426f641cad7fb57ef58cd0eb438764d49a98276de1a561671356a11fccfec2edb6401c5343425acf4994d341366008cd7781eb0b032b00b2cb9d79546ad328e065f5a30b630baf61715de605b38eb8355697ac0eb4c958a06e113b3f0aef289fa57bc7670f7f9423432c69e36eba1c81d82e815e45ac0fc7574cb37b1b0a68f58fc0927eefb9822584202e8190afab05195c2e9f433971988570e9aa0b4e788d2bcc55c1e5a9408216bd1d0c7f5e484ec2c3e82f0fe2d29fc00d116041ec01e758c58730e94b64e775ec4123491a24bcec2550db65b2b6fb80da42f3879add8584335491134556f8666750ce4dadaec06af1e0227bbe0a0d5f52dada6be9106202edc4ae6303ec1c8bcd4581fa9e15e28213a2784e5da3184e297c85fe60488d9932e0199c74a1c27a780614ac6200173413a9f12dc2928990d2add69e43439e8cfd296ac4ccc158fdf273a19dde159ccd09892e95afa31947e7f8a84ac5f1ccbcf311213e77d512db6a0a863ea34078978faac065e74fcd39bcc97f672b44feb944a8c1ab32f798d4a29cdbacd93df48086930edacd737d46b285c910c411083f8e4c212b99b78831393822c961dbe63e6ebb4459514d726b393f0792ecb89dcd5f3fca360d86b56282044096799fddd2b2fa274de4cfa5c2bede582b600bc737fd1bc24bf6d2c1a27c45d0c3636ba6259275f1bd1a7ea3bb87526e6346d5f398ba8c3a4e3aae0cbd553ff18ea1b6feee1cf3c31076997de111585e63365b9aa7f6bbc49e330246259c9302f889607f419d826cbda90fe2c1401d56e1f2bb8b4384cb88e07739bee9bdba152180bc9c8ed639159aec80deea2e769c23f44a19248acbd4c417f6666d3dec3a01e3120dec431d8d2081a5ac5c3868ca8daeec6dff0ea184a6de20d8b8d0153236ebe1625f7b5b1f26fe273c794717fc556d345e818540f492cc99f129edaae486963a89e95ba7ead11de0e252f406b377475a06a3680130ec9aed25e969d90a0c5a3bcb37f2a5f900ae82a1278df1c2438d2a56dcf12a672653b237ca18c4faf4c067d98b5580e765e3a1a9ca19c5e140b8b71dbec3048a8487bfc7269f8a0d0bf4d95fffae2fe066afa265f1a9194e8348373a7157e809e61e4c0362f9efc26807afca87f06cc05255f532aea78a29308cd3bf4f320684b5ebe4065ef0368a6b03aa71b596037475fcff889a932c44aede18a6b1c81a55e56b1bed56333758038c0f057fe01da2c0b4bc52033251ebfe524081a8798ab87c72919156f3939e270b252bdc4167141d1de45d5c0bdb55353cc56efbb0bea366ec54050b7de484e57b10177c8775eed825f0ac12a49ceb202c002c0940865d4ed88dbc82401d852358814c88830a5cabf1c886fe9f322e6c3357c3a66f6b7e134eecae4aa4750c9ffc10b3fb6ce5997664cfc8a6a4de44b781d939c5b17f7a4a8be4cd1dfecd44dc7e5ee187b30e58de6262619de0059b7c78480b2355010cd57e5d060c0f308c790ec7fdd3e92f64dddd27c6fe2d1bba0957615d99fdc3b4f0112cc248967718e69add684de0b4a66fdc4c11eb80f2d12b23384351503ec1eb31e3cc55a4532daa52a7ce3ecc39f893c03aafadcf9781b3e7ccb44484647db73fadbccffbffcf1b724fad7a5c51f60c6d43dfe448f81592216b8d498bdcca876856818a622a00103dd6dd66b23f99d96a49f7fb2654266f168cef9841bc18d70a8c469e4a783b45b68593a2510a6b13969e53531a2b1d7f65eeb94424bd3b1a2297c0d209e77595e4bf91f8601aab22f44cd98cc7f04df0f73f4124960dd9049390f8df131037d468e184221b675ef647c1d77bdb9588046ad4cf3ce541773acdd4f729a4d2ca7e2a116ed1abfb25a8e5ee775b5404190a246c2514aff6dc9ed87464c27b224b6d4f12ada732ad10eecb9adcddcad1502668971bd18439bb8ca36534f89a0ebfb30ba86bab4c3bb29fc3650bac24b84c6e9ec791186631cab8f2c1abcdb310eab70ffc7ce265bfe3abb757094031d267318118bf6bb84b1a5ec933ebfef72ccbdedad6b3b8f9aabe3f63b9a45b1f0625af3471a3d18effdc7d66c8cfa8ba4967568415cd71f6fabb48760d904feae3d35e429f4757804e7c311f7e5749dd8ee00dcdf7e0e362a294564b4902fdbef7e3051ba8f157d7aa1b5cf0c239a01471d6284fb6073c2fb66a5c27462dbdaaf9ad3eed36b34d810c058f76cc6a8671a1357befa5b50a1fa6e3b79f4a49659e4d1df8a924ca580b27192e9b289c6e1bc16b01ceeb31bad58b017a901e56847212c0f14cd52173883fb4b034538af7f8959cebb773bf9954ccf0fb54601b4c887ce906a4b81bc7201a24eb7e7438a555388935799ae59a750adceabc104bc7fc55ec10f1d136260e5ebb2cdb75a652985907bf51974f6ffaa6f49cb09ca3054169a99467640db19ac41e3f0296dc36aec71d75ce80031e8e43809ceb9a8bd606c8e03e983c5d74d3021ac5caf23868eea2a831b73b605acee974f14e24e3150ec163838e7d7a8f1c7c6ecb5b1e4c981ab3fad08771678268144395dbad8227bc2798d51a5929e667d3cd851b4e52709af5aa6da9cd156f8dcd78871d590fd639b711699c00dbf2c228252acbde3733b34c7fed2ceebd35c52a99b6f3c369e2ae9e5974bb325ca23e59e0a74311046a3dad3875dc780db30b130a324de3faadbdf0a479eddaec6560bd0fa972860992899cbf7a72b98b3fc4bd036a047cf6b5a6cfda89a2da9078cd3cd9cef7ed0ea2d711784b761cc20cbc1a959246a6599866ee299dc7717909cd76461d6d7fc3a30c3c5660b257d3e899b1cf6696876c74121ca5372674dabed8c9bd3985342c0de8522cecefc07330094e645dda4c532a9f8df3cd92c476885ae0dca6790425f5a129bc778cf23e51aff3d462ed77900e6659bf79facab57981d0b991baf834efb6048bcb9dc4bd09cf33a4cf6f8b6658d9368243cbf5c11bd08d34da3aad0da39b9798783c84a0bf02d7fea0e07affa3793ef5d319146cd76fd8b13298f5c4e146ba1fa3690fdc555eb16a21efde18b621ef44d2263f70c2590ed8efd61e7faf39359bfeb9e8c43003e5c7f74dce801a5431a8754e8b465ab776675b2c594437c646eb3fb1684a138fcfd767f82932d3128792985928c3df8ae6dcd6c7cdd39a94122f7430481b300099a1d581f15a6713e3711a482e2c7b41f39a8758db285e2a56e949d70b8573f4e32ebe92a5971878860e15fade01af44c70bb1a966b1b3c191f2fd69c2a4dbbce791e82b46bd37333cb81322fd6f4f0c6c90f6bc2105a26747d8e60cfa4931d798545efa46846ead75819c064899c1d4deedbed839dfe4f3bbe7cc1df8758aced917ed2eb83e871c0078c62da4224e017da0e3677b5827923c322cf6a1dca58030d4fc742e15d9b981b64a35d375a72bab034e71bc3c13ad28c4a1445f6366ef335c5010c8aeaa6312338ff60cc6d14fe4dc6528973c1b726e1f6135b7d0c24e60f8744b961af46bff39fa87ed3e7639330e3e3743aab9c82eda5204d1efd5f256d461ef083a961ec211355103a0faef531dd11146591b57c5777b16402b56cb192ece78e0bce1680d9640f00505c990298872531ad37fb696298687c46c4123dd66147670992def5c15535cf0fdc68ae42402ee89cb0d92a6b54a5b78414cd83ef104e20638c62fac516b64b4ef51fdc82e70019a78d8de46755464fd94fce82b11f4670d5fd393115d7ce473a2c9a91e178430b6d08b32f2796d1fb6b9e141e5f156055eb9c926866658b062929f39d81a5013ef80b0bad51e83a6beaaa4c150fab880e2d8a87a2570e32835c76e2ab0ce8b40e33721ee0ea555458522e374c269092f4b26f8c59935aa843bb6bb3dbe3a3606ae0ca9ed968263f86a0dc473023091a5863ec91a64426131dea6d0b64a5cecc4f22d3b8f4d09b96c2c95f6fba9a0647d2fe13f7ca808628dd90e03096215bcf823544ea18d0ffc5c07f57262aff5ca6ee7b0ef4243b9047c1330d5369e0f6ca490f5b8c256863734bc3001b0ab6e73b6d397b61f29f6c5fc87d81b0f3dd814a0ec62533f81a51cace39d7f69c45100d98888b4c126306bc61862ad026cfb2fbefebd97de0013358dba96cf57b1777f5dc470a1ff4245b6b172c9351752e3e42a154013da5910504a37be464aa1928ce1bd5595db44a007d80cbffff35217f5c571ab6a44e63844693b4ee2cd4b1753a4c98b229fe64f3a132f23e74d302a8852eb19a25f64a93f39c5e5e1105e08b90222e086aedfad4bff11b37e13ab26362d1e1b04331cef83423d45ebba8dda33123df19cd2aa528aa10a8daccf6c6b878c634b04697bce4c450657ccf562e7757f807654d0dd1dcd6010b40e0ce974cf817e181677c774cad683a9f56158b1dd0acb2c6c84c3ccbf64b6be2ee2fe0616a276db6474237ba31a7e95702ce46418b1a500b04758e924b83eeb2bc335fe613bded2f7f0c1e3009373d8146aabd697d4984ffef6fed6bf609ad462b35c73407943dd749646749b72813589394f8672b97fec5766d8d5c1d3e8465c7ca8f101a272344f4738d485081da646fd3b6f42292cbf1a80acec44f3972669afec34203d82e5b7d273716dd8e4a4533dac1bf9df1ae5ec3d8700d6d1b73137416bf41c142f48c16d6b03693593c996f96a70f30fb66bdf7db967b2870b58623f276e0423897e894f967f24381a1131d2a0fe763aac4fbbb8cb92c7a5dae5d02df1d67f198ff0fcce7a4570150cb635c5a98ac74f0cd25034a95c6de0ee149f729326e3e8b55a998270a0a0a00750139b32f8af00bd0950947e02d20aee1cb8901beb6cb644029e9019ea57cc535fa67d0784e2b52eb99375d9625bc566afd42f26f0187af041f467dc417f8a5b1d396ad9f135d6797a96bf52994f2208f6cacc917c51bafb8b82a83bbdefc1598cc32dd9cdb0881d26ac3ad96d7d9c878aeb1e05b9880980742cd993c541e35e6cf1b9d5c78545cc9d9e0c530a5b1319aafcdf4d917f05c40646b5c228c4dbf09e44d8191c68b5c29c1f49c78b375bdff3f84f5f87c924198e4940098194fe404210dbe24c04ed69312ac4af0b37a093b100f43ff832f9e2c672296d50d201fa4da7566cc5b5d1008a2fcccc58c7e0b9234c151929a9bfac757e92da2f42a4fb03b15f474e0111d25085e884217c4c66133ab41dd1bdc99eeadcb7949146d1cdd73b3e651c13991e91c616f14255e471a5c4170554d81ca8c9a6275174ec0f12b626b54eb79e01addce802b766b0f3683abc6f6f3873371875425e604fd2d740bf0f876c0c60bfb57c52fdcc602918cc22049f95a774343d291e4743b2f0fd33b748eae25c037a0388970f97e7d6d2e48cb9e7fb9337b354ce3bbe255d4b7639184c1e7a2ba0157ca9f4d39021552003519697a1a40e37f43d81b9acbbfe0b3d8bc8d07b4ea7764be1d9283572c45e6812030d61f5acf6e81e4ad9581cca32bd0a108f0d1ee3a940251956e684055364bdaab29e83e6a4958f5f4b11180e7e2e92f38fe17c995a5ad7e4de5424d9e84e83a8f688040baad6adb07c7defc4485a2b4d5d3bb8e69fc2205c0bb5d72bc5184e58ce654539480bdc24527a52715e1dc760fdf10f27769f516fa7cf7bd6449781a8f1745e44d324406559bbadf1af2031b01ffc524887e76d1286a5d659f432222347eb36504714e44b7774fd325b158ee74d1183af37e1216bf6d5d479c910eb72c87357316f3e0b6370d2dcbec0d5f3a6f3878e6457a8c04cf50b07f452c6b390335e4add843e14deba791f8ee2ece5d546c70e400f4949d8ada2551e6d0430e7507715401d1832983d964b261943a1631eb67e0f7286cdd8036a8d0aa2577442a121bd94073af8e3647d954abc632cc3c49a50bfb9fbb78f2caccfaf1f1f357964ac781f1a9291c04cad87308a96efadecce9c16a02367008212c0fb764b1f6ef7dc9e02ec1ec0769f896502af1f17f452a5e37086ec67bf7d2dbc1e14c8ab98f216dc314d4e7e578cfe463273265fb9d169070a543f8b9099c2a0343ee736c3ed4163e1865927e4e54e30a5b503860c1d872f7c5eae2e30e3a30d6b5150830e0b1397277d97d278b59096c7fcc4c7e76ef070ba107e971bc90f05a9f2a9b2f29b0db1a5cf477c0e7a7397de466fae88ea091a88f8cb9b2d46fb8d304fe1e1ee96642a6b937d60a4dd3f576cc94ef54636e6ab0a6f90157a90b9decb0e7614b024248fb2e9e16a1a6908dd6bd851639aba0e2dce7d079c1dcbe15dd1e378cd04e8df8e36beebedee0ac4d7e458dc51297c9bab7a880d645877dad06b6063884c8caa7d1c20faf335eb39961cad40f4a9f188cab6f4b458cf044a845fe377dbd159974172e9e065f2b449b2f8919568fc34d2f2d2e0a79b2b1d81f64e76fe955bff0ed25ac734934309ecaf141a2ad832def3eabb75139aebd7803e4a83d873a688797cdf1df91bab4fa6ff11e2b852c1816570ba0ee32cc72228f7f5097ef82ca790c03195cf9c82d51b734ddb96240713377d38257be7e5a4d152b4e0a1c7bcff908b0608d9218aa71c36c239e5e2ed85693dfa9449e51b6590824c7d4d239e7addd222c62b96ba9833383ccd430ad1d441e569dc1df33f332be7f3d1b371b2c6110e133315b08707e4ba13f0dacd459cf683aa0b77cdb9856722ee435dd7c4c20d84c99d6e22789a3475d669c862dc73fc97532829e79ad0f8af24f5bcec488adc152689859650b22e9cb35d9f82c5c8ee60bbb571e4642c538b57be14c2690c239d39368a4ad5d332610090e8da9fe8c52cd0535c01d1fc9816656b1de3e04e8e3ea09db769ebf0634a7b9b7f59d7423abf14be7f5f4082c3369e923cd59618fe8f155cec86c9a8ad3fdf8ece93e850eb24ba9f85f38b3e36d9055a0e81be1f80ba0a5ee995e211298198a32294833fe949880154f5203ccff87c2164d60f7347db70e6d122bec4450e19514d960e5e06c3312974bb44899ab39cf7f55a75ef3801ecfd22b37c26b8008c56e15f81ffcabb4d861bc7156471e25d12fe78814694417b00ccf4a6f87e5585721b9daf94d968f55cb0c245d4ee3b4a878b8133a4a3783df16f936aa953c25fe30d615cccb21cc8ca1fa497a8c9321db437a78258384253e457877d695ad1ef165b4d58b29e0add3cd4bca42c90a8e992c9d1193bcf8caefff9366347af8388509239816a7770d6e2d619dbb92450251d89acff519711bbfeb690000effe38163b91911ee90e2ad1adfab07787e628bc30a7f2b1131e27fa6894441d1b26a6d530fa5988cdb48b6210a8b43216ae41db85f9bf9743e38a63fc2d7a795db0b0fe7be7aedd802f316799b93ece06859060f532eb9be71cc097c02e649cd6eb16a6020873834bd21392d2bd53d2338f2a00866370ae6ac081d4d556e043324e693fd454145a9d469af77ba06618378aaf49f29d963e5924b04962b2e51a1b9e2eee4a6fbd28e2c3648e54c8ba37ed10ec6c5d628f99d17d2764ad14e12e0324272853f7317c38431781b1075b60e1c717ac3478e3b0e5e67a44d4a0592b3714c3ec6476eec17f2e16ad5b7c3269a29d327cc40ca406df4340b2322f061c8e43841b3280b89793d86fd9b07b0dc0c557b2117a4639bebdec5146a999dad77db23552168c8a2f63a55e1e0b50a7fee105e0fc659cbd7eee0d5d02b3ed1dc61f30cac0b08382fc426f0964d1541aecd91dfe27dd7f6482062b396a153b02c13c6b6f9d318772f803fd4cd376c2c71797109f6f8b7285ab67b959095204f895a84aacd8ee8e227824ddafae1de6ca55b7770645f8f09eea568f8afd5e0bc53f6e7cf58cb84b5be5c8e93bdc59ef8dfc7f85c43f42576ee7a2c8e53b7a89bbf31e6bed256911f0b5b9fcdfc911eab5fbc3b6d63f3b7edb68afa59b69aeb9f902d21461df240670ec35e5d14e0e19cccb9e68ab1830244d83f0cb56d7fa64320cb961ba56691a4d526dc009b280ced225f018920df9c14e28644dc59e3389da96ccb8e0650bb157e9479d20ed3c8b2a08b4e7d14459d32cb8a536168b490f0230fa0f942e8786f4e2184fdb46dd2048cf5d201e91c2fde93a52344c6aa96dc29be117e00f22c09e7b63bc11061771297cfd16f5c2a982f762bab090d8477ed5041736798923a8eedde980d970c37c0e50af65375ba79259b39700861d8530071117d39fd3d9c8493f0e51eb05626b9d813fd4022f1800526edd689a16b24b045a4a3eef35b89f7a1519c34bea17465d9d5bd70fb7847f37f8363bd9a1722a1850886fbf3cd0bfef14d8e9afeee27e53cc83db8fa0ba18f077f7d87ae2295748edd7ba790c8e49293c89cb8ad36d802c831eaa7c59994c44224272dc6c6f04f35ecfefb5e33c201cefaa4b0899fde065aad9a89fc635c3bbd0be4880d495072e696c49548c1fbf43bbea2ad9cf85aa5b37e5ea0bd2a257c27d4d98a3ca694bed022212e24f6d69b268adeab9fd5fdf4f0c9a8ded097293e798a0ed65e8332a1a3453759cf88a81f78fc0f35e6800e4a43910c2f710d65075b4b107cc04ec292aa630cde5fd2da3d1271389c4f3e525bc483d9cd673760e5421d9c2d2b83af6cfd63fecf64ba310a6f19dac975c16e7b5d080773b7d0b5c56a9a74eabd6076416ae914a383c5e99a6845ab8c372e51530901b6d6979303e9bfc3fb1fea930bedb2877778d2288bb54b6d7eda8b4c265475474402ea9ed9f24d5b03712083c17fd3d8ecbbb8f8d964e2efc2ea0c98d80012ffe65e03fe9fbb991776c6d7bcbdf8c7211853f69d206c32d5b79d43499a184431b16277e54a7a03a0d47c5e96827fe3e78c81dbf41cae9ab2eb3aaee93207b6016be8ae9d95e066409e0de129f761fa99bd3872f1456431832f31b954f32d142b7be9881d9aefb65a6ef315d605071c209ea359399a386e911c5ce6b3110d72f3a010b7ea9aa3597eefc50923fce60a1466ebac8d02308d4245c82a63e47feaa92f1d8bb727248ddef940058f2ef22532708b334b8ad12bb4d03c81ac560937ba68fcfb48d684e648cf4ed9c034690ef0c0299795089e5626743f7563dc08b5234fa0c81e6a2be747234461ac06ca549320f45c5c8232895519ca6580dd94ccf2757e8c4c447377f869bd8de11709d286b57523203fb0d4da04d09f2090492e411b927a8f6ee81e2c876298643ad2d40e9d19adb2e5aa04fe64bea77ca167de0e7a46ad03aa41c6bdb081012d0eb520166037f710eaaaaa7e543c4ff299af8c6c99edab017ec6c073c1cebcf0299daa2a194ae837fcea5954d742620549b120f7ab84087d61521b0889c897ba4f1647baef0897bd18a717b5a956fef77cfd4d20e48b44af5361e24d47876b50e594afce4b15befcf10327d2141f0125e6cc9b730b73d0fbbf0a28da367565e96f8dc54a8f168790ce7dcce1c81fefaf032032c71a4735228bbd10f537fd0dfbf34e496e05c69cc29ab14b2e760ac341f9d93813698bc95fd3980d87e4e346d8178bdf084bd56a3fc365ba3102af5bc49ac140fb216f5e96a34dc0b977db611f0f15ec23155fc707b200e56fdff84a0eecec0cbfd6e3129dd25a9da70f6926ae91b0a75a1ba6eb80e584a88b56842c144f674cef0483602b667a6d0578289bf70fe482c0da7e28b0a7056cc07148e538040c9fcdbb1df61d59ebc346e7b34311108b21d1c87a156a1aa9eb6558896538e1058f9dd84b0f5e96b9c4f46965660fe44e877627610e3eb6c205b54d67235b25855e978c8826f286534df85dd9b94224b0e6dea225848c46d1eae8a884416f69df094214476f540963d168c98ecbaab314bc5666f2fafcab7c9a81be04fb35e1f78234fc19159faae26cc497738a35850dca8a207c634f217e8f11e9f467851bf135ffff92ae62bec82bf2463ffbace00b28867c0db4ccba5d3ff817a2c56ebb0b9e4203ff11685be5974f08904e9595854dee8c25929a8e65c97393631c9a454b319a08357a414ee270a2fe3c079acc172864a97a1b2cf0b1b1e209cb75b66913a3ec540547777a9b98deee81c5cdfa5fb9240417a0ae03dc576062a837c8a01462c5318d3ab9379fc41f135b90cab6470a189da1d0ee3870489712c3b218ff5ced0147741eb081d2fc20ee5a39c1d2b121f12d714be43d0363c72ae0b7a4619823417ff6b66285a105b9322378d9a2ca4390aeaa5feba315cf6f54fe879b7942775729643febf893e5c97482e4a9f08eb9c00c54e5a5a279c305acc9eafeda482618b7576d8b3a319fde4a9ce23e16933c5175c23c3656b6fbba7df18391c92c05554943431f242d48e62b11b742a272175d37c17e7df537e8caeab326bafb96eb24754cec5009c21a482d7f0614dc01d4efed3c54b1846893706a2eadababce57279c37ddfcb24d78fecbe0db9455b578dd566a6e9cf01ff3faeee37a49805157dffe89d924fe2872a49cb6e306a293dc506e543802158b3c1f6138b3e65be5237b9a06a08527baef2510c0ba474b8c16e21f8920276a7c73dd1874784dcf21046580342d90d7847854d07ef2a4c9e8e2a3755e1115015cccf250017497a2e9002cd48af675814875895a4f53baad413e6591450af5128f06257aabfdd6f277c6ac5127d62c4ee7aa2a76e9bafed6b703c85e4078d6b1d38bb6b4b13b5ddd3d1a9fbbbb91384576667c5e08762f24d6db84d46cdda975fd7f10485a49ed5cf7997146e9a00babd5fde04f7d8aec6339cd24c704a36b03c64c1b7707741a3bba96e82d56b8d4c2dc8de6ca5ded96b236c6f8195ab5572d4294a69a46875b2ea7080da74cfaed03033430d47fcd96fdb4f88dd33c7168ce0555de83effd71cdc3d69c6e256100e17e29d695634e7f179a08e38c0ee893514b28a5e815a95d3ac35d8519133159e73273d09e95bd4ec8f60e2e520410931f51877f4caceac92445977de2572aa223c9248bb01122143989b4e3622dcf8ca14bf3df0487a13377ef7979c156c6cca0139fb34e5789f734976a8d968deb2d0c3684f9ff75b68606829598c137aaaaadfad8f34a554a49543115d1d6b022064f47fae98d700920168f56d3ab6bca4e14fc6f8c2cd048fbba1fc150ea9f709142a0ec87bddffe237eee19530c0da3df00629289596204954853b2e7e9b62accc917038994fdacd4b63f641b0e0e32ee999f1aa51601ad7f1b0371c2f9a20a4c0974a91f77ebaa6c9018a40ec48888b5d4f60bdc09dbbfd1460457ff69bd5c4c040b5850c20e95e13809c7f572ffba7bab4afba9770289b1a9dfbc9d4eacff79c6a431c65c453a14a82776050ba86390f851d72fc193c22acac3c55c10d9337e6a159cb164a84910758a3a9f467e2033ff3c7334db1c230445f917863195b5e40c7871b55f9962c22d567bb4d7319827fa68272fbccc030dcb66819fd6f713b75cf5f8d9cb202e9d55e1a5f450ca652a649e3ca5b3f020d927b9f9c7a0e1a0fd45d077367fb614a6bfee934b09dd30be09ca43fde233e1d35ad7fda8c77bdde50ce69dc4c83cf70c6833dde6af8eed612cbc9bc6acf1c34656ea7ee675116301c824b00e4df7cd8a291aa5e2cca7a6ce0fe5f380e486b2616189331bf9212526bb2c90d16d00deaad2e24659088ab74647b2280118c15e70393ab7457257cf1a234ce65ea7f865619d913c6f6328577167a689e0a367c3d6325ea6e8c47d037610faf7bcac29dc8c28ea0d4a0166b6fae585191e6360d59e61d0c45f34354501e8deb086eae396a44250bafcd161c298b285798865191b8a0b4e13dbde2b669a63e8b4db2f48d9128396b57c4a6bc441dfd13ea07d3d499ebf522774ed86c04a4c3179f63b28ea379c3d6e2da109929b82e2013abb95c278e9cb9e91005ebc5d16ceeae59ba11336727522b8bb6294d8558f55182b20688953405b71344fa881ca477141926e796b22983a20ae5ea2a29eca1ed4c5ee8bacb4212ad386f0fc6ecde53c5f95f36d17595f988662132c158bd39576a04fd163c16f7475d9c8ee7affc65801843d23741798562f1e0cfa3841fe7ef5aedd3496b7e6c6d0536bfa761a7ef62c48570523236782a9b6d70a783de3c41ab88da01f92d1d3bf5e9c561d893349749f394f18883ad281081265dae07ddadcff3ecf66d07091677ca7c9e6aad99d66ac7ac17a5be500c5537b33a8250d9b2f2ed28cec5211b674f6f31da159a8d6beafb909ba3b13d987cc16e3acea0fab451fa525055591423636135c40b5c73d86504ec2fc5dac09167cd609cbfa5272095922fedd2a2c7fb3c73df2a1794f5e3c466851df42ff5f1e742511ef1eaf49dc73beb18cdfd4eae593d37bf7a0c13ab3fa3fdf630a7f95a7919ecd7068cac0c7004d008473c3b448ee25ada37104ea5dfb7687a2e2a628ad27819f48fcb4d1cea76d3879f0a4ea041859fd6038399251567be37d99c2d03b07bf911e5d0f7a01a0980f4248e678a2ca6f135a82dd87cbfbad69f3db2b1da54bd438a64bd8314fd2fb781ca366c0e9ab388c9e1da97502150c88461c364bfa036d54083263d03b2eb5aac3af61f61de77d3ce7db1871149eadec7b3ec0b1de7201c3c0f56f9218c718760246d760918fb41d59aed3c6a222dbd161d5bedfb2fc6480ccea203659a7b901c4108599cb77f3668ebefe54401ed760598010db10203e88341ab0a9153c56ea3ddb0da3083b6632481e1f80d9266e31332c92b9db590dfb7ca0aed8a5d228fb2278a7ca2d9283ee933400eda17dc7072794ab9cc45e4d7007e33be468f5253c1121181942826fe4ae3f3f3898aec913c2d13afc4404473da7352ae284c1d5f9922a8dd1e96dbde988919315095582f9006d7d3c30a429359bfc9c2da44a3281354ac180691317c4696462d012c0996e34d23af078007a1434e002f8f1cf7a4276f5b5d42571cb7521914b9e25f622524bac09a08e4830ada6734e88a7956b63cd4bfddae07c8f548321dcd28da243a46362ee5d577986190a714bd3eccdc1f30771f88f3ea7b792a9b1228331d09344330915771856ee578ffe34eef144e5a75a47283c1cc5a08c65249c974ba18b602b33cd58c36759aeece9308f58181746ece182d779222dd37db3ad2fb7044c1df0b59277572ca33177db0d0c8729a333215a329f99e66add56a85a7e0be8483e9c8f73e530cfac634c061287a3306612a0aba48039aa8d247216a5af7091935c21f8765e0f6850862bc4bee650c0b14e9474e7705fccc784bad14b124da443ba0054b5ad101536a485219f71fe350cd857af23983cd47f29c279679b1d10bfa795ccb9f8df4dd94b37796df84578b93f8625068bddac3a6496c5ecb003683a01a53d780a9af82c2db8e3efa1875a23214539dc61b78440cd5e48f34c0b9674838e1c9e218c8e0915ce287c5ccce47a0276910b149c36b2abdbf8189d06d1cf6119853a9f3f11ce639b328850f330ece2f46d863a5626a27ec9ab81a77522a3d5e81771f6f4fb268dacacf4247bf3da4977b8fabdb38e4e625cb0ca5f4bd2b243617d1bba6bac0f7000f4daf369d88ce6c12f2b04321eb1d2cb51dd3419755f20a3ba81bbd6b1942128d204b475a5758a037772a9d1c97fc8026b85d96285764399a88fdeca07c3d9204da1136b77347eb971250f801034c8219aac8c8f0ebd87178c559f1595fc7124559efb6313a372e46bf4ca07efa4c6cdaedc27a169a19fffc1f8d6a241c78eebc4c50a163c046b3de262e7968d29150aa2f239d6d12fb29644d4b77583df5bfcb24e9c90a2cee4e577633c1d9505986cbf86b3d42bdbb1bec8c50c834249bcaa2dfec888ecb2b6f40e51b0d2c6723829e5e381659e0dac6858b491272cda99a3e35c025eba2b7cdd41ffb1a5e46e3d524b26b7850ac0a887da219559914eca9273a88d900acfafbb224056a7c6334b16a0bf121ee2ca82683cb1e1c36aa8288eb5e5b117752ff514c4345b0bd99b23d6586f8a445f4fec45133367135c2c2b68413d3e70bf6e4b58caa8e76dc3597428b246dfaaef11a493630757c4e743eed562c8595ea5e26816cfe117cbc51612837c9a7601310ecdca1c57e91dab9bb9653b82cadf2a2ffaf8981c9ff1baf927c761baa8608745d278abf7dad651061dff8a3cfff63d921da5c5ebab20137fdee66fffa70fee064a1e7b7700abfc9888a07a3a664e73e5aa5ea635e5d018b556097a0a4e64f4790243a323eb92495c73a81176a855d40fb4b69f85b37baa6e43994c5cc7ec485f905d6bc0442b1ed33862b42f4f0920b2bc01c219eaac7893ece0d9f06b73340bfcad4003bdcf46cb47c80f1583aaaed25e393c4ffe7ca62cb791c01ecc22e7fdc4ed806de6df4d771eda20cd2c677ac22575bb2a0ec3b10da7a293c2ce1c9a94701c4d0e0f38859d8c65517034754d64878879b3e3d00b83a5ca181c84f78e1866b61b4b4ab59cd5d04f4b874d7a0aa242ab6f0062d14926a792a650ac1e4d44cc7735117496fb08757c3280b06fdb14cd3b5eb4f37e553506dd1c68918859b18375c85755e76f141b0fbe405960d67011f98064397bb75bf3fc535ff9617e66104edc952d5a239239d70232ccab7c33b30b58271ee207818a9b7b26a94db990798f0fb3a797e5dc9345408335e63372e9df1406e457b8a444454c005dabbac4270ea4bdb1fd313af18d968e2cd8f52eee5660410bfecbbc1310f81ce26becc0f199961ae3c23ca9c80d7131c984ed55c59ec5a454cad3d91fb606ccc5d5eb66ac3acbe9dc436d0b48905c7e9b6ae0cfc6164b7eedd42da7866024e11d083b84d278b1e5497ee17f3d289b02a8337a58ec1a1ff13f08afd07243a665214745b2a4d96fb0f1c6bb846bfd552e91e2e16348973982f509c495d0a673b53fbac4556e4e5bf95602e13343c4f384244bc5f69d6c1e73424587794d8e7304e5170f32d571fa8b85d665f8eef2aae737dbb72e1f1679a77da55207538e56fa82653542925d0206d32eacbcb4a9188b6a8941a6abe50ef4241397ef082e7260d4d65a0d879fbcc80b91ab34a87964601af7f2c2b1563da992c10189564e4d941a7a82046e94d3207d9cb190b41a305962bf3d11e0c7324dafbf646b35c16487be074ede40cdacc85d3c2ece237a9c550128c6e73283dadc924aad52ca03db57ee25be53f4e2a8bff74480de07ec2618016543ae1c2d4f3a931caf4c6fb04e417d3eb249bea79ffb99a6ef2e0f9ee973d047c7f66d1db7be5d1174e7178fb9bbbeee2b4da93931324a14fd32c2ec0fb8ac5b7230c3a6fa295a763fe5b6c7d677323259768c217f64145640fbe4abe69db70c3c05bf20bfb89cc3400d4b3a51b121b49453e0b1b67faa191ed7bae657a6275d4a5963404eece1f15109ad727957132c4c46bfb54b657444948ee6b61e2b66d834165089a1d6523537d2b34fb29998ed22019408706eeec0693118762ab03eb64c7779e1b7686592233184954c744155e8f68fd1d46f814e0e12db4ae4a8131f81f7caf37b1a56b286623fd1a3b0bc2dd606209ab3661c4811f27e1a96bdc787542517ac3b85c7a7de3f42a2e6a4dc6e17e1129ec3850fc5029c9962415a1e495be8eb47d0a090eac47c186dd054d973a65f26d860861b736c3e93c217d0d98108e82c1ccfa387f3806838363d1dfc599e7e73d5d15899da8039051ecd0350ef8073a23c795532a8d2811709d256513da9448923648561577d0543d79f102f77655c70339cf3ed6650d358078cd9a1fc4506b6882a3acb869b5ae7ea027b502ca0d35f118dc5c6885bcee1a078613e098dbbf5b47d3dd12f0f3ff4edcac25956af74bd51c6b7b06081dfc6c61f266161481e992a4782721aeac41e6716a48e9540bf9fd0f43091867e2945ba481f88916c64b133e656303d77acf29ccef6bb5e4c0a7c408c43b69a94a2aa7284f63318b1fd29dec81228b51a69b631fa8938483d6f7c57a33ef733be0028f860b329970d2baf315aae951f18a90bb979db35cf2d6693134625fe98b5a9117f117948a3472d5e763f18b247dc8f92909650790b3e440b2bedda923d4b8b8eb502145334d5246979b9643403cd8b5d9b3d25c731f5774425a9c4744f9201ce54b31bf8ce3fdf66875acf39c0f7b81e61e119ce252df08def02b9637a761cfa27dbec309d566c53e6fea76e313d99a9cb8712fa284b6a8880625a51ca51a7ca5a9d6998fb5b4db243d4127a9993b139662676b7cc4d2445d6d78c73139c9a3611d1d1a2eb55a7a1f526ba488ae9b1bcff37d5f42c21a88c6ae52e28846e2b4fa07f6b0ded219c3675cd770e1dbb09030297d420a9e4d0c4c6e2a6af2b73d5854fcc5d675c428dac70140f8a18b973a0124f9699be16bb1651371cc61fc9f936b52fd5becd1f86271c694f8effdfe541e848b931d41ea21bdf89281869546c51f10bb372368112df3e8ba8a35661e9eb141a013803f22c0ea288fdcec892998795a2ec00a7947fb153c004c3b330bfc86f6a0b36c537127097a2a8c25b53ff709609bf9b3e86c7a87953afbba97aafe9dced5bf7bcd6d869d1aead4dbcaa26a1d142b3af43450dd4815e5dd9ab1d6b3da2938c78e7c21589f0abeb13407f224d398856b29b560085dd68000973e33068d33f2bce6c0f71e74888acb1289ac671c71a003e98f0f574b48a26e71d668ab6fc3118ef0b536418dae25a40bb13bd4d8158f6c7e1f0f0b680a38290688e451b8889b4dafe9060fcb73616e346cc34cf7a052d617391670b7884d980742d4694548c7033b4c165d8890a0995c13d70581d277273f063209fdb165771ea71e6a6c59654e5667f64eee4b7469f6ff36bd15cd3ec0d537b1bd2550614ff8f37b45179fd1f8e36e3b847ecbeca58ea6ecfb080e1019e9498f2b072df7675b946cdffa74ce9d1ce8420b7b38e7fbbb20fc2e88ae12c5922c7ec76263f3f15cebe1fb6e710499627865ae52438373bd6115ffc40f9e17aef0d3e0b046dfe671140beadddfee7644471865977854e3e1513eda4c1bd96a5b1b461ffed60ce45c6c894c9259e0897d6f33e092f4adadc6ade4fcd7ab49c45ede711fdd6767f6d8a7cadfc1e001068982a7bd7b57d03318d58431d5d885bd4dfb3949339ac14aad3c330e93dd4eea41e9d3275dd303bf88939196ee07352816f91292948fa6ad62f5a4b691b51552ebb736f339f336304e28eb2dc5bd88ce6290d258d5354dda5730e756293874017a374387fc375df2397122455e9ef43e4c874e9cf7cf64236843b7557610234897da2ed574b99f95efb51ac18c97cde6f757b72b0bda342165d297a45cfb15f0b64238f431e7c3bb20d64c9de4fb49a64facb1f399b495e529f7ec90c192be72cd778db6df9fa65025362f8173189aebc73b0bfb466655eaa3bd024eb922bf97d2df4f17b3801b3431d12f373290f648276f6f5bf8a63fb8b4bfcd2c6896f041fbde2b2b93c1c4c420dfe3620037619b12f527c3ef2ded42fc1c10a49a3b8a28d70ad1c4fe7cf757feb5dd0e29e307846c7d6dc07917e3026c3b5b0ada6fa98d706f6ea14f43975d9fc5cfb7fe290b965cbbef31bddfe100a478670e4c0e1b363a66a8e1fffe9c13c842b70fd3f3858d228712b86cdf285d227159f5c037f77e949deb60b45d4d0ab92bb93ceec76fdf3ff40a3e81f110117cf0f100293e6ae166e6097ef1b46f4d2ae62e44ae19d96d767f2b92c160bf0c6ec218c44bd24dd51dbb73b1229412d937a0354a247157c1673b08e0862787af67a5baf2476c204d7fc443f8be9f43e53ac9f201d29d719508e2f906caaa187d40976a569a022d02229484f6d8c388a43e32a7c44b2b210db3ab2f3f391d32057a8436496448dfe15e13bfe0475354002beb4d73b84b070621dd06aeb616b326773a185a6308b852e1e902691a463704af8efd7f976d64c0661daf82d9df6fa220fbd5823e305ddb5ab351feee14cd6947f5cbc37871c4b23e7ed0b617947afff36c11bde58a35923e407aa24b30d46bd636baf2032426dbd8e9f2283f07194da8d1501320d4b27295a53900849174d71bbde399d42ac6f83654967d122a2076adad44b0eb91fd52f374a7aa10c33dac46d0ad07bb258259175b5322e2966e5ca6d1f60d3c3057cd7b1acae5f6704c8e4866f9f3caddea04b4e05fe49a6433f759aecc9eb322750eb5522646c308aaaa0620a43cf6a92a0a1e6512ba449b707bff7bdf28bc33b08021e2321bbdae9fa26de1328e3d5d3cc10fe1aaa154d6c7ad5605864998794096460c099f60f037132bda5fef223c1e3d7096e4cd4d8799b947558d921be1e03b7a4e0fccab96dc99d698fba3d33f480774c5154418fe77af5dbb3bab0fe71313f36cc66d54437da64f19e59f158a2ca12f34cea4551439e2ac873d427632286a4a7d46699f55e72222573d63fb38887aa08c5f31ce23a233414f155de474619e24fd39df20f530121b73ae4b02518649180817ea72a16a0876150b25f07138edc5418618b104cc159ab5875d6555ab0209aa771b2604f68698846b36b239b736005ede6107ce10dd6d2d79066b4af99fe15d90f0ddc52007e9ce73f28b3f85cf04d40309f729910a6f66af377bd154630d197e5bf3b421edcbfc72700e8d8c78a3a02bde93dbb50ad830febcda22b84031e0de9c5d1b1c4b287cc809f8807e73003797a62278204b731435818ae54327830b671d5dd3c8e2aca8b043fb6e1c41543a2f086b9abb301194e1cb4c6a0fba3d294b4e8218b3b63bbc0494b20079e741aa6f9fb67262617207de11914982bcc7efddc1b49382f870d70096e790231b4587815b8e46662453aec76ff0e7b4f0ee8ff0b2818f4f6718d0649de92fcb38df6a962dfe6b75c6c829c8906da89e8546ffa2d554c18a3a23bd6266fbe08c9537a6350e08a1da3ce6acfc806a81908d4275bbb7ab21699cdc9d1d498f567c1cccb9cd8bd383ef10b8cc939015372a5dc399c3ba4733b4fee2a82baf0683a3fced234bef3ae36fee8eae3bed2cae766b458e617ad3836962755a59b72d25cb801f4c2674baec8f0762d94ab60c55553acacb8d82d60d9100f2424f9472bcaf74626dcff1f1a44009b013e6037adbd317caa556052fe2d24fa0e93a7648c9e320085611d08c8ded83fbe3aeb224bc62261d0cee02abf3fd30911f1ecacc3669947c38e21199f4e5a48d82cebd1261aac223e78eb84f4edd2aef01d45d7578bf965908b31406dc45fe2143b9ae944ba51bedd4d3f352dbeba62952ae13ebf4e49b485d162dac3465b232e2888763b876b3aaa6bee2f2f5cddfc5dfef935521f14a6b896659caa43eb325e367744474c56521dc26beb9fa9613740e588cf66fbbef27e0d7688229eeea66b342656eff98d46fa51549582c3b2c47945c25fea8372010a1e2e4eef5f8d94e98a7ce6c3f5fb1a5d3bb166fdf162b80b9d0434dbc74bd6e1de596176f2a8f55f30033a8a378801d1500bee9240850c0091274d889041b15c68e577e772572edf2f7bc3bf05019b65afa78dd0201cca0aba84083b1a739ab54903be9a14b3cde1487e5d4e870f6d306633a0ed754b7735fd4f24c1cfec52c2f691565111a1866aefb2d054adfae23b57b95796cfbb86308a830c8dd70b36dffbe69c6147f9b48d877a8876955245c38af2a24936a86ab791eba5bb3a02ff15747f92338df140ab9be4fe249a95bbbe0843abe5b3f95961cce64fa3f1c9069d0b71a267d2c545c6acec522ccbb92ecc37a1e72ccdb6e4018b882b6863e098d3454b7045c5203303d924ce7893c3b17a5212772aa514805ffc2c3647c0cd33c24cf6ba4c9b79db9737e1d407a02764e0e2de1191d5763d0584b3523d8b7c2da4e9691763ea9858d82645e19ce87bb53ecd5874beaa6f9c5e86d2ba0e1872b2982272e82480fc57d28a6e9194bbe7ef0ed22efec7f8bbe5f192b70fb928f7799bb9695c4d3be7517e0f14fbddbf40b91d375e3bddf361153daa8a617c24bc40f06ad3ef913af0158f0a32ca49316eebed7a141c72eda4730d5ba35e0ced505b513072e89a08959d67174440332a419356d4f43e6d85ff6646bd26f0897d5e762d51355d31fb800e01885cce516e8b63540dcdff1ff9ecb70b2217caa0c22461a393df5cb59813e7fe0d60fe6f094f227cc70ff2220b1803c81cb99d42973f95d8a23fb2f37d47beb052722d0c7627658621a1404d567db483c9f3bef9c972a3fbfb6eabaecc2cde7b28b4e182a66595631cf097ecc4545563f5ca309ded17c3e149d3293cdbc1d7510446058ca21320618889065fd56f55aa452a89bf2e64611ce96d80f6a9aec71ffcb05b7591627ad28c2274fa6b41b8fdab39c41c097c36241aff4e168e9063e138618ef9810f1bfdc581aac2a544544faaa4b83a8136e232b6e02b54d7feea6331f1c7eac835ed9c2f3400343b1dc30a972ca0494e06bcf7af96e987637c3b92a04af620450cd40fcb22a41c39574d6d9d32363fa19aad5003b89ff990a54e868bf55817bf842798c363fb3973d7cf17385b10472d07b0b1ed3e6ab533a3e237f582307802b6667e161430a35cae2c4d651fd8a7dad93ccb851175006b7cc1474a4fa9f75109a6d2ed55e2cf2a75093d5848a192db2ec03493390199551807118db3b675d187e870719f0c25b00fd4e3f9e902b794f9eb265592e81d174892112b7d50b28e9db49dce0007c047675b124ff45381fe5c08c2a9a0bd9418ebec784c461d9149640743c1334cf5cf62ffc6f2d8374e4f79c9984e7926fb149d809124b224919a76ccbb3df134123af84bf46a394c863bd71d32e28f922560111fe45bf9049a5698f70187335e2b96c4488b6a65f39e6503eae661576b906303d39a54d828d8ee244e7c3a8b21e53cccd86e2ef29ac58ac5a26f703929bb16ab2ddfb5984c4358ef13cee1fabf868d6bee3001e450bdab1a875f2e5407d79cce28e939a5b2c65e7c7574ea1bce3ee95ca418bcb8163f6e25678aad2ad35fa6fcfe3d0e785de288482742c0a52bf602532c1c51944b18320a0bdc3ac11ac6d9e414c2875156443cae1eaafa1c59935c7836e9c73c6562b32a609bac1d5d4abf1e3c7eaa1628e8403472413145531d259d6fb197fe6b369809e664b15243685bef3f69c24a6b3418dcc57ad8113c5c91c2e193b51a37ed3efa07b4a1f13feb7ae151542b22bf39d2e9cb35aeea9f5e34d3d7ab7e72b1cc2653696abab73f8aceb935f3bcd953efe495cee2f27e82e4f9bf1977624fba318c69f0862e3d158a0aba180da3e9553ae293626b2d7096c34cf9803224144296f8ebb95a1520e3fe09e2013b556970d50ffa7de3e49ab927db781273e94257b20e47445976f5a8ab62c54f2456381970b17fbd088645c3933e3b1967f97b6555692c95e7d08a2c5571d6b39e1c4b0b4a909136f0d55f5a45a00bb198647891771857fab9b78141936ea63801032c1acc0d640a0ff68e003533b4579327c730e09aaaae3be5305d1f2ed3d98ed53b7b447d80e4e5093b24b959896e0c579f509d1b52d00ae2f221c0171288918e59d9b38157747e8f182850257bd1471e2338a95dbbe7e3327d1c151dd831fa7bba068d4050268ce339940f793a33fc169c87763058fd00f196aeb695d948d48832e86c9b2e5f2776a6100b2d9739686da25fe8feba239b2eed4b5533116157a575c5a90f6639e3e00655097a951cd5e16cc59973d41e05b8000013eea42a33c7c15c0e42acd0047a3ba3e809b7762433deaf3d60a4eb572d817e00e8d253d1c468d135763b17074852c624119590cbf9a2efc549fbf06ef91b529bd67ac00faf9e8b0c7dfc1007d22f05b48d7598a22e355ff6535f2bfcd49c657a253f279b5a94e8dba99754c528583a7ab37c15dc2674c6d3cc0a8d3d9d4faffe5f0af12f8da68c08179760e84cd1c08e4ccf216b13911cac1eea34ab7f2ea976d412f6a7d79157bfdd419eb399a40b688beb828539874371534c54624da4c6daf47ad89e496fd6921e544598e2484c86699c5ce54c7ee8e083aa2497080fc47dbdc8912a9345af879a59aecc981e6a7d2ea2023a56baa079d52e3e7fc39f51127e762e260343951a34cb1a49c1346c45a807bef9e75268c71c8fad076f4fc2379a1a7571c6e5a0fd3c27a0be5eb27c24334443beb6290d230df86d6f4e78e606b317a7b2238c726cb24e2631748f15c89d74a1517f415db5eb03ce50a3014b8edfc13f5fe0cc86dff6fdf7e58014194f96674b8d52a6972d1c84d63e1ee6cd199c2b33f11ed234cfa6a75a6c1f319edab4c8f60d677506c2aac04d2e484bc9145f8859def7c93871d4bacf7d60ed8f1b969d7ed5a959abdfde46ad85302d81d290722b429219ba6b422f70ecee8766f4b8e84aa5cff80abe0ce012958962b854348c1dc678e04ae3a9fbb816354e042279fd7e9ac5b84aa9b766e6d9f436125e7b648455e63cf4e8ffb0c2deb19fd1823863d5fab348478e396b6ad7de805c2076a6ad94ebdc205a2a65f678f536da56b13121ae05770ce55504cceef902456d86c6778de2c838518ef4fac6fa899d57273470922af0fceaff23b16231e524a8fb11f291e2472c6576e21c591b5304d507ff05465c41f036aade4a6a78f9ebcdf5316c1f4bbe1bd4b0769e72314c4ff2d72e7ba674bd84e94600c9118ca9d384b181da454be11b8ce808eb64ad7318eb1cd10bdd82dcb5de4be914954011a05f3fa38f7ddccddba00800ad8256535fd460ea09b67dd76bff00c36ec6d6d7eb0840c880bb88818be6796c087fd0963832c585ff6c776f4567950cc3326afcef32c8d5713f23657061da307f023b9854534f952ba8b082ae885a3eb82b5df8192093b3acf208e3f54b8edf982318ba1903657a3e2efed7ffd17235b90fdde66134140b5195d0d0e97054cbe4ba9ae555f16e9dd0fa1c92e8af9fd874670e8a5e2c560680b151b9675eda2d3951fc7a3d0fd2a3001cb40604b5af3b70a68e9aeca13ccdceb4901e4d3b781b6bae6abfee8de134dfe53ae14e91fdca6efdc69fdcb0730fe77c80b20b26aa4687358a725232854d76492a38ee13e195cd43a03bebc8a410cb83e8bc5d7ee44e3f45709a90559b418d4952514052d69ce23a333b75a7023fdc4d3e38d33c3a65d67c41cdace61584af9708e9711db7dc66138f318434ec434f55e27b1e71b888ce16abe464fbd3f28c28bbbece8d32dcefd891bd13efe676ccb48e2b3a3f9a533233619764936ecf841dbadbe340ba3fb323434e9fc3525c9c1e22f51bcee0bb31eef31fd5d81d314ec3c6eca06ed3e4b9b7d5f80b53151fb9b1ba60ba21874a2d3f63e4a649e7841710efcc352f7eea20366073b633e92118fa9c7f3db15299b2785bdaf08633d0d3ba468fdfa4a1ddd998b5c541986292467cd53664062127bd2e189e23f6f1c5d1c3bbe910bca719cde129c5ae8a05bcfbf8f03840e31c7f5198a1038d51874efb74ae72ffdc94b86060647327b876f68e5fea249395501d14df7a02cda02cbe4c619b171b183461a60a9118de96041943726780275b28730c83172ef63257294f3011d4a807efbbbdf989eeb9df819a53c0f383919b1dbaaf56f76c311b13b5100510a1a3475c3a03cb6a6f40f6530e3f0b3597b32cc5712e6fd2a4c841c4c4514760522b819ea51839144219055c743e4c1f5f2e49d29a1ab9c1edeb61615667278f5cb1dab606d7b22ed0433827b1c0824cbac5380e9ed3343f488d2a52958b8b36171e0c68964d5aea1b4ea51b915ef06a37a7942908a5d16cc4376818916c99b91fee67401eb7841e63bb6b198a0b9121d02f54633d022d9665b4fea48d83ddd9bf34df60cc8b775db8c15a1f6c610f70ab3af25ddc66a8888700f45fef61c6ebac6050c3f59de8681d1273df244088bf8c9f9058829001ad21f62c664250de918c7288f7a184ac54f68dbafa6ce3ae52c75012a5d88312b8ae47f298866c16840415c565a87138d3ab5268716ae3d5d55570a8ff67a2ba8079fd5b12f7da26b5bb32045baab79c25c863b7ee1402cc5a48259ac9777bb0e8fbaea18c0bf5ef8fb31c38a553f69b07d47bed94e6f389643fb79ffbb621141015b200728d349e0398991c5c2e5f49a6ff0d2da29f40776e217b530b11148afd7709bb028ee9ef00604c44cf86b1c579ed0e6bada8596e80ab4b82845f093614bff1e7b095eb6baac66eee9e7f4cc6093ce1945a2287f8e80b58b58f068197b66e1728febabbc93abd79d26ce43ad11daf4a4b3afc0a54cb47f4b9dcee22e6dea02f475b4f629b5c2f0138aaf2c9caf8ebcd2fcdaf18e09c33db62b01f33336346889a9343cbf053c9b66d86892e95b75094e87fe733e07dca955971656df0cfb5b4f3d2b51c9841a00004c0b2878fe66eafd9927778d5c1cd3d5c0f543a0696a338fd9169dc5eef128d6def356aa70c072ef8e3c542c7f4fa590965cd8c83fe4bd723ca56967ceb5242bdabb268b281ff8f858f664b7ba40082ccea245b940ee97bb366c86b8b52ee95745c85cfbbb1d60b52df655b819fe3de7c7758b31f232cf820560f20b1f3f2f96421223c32adfb12e4a9f403da5bd477ae54f20096751536f5012bb5771cf524d54ee7502f2f79185a430c92918a9f1191912180f9ee57c49053e329019205a95da2cffb88990d791425b02f5c6ee618d019b6573a94ed68de7ea56cd6b3976115940d7b2511227f2f9e9878f2b6a14ac8ab86f7003ef08b3ac127585e2d839d980b6ae96fd5feb6e11b7aaeb3c8a339c11402b2958b2f59614b2f5e6e90a8b696b30b9c3e9d81fc9a407d5e02116eb4c3e54605cedbf8578f156504a6601dc75777b07806fd54179d59cd1cb569d052f4ad8c3dd83f27bb5136b2e1bc632f676e2f9bbeb9f52112eeb5a2ce054e53c72b166d9e68358ec660610031a1f3af967700dd0cdd4ccc3df39d9538ae7c8f43d81d6fece066b1bb945277bc717de7698ec87e01784762cf5754d9d96baeabdac204e7ffdc1b26506af9343123da22df3fe3bdb258f3f0e499a71e86c262b5e4bbaea31106424eb1a034ac1e1e8a66f3dd13d8cb6fdc29a4fa4620284f7f573b5dbdfed680f40164dc56144a8734abe82f81baa4e8291776b43d4fd67bcf3eb16de7a816fe09aebab081c39a4f6a5af2357e0efd278c0b94b2e34f4223cd87af1ac0517fb1e31ab367a34fbb5036b5787e4ae12f1deb3e61826622f8827b5001c49658de4664e2830b2bb98f87202f239dea5ea0257fd05ba6649dd2a7dcf7b03b779da1ed96376b755520d9c4d0a4d1cb7be2332eea4bef8225d19e3abf22c911d9c25a7eef4da1ea97bdb84729c3a5f0a415a4a339d1da91fba3f8b7a2c2834b2a7c20f7d1222f4393153f9b440daf598265347bcc8b5133ae3a7139a9b5deb2891f7cc328695402b4d0cfbe06ae506e34d3aca25d08ad6415af9b436c1bbe8464f6d4c178a7c94084b47dcdaadc5b445ef30798270cc4de1ad36735f5f6eda8ef22225e8818b28fc802d388660e4e790d7bf95111129fb3de8f238a71df3e497cef59ecf19d92b084af63901cc9c0cdca24944b38d381f9c5600843b59a7dceb4d5cb60bb8f8ab6e4fbf445ffcf8611d0b9f8565a722deb881d5a96278faade8c92d66e9c0ff2421a80e7c38d0540673283b6cff0d61fb7409697878ef321a88f6b6ed8b4779d1270bca84f23f4c8141f24c335341ad440a68e924dcf5fe5a41137ee893bbf24a91152aae178a213c0630493a6ee0e58eb64ac6763ecde85dd67cfa80b4c8da0341ca55d6c6b5ffd3e74625cc0d269e6f7e216f119ddd00383b6050c51760f512c02f97f177c86b639c8da10e06cecfa2c01926e514971c2689ce27b3f53b9cb06944b0364e30bf93b63067915ec791428878a906e4f6d1d06a25fb5d89852c74408ed6e49f0d3808afee734ef47d7c768331cde4173045acecf2e0439433adf3cc9d1c075235a5ae1c99fee65d1ce3fb2ca0c2740eb5258b3120414d68470541a3385fd77ad2ec2aeefff06ccf1b997c815138ded257f64d9fa01b988f9b1e983189ff176bd24826feb7e4b9554e77f9ae9d95673432c3a5ecf128cb85725085ebf5654a35e07c18be093447c8a1661d6cc46a403285fa6734691e3d665d235dde138a0f7f44077e550162ef36dec6e12a59faaf96c9c55f1ac88e4bb2e3a4e6d05c3ec7aa834c48a77cdbecceef54010f0fbb36016f1774439d11aaaf7732776ee3976c3022b8f20e2cb2136d18a1065630017aadf5efea8babdf14910e2a3944a7a50569445755f75413cf2e74629f126e2763d06ffbb1b40ba9dc91ba8c7d9d237365e13bcc3b72c46823289e543d2839db2e1f973778123de054c119b91c4d4320dc3a6990aad3276df3920f5133eb3ebaed1a0d1cfb38c516f517feef6e4246106201804c1e5188cc32322411bafb1498076393e6fd4ab166bfcc1afe882dda3f3447380abc7643b9d52302fb0e8cce26b21ccf9498477d05e1ffecc270c80888a0a96476a1fbd3efc2f08afe8a1170449ca3776b4a0d6f01c5d994e29a0ade13b03cc63a1047f84fe9fc2b5b154297da6963c380e73904b5925d8b8660368120769da2fc60f7c0773de869ec1e9c440f7db0222acdb6b3b7616d34733fa3d5969e5d7668c56e938d36df716816b689fcf78f5f7bfcd1829d08c0ec91bdb34baa2728df93c434a700bde7f9f42d016067e673dabcfc99c9542a19054da4bbc8136c0c7d684df4ca546b3921b77afdc0b44f8aaf32e73e3ec07e2a5ab80748d53e47e0da76c8f7d44aa472ec4d3f2fcf068e6caccd31e463fc1ddbab93b7d37f4dbe0bdf8f82519f224011f014df8717a37838a85879b58e44ef529e0008dd432a28d34c643176a6b295641cf8b2ab4192e22bb0cda6f2f921f39a4ed1161a729a2cc11aafef8795a72035d9e4729334cbb4e14f70e1bf2d77d6fbb25869e32b033c813fd100881d56e7739537503c270c887259562504103b7bb873966986608526a61b92849628f0f3537c3163a0972d64e79d619f071abae368633c2f1406d111937a89d3bbb82eba5df1321b318e9d3e513943f0e46009ac270bac0a0b76f1df659736529925fee2e811191ceb25463cab2bd405ddb55335f46e42a856cf17c053a6f230c8396c3648ca376e12c8507e07e219d704ed6a2b3003623065cf3d3cfb8632d0c931a316addd082654106e5de84f65bc8f480d16f087aff2f29e4fa82005531ae9422e3fe5117e3f0398e4d5ab99016b1024b2b468503ba5ade006c022993a0c92e0df27e92807128fa39bc3cb294102dc2a2d48ffd33973b01aee648bb100aad8a541b179d7002f18644ffb3e7bc763c749d96d200843e0d63407443cd6c0b38d4dc5810013b95e75d4b5abdebf21ebda943b03e795438b6e6ddde9be58ba8fe4fe8e6f77608cf7f547e8401ba08f8c0943aa65252ca0ee9b87101205b8012c49bf48a46d42fb99a1fedea44078f90002dcf61a9e309853b15e4f70815aaa95e60ee9a25dd76193514dd440f343f77c83370f376746abaacc99627c39aab028470644f56bfa9ffbca486b869e0c73da226fb24b1b2fbb3b28b2e4763fbb05d7953646a4554e0dc68fd1aa9f6df0e51a72553ad4cf55374d05ea40b02e4f72808879acf8a501b7dc7030e0eb839a711402bbded0a837ab7f7ff5ed0d76122fec91a7af1cb440772c1b14c9f55042e44dd88382cc4bbbd771caab595d49b626f8f9798b0aba11517f13f882bcef23276c5e846f2f107a852b43efabb091da047a21e58d1385c995c2e139c76f078c36f210d2faeaab4c372190158d24650092d342fdd10334d78854042e79ce4ce1b0e0370f4b2b37090c754f23449d72fc7ab0c2d6eaf9681c7091f6fe3b61588cf1ec4eedf54c65f5fb44c3fc07c6e3fdbd59e7f6d9abba8abce33ec717b184356f342ebeab57d1a7916abef5fbb3adf8180905d33d000a2f800a36f4c980f10f675ec1edfc7d5266a37c63aa1a64194ca775e94410d7afc0012b1d3fecec6a7c1ad53eabf428213704d9eff7216b568d451e3ec5e810e65dd423230391826b7682d9608373a1d611d5f4e95b3ba6256547442a02bf08a7b39a0dc2433ab92a44b038841f9b84a2b944b4695994a2a96d81e886b2960a2ca7e4db7aae2f8f857646ea3887aa1a53ed9e50fac7703e7c741f7f29b71aed52f472d14a929d9a98181bda482a3c76383a16ea269d97cac0766a1f831244cca0adff8a240650762a8646c982d2e915b6d8277187474cbbb57b01b011c24adf9d0dd49b69bbd8808fb7367ae0212830682f96e61ea0f1058c5c6a5d76d46f8a95f0554ae33ea4ba2d58b963f4c22e1eb9100e8fc1fe66f6f9f0cdcd5ac7f71707b794178f694fa676fe3244bdd77b18c62e4489a967dd5fdd923c088f1cc7b6c7fd055fd79008b5c1efeab305b5ff45add0ff28adbdefd56376b87f5c20fbbd3f1d21514880c5ce1531a31020b306a153eda51fad584fe5756e3935fa07e15214d2ef12f46f72fb58ed1033f1279df1acdc86a8d64ece86a917cebda86d2dc74db7b08551f50dfdb02f7fb2189cd2cc4ba405a69f777e7f223b123860e14da9ccc516a25dd1d5bc58ca576ddf93f3a43729686491bcf56e1fcfdd39aed460e8cf633542a62447d622610af507ce7155933455e9458c3ad816dd3355e643444c4de41d62bada8e2963d6fb641931bd2622a011577c9f0ae3e51035ee91f0a4aa84d60b39c566f7a71bc45397aae2ecc5fe644ed8dd4c4c3d8bbf7a2bbb6c4f35bec91504d6be26e476b67fd47e5fce9711bb1a02c60b59b186667b404e4d85f71df7bc03288dde15ebfbbcf03380da73364812d93ae8309982f7470b4bbbceb0494bf917064d42a9be22d2593094e0c1c623190477167984d06fa5daa04cdad18228fd777e63743626ae5f75f4f5011a97da32058f10aca8d38557aa816929d574fb723e580cd1d5fbc7cd76a2f0b1c3995cbf83a9dd2948672de219cbd1b501db2fcd80565d562f12b36d24ee5bb9ec7ec3772630395f0cca88a134aa8ad6821620ae0604447a8427c1d96adafb0882a5b731ca8aa7866054e6618aa135498f805c7b6f992f2ea4930baff2701c897e21b98faa9536f8dee5d1027135de74cfce37a041cb54153fb3a9501ce926efb0fdb8c3d19a49966cb2b6f5d1e8cefba860beb01b3e442c6204e6536071cf79babd7caf739d34fe42a3c7aa82eb8fc4b5b0f8922404632d916cc85e641a3635474a249352b4fbfb8d5694514f8b3bd3e4a6b6107a148a8df4f540d509bcc5e14e20111ef6c631df59cbf6b1b536b94f900745ce82d480a8f5b2236aea66a902d9e8b4cac7b9987a3f33a7f00fb09201b49409c92526fd21433fb5d304470b66e059476ba4beb60fc1571686075666b56712a0a132f84f2217684e98a35fea299ca98b22c909b01578fe6a3744f1ead35c3d9097c0669c87c2642444e3b2f5bfc5b3d842af8c97dc5d5beb5ae4a9df0fe515a35b746550f098506fb0f3b940a536dc38797dad982210fa5c5f15411ba281a7a5871646136eeb42ded3f85b7918765bd854502c0fe10c7e4e205fcfb8073977867d82a83cefaf54a0b618ac08f1e761631f1346c2e7c36d6b58233d66a7c8638f7f433247180912df86381451ee1d14afb3a004ffd0ff518ed7b38cbf98383bbfeeaa0568e9db1bf4ca0108a8da8503eebb561a773e6c3241d286f70d2c4499168792a9538eeb6cf907d2f4306bfe58bba2c3ef98df78ca9948d58e81660f0aae1765f0a839d79e22b02100c792266b9458dca67f04aa10c9b4a536d3dd9fcc7488738a8d3983367de5281e4fb52f6f687204663983adb9abee3bdf418162d31d1142a24dbe69a7b287e01a8350bca815b9ce817d50cc770a075aa5eaed0b6e3536f2931dfe288b6b180d63e33b7e82d90c4a56de61bc63b1c211642ce9e30415da81a46cd5d8753b2108e0769e5e634a5154597e1be6925571924e55a5e8dfe59bc06c9e64c36775460ad62a2b8d392fd1fdb9cad2c9e22a8263b2ea02fdb134ceca5e6968ec56040c7815d909fb03069be13ca64ad676bffd6885bd27ed8a75db2a0a1360cf006b482cebcbe157786f1015c6c8170ba678973a74fa5ae7276a31a6dfa52cca44386fd08db0d5351378e452556772994a331a44a5d79be144a4fb9ee45abbf886ffdda5ac0878fe92295cfe30afee773a04d258cd1a1be96f63d53145561893f196d3251b21f1006f2ffd4c0fd406336e4974c79275526aad8f6f35c5b0a0cf724f3c5b091dd269e4b0dabfca96d2c3f9169938cfe28b7f678c9549e188df8ea43687edb0dddafad47acf0a1637abc18d156f82f7bbdc2ff8e2a5fa356c69a207596e2853ca13da88500b4a285ada4d19a729de00893b217a8ab06c39d4517d1e35e8421e68b7a19f26087dba2f77752869c79318b1a8474ee257ec4a6ce892abb157190687ae62539a854c0c814f06b9e0de2c8c5f3368f3ab9bca16c1691ddf31b10dd239c4c825f0e7f6b2004e3d5364642c3463ad200f720dced21195136e6afbdd2bb238a7dac5f5e2feebfaf3208f0adc17ee994edcd5bce3c6e572123d13c840e5be74fc41ff7887ee80b45ca39782188dbf00dd49972423be58323b2e9ad0ea92f0cbb6986a67d8cb99c920f9bcde28756bde5b9e117a78db3a6e250cd47cd53e7beeed854303d2c194409b0c04b881d1a63279e90dd93400d9f5953230fd52d48a8c453020e1a533a24b501ee1f8a4474867651389f4365ba974d76e1d03cf6784c88a389638896bb18ce192b65143b8eefc5ec86a1bdc6797fdd354a7e0323890e28abb5be2756d4b2101e213617ac610095eb2cc1cbbc4d64307eb35909a64027f5d129061c1d149651fa568c3ec625f657b266444cefd11c4d966243f1709eeaacf73b32cb59a994a378b1195e227820f9df1bf74895ef68f04e88c9d988ca40278c9742bf125103c7d1c3cfbc2de1ee3484f58841f61e3be5e10c4ba6ce6e7efb7dac302d28bfc7de2f2e4217ab37b6faf2507ec3f4b4dec2883e4d1a55031b53a2bda42980d733d741d613e7e6cd4ce7e53161befba2925686fb9f744a276ba91284c70d93aaa8c72d4b8551f8f1dbb2e0ac6638005916bf0f4bdbe91454c7cc31f303b8a8436942431ef0385b90bf9200478ae948c19b21742cb624ab6d70fdb3e18df47b5b86857d668c8d84e0f3d5dd64faa7bb0a4663bd7ebf3e6b94b6017417c2c743284279f4d3eee5d4440eef0f24853509c00cfde4e6abcfff0475fd1ee082574c31ceca1b2ee9c9e8be0092742cb23e13f02d3a4dba1e849c9334f8d0a78822e377567ae6c984a60c637e7b50b4652819f4b88b8f1a36fc7d1531790f30df7f3aec349975f4c84e735b862d3ec8b3bfa737b68fa1e9c2d0151450de5c961212d2100f62957336eaa968a2b8b92b4d0157932e5036ed52cb8b66543a29be84bab6d68d80b4c84109dce5bb1ce3cc64cf3cccb6c3fbec41b974758eaa646e3eaf49a15e8b862fd8280440ab9e57f0400126fa21c203f3d2be2cb4ce443a169ec19bae713ea0f6f258cc6dd0b3e6e97a2decc0dc4ad2de2f6b960afc838cd35cc0fa2275d78d5cb89839ef92ad756e0f99f55644893d1eab8cc4e15f3880517e75cdfe7832a3066afafae2e7fa1b367202386664cd88528a744cb9b01e1fd6266d0ae330bf4b6c54c2384c888aa26c099ff39d80087815dbaeb6588243eb90cbbf18516a4838aaaebe6a68a5d42deefff90bbe83fc10d8b0940c655f952a2e58371326615ab840d646c7de85ac529cb26f4c1533e586092ae71a258b541010901b7153bec6d8ce0f4d392442c00c6d75390de3817861af325d14113e037aa3a7aa57e0202ba7970f41a185367ce4399a60fe143ca42f2ac84c7d6ec4960c6cd4eff533adf6b3fce2291b98cb58f2caed70279105e5f493c9f63c9877b36798e5770b91381adfabbf851db59ff46a3972fa44a913e1c46ff6af83026871ff35292b03baa309052ab54512ddbeb08707e4a46d6bf73ead2610a219f059be33608ba4ca967dcd11ffec80c838d0f79dd7204ffbe5c208a9c3a024fee5318efd9a165fe3512af5bd8f885751fc5d9f6016023a7150a64a089c641f45767791e25e4d5143a5f127782721bb52caae80243e933481a5bfb8c2f300105a3cc19c6bba7938dc0ce300e85f5b76e77a2e4c19f66b75b6e9a50123c51b49a19c34cd430e3bc84a8928479fbf497f841be3263f1e62006ab3416b1b4eb7c09f7f2a27f56a13cfda9d09ddfbeb48bf0ac107d86c8fe2b65626e49925a112059bee9774e1314e6f827940f4fad2665253e5af93a092e62cb22b23a1f46a03f140eff67da30a9c4051880a6331400f62796b98c3b8e184a977dc3cb5d5714920ec62f5a2b3a2d936088ae46edb491b898a29cf25c55cd70d4d8ab398c3cb76ad9c11485505cf88565898eb4cac262b81f368f15695d919b79a1f4afeec28d807831035306621c9b4af62b7e5430ac80589e3ba8d7b027f0c4896688a2063d8914c7da285b8d4cb745240c5642de0673cbaa84f586f148ed362116d1be109ae271c02bcc3c5e98bda5689a3b037e40c059930cf6beb8c674867015f7a8dea3c5135c4c57d4e0416133c6161f679c236107a9276cfcaa640f1b5666644775a4f49d7086d19218acf1bb2420713f8440582926c82c1e5985aae475d51e4dc0fbe714503b4a0b13ac64959fd4d22bc89d7cb4c2f7d4c674b771c41dff7bc75f223283770e9cd4851e5c0946a0a9ab1c4a34a3024314355ee02378d1ef35efd77cc838df9d3ee80cbf2fbe2cb590c5a1a0688c9846015b911deca4bca71a838d1f2fdef610711111e556595a8c81df15c959769b38cf6ec93e60517cdf08473d1137ce1a72a593a7933584bf31833e269e0fb525f94c91a5d6a892beebd7f99dd74f1dce2f2e231844b98e8f97ca94b230f9b8ae703499f94c504e38be0ebca3ab47cd48b24f5601029ac3d22ddf82a9cbb0d754996fd818b6c4d0ee17f80c262053241ce7175af8008e1736cd89e25e956514e4cbe52ef67e574d2b71ba2d2e737f3bca7aaa0c547292a61fd818be6432c30bef050a4d37aa4015db68155616152a2f4105b6b4eadc4d6736a477edd86a3002341256c89a118bbc4bff9ceb8e5e70d2f2fa24aff962c32288c86e0b21b73f33e59963f46cb24f028e513ba206465ca4db59fa168de694b717b8f4885bf252b3ee3fe09f70f0fdd9fe29efec4e7406650fdea6c596aba157d9bef51a0430a75c6cbdbd03dc0d7a6469a0c627af08bb69409e69a5f57fcc0c7e732f36473ef7588585e50ae5f4ab93388cc44c492cb130d4e1e0b60578efb1b7bcb3c8929f6ca0d9fb8af33c208ce89d95724fbcae15c336713bca6649f1c764d22541925cad33f881dcce3887cf9930bf64fb89afeb52071854384bc4a73fe5366b9c330121d267619b72d528b981d1fcb09ed681f746ddd8bd5592668b061a6f79c952b9fd4e7ca293b56a5a26938892f257a50339dfaae1dba1b68226edd6b2c9b1db3783995eb2d002460d3c331abce67e5d7f38f0783ec3f1da7d8d7811c2ea374e5df6715a0bf322e95396add7e83cfeccc01870aabbd7743918153ca087caddb7178515736eb740ee55ada3150a443290e6b1d3eca727a6f7fb68cb2015fcad0f5eded84e295d5bba291f2b79bc85ad0e61e0f757c919a1663a64bbc191f38b4f408f2f66ccbfe7055c2223b1701387d20b35e9c3cf2f4f40c69afdc4733ce066c7f3ebffab75e87d8cb83bbdb5284e7e4faa2d94dbe8113face16e0ad2cd8dc543377471b18c6351e274788eb047fcbb8b12013c86ec8d9d64fcd329d35197d57d56fe5bd4eafb02e123259481ad916e28c2c35460bf8de87273346b44f41f48c2d4ecbeebd98a5d226f448600475f245dcd20123a908cb67057ef4b8bf8e3650dedbe3413bfe90b79abe660eca85b3962c213b9e014bd4d39c18e2c66c0ad8c4a399f975db5b55ddd3e2170cef7d185405146868341d40a5a2888f7ffff89d14a88244c809e063d0ed0c352b4446a6831d7f977899211cb7c7ad6fb9883443482077c4dba429a4854c8c130f0117298a178cc17c00f9898d14ea008edef2ea322f66d802a1b40f80cbfb2be41b598654b43f2d5784b2f721ccb980b1e544e79527c15b36d9cc772062b77fe8d4531ff27b5288056aa633c8f9b31d5bee9d9112279885759ff79c5de845dec226988edf612cbfeb1af37a41c1b9a696e5ea19944d070bf388bb88fe5f5ad6763f4e5069f9eed5d2b090f21255bace26310b547db4c3acaea5c8ed4df801c5b6f7d15a82478cc353cdbce9974c93c0a033990073739b1bbf048ec7b0d322a2389c3c3c7e4a555850e3522a3ad7dc7f6db92484fb5f3dd72ebd0a7f0d68c25d2b1dea522dd6f1e8591a258e10366bc09b722e68aa943c6136d67c8c0a3b3aaf7107b345884353af2fdb27586dd0ca27483858c3201461877d35f2b0c89872cc34b9a68936401dc35a5a4107b93510f81926ddab799455e01f9192af2e300217eed27651ab281391242df28b1d1f627483febb1af84201d07442256cf9296fab9ba1de50283e815a61fd83c6013434ee197e818cb53016715f87f055ad658bd18333f9430f7d04a6f52131ea9d79438cb5e5d32cb76d0cb8336ad5ba7f22341dc4ca02eee869d3a3c3d89b80d524b704e467bbe1cbaa6d5705976e475dbabbbb60c683a9a0e8fa34f23ac7c1e7b906fb2757cf5859d501dbe1789be09e802abb338a498fde0d8cb90fd95bc64fec63363f32f75e6a23549e7773d4d98f891603aeb0fa32eb52ac23e1130e120a6dd5a5e318f0f975a854f4ef6edc93c7723dc8e658ee97c167808936b0ebc07dd2c5592eb9143f152dbb879f39a3caaa87fe2b1ff12985d1c1c76a5b070d12ee15df7136d9ce2ab9b6f3bcfe6649cf6e87bd26798b3acf7b4c8f86544d3903c106ca24f8468d21fc00cf062c2c70954c585dd847588979bf99c650659ee1d4a75cf6cf87eb981ac5d3dae1d4c9d59b9a55088c5f4f2f1f97a2a79813b3bfa437b335fe937b42f2e08267c48158ca680206381eba8a848a6e385b58f02f0e3fe114f7cb6a91dc556551a341a8762ef2e6796f0a3c3f708889c266ec702a1bb956e6bcdd585ec90aebc44c2dc82b5a7b36c150053483190e96dcecb62c31d2268f98bbca67f857bb16e82f283dccd3884dd21b5ab96e65c677a2f9669d8a67ade83a70597f0d709d8b0f3ebe6eef0570f268fa070ff0317c0f0bb32ecb9662aa5d9d13881a38acd3222ea9c86eb8882765aed9705f1fdb68ff1632c9a490e1977641fb6b563278bff1dff21431949fad026085a82664141b5589b07eab003903e51b3f230fd933a6af60a77c69184a91388d42cca8830a567e9312049c74679e8075fbe6db4529656faf0809857247f8fb5bb2e62a5d0fc7085b2d9c627a7c7ddf9925eb59c0342dabac19100f99cff44a11ec004cd942bf2290c1c2f7833c00a460775f1998683901c95b6a52df883b0d82ace406b0e7f3f1f8fdd8e24f01efe2a7210131f95db9917d61ae72fc9fdb830ad4c04a13a009b88c60226d2ece880ceb897b2884eb960ff5200ced0ab6db79f524ce48a5825f1bab139d3bcd9d0419e97654073123fbf789ca3d647e142a701ca26feef60f05fd7f469ff42a628941b82d1303438868811280b26269de61a4a407d4136b020c17716718b3642798f3cc51bd75021b5b838e99e705c52dc1a3fc037b94bf7370e19013bc01c08bb0424a9d8689f4930fb5cff903d9d9bc348085cff4af9802f4245fe227e8c56dd3f6143c68117393f7b268bef940fac6b4a1eb4dce52c1ae4d04126f7733f8483b7a80fd633c985856b15403258ffca4acd7346b77ceec805fdd20ea7f28c65b114163c963648cfd0bb35d38f5f40ee36d72d58e94fc4a8aaa78d674aa31d79dd7e9f6b9f92b34b2af8f5378b8093f0fdfa7f5dbc74fff19f94e6c1a20725b172026323899ee3ed472397c728d9dd6dc9d4b669eaa825a8db56fddf5063f4ffa930c74726f1db9df8f26a7df026b3bfe83277fba15ffa06bb5e020c930e6c5bfc7a69153f4bf6fc38c7c27ac424e7dc17bed9efaa22dec95b7d54bbf4746dd1b855c47e9640db9d70d3fa91b167bd26d66beaf6eded1ff47a06a8937d6ff5d88df6637d7776bc075693cd2d35ba638ec04d38101c7b2608b5dd3005fb3d2ae519e3e8653636226435e9bce7f87d5be7a46606f8551cd28af37a926ce5c141fc9fce471ab92b402f0353a3f716ba3c528684c49d44fb2dba813f9f389e55341d9fe18f0beb444744294fffaa11a8d6eeee932ab99eed41e6351218737d839c94369562eb32c41b782b38e944b2b7aabef2a1bae842fc6ad91e017c8fdd1a028f96d9b7f07ebf02310bfe6216c2dd176ac5a9d8f37d39f452e50906aff7f2a28bbd571488eac3288ae4719bdba2f102b7f1b81bb0d42e813e9072a97c6b6d4359d7d14f6be46b05c4ebc68576f9866567bbf0a3c40f6996b7e2eb14c10bd779274bdbf1e867d0497b8a0e0a2bd55e2ec9be7fe6c1b8916665f9b00ceb09c0c52a5298c75f742e687937dfad7da1d94e25034ac9602bca96bc5524597c50aefad3f80ee72468f14d4130c6521955fb7e4464d3cfca4131302e5fc948481517f016f31cacbac0a501b80c3ea942602ea990fabda53f197b5621152d1a69a36ff44b337a662da9a0295a186d684ab8490c2db565c27e32c33161f6d99b0cb1e67c9960996e678955bb3899689eb48df77939337d4ffc507fc5b32eb88ab72ed8acbf538a94597b0eb5b587373b4cdddfe3477114e0e0f453a742e832ff19dfe85cbb4a30607bcf3bdcfa305b270c06110e1a46e136952096afc1e38739d66bb7f5a21950d1c403a3c040a7b7bd9f0a4c63fc8368dd5bf3788bd0647f9ba324149e77f558a808469c298e75c0c43fcb1b704451e0fb3bdbeba783f71b69eeb97777e7af863ecf3343b413f0b9cdb9df439bdf1589687e15506a24351a5494391e2b29d2a94fb1c843524457a55a83ea839c9a2a3574e1ac3b437bec3998dabf4583f78c8f2ffcecdb06d9dfb955a8b00b1ca90c6586859175067a5f6a90397cc1ef59a71fa2b6201319f9a70551ba230909c94223a77008d3bf7976e0622b270b7b6a1cf56b1560eb29ab85dfb3512b4c7af2aaef9497d048e9f48eb7f7c64381210a57258e7d6cac4ab6d913b1e08b7a7f39a28ef80e52083f60f7e2f15c3622cef3be8d8a75f2052492345aaa9cf58887c2edf28cfa2cb05217646f1c33394ee9b56414385c003dea4065b9a42bfcccb99873206f223572d7abc7976518651c9b49259ac8ae0c4b6e1328969dd8c36cb4cfc178b5508ebe6345c1265db4075781ae4adde0bd3d9194a27c2007b4b7a86ec255e6bf4aa7f206e59cfb311d4fcf2b549d8efa76eef305748dae5e48c58ea448615de14a86282195dd44764a3b1b2ce44a73dcc41ab59cf8867c9731a41cff601488928c07d179530c9106862be337b050483e51f1236973feb4ec095360270ce319eff7704971352eae712188924df9f047da6ee85a8dd0dd2c953ebf43da2300c087d4a2fe9ee9428a193eeaa4ef327a9ea6a158b68e5847dc350dc012b8f4c2b955eeed78e997574f77c71e1a0a3523435e2c619e33f6d0b946feb00d5e5c77dd808e8832257d3553b7ffe6d526047657c586394a5da2aab86889fd25f41045df362c97bee273730e95baab58fbaf1b1a54ab2efb8f3356f33d7e72559e74af64f764f8c72385e2811dc07bb7a0cd4a0a4349e5b73e3ab419a39ba25814bf9438c016478160d8ff9f5a7fcf91feb8155ed20b112665a90423066e8fc66d114d20fb4f5829cf3bbafb03d1574a6ad56e3bf3a2737e43cd3e65140b18ebce5f166b4c84b4b65157e72697a09498293e7ead9605e47691beac9d0e69a186ee1736b0efd27621890fe6f4f40486bbac57b9a8d3ec59594a86fbaa5fa00a6b6e3e323653b1151afede119f402c6a69d915134badcd1f340371b6f2b10c8d4d748a31be843e59bf796ff359cf24ad14f5ab2dfb2695c82fc27064ab28bfd368cb859bda06536c2cd6bb71bf32d2dada269d14616a77accc51f5b4a94f03549002993cd49cce106925cc004d30115977e3f018b648339a441ac96092b6318c08a1f50d4a39824582df8645d2b9c8ac63adf6541f8368193134845156f7223813f27ac57b50ff1b067fe8fdbdf83ec32cc3a9f68977565c07de653440529db41ab45345ec77c9a19015a8747046d6058e1376ac7dd3bca67ea24c2ba20c221ea5b9fdefe9c3d6b36f52641b23df3fe0055464d6b5f0a0e1a021c50d72e56f85df6223673bce64363b38a8ddd5f0b44714b30a5b3e0265804b8e340b2646aa940e7bac7e09a24fdbb7e82bb9ddab22e0940eb11f84d1ec5ceea2d9e5f82eb8eaecb8706853a8f366bb93c0a584b143b511d9c3710c346e2e5ed39c6d05bac274f6b866a6e7b3765b34bde9a4394b57df75da62a1c70b0e4cc270eca0221778970d23aac8345a580e8572581d37db76b48d835a263c7b25ee8ec427b600df3a6abfdc3be5f0a395d7102502a5b6295369ded92e40762af14040e68394aba67bda9f3862a2d8a13e087c50dfdc145c695b1c1c243cae8867d055603fa7529fd760253de78861e08f9009300e8115f64d8b956db9a1684e072918667646be8a6740e80efec0225e230a1dbe8f65fb10ba74b7d5503e48c96bffd3ec455be9f4ae47e297b0b70e3da45ea9de10ca86f4bd93a5d876d4c393378da2f8cdb8a20733c22ac355ba42c35ed5cec8b33203421e3f53bd049beb9bfcb45e5d650956dc299e2a7c33a3ede5fef7cd2f9a8a60091f6d988b6cc8b1b0e8616702c0ad5d0bda3e76e9522c9884d91fffc0d1d3a738db43e65c524b820b80b2c375386dcaa042a1d3e0c0766dbfcb42e7993384737181998ff387325dbbe256e45a858591e29983d9763baf0161b60fcd4d505b4460d06f54e0c85db9e30bb34fde9d401a1fcb8beeff427291e773c295d3ad6edea478de660aca8eaa5ce026dad1921571117e2a6ca94d72aace383002e87158eefc58f6dc22e8636d391c381e2d09a3bffb8c2971ef9be73afd326a1551c0f9cb8936f2198eb2b5b2ea1886dd926ba02f93beb5046939c418c192a76276b27c78287a22e1be604bd9dc578c865f02ae942e73eeed2e48728c316f5851935ad929f3e7e06229eb81c82d26dadbad05e43afb2187f0fbccd2ebe34d1d1e193265b0071ec530a3269e3bd0a4da18f7863f92b5524b532dead70fda22f00ac22dffecc8527881959ca561674a60135532577cb9c2baa95da25168005c1c4811342b52accdc7d6a06386b1057dcb2f48cca6f1246e80d7a26041f142fb21b01ddd7d196edb2877452fe694a4a3585d83fa1c303e095313aad2209f1ff40f4013b8e3e1e9448425b5f6dfc4e31f8de6650925dcc8becdca75a07168bf7b14e9d344c0811010a0fc58e27046ba54cad1bddb7e7f5adb7170db5e03e858098cac694214e95f09e391b6621e8583a70dfafb0b5b1a0b975c943a835bff3f4ffe12d51a522810c1d9855c7748e84cdf06a26713f728642787c63fa47370c119b0c3d1b6fe4d876f1681d159574437fa8345174ec76dd111afeda3db60055bc4a1e98811586af09b31cc771724d9446803e49d08ef4749e4ccf177909fc22cf3d1f75e31e75c5d7d72995e66c99ac7c10d10b296c721d0786c0acb3be637fcacbe8a71a00b073e723fe923d02a455add0c0ce042daf582d6770bd59f20141bdd9307644897c7978d0ebed960dc663cb3ff0c31c7e11c739cfd5f855a6b2f2c3cf63d2196daab36c0f204f932ebcd0741b23a4c2d66db2ceec8ee52f086148db7d9a61bb60cbf1a6a3bfb9a7c83b7a649783a4f8d7469113e041806c719c9bbd7fbf3564a01c1097c39b362136cf03bc1aeeee4b0643bd88de8331b6955bca6474d850434eb3bb8e71bdcfee62dcc59800a4f40a16c4921bc893336c106d75fd08d563b6f0be79fb64c0af05eff2174abc4089a6e333949d5eb5a3c4c5c65ce307e2607f8c8e7c4db1add2f1704b2f5d1b2e0cf98064fa66cb41f26eb8c8abd1c840db517d93a4ed5b6fdfc5366910b66140e1270fe81cadf88795787f0e2fb8060321a020b0d5a70dfe8feba29533c8a319535c566d949e4dd3f38e2aeee71eef15cbb1c4d488d978f6cb16fcb16e2900717e0714b3913ff790e79e5ae6b66e99a0f3cc14d34bb0d51b822ca0e6e613c734b93182ebfac91fa392a24aeb949988f0ef1f013726b6ffb410679361d1b7928fbe2d60eb88289e906df1e7dc4e908313ec41221ee1b548513f1bdb5ca4e71bf94319b1b1f82fd0d8fc19e273d6b3f66b3e7731414d8fff340bba5824294a55d13794a74d1c743168b47fd3c7cd4856ffb683358ee06c60839069c343569781eb053db2e665562baa61575aa1cdbceec2f8a39a602d62645d01862041d5f8dd5c82ec09a53907b7af3debdfa208bdcfdec34ca12aed21e95d574d34e2bb86b74d9a33f7b62277361c7a8ea3a2e3b0887af861b93c22aa02c7fe76f0d788e2fc625d50424a94fe45386499c41051f6c0f6ecbf2a71461f2b4aa3da2be3139b1cb8c4187d9cf4a1553d62855fdd4c7dcd5be9c3be79cce35cef48ebae3ebeb6b1c2f64ac52c2f35cbe250f637f18a30f49d461ec4e3c7f6a1ca2ee7f3942de409b01ed14ede5c01a5c4500b02ebf8c609e4bd9520a26a4f19776de6dae7b14dbfa82c00d00f96aa1bbbe1ffb7bfc54daff88371f902fa71847159295364787610ca618f4a884d2013f022f374b76cef0acb7b33df1396c003b31a5eea8324d2ac0986480bc4f15b29bd1683faadbd4a03328753dee99350a48b0f1bf45cb720dcf0aae804bd2d74f321baf65f3345325d1a7d507b31cc0ad159850d887b8ba83263936c2f796855cb676db5342bc673f0441fdb41d60114e2da3a0fd4786d4a24026106fc0cb3ec4c55fac5d9f61530be33dc72dba56c9106c65a0ce663f53fb5c07e23c8e0be98792ac5ee9fd4b671e290ac7037b304aae418ebd8f63b4166969e6b21c760bf776b4ba7e8d53e6ee5dcc574f7544f365256ae82fe891cc1fdb05c12c6a7cf1afdb4ff4d2cce236ab9160c0116ce00253f7c2bb23a43a46198fa79e359ce6b65b997ab843e708c7dfebd8e4af764fad2a0e17c4a9476cf72e455e10085760fd8ce97ce3dfeef8bf925fc3867041d9936b8619f7a7fda8e9de027cbb05991c7ec47d07c3c53c2fe3fe561050cf657e856047fbf2d1880aa6a71cc5ddbbdc570c8635fe74a339c739e7da2c3cd7f07e5c6f95f702f49f1da061bdff097054e0b073f1a3aa02e6ae595cbb63d8614ef94e7b9628dff97894874386dc08512225a675fd03cf680905c0d53ad4768ecc225967252ffb86eb96f34eb2f9cb4a42f72774f06ec2d59f41fe76f3a747101931c18b6507d3f99f306de5fad9355473fdee23ad728d19cd80802fd05bf1d78bf7b79afb4e314864fd23fc05e8a8e496a5a8ad1003172840e8d0e8103c38a17e311c1b25959e0e0910e35145c81b48f39b80afe20bfa652f8a66ef6f8c60957f6e2dd3ba87cd235508a1ee458a8e7b2774a7ba66a2f4d9208bd29ad7988a14efcc748372a95c0c92fc090f052cb53d917f1a917c58fb80d62665463d99fbccc5e52629af4b6fedc22684a42fcb4f79f9702ecc6270e46d140b2b28d0634ab918640678b312604082fbe21547009011bb6519914f34715f414ed2f9e53bb5ede7f0b5c879e4ba0f1b5c498e403ff20d9e2958821782d344228411856da6018580b12ebe8701b2d0b977b7194e30a5c3ebe88ec337d743752fe7aaa75d9bfe7d537de3489cde6cbf98f5d997f2567b12c008dda90eadc87934cf58a6b6225542696240353cfdbb48958de1824a8b058bbd8470dfffaa24f4ef3ef9faa64b3a05738df423789ad6982a4e21d2d31d49023924c0a65a20a39a3a451f18f706afac1b14495ce17ee45d117693557e5ad555ea9008776f99b9b12035bdadb2cc769bdf552ffdbede28cd6540ac60b5f057b4f0b2021696ea88400142cafa65d594fc9a0a5b6dfc08a91e5cc852ecc220d4650b6f2acd7e84616506c91e0f917408f9f952d746238647b7500304cd84028d7de1b93c1c16d99516deb62c896f6d9b771c2f5e87e973b39f2e89735a077fb206d3559b641872653d77f0d92aa0b823f8f9ed52dbb42b3ad72912fc272e1a30837fdf15f62e694cc53a3080360074d190b028236a9703b9687424795baec79eff921036b56536431090c6b753f7439a122cc570bd7a2cf30e0fb750882fd630b7d03c1b01555fb3c894a375033977d3251ca24e03e65243cacfc0dafe4e853b9d6e764ff6166d228e6985f4106bd832e0d06888c2cd73a30c3023e071f162adc59c4b2095c311b98d22a5005c541c3358f9fd7fb814addd418fdd004641d917e8b2fe9b5ff0dde1be35305b6a6003f9b2e088fe4729b6cf05c212865054d327104cc10521dd26e18fd3a66f2809425e46150e73eaf89fc93434cfb47c64301ddb0b87d76f1f1cc4bcf0f7e07eca022a558b27d3662c3401745de1ff720fc90ebd45b6c7525dcc420c9082dd51afdd8de9f0bf67ba7ac5fa8423225efea754fe7d201bf4f56594b0733bf06b6223ad3ad06755956031af1ef1eb2b8521a5c2a0411b9a12b28e7db3e02d3c684f10a3961777f6961af852166be840ecc3a26627232a129d07239d02598647226ab7088cb16ba4d04c4214db3ae5e566c80f2fdaef164ea8300aea5e7e30232011ce7a4f8a08f71503bbbc650a7ba9b672bf59feaf89c481a0f1387718dca61ed62c2460ab98cad5fdab5476f600ef6c32b38308de8aee1584b34f5923202b8c2e756a59b5a0afd7711e4ff6c17492eec4e767cd6fadd02984da1cb39d76985359d97c7944fbdc5b8f0829a20404b09213fd6a0c8789e07e2ca1981e0f78f9809ccf82c13ba9298193dc8104571354856e86119592e8de8ddd678a543cfe3b8d24e73a0ddc8fdb5d8cbccb11cf38d0dfc402247cc06d89ffac1caa1008bc2db45d00a487b904c2f26a885beb7efbddb7d66392765712caf5cb86e31007161ea559a71f8fd4a1b14173a6885c313e328ca36f74db61f12d78b20ea6111fe79c107a193d5a2d033ee0bc90d2291d42c9c036c90871ebee80c39b4830d96fb784d8b4cb6bde9052dc7c2a7a956ad408a035ca00def0cbd2892fdd273e36783d85a92043cd3196a301a9547a2c3fe925ef73ed3495cba4836cf4d7cfc5f7c3d47b5df6bb9f4d6e45044075cc5e8c69b437fd061127830d4242f58e176d1baf07d3353ca5bf0d3a2fc3ffc7c048f51d2061acece013b40d355f644415855cbbbf1831982079d5c93dd5911a0af31503a520b4f635a71b464b5051c28a48a20aa674b39e4c7629154d7ed121b3147aace1fab3eb6f334c0e57ced5d55499cea2b06f099fcbd5a3cea43be9728e91bf517ae58d576ddbca7a7c329502501bbe94aa4d99768fab7f94b3870c2360e1b51a9daf0e399ac72d62dde8490b42beccb1de76929b0b12e618e6cca565f9c05a5bf578cd7e17444a829eae4d3aee8fe29c0dbe949e95a994d3be6d1f9b65bfa3ba6825790183374013481766180a4cc5fe3c773e4969458ab44e03665ebd2d9da3efeec6268a276ec1417058b84ec7fa086799ab7586c56cb68a8de5ab4c04fe850238c7e50c155fc75fa2a84368c5618b3b62c40cb92c41115e2396a931428c9f38203c786aa33db820647ef78000762409e1029734892dcb2778a9dbd377991dcee88568ef642cb43887dc41d560d111da9a2997885d6feab27526aa458cc98649efcc0681f47d19850458f0bef274be965abd15e37dd6e99b6454f1b267d757fa60237ce355dde91b4282956360f89e91d4d166b4b1605409b474975f5d5a03cc45b0d47a1a472fa2167c8d95d67519a31f6b435a9c4d6e55c48f0c4d5959f0b79de05b71f73c25870a2ccb441e6a89a05285d35fa755ba4ddd442034819a131c3fd6726d86ff0f9157ab2935814a15dbb673493288aef74b48158f4954aa949518880c83e0ac9b7c36eefbe665a88e400a2126358d9c5cbc0e3a144a48f59d98407cbd37e9e76cd4552da288044e2d60b6f4da0126d36e0fa4042de33470cf4a1b1b138c8ed2c0f6d73aee9d9e08d4cb7c22ebf3c1348d3ffb531eda4d77ca7943cb3efee662a4091360f4cdf558ac08ad158a437e074165803c9c4f17e6a860aacf22153904d4a0028799669e2e76d7c21de6ae8adbd2de9f4c774209188294d14ca33ebd03b67d08873831d70240e7829c4aeee2504f37c5bf98cf62a1659afb16d02b89e5f735e754aa73f21ca9b4990739b42fc6eaea5ee7ea3f51511cce87363ec29dd053e3cd0cf7cdbffbedad722763fd7f672cb0fd50fa8253f70e9ccce045584153652309e35489452495e73bb0d92a334c959e931fbd0600b964a88d63014274a66cd0a056ec9a3e35b1bbf3563d4e3d7a34ba8e05d93d898c7dc363bb25218df0b26201bc89bfa797e2869254675ce0dce038f9527646a35df2ac37bf03dab18386d87fb574fd51d83d77e095df2685306db8e294c98db2968da6dbbe07eef6e9cbbad21cb58fbe7bdbb8d574317be6e6f59f976187a0ac430f0a915960a515008852b7d12a5a92d2d218f8141866afd1f7e1bdf2d406833f4f8af9fa5f0103441ad545def80bf64f22331b4e4f8d0b487571f2d54733a77b81eb9d8ebfa2385e194b6d41a48ea0e5d00d569f95243c426f2890e57d0116927058b1453d84c8a2c29f8f7d2889d39ad5ad4c74c586596629cdefd56f5631f08e208b0c70c182b9d13f00d1dc5648891bb5956c580f7a6e12f7c4859270bd574780c879bd423b87f1e1977bd563740a5075a74ee723d5b2e3f8fac7727bc5dd76e740893f67516ee23b5d523c10af5e06f23c88369cb6341a8bec9fb1ac4e628fe2f81341fbed61dd4113481d8079db23b425edb76448a03738f59c6cce1014e7cd9d3ae160d0aee9adae55855ed8c8ccc4a5a131c10fd5dbeed406ae737219ee16c2d91c65aeba7c58a9a0c77bac8a6d03f5fb031408a640ca37ed6cd6412153e6152704c23897b1eabefbe25fefd66b45583c28003b75870eaaf9315774f6e90ed38260e4f675baec16b2b7255939e858e9e58f5b9309d01e5e7d3a3862d6a6679580268262fa3068187607189871eea8b8273e8d943f511ae69a0a84bf1abce0dd2dc226ea3382c0df5bba6b28545e353a96ffb1abfe821e10cf2d414c78ada25b0003bf9870328355659eef7b902ab9ea37aeb3d249d44f2a45e66bee98b1e98dc1709d44e05f8be446c29ec02f0fed7edd06e30993d6faf4478a7c995393115667294c2d0c130ef0bc30e77277a2333f97cdc4fd372a2d22146fd3981cbf5e1bc0941ae527f1e3f62a961ceaae42554159b71952bbb334ca33a626aed1b8fec45c80cc4fb8e49485519530329ff9f1a8f7a42d6e3786d9e5ecf94ee70847800c092eaeb2710b0e0058c2319f7ef3fc342376945dc294682bc0740fe5139da683c3d8ae7bb8d72dc16599c43843ff4e65fe20c0c8c5cff2bc728bb50a977f7dfef963331049c96e5f1aa9b39fd0f44036543c8c4b1d9ede0ebc24be90c9e0e2efcc65448f617bf8fd444923bbe321ef7d5fea2459f1dcbbbf568060704d314764196d4a2ae376653a4b38b7dce4b4d5ef1702bf5060464c9af33ddd8317533b14e82bc2667b2bf2e0df1a879fb5cf89831d22de56c4e0fe90e7bac5f3d83cc71151a5bac5d2955eb7f2e957a1a6648da25d1700f8269c2f22d7480317cd130726d058b570650adfef447c4a3e6a616b157b9188da37b2fee08f91b8e4d65817734ae18f84e84a8dffb8ec9769fa3a93ae32a04b028c44e0f17b746f3ed32afd6474604009ec6c2c32f63f40bcf5583248425963525b407ee1233093a71cbd8b059beed21fd8c662e79e9d245b452a05187a3b627b5e2cb8e45c2383acd4b0f9d342d9320ddb5ae4af2ac62c86c33690160d2c5ff36e621c88a284a0d2e33506b0041e7a31e5592e43fd9c6166a633f03c4ceb6eee4d605022b3786ec2df56cc763539b7fe0c36b3f9f75e3d1b4d0e477b4e6881fa644c05f3aafe28368d9517a2b3fbf49c0e57d6da74ea2b14734922bc26270aa56cebd17ea87731f7b7fbafe87cea1e88165278292c53be7c79ebd76600ad655d2197deaeb136e965ad44009598e0e7b2d3aac70bb33838ba98a631f7805676fae1c19a75d61d8fbe0fdc3f2264b27271c4c8b55bc3129c48b870bbc44279d2c7a94c474ff87e7ef4ca9af9a82b9e8a43cdd3389095add011c68ee9ffa5a1aeec4c04cd80fe7ae39bc55ae9dfa6e6c8f1244cf38e0227170cb12c2bd031031aa5ec9ddd1884d678745663ff475b079a40e799afc35cb33f36cfb88d256a0efe77fe144465f82efc0d08cecf5d72f2b80419120258e4ee63690da5ca6e5c7b991ea33e2a3667db8aa1fb653e3646bf411af9444a802a13105af003dcfec5435786624b0a933a1cb1a5fd31cd047be23dd8445d88dda175a0912aaccf3ffb9343b6502433ba5e99fdb5e53e6610fe6c949b038876de0ee29cae3ed9906355ea67d11a93815a2d1d2cc43a75d857841da0ef98586a9f6800c94b940b7928b7716f8ecaea50806deb9aa9bc0e656c705b5ba2c53dac476861e17d27b98c89beab97150da85ea479769d93e32d5988d4dc3dc008fbaa550a9a5c3e97d7fbe0209f7c182cad76610805f8ba01db03199b5369b7eb03d1a92c87f423113832a023ae55e0d6484b1aa9453587cbb06125abd2b68748b456f064d78dbf604182319bf2ad94ff3a424a41fc65fc3c6ab564fc3ff8b47e5aeb61daccfa46d0a1bd93993ed86a52200556507bcb7d0ab453f056c3279b0245bc0dc18730824812c5d6b66bb300fbc12291f3f56010979f569d34a1d72fec7ffab93ebe3f6291bf6311e119dd296daba076bd4a9aff9158efc6db9419da90c0c03a3d445fdb5650d81ccabaafa097dd2d1152e8ce6042ef8e0b3a4e0fa5586308710585b0aab3c3641d92b0e4ec8155f6bd8327577fe6dbfacec51d334a2e11ec5d67463a59945a69dc92f7225512195cb9b60fc08cc3e50a5d5d09df5b801840e5373917fe13598de430ddcef443ba9c2c1c16c3575be4954320822728f5cc3881f543ee91128ebb5474cd99210db628f8c1cb52c72c440b2977a737e7e6fa3b1851b4c7f95cc1d530912fd6998c7f72d4a0fc48283d94ceca2111de53e511a8942c3042c0c400e32b11dd72fc11be7f4594744e229515e0126ccdc692583c84be39ae2bc3ea538e7129e98477e2d02cf635204ab4aff74623edd6173d15bcd48cb1a1c183a86ee8857f9bf0672919f061e62762b7e1a7035b732faa3754679a5c26e37005b1606c4980641e3632edcb764c50c47c930909e71b3dcd0c24ae019a1260f272d63f772362d8a5e62a0d7654a49d495c96b65f3cdfb1e8182cd0ea99ef8106ba941975fae482f09d531d100d4677678e30428303ea8fc5afb0fbe9737ae7f06f28e2dcfce1506e1e3a0da5ffd7cda12b7994486e62674a15061ffbc6755d27301a1149df7de68572d2a2b973023fd7fc000e2b5117a028f3f4352f5cbe84a211450fa9779a34d246fa76bbe326973facb226197a08696d8b3e755ae9986eeba44ec299e01fe47be49f1cf18be0104fef7e6cea31b0e79353d0a9b5173501d46f7b4412359f1a6880b8ded60cd028876a45a8e5dbffa6646c9319c7e0aaf4b064abfc7226f99dc564cbf1c150d3a4d6ff10dc6c81ff3f2386188cdb4c303f34de256fd5c29793796e5919d407a88b30da521b53f36a5abb2e6bcb36f9d1a7f42eab4bf9c4d293078de5cb67760cd0bd542544f095f800b5002a7c5f2c4c3c374ecc16f729a046f059ec244107bb54502402f160e8c74bcc911915550c4a671fb85b1049ee4a8e874e9d8652505bb229d36679dd90ccebc2f1ff08a689ddcb8cea363d1060be94bb01473d78fa02453c5d7b42d5cd9b1b2c6407fcd12e68f260e343d5caaa42f6c0d2bb28abbc8d6f89bf7ecd38c88c20f78d1f53700174051a6a8315d6ec1f5537c707e2f6078e2358e7d06a77a6dccbd9721e11fd53d31aa385985cb93448fd504aea26157756f974eaafc4c5b7a6c86f4aa0bde26b306a0f2b9468b9da049a2218db94c5e7e30b26a5b957bc521008ede752de336783d47b95aa73ce9f8e4373964cf825ca436b33879f486d58328d968870b52dd10c20a79d089942b39aabcfc3636e77a8c4b98df0638392462a09ffaea58b1174d318923445b7a4e3bd12c8127b5f0587d7acb3f336453dbac4f0a873b8188c0590f96969420bda50049f0d1beccb63dcb51916fa2fccb31d38d92c3b7053f6dbba6b93d3fc30216185a32b221aca4fb3b2383de3b775bb88dd079c49ec840d28e267eca065db205d82d0fe4fe8ccaf0bbf18cf232b84263468d91aab0ddc26bcbda845a044104877a53bfaf1ab4ee4bde2ab5743854aa99a898f792b104361d4c9ea5dc3c476aad095a6fa1486f584b4fb9b6d6af65b5502f4765734c87879a0c215f685c5b0544e9ed6a3205105611ea2828f30de56b5992e955f18730975a320cc112b631d415de48198b08a28370789594c3e551b299284a27514f19545d4aa3253e5c26f577a60f6c6cdf960991e8f6b162a8f0ce501f41bcf1f51b22115752de57a531b6c60cef17cf20f935dd5b59fedd4270f9f9af947b99cf9fb5c34d3cd88d4f2e16a32b588360d1f92a8d54577ceb7f95506369dd1c4f28b3bef1f28422a3255a5079c3aab8872cc04e4fd5a5b5bb34fcba7aa584a5b3579a80f2aec01793e21610a68dde3ae4c0d7fc38fcc238424c43e04ff46c15194f85e3f82741307e15efaf7c1b4af4d3adb947c94715655d7f3196d1562164ab2a00bbb575cde062c4aa8545e7ddb27e6f2123569f344c204f5b1882438f78c997fab7b02ceea86356864dcba9d85f7d52f8d2b5737639400ce746b8cd020ff88268c2406cb6ade6336babbf6de5a644542c3de86d79693070731936f3405ce447c08e0e9dd41192cb50a960d1f09b734ff46ac12969e8db3dd86c3c6662477d84e1c8b9883586218da4a50889a4cb42c817fa522fc5863acee1914f8f7070e8d41200bebeaaefec17392df196eaa5e084f83e46eb4b44efc86473716df5baa21ad3ee71514c5d9cb47476b5df5424026e588e4ff993bb797bec50fec08add3c2c6f3a80e859dfe8147aaeb6dc10a1c56fbbffc15855f7aa1712ad9dd3d9df38e98612ede85ceb8f8787043f143b2645327b3d02c9c0e9d2beee32b22053fc47aa23e44d80649aa4ab237c2ff8922bcd363b53872b07905915494ab23577205db0998d5d2d3f5d296372986f75b71485f6960abdeeb94d2619117c311f0cf5652a99746d044f964d86721a76a4839ad59404f49327002c0026ae29612baf4537376e4cef8bef30e2ec8864b4e684db085bb762966cc9fded07eb6448bf9d942f2b6046182b7f740b51b5404d2ecd0fcac9a917ca19947296ee5d13117a1cef885cb6785b6ad71ab2e5f33b3d83c078eeb1d7e811f3214bc91959f2494be41c8ec8be8df25683990d9144be8b0a0da1f1015034a27830fec625ad6d291e8a3e82a4027a0f405c4a9b72d21d1d7b32251d25474ae29683eb7c636552f48401f765dcec82271f597bf644e49a14464b396dd32a73e8e12af55c1e4b10b04083c4429ac363caa3786220a9f2556d59194837b96e1459faec7ba6521acc1b60831f2e9cb02b8f956ebd290965b9db0f472ad2b606d0c06989e65fce1f61e899a7638375d71c8d61ecae2b1a5141076f27c792f13b90690defe618a8d7fb5158f7781de5d38fcfb8a7a00845ee16128e7d6b18fde5fb7b99f0371b9781f0fc5a5d3acd67c9b9adaa17795d95c93ff2c29e95f834c4a49dea54c0829b9aa6f178d10a4acba863e3db9892f82862506491066ff2b290c5c02b46255601e75d143fb237a2aca4f587c3b1f3dcbe353a84b77a0c31e15bea4d102ed9ef608c881fc74d9f4ac2dc667d26335489d76de564ef574a8f68cb7e184830af64bf8b395e11ad4e816ee21568142f7f855bc8d60f496c3a6cb69912e5fc212f2a2c0dd25415dbbf430f286d1bab3b01c2703def6097d53339d9a3c6cc0fc158585c2bc2a9f44b5f34310cc6528bf0b9f23cc593a78e33dcaaf64abc5b54bde628fd7b79691372dd351943172067130edc71e830198dc9a86dbfebc26648aa50d0bc20a2eaf60848cbbfc898dcd0035ec7d71e1b5181cd7d0c4c38624eae6c6aa63d0170311691bf17babc6ed2b711b444ace0d1d1ce639d8209cfed9b20bfb836eecfe20329f4c4683ddf9c870a7cf78132aade43d58167b40f313b41d595d7006841e517a4c7aded7b91600182f9b1187b2d26fab306d68aff3307e96824d74289664982088c35ab663b330dbc1c9bedfbde6d815af1faa54bccc7ffb678c876e08740d3c259d0a42c944d9cedba527049d681499b410638dcb0996c6aea550686607f284fe4ef6b4c7d4b8ae4844374241d52251315f47858f2c8e9cad20ce63bbbfc701cc2593f9bb29505c4c98c7e59776ffcc52c12c703981737f39c9a21587a11f4de55934e2d58f327120e08c7c00da773c58cffabe6dbc4ddb78be3e5c871565f386fa802ba9fb4016185108b8f3ed23c093b8c00a80f2bc2804d34a2f4e12fbfbd3769638bef72199b90c8d8a94b1a9fbc966f7cfb3c78eac86a4e4feae7afb29cf330207bc29be0f6df76c3d3648d60cc48523fbd33f423bea477e63f012a024212c56d376ff565a0bfa74be0a8619794e749b1e40e96b6d70be31efca6a2db09e9e8b06378e5d992e3e530026ecb636454510061bc38e54483f084e355e2db952c847e2ad520f31de2aee3929145f886e8ef7a8965c468848249f6b69b3aa620859db6cb15ed10e6be3c7528a14b6e3b79073fe3d121cfde2e4faa4080726e4ef84bc4b3bef6a005b6ee8ccd0a591c5559dc2c1dc22d467b6a41b1861c57daca1613e736178c1969e2e8126c97145669b7fa0f541a69674c9d31858c60459cef79b7c9ef294d5553ee0748872aaf93d9c24deafa53f88105990e5c7628f3f61483a3ef7a46159317e947eb86be14f89a11b1d988f0f12f45feef8918dccea04a9aab7096b1f074b87245d5610a54d633fbb12141d28707dd5d1c17ffe68b81f82aa7e6d35d27bcfa11b2ffd2d75b7e0ab5d8e714c635f3e55902a56831eadff68e0aa8c318cd0b707507c04258054a62d6226dde9f46f4daf329739d158fad7e18eb007b5faa1287f2024d8e18a305d88efdc5d8cc7a088ba960bbd508837a4023136f6bbca4e7e215525bb49f032a24b3fc2fd50757c28785da9d8e75fda2a08a26843091450481959f62673e2ed3c27f8870bf6bbd9e48c1fa195319143f1942bc0a70a131a7abb7a450116ae94eba5f281428d6985f943e6d72fbfeb4fca003be732319db77dbdd0e50d3e24546787b2701155acae9bc89bcd0209a6ceae159ec6f7f1349699044859055c243ccfcc2071cf20b27242d7549d652a0d7479ed0447d89f6d0212699dc8c1d1e847ad8f19dfb996ae7dfba1a99751533651b3e4454ac8826f9d79e9142a40a6d27ce9b690cedd0a320c5712bdf7971e27cb8b1379af131d226fa92aef8c204e84f1674297516a50d669f96d29237faa6302e3c8180c32b7691ec366f5fd0797213245677c763af73862a56cc6fc639f265f492d3f19727ef7ede623d9c83e981d31fbcaa83609bd73a151654a72643d83fcbc7c14e4dd2b12a43315972bd0eb80bd2a4f87fee9bd9d8a3f000c5bb8607fd37873b1b0495e13426468441952bd23d3db3d4d34785cc67e05c74c2fc09e03b67d4ab796260a5e51ac133f444843cebba18ed93bf9b34f57ecc7029e33e0a32473db625bcbc46bca670272720adaba09de7048a6aa83a18c7bc696ae48ae0c91fc04583fab8dd0790afc2d3a29e665c65a483a3501d2cd221d5c3baa7b600bb1da8566e6f76a6573a63035d15b63a59fed9904e481ac7e87e66e5650344199a6ee5db0c6a96902d68f32066edce9ec485f967ad7f9a0c7b90cd68669b9bcffa5cda858a38766ca48f05fab07f246395674a32b7d99f56a4c9e3ae7a442cf3e3a198aab4a84569e494a5764ca49ae23dc99ed0a5905009a842fd0b8d32e84f44fce5a85e3b93ce9ad68e90730e7e3e87f35408da7065e6e9a2cd165a67e9902975339539c00cedcd3c5f7472aee5bb4a9d53e36166c925d8bf41ca905cc170d906fe9e63c828da27967bc29e69cb8274fd499a43e85cacbe64de6093063a85d85beb703923245a6ae22a589daa46df6b847e0dbb610a01ed9ddafe0984f4b09080d9a369c2c40f37bc64f457969fcd0c76fd3fe48c671cdd863ffa43b0c6c43fa15f1394f5bbd0175b3cc062e189c4b436ce234b6581999445b27fbf8a32ca9fa6cbd302b690f6700b6c29b2faf7675a47aa9c0b493aaf4eb6058fc3af2d2536dfe83254a232d9acf9a6e174b2adc6276c0c50f523db86e773a215a2c837574cffbaa8a8cbdae2af98101c2924f74d2dcdefbfe50af355cbc699f9cca656a456c796f4e5d1757ccdb2fb26668e3c0080a5f35201483b164539295a29db44357a57d9d4d70815b374a841c897db391f4c4333264d4b289c19d3c3a2420333c2451642c9d0571ab15ff605b3716413218d6b9177892dedd4df50e4ca7fe38b361fbb472fa1348f3fbd6ca5d79e4586aea612d08198b8bd5bd7c2ce4fcad302876beda2956834cb5f047ed74c35259d56b3b3a965158912117c1f6ce62e469571c1eaa0d4319e145e64b2b68ca509266903b29a3b830736f63cdea143c8c2a9387980ec6935af2114d0bedc814c3335644c71eb1bb80b611f7b30e3c9e16051fe05cd641fb163fc65bba1688a128f175f76b47f7a05d56154bd82a7652de795aad41a8296dd4cbe80d731748029b674073edf4a5d980b355ff7acae4315a4ae7becf94eb97ffaf12d993bbf2c93ceaeafd36db72b1432c17cbc6d46e3492a85b4bceebb0cdbc4263144cde2cd09ca353ee574a3a8b841d2223790ac9fba1a1bd2155fc5dc342b64c72fedc8c6ae607e59148fefb90738c43d4fa79323168a4e86d97dfac756502bfe0a0ec5c63c581042a7d573efc162c806133852133f5f1f0f1dbfb999c3a38c76b175b9fbf2b230fb85f30e1474b5de4cdc243a7ef64489454e2e6441526682020fffb1d752da276e3ce66d9f45fe5eeceeed8da89dad41794f52c85eff1c66c9f43c75448cd3408268f4d99ac7cbede22c1551dd380fa07813ed218f770fd503f5d3eae4d6dd3f14d697aa00c047b30575133fe1f0dcd6be8846adc53775389db255d491a793f96e293b7c19502f2f8f18fd930bc54cc0069b7d7ff86961f8270e7055d52b44b86523ab5f92e66c1329d0fe9e180a918e1c0e852b82b038340813c5e024445cd07b5d8deb2bdc844713ffad738d2ad17309ecd53c89ecdd35511ddc8a47c7381406c5abc47d35db07969a5ceee4914575fc7e0953a2cafdfebc11f49d502ec7cb25c227ac084aa3e608ff09448fe0248eb822225f6f3fd3e4830f10a29838d5576e34e727aab5081daa98a08ed90efc8819cd7334136e424e38e50d5f64051904d976767936f5180adacf52779a8defc91531c0c54b8b590a578beb122829de93ee53d59310d98fbca1921950a205f5408109e674d9861115e7706b62f43ff79c54ff4a4a6b36895ac96672c5c1234e72fdf3c179b50a01521bb193f671f57110b006b83f7fe5966fa2a96ebcc7d1adee3503efad9bcdaa244ebd1603de5bfe642c6a4d74d84d6e39e134598c8c645779a5f2990315ac8a5501d51f5516a6dad46036248f4e192d7303365eaa65e5b69ff8b1a3bafcaebe4e57b93999592edb20095932b283ec5c3a20495e3d747e0cfdc48fc757b7ae58d9eb68526d1e04c9e9b8728728c3eb8880e04f9a38c9640eb3b763938c27580d0f0a42b13eb279c998541d9ca62d7e58750bba4a639366978dc90966f9800359390b935cd272648cc7da6d5659272a35e75315137446fcc42a28b95bfb8a5a48032995e115303d084efb0f71c64d5cb8dbed963d8a4afeea6ed132aced0ce2b1dafcd2b42c6b935db712d12853190f54628bc1ece54409faf5a5ea34333b0ded0d808b621b25d6ae3a7986dd324bb9f8d0d2475417b677ae6774bd9b79921201c1808f18fd620d3b98933a60d4ca39cc48fc8d96f910f00417ab745fd972e15ad15c5bb0846a064c0da4998a09980a2c7e7ac23721a0426340257b924878b555e1346b399700bf2c11f5d17597815466d4cf7b2992ca1d186c0aaf00784d5c0f95f49991b774c380013ac1fa936c1c13e93eb2b83f3391eaf138b7b174b38bd031f10acb28b14d86ca475f29944cb9170aec64331a7d4be8392eb09aa68561a1e40af9e381dd0da9478b55a6c9bb7b37dd60039b89fb81eaedc3ffcb5440b946d4f01a0660358774399a4d657b024d669edae08f074c6c75119c9b1d3151650ef3568dd8d3868d323d8c336ceb0a776cea6ff5d55da20fbfd27fa03c94d7bf8cd526248e6feb58d9c765fc575f1b35d621af8525feb6f7be0eec4f97e771771e7623856d6ed45e13e4b820c93a820aaf0485decfcfe67aa6a9486787e10b66251e55161ab77412c45f39c71d31c9ad093aae4b932a93e5d9b7fc93230265fe1e63e3b0ead6914bbac43b1516c16b266d730b912459f1536e07190e7b45d05a0b828f2f8d7b7573257b6c821477eeb293bc5c096a7006922939aaa3e848f2c1deb6f736c7e684ba5e9601f0d673aa58f5761edfc9e6af94401f9513ffa93b1efd5ceda79fc1d0cd896eceff148595ed4f7827b34fe35ff05b8f68a2698cd97fd8a4f6a55e08e17772776386e5cb70a27f284ce9c0c47366af93ee6d11c6233f055984be8e7ad3347fb6ad3f8a7c874990782c6fe650cf29119e91991e9de9bde3a52913da5d1aece14639000e78763770b05fd39d902ec2f2da8efb76da440c437182014d116d9f3705203b425cf480111d6694a7c00a8ad1b1314672b7ba195fa8169abd36a3d8a7653ee594a22f10392004bc333cdf056f8ca5549801d4ba7cb8073525003b43c0c13a35c92d30c9fbb648ea7f5dcf2d2236ea45c61a4018705c260b7aacc4c7fb8afcf7883ad753b37b98ad7a34d360e5422de4ee04d9cc6a60c975d2533ccba8a55bb7712c06fd42dea3f811ce76b6d55a515fc52a1485f69f69cf21486ac6a24a31484176915ea4f3e91ac99c7ea3719f49b510a9dddd212b9225623c12b36e88de5132604ef6306ab008a14fd892220e0aeeedc56f1f60fd17a15e8c4c00feab2eea10a3d9e6e909a5f3139952c30a3c1318fd2eb7aaaa46633e71365e3acd848b3b7180e153cdbc7dfb666bb40151affc47a94a116cb247dbfe80c8b2e98e37dd2f6932c283121a2021ecb4b760777d6ed1ca44f94a47e5a79cbce695d99f07309dc9ba4c4b8f738bfc2c616aae92b98490c7559cf3b7f394ddf1c90b25e93bf7476602f2db73f83bc3360cd6897a88a96a7438b2638035beaa6f86dc30f124d87d2d21744bbc86a0e2c061b71c82bf8c96e5d20ae5fd56f5c36edfe70ee6990edb483869a0c27ee97d18d5ec940b984f9ab019c6eed91c2f6211f2d4cadb9edca8bf80a325a4d5aad6e7e6e08c227e72844a547eb85377a1ce6a6c0b0ed6185b43481a2bf66481fcb53451214a190d35dc00923cc3afb23d956fa1e0099e48573ecbc0bf2f4c639b0a54f2e73f5abc24b996d89286d0503d3474563f446b70fd3cffdc3f156f5d7f2f99cd2171ba0c27b3df047aace5163da5eea68a77b15bd1621264ea4b95d717b62e7eaaf2d1776132c6f17297e12f1601385985c1b4584c6617e44d69a367c318581979fb824a21f6734ce326603fa93be9e69b14f2fa009b4175580651ebab89e3b61dde61db265867667b76ff5a9e7de5ba3f03a7833ca618baef6690af3f6a23c623a525db9945e9ee6d5a0d7c0ec9179e085920b02a6164bdba90b0979ccd3becc37474c4c96674308c70bf346bd262df30c89f4d427faa355378662c4a650e1f7d36ac678c9a4abf7ed93b398b6ead88e7d31ce420b271dbaa2884f0c58162f540ca83f597259bb0e94c4c1cae2b60b53c08765eecc4126e64ef9eaafc93e56d58dc5d25a7cb37c05599c5d399b2f1af8edcd3ece0760f10875c424c9543e92253736594c73f4dfacfdb8ec38d7aa4638f9a1ccc1ac7e0d84c43f57ef6def2f9ae99cfe4a329c1b477c215d3f1abe7c9f0a1828dc468a182eca22ebf17c03330e06319e5839a62bf0609aafd99a93da5d2d07dd180115af02934aec60dcc71a6f6227c101da34e23c018ca9c8d0385346261791b46de40aa149b9835e4275bbee8fbafe907039ab20ed0770d1699123a010e57ed11fdaae442aa2c4c10ae632e1ea59d0ae00e327bc0d40d252d2366ed96a23879385d521e6e0d05a74cc392773b26824255e4f91f6087f41967e87f85125845d893d661e3e1dfa29aa70cf2237d52531e57294f6ab86f08c7a56a94e92d1a544f98d9f5d69c10d1dff3e546272e76250719643fbdc183503e85b7921423ec1f2bc5bc560c2775b440abc58fb3d5f9473e984f49a14d7f7f2a6857105667e96fa35bc48bea1e1357335ec9e8a5b20b51bac77cb29e621c7acf5010e9e7581758b89b74bf1dbdbc5041655e75ab3deab5a02e73350d2a218baa4d5c275b9d702fed4996bde5f040664a343d2949580cec1c91e0b6e88fbe6ae4a5ce276a45c2f2a64033b66f83167c5f2865a6ae35a1ebe7a65fc45b4830aee6d81e636fe6038f2aaab3b2d286660cc51d49f19d032ab15a8e7d4a5d1042b77fd5b0eed41bc07207cb77113eaa938555715dfba11ee0ab3648b001f362cfcdf4631c7a2a001a48132d5ffb59e6e11f90497477270e2c60c60fc8f0d0b9ea3aecf23c0785973e588dbf764694101537376937138093a1f160ed80fd1c260b1cb38c82bc383dfcd125a9bd6ee636923c18ae044a6268e41920bd0fd2b953b190b0432ea5d2dc96ba6785891f08f8b5e03ccce809f174cf33766a1d759a7b839612e53148909771c620de02c872a80abdd0c42325c0d016a0e754811305c690330a46e7ffe2d2cb5ab313f0c9077dc95c40a922142af192acc9f946c64b0c374f22946f8e2bc6408e0a002a8e7921126871de880463b102e2ca4facdaa41af871508b56be5011bae09d398cf747c7962aca44928e7774ebf497e1340aa64d4164c97c5105ea0dc3661b167f3b6503e4ba9a3e03988fe5f35b7f78601760f0e25437bbb25e39520193dd28bf4b54c9ff5ee6c5fdcd3289714c6883bdc1269d1d657ae6c29fd95de3e20a2fce54316379d215348a364945f6c882ce69d94f3b16d10addd8a691e8a3f8763de8de0fcadf26c68e4fe9fd8bab3ed4c121d64fd42ea1b434b3d53694c44fb8a8e01be32afc3591be6239ce8ca2b0dd520e2de75713ccb5918418dd4159fa6c2eb85f877f28bf16f32afa37e10fe6e4dd1e1ed249e3c6c00084dd14f5a0c82daaed60e82dca8db7acd8e2ae7b912b8b671d0b4675584964bfaf35e5b261b3da3fa1b3122d2b229db0e23724ce3a2e09c833631c7b7105fa058c3a53c2e0bf4bd185078d994989c042cef6a13f7925bc34d1144f3bc6aaf22792c9490e3ee985d670c4cc73fd30b256f883acc9bab25d039d8ea0e0548e33a97323fb22632e9f9f39d6bf2f4b565033071bbe364a51623eab64ee6b6f3f2a153957b1afbbddad0f2928e2c4ae3fa8242b576dd97a015f9fc29718bcbb56ac9617ecc5cb05b54239dcbb22992c49862d36427f596f77577708e181bf5d69e478bca27aaba605512af47f1be2db28269470051b6e0539a2f996de64d1db5537b84a97b5639cccf571275f8ea557521d2909c793eb76ae5057636176a92a07ca677e89fd2938617a58f8642d840473fa9d6d902b6a074d0296f66458b30fcf5ba6cd1ccda103586a8e09a2129bc9bce995671cd07f4a9c338bb5418c6dbbef6e782dcedf9cf3775f3f732386ef9eac1d1809c2f532200aa526f96dab5dd97acbef3552a02db2e38685f6778137658d36c064e84cd6f941a3e3f7b882c8976aa7714a3b5cda6c6f58aa2dcdd538a1894b1769c1c7a41c94dada72373b19d5b354d28e7ac3454f0d1d19a43ef231e479abf7537e451c08e3acc655b720d9630cd2854d4156330e9a0bdbc9e77d293c10d5492162c13c039de804857315634eda1ba23190c2ee858897e54db8d60ae94d3bef961aa1129f56c7ab8f4418faa68ffd0ff99b333ddee0515e9876883734febfc58be18d91abfe68a9c0e53a21a975b9c2a710bf6fbcb0312d2310b624eeed70adbeadccefd33d066abf368d946fddb6aecf1303efc0a9af95f75fe64319d168cbbe0404e69ee0c8c1ad2031e1364d28fd0caa058c67610b52de79ed1a935c2e007611465aed1270d464459e0c05caf37b200a13d502d33739bf02a41b06249691950bddd1732557378e6bee2bde03fc9104b2f229b53a506fe87113b3ca43cc4b6c69d0370412d4b5b3c340c679b5bc4e5ad39eafedfeeeec6278175f0e69649027a860ed1dfe589161075c0086888c39c0e0ae21820e23f82b672ba3fc054ef120312f65be381f14b589d4da0aba6c4483894e9c66871f4faa70a99682b18f220be1023b5cb1b442f7bdf4e59b93eb10b423ce510997f3052faf84065cd37b6a99831a0b5405c0c4dcc57e4fd440d2f8770b0f1fc904fcf917fdce5b51e95e9b7b6f35682c9d53b82ecbc21f91633ccc0972756e9610370e4899ab017e773d1f3fc3818be53642062e9770141df8eb2c352e35fb40fde010eaa429887ba1a36726a07ee79ec3d19a285930035de8d3af9542415c30a44c206b990747ff8037014717a4a3cd87fe76bbb746071dd6f561d91c34048fba8b58790e3ff9461272b81af4e925779cbd95ec0ca7a39f077bbac2eb735df8cd7bbd7fbf958459fc0b5ef0fb5146e99dfe5e5958bf926674f92872eac01ce2609cbb66e73aa8b89592c06f4de9fe2768f3cf49aa5e6132a43f7f22ab5fa14d978737bb8cc23e00d20f4f3355d9f86cced753d389f213a36a050b8d964e46106fedc27a25217b61e9fa5aae36e4f7a1e41df9ae01b9563b2154afbd09132e4524f0eaf44d8258b3942e95685adefa3cbe52424544a821e8533a7ee4d491f6436459129095415280214922e03d8bc4d65d3db6bcb4b5de6230b8136d77c396380afce8c3a4e105ddc22ef276f61b1ad6234268d9ab93c41b5609ac56ad3ca7de0043daa87f4a7662226a5737f30282f2425f1562de0516718d5ba1d98626b86d81ef26ff0186033106d3866e8bedfcf48529fc104b669754842584ebdc31c4c9e5fb2723f80a000ca1049e9a901e1fc85a2692024e7da125e674c885069aeaf6a3f9907a6dd8882ed19b0cd1f81821156a93992f95e4c2b0a41e5f05b6ea27eedf205fa4a25d0ddcf3b837c7889f589c3d8aa5777d7b19593dc22bf3ed1bb75fc490324e0f6a18458fe3e778a0aab3a7de1a540ac40d5d5b5ba24fe70922c71017c4ac797ac6fbc50ce1566cbcde11ea66bba046e9722ecca709f1ab80b984825da7efb676f6164f267a641afe69c66e124395a62b6b397e468d4044a8a6eff69d93d21b638d853a800ccd2104da36108526c1cc85824e161b73002619ee807be55d44b2a7fa143156aabcdce838b2d377ad5bbeaead6b175713b1697045d21296f6ddcb993fbf8996da27af3e6442e475b73bdab28568e908ea2e6adc20654ea0842fa75b38225f1b6aa43a3cd6cdf564e2b8a8d4d4d804755d196a7766c2aad5f70ba991e170f27fccaa8cea602fce374da59739dc37b5620ebc15cc4f148501482cd482254bfe0f2aa61056b5b788caa8970ba8edc72993af869c6077f6c5cbc26f6bd351d1c798d8b9b728e7043da5bebf638577ead20fb87871b49f969fb7887e765df767c21860720eca1ff4183658c40e353c144afb52a7e8e4079fde0f997afe5dde6bce0babf77ce879bc3f952da46235895bf8ddb40c8f868280a9b2d058a53d8952e5414cb30873731cfbdf8d0d2ec8ec73cdea3405ebcb7e9603cef5f7db2d3a832cbd1a606d8adb44476fea9a5617ef7c4edf8c283cdaa05a4f9b1ddc44c0edf86a8f632afbecde73980f38b826334a4efe16870884d8aa6bcfe5b0d1137347dad14ce44385d2b76368dedb21b2abd03e5e8b6c78a84a052f82d41e1e01cc4d12487fe4f5095be30f676ab91d50182e551b311fbe9eb09965bb837534d3008ede8526a3242e6bf98df68281ebf714f7d866ef9c140d3cd2ebfcfcc82869eac49ed5e2068702361e1ab31e82624fc2c1bc69013d8c9eef0c6d8f13f11efb49f9a4b999c8b8472d05a43032cca6b14557c7ebb2ee237e06a90456d24f8567a18923d573702460919b021269dad03a0ce4bb1e3b25a49a0a9459b72ef588232edda316ea9d3b2b7178920e26d56c6fb0caa475a29cf772aecd7b1f18360a83e688f4d3bb83017d8eb68827606c44defb6c9a8afe24b3f33079c91fd01ab391d3ad50667436a7d514de6b66e129fd95610a570e73e1c961c420edb4c74e2776535c54750060e75cbbb9487b83500080dee693c43e7d9c4ae0f8795c42fbab7eec0c912dd9df940adb3d1cb72b886ef4f63dc1e9705a49c370c705d4aae543f059c4730fe3136a4daa8d8606e245b86ccbe54e45d7d157c4be2bb94a96e5772475ce05ceaf31fbb53d2d741b39648a5f7029d42c5270bbd62b9b0e80bc5478c4700152ed3b7eb7fdcf0bff6393821f227bf9ff1d244a05afeb0770aca79a13c76e008a849f7dc1699576e1f831f08e940af8267c0737a9e0c9033cb42934bacef38b7e9dfe07d90b801e3c04efb69a1e4db8b7a4d45545a4d8cc48e460a4d461f9072fe8a2dc55f7921f7fd4d7ee238f431e70934152dff98a720661ee88dd3a28b0b56d6245772dfc21293d03a8a4cfa4e3bac43448ddea257a88867aabab0165aef75f52149b6b8e1ddde561443b3e493cd448ca6d81566b0f5d2da4d304fbc171280dc7cb0fdf81bf7b6258e38b883b53ee7caf8638820d7cdd69669bc48f06e618e900d54624381dce785eebbed7bade64ac82bcc0be59ad870eed7fed7dcb1f889f16f49e0976df8a4eec08a5fdd704add7a4033f681fb0fbd08eab3de9dd0f8441f7a6671719227122003288058a6910295061f73e314ec03ee38400ed5f64dbb509d2ee472920c61b2b925b8c7d235b3f138f58487e406c8d9664c9bf3ef626d8b244940c41eeb88a1aefb4ca69c8ed14f4dc0b27fa65483b03f5f69453168c65ba5efe64fa0edbcc80c13c6fc911cb32c7a53f5eda9316666b935ec512b514520a0d0577c29f9269089f7e3332b4659818c7b3d0039f78874aa5576c7a45bfd01d595dd32e79868edac4a14457ed8c8398950937840668e59e4372213d7f8362aebd76d6e59a2d9e81e0cc21346130c367f5994a705237e25a1303f5bdc6cfc57c45b01f21d939cec9a481f8e4330536d4c4d487403002893ae72528548899290b896104b6b9b1d92131421fa65679cbaf8c4c8c2194475b390d48928b88c650e01877d7a36ce7f4deb9bc40730acd0c76ed35deec5174a94c8489fa4d54892c4dc7e3df82cddf307ef7a8ea2324aec5a852f43e312d2d72ec7d700f1bc0dfce13e5222b79af2156bfa9cbfd7efa25f25b87e0c870e0f9c8832a377ce196544fade5d934cded4f690bdfaf415756ab1334794cae0be3361bba33a5ed29005f2a6b9b6859a2904e744b53ee24e972eb96310868d8586173d4e3809e434c4c3b12b5499bb5f9a539cfadd1013242695a0ca46f965be66d6045a6d476b925698fdcc6ca03cbe50d9a3d9a245b002ff19e398b63be7a9ceebe91fea7552277951ac9c4a4656a7a5969e4d9c1442e81ff985e25e44c288a98598d2afb3eb50dc8ea5b369b401eb509e4077420eba92f8a3d869d8cd0a8b72c8e91fa833a44f6841efcabc2a258265869464a9875ea51bca01b1aef7bcb213115a46fe1c4b18ba005cefaaf6cf3cea83e2a587b33433784a1637f1fcb7a3ae51f917258e8bba5b161f350749e93241f6f367170ee46b2ae464459a7194503c97ed901804fa6db9dae3ca7ac1855c3a4ba09a7db2fcab8807ddfedb2760ee2705587fcfc53f6545c23cf759a506fb29533986a8328b5e918c1ccac6a31c156e401b90c46afd9c4e816dfd4da5f67669da080a7cf067507ab69ba0a53e312f810b030bbc0932271d39e8fb8138fd833b03bfa4541b0b80b05c50e66d81768997d02f04650272721890a272a0671c3d30ce0840d5cfaff1bf6ef1f475ab37829684bfc19226f3a4d0fd88ba991a4f19f8c91c4b852275eb8ac3c1b7086a964cad882b4eee9163a1f53084acfed7b7b2fdc8dbbf95c7bf113b9050f2eb7611ad31ffd172e02bf28d29eab7ec2371faaf10e1a9b0ec2a73b4b6ab8a512f581586dca48499fe1ad83da4ffa66b33493031eb8b9c0b92f6326c2e92a0c15a11bb87710ab485f660959fd7e7ce877effcd47f75af28d3f3969df611b28285e7915f47f54de6edcc3d4bbf166cb61324b88a8aecfa49397527e6faddf0b46dec1b4e44724b749fc2150ce4d6586fcb5a50bf7545a68656448a293deb9e114f1675678f33dba31eb1769f5132d09641a8dbb3ab478577ee0b35f678b3f327f0fbd939ca7a6a25ca14f7921e62b66f75de83821cbf22d76ff08ada0b99c57d7c2f175dec198f82a0eea2a092bf699275ac83b1850feb50abba0a983c2ebb249f0a8b8edab50a1c376038580cd19470257bce8a2df994756393361c8dfd502449409280502c97581cbe6d83ab18e0e6fd0519979b36f72c677feab75550ae414a081cb051ec3e063e2c7938453f08ed0a95318aa4d7c530666e1700753552309dbb466ef967c4210ea8ce29ddd81d2beb43aee97e048e01b8b0ace0069797dcf741cce2cef927e687906a21d8acd70c9a53fd00309e9c9e3ed0dccb7f2fbf51211e35db91894d1ab5ee3bfebfc838f27b8e80e160086a020d54b6b36b3c622fdaca98768567ba0efe707c79d0b4c35f41993581645b25265311ee9bd3526d8b529bbfdb35bd9cf631084fe44fb0a89fdde00eadccad9b809dda47839a8dca004acb82d37817d6ef92b05e10ed2d04f711420ae9a7e457ed52cbbec946562dd57e28c41f083074f77a8426af700d8efd967e90a0ffe2366fe875778d958784aea31bfb524ae7d9c249122832d3ae163e2726ade60936c021f56ab88f543db1520ca937e7077a4eb699f8d3d7058c9edd94472674570f9975e4314a948cd3a36668b7d4c6ff7be47f35676023be60ed697554a8a313f3985fc59c3375e7e7bb1f630ac02cb840bdbbd6495e42d059eeec2cde3afa7b3ebb6dededc3ab17075c7f00d33102ea7f4ee5b7dcacb08e1d9306e42f435be0d352dd21f29004f168e44f0223aff74ea404a59af141defe4d1b6bacfb18ecff44c7dbefb9116d7965543d7e7b0c7f8a72074150c281f3df334f31f1bd646886b4e82f48dd56b234f6c1d730d9fbcdd3d549d03b049f9ddbdde583aebf7f198bb9fd1751d251e25630b443c7524c87b4da6a572f5005c71ad402121f82c5c59d15426c631af0271d4ff78dfe63c5d9df3c3c5c58cbccfcc2dc9856a37751cb5288a3bb305d38df4ce5987742bd57f6890e368a82a2ec1fc93082f0468e400960bb54654ba7fe0e672feacd2e8073dbbf2521a21ec91a478998b70c221abcee1ddf25fd02b7b0d789962dcc36e1badd8a72c9fed5d9267d72e32bc0c26b636e01b2ac52fe5b857a0aa5112398c4c3bd4d27e9028eff5b7e4cc47de5b7a4253bf45d49d4749d2854803dc95c7216778b7cba7e73b4cbcb9d8ae50abd8e52da6001a6665e713d4ff11a171dcc5703ba591da3e1ef9c5a564f0fcb32859181f563c8affe49d3b6ced505415cd0c8fe513b2551f7e9e5fd89a8be81cf6300eed23eda93addc43869595b6c238f38a5bd0594114e9d2090b2aa9553bff528578d0db09f0fe2f543bc381c1b406f6026afd5872df8546cb6202f9b85f964c711a87218ed8b5d85570bae293d40ccb9a85574d5235f4dcf2666be89f7ed495b951a4642a786d70ccb5455f202643c0f56534fff60ba2cd42f42f9a7486256fd453af6541d12d9808e8f472cd5a9f195a0dd54bf858927e51b22e60869de11a9c1d9f385668ad6c0a71b549f9d5cfedfac688134338b29a3a0b74ac8d7aabd477992fec3593aa80492745046880be3312bff95a3bcc9dc9aba2e23ecbad4ab295c55fec71c822734beed8cb1f7ce0291119edcd931d7b231faa993428e919d7066c0121332b3b6866c105c3749c0e5060d62d1fff31938652dea50158181a3519329b4f7b4dc394c8e4e01f17170d2fe4623e159a045df21447055ac8a8ffe00b60579221da46cb249c9771f9a591f356df7431df52bc1b54874a38250d8b3afbca161ffbdf241e38ad220ab849bae82ca5c5e75813b5d4d8428152595828871661e5a9f52c489d78b7003a28a3a329e9e1b280406c182686df2e53ca9516b08adc5d5542ab04e6760df2bc3d4f258f4c4a62cd2ecc8564056a6ea0b12d1a0668b4e11a91e7b87982354da54a41748804d4f78476bc48aff642a45f0eb51075c6496eaa71acb9d8d244afe7ce9c0496fb9c31e619a3e26ba4140be61b82fa96de568d692913c698fce99db43bf8fc13a2db461463b715c6eb4cf316d20a6f49cde4b691bb1bd80eb4dd4739dd6e29c7ce630f327071ad669269623e44f5565f2158b7faa2b0c523cbd8c66a8997227ef0efa34bc123cd830404e324834db1009d9fd1ab6dc2191fbd3f10e073df54c73d93098fad9fbab222a8badffd93358336579012b2418184d6235b40fe9567fa52b69718b7e054c64ae4f771ccd5f2f0b52c9218b0467e8340b0a8637873d1fbdb6c4ea505e96cbebd68132c23d1ba5d8d02cf4a7b905c162d862083c35d1aadde4f2eae135a256d1167273583c53d7181a3a61777f54f2763ad4d96d092b49739a27e67cfaca4eacefc37d37005be9314cfaf00ccfbfe5143791b209cfffca0fca7679cdbe92d8f7e53f0904fe6f6e71c71a9d2f6162f3390e9bfbfac1be9179c53cf1af84d4d502713fd5f7d4652709ff71a1882821e824732401726f525b314c5572dfc6d464cc72827d35abdb4acef1d9964964bbe2001f2989bd7fdb64d441ffe75077b1f9332682c69e9941f5930fb43bc17c4a41893f79d3e71adfe6c5fe5dbb2ba7f10ac42132dd20f5ec6ab336f357806555282dd8adbc5082109277d3f0e7d98df4d7b23abfa2ef05eb0ad44482c0c62f82eae6f3b758802cbd374993d84bea8148efaf8b1fbce08261fb2978651df2d2ef739965de7afaa54bfe43012bcb5d8d8b436d48ca375747a13c679820e25ab70f3b70deb0c45af4408af119cb0e7cc7b0f0853434c965b6194bb013ce420f2a8b11bd62f9a5243639313c7e4347ae9f67107ecff9614968bb0cea212b8a3d9243e3ef53952b3efbe28699d794d5da445be153c28ea3e348af443622332f8cf79b40377483bf63a5e9a489735b065a32460a536fda954ea9539621f6c2b7b34b2f083f7269040d1891ce792b2613ddd21f92bf7781ed8b6b0e24cb08d9083d3f9ba52ac83c1ac31ed0969619be97c14078ceef2398045dc1f093ad02aa4019d37e232745ac0cd7dc2feba6d855501cb861e2511f171d6c40ca12ed3e7dd883c34903139f881c2e36bcc49666d55171b8547becea51ba36ddf5be796377e17123f5da632e468c014fe71b7ba7fe9f64b46c8a3ca3c2df20bab7c90db14b369296aeabc7fd5edc1bae7baeb5b26b02dfb93e637ca8baf124f8faa31a93e6686d572d87991472443729a68411fba50d26a3c4cf1210262a27803216208d62106fbbf56979796f36827ba46bd97f9d083e17da8c18ecc9122ae1c23bc3e4b2bcae6cacbb0f21bfe7f6410a44bf3ca4c45e6e063ff1fca33d58587725168a3df241a2b1c7083f634de178be6d67ea6b0f291f475f393baac174b0715fe6f515b07a24d402b6e42416558368f36472d8220b7dfd5bfd47b65f244f2bf98864e61628e3527d4209b54c50c16b1986b2db126b0a92c0bd8bd09b2c5bbaed81798a3bfdb59c80e77af73dcc0bbe72240b22bf3c22ecb654f161a2586f20e707c356060cfc9b91debbf72da020be5ccd91e58a3a1869590113bdffff8d9a0504223c6b6af411e66d95e7f93f0800aa9a37b0c48c499f72c765238cf5fc6d92673350b5ef4e4fa28aede26c9578ff109b8fecfc25b51ba54a3ad38e0412b11a157132a98970a93c147f78e981714e62bd5cba0735e46b5cfa7468b064cf02e7211ea4adc18d2bb0a2961a198a20a561e630d17e51936753b6ddbea527fa8a7fa1cf06efc6f424902c01c998a79fb71f7fb41ebb1d40adb44f71b5ba2511ebd75599561495673140f69cd0117dbb40d35ee4006df39928dc851dd2ee6c8a47d53a32aec6b22879dc5e21e0e7c628f31dec118d02462d16df30f1a1bf32880f9bf36d1bf912d20f1ec15d420bf02eac49036b6a78e3f7725fada8688f5e217612b766d4a72bc52e653d741d02df0f37668d589764602e0c8ec10455650490db642797a0dff161ab97b460dd451e0530a7c26cb02ba7484a8dabb8ce4a2b46dc499cc0b3820ffe3a296c2b3a69b652853e365a021bcf22e18408a7e2ca357575d2f1bd75491cd1e573c8958a2d40d2afcdaff2dd1ae01e09b81e9787320a951e01656deb3ece9a8a17c6456126bb56cd4d37f43968bcbb2fcc2f5fddaac2f91a203e6769ac85605d4e8a7ca715e6d20f15281c2c1bfe86ff220e73e8a313a8250ec3da78a6d19a31c86ed4200425df650dec80c9000df1466df88de0625d7b9ce6d6adef7b0baccd80b8fe64adea15b7815441c17b2f8dfb8ec962765176dd279c50b20ea16b1ea3163d8a52edc8480dce3928c1ba6f6f0d3d52af07821d8f79084fd98dd2e8c93c1544c3a3710c88885da134ee36bdf15ea1df095569f8aad80067014269767494ae60c682529349c048cba786bca69f4cbf2bf04192198004776a416ca5e0cd32552e02e1075a5a14e0f31bb4be844798e9e6e9d80b6f2910ad7ad4f162e29667a065a6564bc7df065155d1f96e1094423ef8c4c9933b9e3929ef08feb9654e2257ac440cb864c190af1a2e62090b72033910174b40dd6e68052d1397c3ff8dcaea6f5ca4d3c7b3302a69ea1bb7695ff8a54c9affd09262e0e3f3c5b80e15a5dadea1467115f685d71d142d6e3294612873ebd0f40180e246a490aa43bdbc5ec5b2b9f205039b909be4b2da6d98165f5f2d88f489e64a16fc21fff7318b62049b5bab11a8ec61a9b069e37ba1fcd9c89ae92b2a0a94eba33be054d0c69f344a5524e0e9c9ea00ca14a8e34b0953a12a5876c3a7173651e95f51e73b51927d191b95c960649a1805f6cdfae4cb852320b03b0742f6ebcbcffaa23ba105ccb2bcf5b2d33bb2e5bba58f5163c2d914963628c179e3f1a1a0ca7f291afa2e07d737d975c0d035575bb839017594cb36a915c7636f2a9c758a82d5145d84fb8fd604b2cb0da9efb000b9b67608e5b4ed153e96d0c446a9ef5286833b1308697509ab82dfb2e50195bd14b892fbc40bafb9cf04ccf7f523f30c849df51e49cc144d68fc9ad8a2b5f2fe48ec168e809527ef30828cc8573e8155dfae1e93e2ebbaadb640c5bc4ffb93da227e4a4e0c031b537a8c6ee8aeb2da8eca8b96935da7468f4e39a78f403854739c0ccd8d1b844fc47da3a6a7324802dade3a8c8f8efaac94190c92897b7fddbd703160bd746a7aacec675ec41984330a8658e97c21dc19cf37159fbb718b613d57864bd9b6e623c77dae7ea6508a7c4f4bec679e1d3a90bfd495f978494f094494a457ebf2b7a8efde66c2570750b3ea25f3c1dc92013234c03d2be2a779c75edb95d26e1949562b4fc3535376df93d259828ef8dff0a89037b914c49ce92a2db3b350e2e34a7c83aea695d97eafa9bf1f22967d3bed47ffe96b9307a3f005b66c8a4e728ddb29f4792597775473826478d14d67048dd5b7d4f4f104c8798422e98ace74a11f2df1147f1f2a34ceab73a2bae5173b95e65efbb7bf2c1a034069fa0e74bfa9ffd3efb83f7cd9af5993b28de2e1c73a7f77a0c4b1a0a4ea4172dce1c690818fbc8aebad8fdf78d01985f7077079eddcd01e25e51f489eb767db581821dac91ad10a182c0551243a966e64922c4320cd83414a5d22a784d339461128c7fc170c7e88dd2fd0983636d5e43b22f0ee06595dc574d80196a73e01f78e7da8156a096694cfbc5bfcf7d6121c7c7c1f2acea46e4d2cc18f32dff80d8049ab29152c85d801de02515399b2a5037edca8232819c2812f6258d4690d3ac4d9da09db63fb48a502d55fce5241251f58248a57e628790edf034ea2c7909506b257667131f7842ba4cbd93eb687019cbabf2c91e18e492bb4101c16fb50f3b6d672b77936aff5e74b5e80e020a29686dc1197736be7e63fd2a390fa0263143b3cc770d3b8d77742a56a65f85605f3c8fdf6367944856fe4568fad41b10f4578443d89b2b0cacb16da75d572c969de0a69872e46e81686a36f66ce877f75f816243eb506ab55f32326e392d1dce1f77891adffc042f8e0160931592803f172e8ca5635eab2651ba304acdb2366eec90d0656a3ef0645414ae0c42341add6258fcf012e05b2b58014c29a70b5f1c228eb4687bac16f1caa5a5055662f5385fe1c4f1a47fda369ad533d068a37ad8566d9e64757439e70d6e91afd82c9d341ddcb74b2c73d9a3e2599202db85fe2bcc43285f63f7a156f98da0cbb522e45c88baf3fc16c061d8fb19473a4c6e4222f9da8e5cbc782ff92352edff25f36940681b4e3229611b4aaca55a7d75eae88ddf857dd40450eaa857e17764c7ac15b47b8404ee6da83f594ce0a25650fcb05869f2f944b92afd48c2567ea9325512a2aa657352828cc2eedfb508fa372ceb3af03fbbc1d9e2b975f08006d8247bd2ebe38e668060827560fbd700002350e94890dcd3193735632fc1f6433dc0f0ceb3b704fd3c440f7f4f5d7c974033fc62960eab54c7994ee7d577b4ca5a39d3904a9bb47d2361eda21c16a7e5f1148120edb510b5dc5a2c025f57ed14b000766aa4a58663be0e14429591d63097d9ae197407089de0a3e38da8674f7fed71d8d9073391e755207d6ada1cea562bd25248368fc15caa75417fbe85da3ad3432f8b34474530501f2b792a783af2b3c4930b3d1208859691b87fd6511a4fa597136a952d703ee148832cc055227a7ac485f7463975a525d96ed0c97bf85c6ad6f74a856b9a2a42890bd3a45d3609a2604e203da6db70042d79368b8069b56e230a1761668992c59f7e9bf79869f40451e84a135d8faf763567fc333216abf26d591f9c3d28bbf26dbda00f01216e02b95d3b1a86f5ac58a2c3bcb72148e3af3134eb7c866dd3b2bbcb8fc111f880348ce472dccaa54b9429efb74ce5f5c79076d07b6e6025928e96bc2c3bd57d8285ff4ee77e4050757f0cd0be033e88a95481006c9bf29921a14f31c4c0fff274b4ea2ffa150a903cfa9f7070e3fbbb7ec6c5681bc9232fd150d178a8583ed23ba1b7b3981e1a1a9c941e3d7e7da6156ac1ed1bcf4dd83b8b587f121420ce7ca1a3192ac5f569addfff5dd2c86dec9d0a958d94414c649a48eff5ef6a189846861a605cc03cfbc5e53437ee3c3e06ea5283659a6e2a4c2b36057806db752c7afd5b140f944c8a583854bd4204f5b248dd277d250918d5cb1bbf4e7d34c1ed7915529006b81c0acd2483cd116310a5197c8bf04e8e5f4f63a868901f9f2b6820255ee7495c85f89b9e2709009d1e25f299b17d181021c34c42c95820e852060c6b9bafe4cf39483eee7ab2fe15fae132f9675319f8a69072f4e36bb96c3cd4a710d50bf4f2a0ee1140b4a5ce37c92373ee6b19ad201d415d27810331e5fa8a7e7e912776c8b9f43cd61530173039efbf89462d8f675413c5742f660d3060ff95fac8d39d8a23e6911baf50329192b84ef749b3202f6ac214219d7f7799cf3d82cb21f7e02fb8e21d3bcfe066ae9eca4f95c694d92e224af240c12c169a23337de6fd3baecf18f28517a160a1f9f5ce14c39cad5643ef63bf85c3b3e718e61e5797a46971aa801f81f7907da1750c92708ccaa4799508014c650ee3dcd6a70a67cd6e9c1c26d38721756b219a1c52ca284c349dff3d00d848b0c5b0e30367a8a12a5bf6e489ec9eebab32b4f511a11a8c50089541d5c70b9bac693ea4c72008dba3253b69c8399cb3d84d9574d9eb6fd826b61b705ee7c070958df916d539f2dde2e2779a91b850b6be407f024f057bbb32a131b231b9961038c985e6ddbe9e8845a1ce3e9dd29bbe65095c13713c26a3c2aa42e81cba2a2224946f131b1da5a1b74d2655a21e56238f7be1810314e119c0abf54e416027327eba12bd54f87b1baabcc93fddd861aab52dd7be5981966fe8319e35b47bdfb2d7ffd7cb3020bd4d7593c4908ffd51e9354d4e38882f3787d7edcf320dbe37b35a6d4566e82cc5ab95f27fcf7a9d2c3e84a87b4ffd92f6092e58411edcfa5509926f7208661124c1fc7feaddc1d395545846c1c11471510958c63a81d51d3aa82be7e3619130ff97a6d4c623a3bcf9a5ac18f5c457ec52e2bc40a54b8d91df6b510cad9e032b3984c159e255d6ef2cc16b70d4e9bc21c1e0c4f6c346f7e86c325938d2207062a9660fd6705e28f546d1c7f4d0b6aa9ac1b792583711505f8c728223305aba58bd1bf7fd321da144859e9c969a865a1ea2e7fe448ac2750e9c614984c0782ff87cf99a9aeba5ebdbca4b9a563ec2141f7dbabe7f326eef271d03e1015c33e20ea183d9fe9ce6491b9124ef6656e0363ba6289eac3020ff985c0a37d5344dc1d7ee0601d7f10fa8e0cd9f94f0813b31df5da7afe0c8a4d42d502ba5ae33bac3da9d659f5be195e43bbb7a7787a5a9787f1c9561437f4786e8245c4c1d9132a3d311843bec75e0d844916de06dac374acf33396edd7facfe3ad8066100a611e44577378578f9f627bdaa7df247849490b35f8ef8bceaf478183f8673e6afd20e31994a5edf817eeb825bfa7ee47296a74a1434d24f1f7d1b46dbe0d0a6cbda7d4f488cc617858099990551fa7c2652d1acf3307f76f5fdf03c9273c5cf5536a2c86d3e83cb4c926197a0c6ced2c8f604e6e71d699039b13f6f95a8882958b5fecde69c4c003255a7096d89b3590108ade08af14cab8666c9825274e43837c6b5c6386f09f302dd6f383ca2e91c12b7c6dce92eecbb90427d07c5129e316f8688e7f68e601580dae6de382b4802f0fcd7e9f4caa09c9ab6c3ef94a0feaf8fd7e2846d6e64e2509d71fa72fb2bc9e3845eafeb6a7048c6081e4410fa96afac9aeb23cd321cc56314fc6663249b96f8d242a959a4d6052a825268b681e83b6a95aede1b180937594b7ee3867f6cdb81de00e70aa55f6285719c04cf074e83e3756db94a64a34a4950e832ce142e2b959b09163791e4be12fd8e34243f91a9153b8e07b83d72a6bd6607bfd09dd844916b9caf8563ca467fc89a1d53b22a0e35df20785cd6cb4c365e762d16fd55af8535bb1e5fa9568d5e27cc45142f6c9d95b8a703f412f2c7602a48195d002d7a74a84b0b57c35af5f3ccdb22a58b42c323a670384df6790925660674c3e308e989f1718cd53c6b2251ee7def0068a9b2f2283758ffff02fa3165386feead3b0d4e91cda04d38790a6d8271ce9ffbd722af1e738143fc80dbf5e8ef9a4df844ca30b2dbbd44ed557d116c802909318ecdcb415166bd4c235a88c80550dea520241b8132bc3c1cc8b67f64e908a59a6a633a6c1e7dab76855ae2c761aba58391ca82bbe795c3f424d065f820338033d3dbe2b2870e3729db592c4105f17d6284af2a766c864a1b74d9faffa5d7171beac5ef2b78be8441f6c6f87388eb71571610172ac8b1de066e9dd8f021b2e7eba75a279487c7c7252601028f84b302308a8748bdd2124194def072ac11a6759ff593db0f041578dca36e1e781475e1e1f5755bc6773ef3b4c25b729aa538a57aa2f1b0f66d1c6f1eeeb1f831fb59033db458d40bbe784bd5dfa45aca30e0e47a37242f1968b2ef7b97e688f238ca79ed1f46db799730b6ca1a3bf10c9319652fe53994f60ccdf9ada7be9982a106170d6a02919b8a3e3cf1c11a873e32c25bfca87c87868d97697a4c7ab18774a6035ac3f6cd4938b30cc3916f30dab0b516dcbca19f32b3d5bf5bb78565c66104ee04e8ea58f5062f80f24884d731b1519902cca0f87a03cea4d61aaeb39b49840b62035bfea6d97b7cbfa4aa25da5386d03e47d32cb0236300f21bd1152c1c70a86bd600b5e3d596eff86ddebe570209dd7af089630ab1eae0bf25b681d60076619197a675761efc3780308ef5c0eac7e6ffd85edb43b82ef60af4795da9c9a0e0a8d680a8fdf51318c5d771279b51e14e6cb254a97d7381ce827677796f2126f50a135e44e26a5924a58268bd0fdaf4b2b0f8c8b35de16a9ab3f663bac48c1bb5e345d615b93823f8a4f1cd14c55dda5af0f0a278da76d1ee2f2883786796ff4aa41826c4c1ca5efb66b936dc59ccd8188f34f89ee3b99b3200fcc8f109c58eafd3f642c9ea70b9da152577f1c45724bb1a0ce42bae8d4f3a4b32da7f4e93fc4ec8dec3020bdb5266f8f67140dbea4e6b41fb067c9de9b6966584c691f3e5428fea22192dda4c07a771801e161dff5624f982fd99325ab44e7f9754c1a276fe8c284f783cf94172d81e6b8714314cd7a03f4395e447c037c10a53e609a32a401247bbc55a1a06a353a41b65f3936d7497e18b57cadb691d1ceb8c3c12366ab927d2e96374c783281cc620067d41f26df34180511b14653f09e81bdb562fe792dc0b97aa4c88b5aeff4df3e12df991a0336407a3035489df9069e27dde97fd727fd78e9b583c7038b93cc862b1960715672141f08672fa8196c47b8ac5ef8388a959f605f352da2f0764f6de13e6f8b5624abf602ebac9c9f31dc540b431adeea6cf927906a64114b0b23870f0457b08c24d9f034a5b2f8038d441374f5997f5a9d711b5edaf204003cd514989fb810546bc63a9325e97c68d0310a2d939ccd292c7dcb4a45f790e9fb2ed850e9c43a87a18dffd8c146ae81b915e73796249ffbaf86b7093750e32c0f7def45c82ff0d02972644b21e7338bfa06d2af05df6a4a0d91df2da1fc2f66e9aca5fcf950baa548627458b14b138e68cd2b8433fe1356a50c7534c7e32960e82674f516ca0af123e7d87e91f9659ed08374d3ff92748e70c752551890e09a11932f3ff6cbab570bc49892af4429bc522b2202570a565c4dc87d1bf5eb208b739c7a39054d748a62cc08fda62b2442289442531dd4579abbfe6a7abc87df7bafbc4b85afe903e79993851580c1d59259445651601380a48dd01a2b57f40e3bc85318baccd7f462a1bd196198355e95e5ae26bdb940fc86bf9dc97d6c75b37a903bd0e83d4a0fb425d24a07dd6c5a98a2a0551a5ea87ecb591e57ea860310de22d675208c96d56466d46eda32c657c90055b82a2d2deab1ec4f851a141b7afe672274d90f8a973a8aa08b66e903bdf7ec089869ba75220546f0c7fa510bfcc651ecbefe162fa22c90c41b0286fa329aea72c1a0b1b00cda17164a0d0c84da0d4849b173332eb95abfa0997d3d256b15f49540ff01b21193db89ca74c8ce70f18fc0811f660c7cccb5592d120c62b39fba88e8c7e83a98c9e158c765a82fdce6fdbfbbfc22d82c560ead142aa9308148b54ae8de43d126960057c1d48fc6c88c60868183aef4135247374856c4383b954967306e643f1713bde4ee489ef6e441dd297e4d00c6aab38d2af3928fe19a6e5ec8750d2e6d2e2fa97c20f4499f0b6b1b66776d539559e232fbea5720223b3215fd63b2306ddcc69f8dac98c0e23a60bef39a3e1b25c7f14ab3be3976a78c00fef753ec38cb2b4a1f7f4b7af96935098737bde34bdd71c105db0e8b3154ab1d1c2e12864836a194ae1b3beb355697c34e27fff950785960f03a1102e79449f4dc1f6296c59f0c2bdfe2af33b20b9111f64ae3ee521cf2098fe74daecf7dae1ac50971953ef4df1b4326b957bb01be94aacbc224c99b67929e209d8337e40081ae9564e5e5e5a9b36253fdf331f98b9db33de45ea6eb5a58e8c4844caf7407514b4252445d87a0cf857baa6533190e4f8fc8b3cd6e1a66a8b67db8170b2c326ebcd99c5a8172317af65de20ad19c574c62a63d347245e4a9b310f69a30f1bc11f9242255959d191324a6a083533242143e9e199c13f63383ba7fd513082a9b6a1868798128962bf6e07008790dd744e407b5ef957c74ed18e8f2c1c85325502a5c9a91b13b2de16775f03a0e4402866e8bed78f1a406b009d0b504a414b76b0966d8f6df876b8a9a0f0889144c750fb384ce8379b2d30be3269089e87628e943a9f840bd89fdddb7df5c35dd15b69752dea4793979029f6de002fbd4f6d0ee1592bac43b8796cb231997e1f8924482baf6ab0e9e53cb71930e5479b8cf5bcab8068d66ea000ebc2c93280e93f02285cef07c9b0270b2fcb0e33cf56e16a3892ae6aeb3976bc005dda72ef8296d34fcb0d4e9f3930f1166186abfaec6e2662e903bce6b8b831b7784351ba47fe7197597ef9026d3c24cb73c8392a7249801b9c15ae09200d127df7e66908fe72bd6992ecdeb3b09c717346eef269dd62532e09b5993155e7d41a64bc804aaee327787d05f3e6469a0164b3cc4502116b50ab489fa42da11a21b9b0969a38bf329f15c9039d0449bdacce2167d57ed56b0f363692fae9d6104fcad89ab5018472fca4b9128d085dd21840cfa825f3708d94b9f981708c686fbc53de8aacf46c470cee6c5fee7c3c3a283f3c23e5b170db0c5cc109c5e6d1ab7cfd967c8f0d72438090025154035002603e3544d9cffc6eb8685bbbb35d1ae2bcb611c4b06b852a4b2ebade89555b0a4c97e258e9f919e64dee6f29ab58a44ae68301e1167f908f72f54e6a66ffbc88e54c7d41962fd18b592e86383efee8d93f99c4b4936fb0ecd8b53bae5f5a0471bc739bce971363803b00577c4f9ff0f4b1ba200202a3faf37f18efa5e396bff5f2db24bc4f18746ce41e64924f7d72ea18ec4656cf440222e5b9fad992a1de7bdd8f5e48998d2b4b1066b1ca4a38b2d423005d225c0b50e259f819fe0b82fef1f1fb30b6a2c5624df7ca67606bd6d90c123b8dc923145610f15e33276a94fbf0cca12c35973a309dc0a25a2e3631dcf384a3faabe40b82149f2082711ff35ec81e317876b2364c0befdc5dd83a188fa70314bb3b03f86ff60b5daa306fecbc705ee19c0808f2fcd25db48a22225bd273bfcdf3bef3e6e7498cfbfbb4d1b56222a4d822618b1d3a77449a50c2c51b84e71bd2e1db895650db4612d4ec084635d86590f92e4fea890e75d19c4f01bcfea083d61eb6113a58dbbdc0b8ce6319c8e8328d3ab646e3af12915ff7ba8f6fa78928e0919737110aaf3047141187c2c6efcc6049836b8f7fa7108f74976e5e1bd5f45452bc4a109fd8c9ce6591d00cb07500af0e6f01a3ed3965602cefb3486716e440bb20039697f107e300fc4747071038db994073893bfabef38cc1ea8188ed29cb0fada971d5231425236120b5385322ebc960d2460091cb764e12fcce8669c9bbd38f8d8b2d79b4b9eefa55ef415203bc6dc6b3ee743f141bc03e4fc8a94c2bfa4e2d281f0e82503615ff45e4950b71fdef4a89ef2c0d7260bc50405c73a876bfbc044c12dd926b6d68ed8fe167bce48070477cd5b58716559fed590f2c93b9efac6924bcf22e25592968697baf01d2099d3bad77d6f3a29e2a187e82c75b7010062d1e6a16e2470827c95b57d05901bc6cc9c8e994cc68d748d2ca9121dc014e3caba26a04c0ee4186a4c01ea258ef278cf2b0e08adedcc4744c9d955b6d21f2a64db2f6f465012d7210489c9ac65c83a5df7c0ed37c23948d02c7ae6ccdba22d573d51f6fa5c2237df2f46f29dc6d18e27a707a53cee8f582eb363298aa0adf070ff6595cd8294905122329ccea654531e2ffcb53b35185f7fab56800ce490383311b56764e95299514c7760fa8d860bf24edaaaa67ddf84736e020c577edc09c921ef478f89c56761a90bcc55c197f55a34ff323639cc899712792c851adca5884fe6486ba6aabebdf490bf0bdd68834e4c12423d8709352abd01a273187afc2e17f931a3b69b82ac2085ae9c03ccafc3755d0f790a6fd8ff2d49d79e5ffe1892990057b03848676e7454437b4c8356b83f42f981d91df6fb3fe84dcd6e4d11dabab3433a7afea05fb041373fc83870ceefce8cd43b0114eedbc496416af81598cd592cc9c25aa1775704475ef913f644ea26ba053c08a3870d4b9c1e50cd1d10d9edd1ead68139f1e1dbd197f1b5cebd9f0c001f08f463e48eced358971cc02f8ef87cb7b75be8d8074c7425ba9caf8b451d96926e8348c32c14baf073a555c76eb21e6c15dddad0c5c158484d16d535a3cff6bcbda2b592364d016db80f9d163eb429051bf05d95a1488c0c636eeb60ce5e61982d08bcd82417a3515ef36c0b9553027a32489f8fec91fb8e575e2be5238f89e32f54e074e3e5478dc2bf1faaa86a77a1607ba430c52ddcf581680f838ddd40bca9cfb33718e7a161e7f0a1f492e12396110198fc5ed47d5b90da61dba7871b1cfceceebce4f8a760a23c71b82718ebb7b582345e3cfd8012b1cbe60d285b78151b68d577b2e8b599beee054976a29b913c90be4f7ffb7c5284b892853f9f7c2b409931091524b33aa4764e006fd344062fd20a088918bf462717e828f833e9f6219e5ea095e6db4f42370f9f56935d8a5a8d451894c65ad3f35cb8673eff5c0c0e65713fd6d630d1c68f354fe026d079727822a7a6c948dc9a93ce282bfed431098a260edb7ad721476ca8298316bc7ba699d41b1fa253242a71388774ca615d8bcdcb0f7f509bfc70391d73085a3eba63791ae3e8443922c8e8230a07c68e936a06fc62e8c83d113d0d4d869d8ff4aa53f8d41af0ac502649f2e033a159950a2cafab83c134217618956e51470bab752a643b55aec2c9ec8e6787ff2900de4bbec8aee479ffc92df529fcf54305a493d257da2426c1b12e98fd03f2bb62af3a71b037a0525e9cf5930b302bbfb7f167f866c436f8af3185272a6497cf8a4f1ddebc526be351b6c5cc2f9d9b57d9935d888acbba0d0e03bcaf877770fedcee541f0971c9af60a5a4e37d6e6147a22514298028649281bdfcedd29cc18a1753b8afdeb069cd0d9016f39e2312008a381c3773f3e3c5abd294d2c917ce321d533c6508079c74c40df48acf71513c34145f22bd468b64d3f1f2889c22c473eb8aa0afe93211401600a2d37c6d5a1b95d0ee2a41f2e54eb370af398d90485a0a300ca255bb14b47b2300edf8ae33d3f2676a3e9fc0220acf321384b01b7fad7bed70b388c63b93718b502149475d43f944b744d11f239e98af5b0544fb726159153a6ddab89ad8c12d5eaa79f28148875a694f09ad2e840d91c164bd7150a1b80ad021418d8bda1b1ebe3b76c3f9d3be47a7895fd6cf4d78fd6deb602cc9c33913d1b85cfa6afac6b324e1871e91a3e3dff165a7eb1a92e81e45f2470416c63b2d2a4fd57ce29f2f7c877d3e1759c73c98a2d3a55301cbeb0f7fc9053402b1150ffb9a91c32b0ab59cd75ba820ade4796d51a372afecd248737aaf90839cfe1a9b8450b20be3d3ddd7abeca21c3d39d5da84a8ee3085695ddfcd4ebf1c011d1ae7579c161239a5e6422a1dbf6f19ffeb938a2a33491ec01f75aee655b04a88f3ad7d0c729c19a14b7dac0a176a429e0b72193bcc338f252d2572d540520426654d65670b755fbb059429b1b82aa86af6f03058013d0df5439add41fffb6cfc64a1cdbf54a05929c738dd9315b2d979397cc272e718537ab9e6b605fbd85a0010f011b800b92d110b1871e4f03993d353a354777c0f4c1b0cb3a76ffa6118df7cdc2622f06089f9e6b935a5308b187f9bf51d61982821ba7d8eabba4be324af8c7b00bab6bc0317c35f21148b7627b7dfe573cf70621967b2fb435a0b38f3bff3d6a950772a339f5f3d2f7100eb70707216dd12b15d4db0c3163ef790b74e978db31effb864c2e3ed3eeacbc9919b19c223ea187cc8174f3e4d92d44f31e9d8861a3364c15a070dbbe279caa93250991834b237ad49939aa56308ca8f87838f3d4d5490fb8d7518c7fcebbbce44302290d5b58cf7f6e5b22e12486911e63c2feafe8f459f4992b610f82b1e012046a22ca301bec3ee7529ba8468db72c50b08a35ea3448b88a8830023a8f4443f47a78a48c20e9f09ab8cf6a0c687c31e3a1abce4c586920265c3ca078ca299ae12aa1782b9567cd6134649e504bcbac1609d101b7732ebefb08afbe0ffb6c1a0c75306f24476cd3396a766db2f1b53f0664b90d2903d92b6c0f369fb9ebeb3f95778435472da299f1b0eda5acfef334385d302f299cff387b24969794a56352590a9b151c4eb288796d6902cfdef3783afce5906707969a49f1bb34230ee0e8ffb20d33fe258e7d207ca6d16ca78a4bcc6ef4acb726e93636cdfa0c5276e173b08c633a312b88f374b55ffdf20070e0956f5f9431812523537f87b56d6679c475bbbf98c8dc8f67e64936d55a58895ab048acf433de63cb8a5eb36f2e0a5474ed61d9e91759166d4282776af7a97be0dd579c1e2f2c3f72bbb40e969059db2f77aaa1c83efab5191ab90c5e922aa4ba1912cfd9727e2e9886952aaceda6a0ed5c7a199c4da851fd7b9886787b75fe9dd5f8756a8c35b2c5337c3aa469f10b51ca83f63183b2c9bd538fa004402ce94d025a455b949aef43f386b32688fe0fe3dcd4a8780f39b7aead4784c0386711d73159f8fe1e841d958ef4157067227cc7e1418de7d14d55c40c54fcb335c2d770d83ba7c2e04edd18793b127ee5364bb836eb40b725a21ef4979dfa74551c3018f6909195e5bc653081a78f6e2ba4c87fefeb7d02fc7f3dee35233898e518d790a2a2b7e51edcd44e043def69244cb853b01ba102d0d97660587ceea993671dd1dfbd0232abd2d0576735db291414f6936b7eb016563b9f319bc104ec10f40a675b279e9f2b3aa7a04d963e1ae87394b45591a8150864c7fc07db492e3b2de10967bcb5959e932ef061adfb6b5eeffb6b5042496f1728796bc06366358824f6d11e04b6473175fee1f57482163b9d204566d3af712cdf58e54b4c9bb3b830cc06f7062ccec4effcbc465babd76d400a670a4db65d0f199996241b49a3dd92fd57d848e9495d706a49a38c51f3fce03d42c02492474201bf7cde88d33015ce685b6d381eb8c44dca0a54d8a2d5e90e5bc19845f5a8a20394eed3f7518c1eb2862ecca7e58141cec83d4df2b4de49fc8d88082ca16e2b18ff4e9732e9c3c0099a0409cfe69c032f97f07754db5733679122bcd8242d777686210ed16de4285aa17256479bacc84c5a31d8ae80ad4c0c3e0dee20f10b0ef08077b5432ca05dcc649a7ae57d0956803f22ac072fa959130e026d26d01e9e64c520fbd0247303f955ea89df5624c54b5a00b0ea8968d1fda0a264004a3a19fae42c6aa1cb9c44d0f1f0be4a634371d82cda0db3a3488cf11fd18af47e06e0a513fbdea1b05015d0ccd2a47f42940f852b1404654e4d6430cbe1c954d37f146287612be846647e024b1689210f8bd99196ae13e39659545d1397ecc8ebc9a946d34cdd82bc218f2d0bf3c5e0db4dca5a0e9ad9d1a74b4eee7f2f5c0fbef71ef7c7ff49a916f57c8cd0b9bf7d1ad43998bba2e792d4784cbc57705f63e24a267e9c0b3811d4d35010dda06f55ac1e99b768c301fe269b61b576b42d2b785426cd663e24d23ec659e53558b94c1f81cd2301461ab1cf95f07de1672bc0964d8642c2e06c221bcd1c71fd025e363afac082a197a3c8621c205e842f82eb36dfdb51c66f0484133ffb64cb77cdbb5f7e941ae186064eee02007f8f3094695e53bb63b72ad5dddb9b5b1f78339ee4987229a1e8a854ec5b5c18dcd05b8ee51d6a33dc2ab10bb625b73a4599fb4b195b80dfb1cb0fa6659b519421016c084eb68f1429fabe7e9dd6291fe736b207855085d747ed3d8592bddbb19c3ed500b327366bc6bc8c76e9cb0712aaa99841b148af9d4705e0bdff4e5aa47fff44990f72fdad2818f944dc6803fa3cdba722ee2c92d4f17c89500fa72acffa05d48734710721580c9f06a845614fa7ccd8e67a445889dc59f4e7caad7695e4a9bfbc7b99509f80b66a29f7ea33dac9dddea9e1bbe49c381a9cf3190df27bc5b5174f7632fa6f5817cab8abd535baada291e362eb94da1ab2b930a5af34cf602ca95eb6d5b77a685bb5247059a187240f79adbb47275b096c7e269b2796963cb2a9fa347e4305d3bbb9cc2bb23eedfc7c9fc77092adb673c0172f43f5240fd982c303652f534c2bd8d08e9429fb58bb53b7b11c4865b888de7870214c3e7eb13c9fa45e0028110526725e474b82b573423b9ee657e7846d30be09e092d12c9f1f1d7e07f3448ca8fe8651186e9486d5dde928d8d4b0a006496f3f08be0dc2ded83b3a956fc25b634de06c2c60b52bfe09b05013143223b2e83efef8667d90ff9911228556da1ff6cc3018a3aef83fb50641c228fd3fb2092866a00447b9c6c2c19c79816c8fa6b2f7fb3ac12d23e852e7119269fbe19edcbe1dc895d0419adedbcc3ae6045c36d7cf1040fa9c9e5734813eae02688ac4624604d7af3d0cbe21c0494ad43688dcd4400704b9db93774094775decd76d3f4491a13b432f806da083139895aea9e331d9c353c37db1b3a38e7fbd7ba8597513d4409751cb565ae193ee7bbe37133ac3d7021bd9b6124f1030041a0f7f07b3a6b04a7c944c4f15b19cb90dfb5f3bd442223eea17ae0ee2cb50ef3b2953bec648be22c68099cd271a2f1acc5317533a8b1a9bc0a10678fd0cded6aef62bfc69d03c6d31b30849ec1c8ce66b7b2f2e33e0e95a2e4696b544baff9106f29e76177702562294f42203233b7b15bb39d76adae51a2b742deb04057c5860046bf236db6ae13281040344bfcfd595d0a81436955e55cfab895b8b7d61a1756d200b38e70e2b964cc8267c23f9285d0db1c2e74dc2382c1f1ecb76c4a18343daef4f60b4afe85d04b418949c064b71c4a86bb61802b17e259a8baf47e4157d82130fbd5d7bd554b8ad5c55f52a491ab6969fb9eb1697fdb067d59c62eef5017e31a092f76977354cdb111c00d13a5e697439b080b4a238abf98b362fbb72f7ea6b51f4276be384f5d582b873027d462921b2d04f47dcc8c4ad758d31d521dc84ddc4d3bccb0591eb1c49bfbce74d5e68e12f1c3857fcdb8df2fe16882fcd4c756bfae43b37c731cc3f7ff5ffefec1de4e614a7eb433fa7d40dcb1da361d388a4df86515b7d6fec5f0aeafca678bb02335523504ba1bb3b78fc5f2f2e664c95977b485604574a3d3fd808ee749cfd0e239a8ca46c54d546b4205f74e3462214954bc54b948585aa45ef515ed75c06a5cf0aad0996506a4180ec4d7a15e082147ac844e72fbe52860d122672eb6d6f8a01e8e333c110af428ac4689ef80fcf6a4e4ffeeddc2d6a4b96880564f4611073707e933bc78f2a20c5717530ff8a636f9b86f4a77a93abc6ce1fa4776aa716f2cdf3aed6f499ef882797e255db7ceae3d8de226f0a4d53cb2b794a7944d26a4fbfe8be46dca447e31b0ae56ad26d772ae00898d4f31a52972a50dc0d593676a5a9e26b155ab5cef7f75d7cb87dd40ec75692dc55e2b15d97d5d469b5ccd561d4eb82c8d211ab9f6bacf211187f2548013e29a87a227e82d6f3733dc28e4709c64cd246a91e8a3ee706b495716b020307dad53a25ea60b9838558ec5433ba971a53e54830cdd933e3bc50ca4492425ecfe57c418097f0397e9a903d120c1c23b15015d1ae6b617e3d4b9ff9276330f1287d51887475b82171dc7393d666676eb5078964211dfaf3a852a877fb6a20b6275348e261f31064c467bd261cb585f8b04299dd89390b9c7c1029bb68c56dd969a02500b95f0ade5464f59564550ac6847d6091171950ad7cd9ef6f9e7b806ff53a1d1a497e72f2c0a3c62b31b0fd1988adaa8abdbe5eac9c53728a39f3e7452d8ba14c56ed51c51986a8be4b4a4c9a1cb03a69cfc7e9cae7186dfaba5106fde007ef198fa1fbaf99157644478cb04cec107cad919560ac6dbfa7ca627add5eccb407aaea5cb6ca914750711961469da47aac5d0ccc7d37159e24255ee83dba9defabb045497f5e7b64fb30f6edd27c1e87da49f3f1cbbd266f1de7e1bce6f53599d64a99b1fdb1f16d602c5d36203f813751c394bdfe1a18a2dfdf87d68b254944f4e77119bc7b38ac162cb1507f3de5093465008f69ed19009aa7cc92342684be10662f4248e986e8e13bfbefd38013334d14e9cfc74adf258f065b4eeca695fdab9798219d92bf888b7092a1d4b4e6a02040bd65bc4e37b711c412cb01090fbf5b756d799d2eb7b38b45347d3d436d3193c37556fa4b7101e01ec127b7f77fac1922cf64fc0b449860846569ceef5aa945910b9978cd2dbc71e311891a5ba332a65037deb8097dba2871569d1662c9b16d0ef6235971c1e79fa45f88b49df17a9a5704ebe0a65573216824dd2a9e99fb4fa9ffe2e2bc7fc1f7ff8e4643138b848c9fa38c239355ac87bf82e2fec56fd508789e2cdf8a458ae4324d8155eb5b89334a4ca7d95ffcb31ddead72dabd620b48094b52d4458a4694db6826d483e6d8fdb5543ebff4e92f90ff532c9e2c910e5cc85c62961b235968ed95837d0df74e8c43fc8fbe1b8aa0e704ef24f5bd165fe4b89488e18fd399938266bad6d1e625ffa609cae80033b56db438b61f52d96b94e918c48172c084d2727883c4c5783b401f888711603461bf17690abc94f80d01d3e8fef4504e480acac67bad73d5521f4dc58fa8fe888117d2ceb0068d36be372e5daf2838ed07b06f36a4b742f6859bd7255b5784230489f76ad5057010dc0783cc5fec3979236ce0f04659f59d256895d821c4b2c798646bb926f124f388bdd93e6c325eef242efb78b762b81182cc8a77a31cb2cd9ccca3ce84160a8dcb846dc4749323bf4ccb1a8523e03130c78df7be2155984314f3dce3cd3f9f89183e5014e82cb9f3abf1f8fc009e27f93eec02214f7cc9277b49eaf1e6057cce888f603c88884a0a72d812919f3ba5de7607094b2bbde93c5b07969f0e71cc79750ba58fd99855035c5b735592deccac5a27137814d9819f4bab3672815963bc9d16f03bddb42fc7ac356b57418284e187259422f280bc0f628c1cd85cb985470efe04443d04771d33f2c063c5c73b061c5a280d4869d50716514c87da26b1e09f60597c95e1bde67f0d897d76b57bbacb71b952f96368bf86a2d321f1da7b016c4915ffde7d179ca4da366c9f76f26e3be83427d8bceffbe6a74150d443ace0cf89eeeb1c96b84f18e5a92083b94758e30efcd54045f0a17b246903e4011470ba7a2d492247d772762abe8b66250a858242e9e501165450e4346a6f4ae77a81e19bc7dd62d3fdd2dbf071ae162d4288ffe5523469e968f52ce7d206cc6967bbfd05a24a715254a40970934b88084bc1323f8b15bfcef8dcb34680d4a215a4c6926d7d81f9b8dc4fe71729bd43c83beebb5057a133eda0896fb6d697aa9b479e044953bb56b98e13cfdf44446b0481de168645f754791a46bff9733f1e4bffdcfca478f14fbe30564b942a6ebc7aabcfa42ef7e74b679064d0b41d84d60a8a94ee6c44aa7cb1874d9791fc5c2025485b48678240797349d13ac9e48db2dcc23b647f57927dad208a18706eb1b375572b88298a912ad8e04959f3a056f6c52e65e8994ceb13bc66d2b473d409b7bf849d0f99eb5a679880e408a93afbfe7316496c25c796979d33da3e5c4a8706b14e7c1c4643534085a2ae2ea3f58210c90ea1072bc8fd855be4afe65629307ebb440dc75b3bcff489d5ff415c4f5a9e2362e326535c020f6e083fad8897d8b9fcca82473232886a49e0a2be466afdc6e2d7ae97456f76fcbdd12bd0503a0973015d54422df31c9ea760f80cd16dbf45d28261d56e1f13e4431d3fa6784b777f9379be93bc1f1cce629cbe5d0fdb58a59dbf78d2c7b5d44f651c0cb0e82c93a5b0a4594aa291e6e91fecd10057377e526c0fda8473dbb0236018187074d541fb40ad463af5b8b1b5dc5055ad558ce65db6869e69411242b3a27315c389ced90c9197000447d11a9ba4ec855a21be992c0b957d5966eaf0e9859a3623bd948c1dd445893067bd760a0e82e11d1c44170fda4d08ac1608ff933668cfb00c2d44d095dc4baf5c93c0122cb7ac2631b2d9f3d02d889d08ac64189d61535d6d1b2a648232f7ba3b4519f44eeeaed6ca921124e50294bb14eb29cc657e14482acf7fe136b2cdbeed70433398af079574fbaa5b4ec20a34e8999e6c9da3a99a222b40bbaae2fd206b289acd8d74e57e191176913f8a990194c5561339ccaeda76e55fae595748dd2209ee44b90629d08e1fbe7f0c7ca28b6d29e89d28c06efe3e80dbc5c0297be4da359559c88e74af8fa2e5bddb6f6a4a7279f462bf7b46927d0f3829eac6883e517132a070b139c091f3e5c898a407aa3a99eb4cdb17f7167ab2e25940e87d653a818729e0f648c7e6f49dad250c963ddee41e361add5b6928a6bdcf22c9daeaecfc50b1c45c93ba76d14bca2063d8db881c1bbc5fa78d414fd37f169b3b69082eac3c38479ef2140eb23c00d03bdeb5450a2830d7d3ab183e57fd7de42208cea8dcd895872419dd5feb74229d49280b861d7c425dd219b0c7b0613a9d85394063656f6ef767b6903ac8587fd940209fbc93b6f503412bd2592f79a2cc1334c84099142784f39b4b17f3dcdc30fa1124ec1a0144a8bd5045bab12ee6b1af8df4ba9b96d158e2f1b78900ad75e5647e8b106620c330238b9917136d110de32e4d0a4f5f53c55c1cc1fd9a247afd68ee312414f85af5cad19f1838bc27c165ee7f4cdeaee6c446a75e23ea082305660ba201259943c236461d0125770a5485f228b2aa63dc1a1cdb703d3807e3db7d563683924e7b0704ecbef4cad1f2b909430f0f8e65683e9e366381dd168aaf5ec0aff4a4b5195b4ebe66d10fae5d58c330eef977343a036595982d4d68b71159978a13015baba9fad8d6d212dfc87b88518e849f89df4232a2d3920e693f6ad992e7487c86fe7b452af313689b495c33a2a16b595f67799d2e40e698e2fbb393b2069ecd5093dbf7bf3489ced37004f2d415bc246fc8d552b5ac3bcaa3e54fc7cfa40aa836f4ca71a582555ce1868385e12374cac7b92094cff70a42cd8f7e981240e59880bb6d6fc482019bc1c571783592025fdb492a33277c3b0ff9980cc35c39125a697431c0908a74471de507932e88541a23d6849ed853e154793d3e059d3ddd7590518411e01f2b53cfa9a5023e60f3b66f5294ee7ffadc6987600b9cf9b3cc0af2f24dce1438d09ef32fa0b2199681050d4bc6581684d44d95f9ea5859b920919f7efff338f46040dbdb0b24e86021198096c1eb4e3ed5e7530f7bd0e3100ba3870fa344fcc8fb2472730bdc1a6dac25b0218133e0d726fb7f3f3b519bbb5e77a3bb19bc220cd68145ae4231426e6a3711e407dcf9abb38865fa0df232cfe1a9f93e608677c4dd16a5428e381df5ce8179f1b90b09a81bc7b74204f8b721f08446f7b1d022d3daa9f38ec7eaa0136403dd848ec146ef9d242997957209d148cda94e9ecae3954d422e3edc6949ba1bf0071ea24939ec8eefc13f2d5dd4859b1f6ae71cc634ad6053c6808b5f4cb2d6e8717e6a3b5eb26f4fe5056e746abebc39f0b33e55916be411b38e28c1e4d7e0ea9bc6372fb09c05b04c58860753c5c7032520bdc15b8945913da1831992bd2867e6cf011d0fbbca2b24968962076f66ddd157ad39ff73103db71cd176bbe9abcba18090596f0c39d28d7f9d28f239d5bf652cf425e5d438aee3fead0f33be8c03693581afd8bf4b4f16e2c59c4055cbf5a270121ce5ab386a4d1a28bcb755ec672bded7e86308832bcce45d91de45ab5b2250c20ec446cd33d34f17a3b8f5e6704c2662a0cdcd0c5cfef5dd3234ff02cfcd174b40335d29bc89420d3ff0960700c0e07a23407a16b6b3566b0f26664098704b899e4d0664c6f2453bd458c2b26fb1d2b2feef3f2a3afc60c68dc658a0ce18d5fc0ddeaaf9c16881976816d1e9da06ded9f09d7f82438674d25121b2a5d5d6c0027012ea7f36b15c812d8c95977e31a0bc3e58405a34bf7974df3a56f79891232dcb56cd7ac01fcc89480b8c98c474c3b471260d61215a00903915dea3a5068273a87fdd3624f52d1b976e895c17d68d2e9c9a0716bcf8c1ad574871b1073514fb5b714a71eefd73a593b374a428c9f995167cb40f81e413b5d337a4a309155602ae94d4db85d4c204215ad59d59f3739dfb36726593d2333056dd0dbd1565326a47eff00d61d489ed58ffe3a019e08f32765ee0a4412b132a6b9d86c5467a488ebbff02bb18d3c49066b6e1f7c99056c1cac7e7f844d54509e2610d5dd5fec4e6fb35cea4fb015d40500f36276aa0bd71592b9ed6dae2689d036d57578a24ec9f97b1b090bf4ba187cff5abf79da13f3aee210eeae6877d29e0c4a105ed5046a322af001fa4a93e61091649c57ce6865e6261770e34fd1623da158e882753971d0c57b783ae00426a4d14749eb3144498a43db5b7882d019e4e1d9be5c46c8c4902929b4762f07a0145c7864d8fc121129f1b5776150bc8b42bd31d910b00ad823e702fc69dc663fc0575c2123062116c922545293a9ec8ecb53edeab9b4608fa2b78f0cd83d8a02f5871306316bab81b0dc60551ba4562d1ef57bcae595fc35a01a525657238f2803cc943d7b109f1a241175a4fb89958f453f2aec16989ba7c7afd3000a3e967372d803efe2bd6d108ad9de1d3261f70a9758f112c4085ff9a5c8ca330cff2b1199c24c8dc9936ac6edafdef3815bb9cf2183698570dec6a4a87433e71873de84352b57e355c936395eb03e7d4be45e800de2b35b88c0fd48c2f0f7b8cf9cd2747fb0caf65884c276ecf2947a874f73f5c76bdd70e9f635c9132df8607e4d9e29983576e3ee631d3972e5bce45f4f9b6442c5da724ffb4ccb322a76c867c173bd7dfce0e71554615e47887663be9e0d2bdb5f294257c9c0319e49d73cc818d7d790228fda3b622246ce875ec414c5b716df12d2237973ba911940c8c90edc227f2003b1a9421e644ca13cc4bd554c863027d55475bb09ffa61220480f80765e50b26fe4111fc73933385081a75f8b36f1ef42673d575339502024b95c5c5eaeea026845a1c4b028691e03a355071c1a00723c946b22fe41fa2c24134dcc7e1b28130f2dd5f52c271daeb7e148ef7256b36634faaa34994fecb3d45c2df83bcf6da78cb2e3456011489613c482371d4fb7a7abd7289ab80f8c456b49f51bcd5545d1000b6500633e185bcf722c41bfe01a09cea61f2a5aed451e0a923f8b8975939e2b845fbdae366f360e4b8970f66f573ccdeb9df090a7e0c79389a0833461296316ee943598833e1b4d3e1929d9218c2447fffc4d681fa892949215c4f7f4ebaa9f8f9e05cee69aa43394671dd9768d5bfa02380e52ecb43cb9d18819acb62996acdefc70e3923abbcf5c1e9374b6074b394781dfa8f3c3e469d72729b59440858e6e9e0f3cf7ca6ae6d0af196e89e8faf95550516ee6cbdaf2dbd8200a0e56472907ba24afe86f1e695c8301aaaf39b5e9f440f4bb207ec4f22ac7b81ef8bec2b98e3fc3c7c9569c2c67bd0e68212549126a46bece9df54886c84e32853fd18510caf6c5470216a7f7e67c27da8e09cdd78a99918d830c62e67268a6ea7141ed988ea2ba19ccdf12f2848968c17066f3e1ecf83fce700b7ae662da53b9f7970ec00629f22a298ecd01a3e001278dd554f1f93b37c4beb07b5e564239dd1183b5b72723702809039552a64aa756e3a078bf7e3f98122ed29024f54b1172a612076e28b8c0d295395b568d770a9810399cf7881f9f959523cbe9f7d01e8101022cdf456d2f64aace2b0df2cfeae11ab900039d4270f05caf6958c14ffae7b8b75b10746326cd1912d9344c02ed4ac29ae1bc35bc4fd6886d5f9d5807fdf4f52b1e980af0b76c18850fc303a12a3e221cd8fe58dc9864c7e5bc31d96fb9274aee3c1ad4c6285cc8f0d1abad41d25b0858f2bedd1b70c01d1818f64c10ee1cb6acbb4d62df0f3d5dc19b9257ec5442027d8276649b601499f21c5af4b8f0e915b2ecbe1ed74dff538e20a9cf576960c5bf0e30cfeb7ac14d160dd24e4ee946461221473a88437a68169409d210e433c96c1230788329af66cdd6c102eeed8a9ccd7eca5f79430683f5013e49e3b178e2818b401f7eb746730c3e51c55560b8cc9af1cf9c4746728c496aa4a143fdab53c9f2fa38b674781467e624a89b994d655391bfb7670148df96fd7b1ce0979161719804eefc2ffc10be71739ada5d0096a73ee81c2695dfd7469b69d1349685da35b9b2eb98a7dd7fb337ab9d1efcc4e881e95b4cb2c3ccda88a296dfbe52502dc60ccb25973b40e3731ed77c21b9c18eef0d3dafd332862c0f502a81d545a67749d5b84721370442848f7dd7083ae9d1375d0fa6f059877b3b42a8d49e8a5cb1cfc28ec8a2485d07f2eeb03ed4ba8695237c64466ddf0966cff5478615feca9f7ed55457d92c0beeb1e5a30bb78735cb5a67dabea5e977c90399b45823de4f07013fdf7b50bc11b7a9186b6ee439092f4f1d619127132914d1c6e9afedde153db9b36c0964c794dff469399330775061306647b5fc8177f9c5175f9f27dd998288ff9c11bfea1c6a5e5772afe961173df2469d950d423dca6d8692e863621a51cf8f239387035b3617b2191218e43d1bc4c848d60a5bc5390fc70e8221ce2c3c6c4ca4add1f85c63ca366576fdc4ea3845908bf53656932c92df45dbb1d10e7d5d3450d0d62220ecfc993714343b0d23c3cd0d17cfe330891f2ffd0e2230e7156e7af0faff9b2f38090f978e3ae13ab8d2a057cbc5482da37a2716ebedf1b78276f3dc2e6aac80df229665dc5504adc801ab2f2274a552ebb048d2d3044ff821bd04c2c5f4bd4ca58dc2f5e559a3f64eeca76a029760fade01b13357d86b32c5f780a616b2121982ba48ff89ba4cd14dff32faf54005ac15dd73de6dd9c1e2b9dd7eeeaee26dfd3122b4738afc0b7a8223cf997147c096118b9e555d36f626e077c8743cd170f02311bddeacb72e64b9a00dad524049f062a412cd90ac8d54bae07fd4f9f40c91ba9fddd7d804b0ec75fad43ab2fffe6d48c337f9b35ccac4564f212b09a6855650e36c5e5f0bc9cde3a2031b1da3b6ec4b89b30127e60316e225d0e115653dd4279540cb96914cfd32c3761249b5c2164eb56a70723dc51fc19b3d62ba915f4d17e362f4b5996fef98caac1198381c7d108dc582ef0231e6f83806f9251ec4e496070d9ff68e6abb82f382cf6f9b8196b936cf44733bc2025d9494ac4c24266d45323411e940d323bb2898e0615fb66379b23701922bdd43c3d510aee1f4258d58022935607adbb9727fb91d590aafedb7f81c11caec31072a196f08a68d535c9e51c93f45995cd626598ebbacd34a9e62a5e8fadc95f13cea25fe0280dd77583e70a32c10630b927f2ef97a5b75349588a48eb5cc46035d8294a765bf3e4dcd82b86f8e8a90abf339aac836afc115f4060ae44d62f8b8f24f442caee841213c36faff96d94305ad930d4d5f855685d90ae32e0f949f0e7bd23702bc29a1a5dd5de7</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">个人文档要经过授权才能访问.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib小项目--绘制学生成绩雷达图</title>
      <link href="/post/9026a025.html"/>
      <url>/post/9026a025.html</url>
      
        <content type="html"><![CDATA[<p>这个小项目其实挺简单的是博主最近学习从书里面看到的。比较有意思。正好博主自己也想做一个这样的小项目，来熟悉 对 数据分析三剑客的学习。</p><p>有什么问题小伙伴可以加博主的联系方式和博主一起讨论学习 python书分析三剑客。</p><p>这个详细的在代码里面都有注释，就不单独拿出来说了（嘿嘿🤭，偷个懒）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">courses = [&#x27;c++&#x27;,&#x27;python&#x27;,&#x27;java&#x27;,&#x27;php&#x27;,&#x27;c&#x27;,&#x27;cs&#x27;,&#x27;html&#x27;,&#x27;javascript&#x27;]</span><br><span class="line">scores =[80,95,78,85,45,65,80,60]</span><br><span class="line">dataLength = len(scores)</span><br><span class="line"></span><br><span class="line"># angles 数组将圆周等分为dataLength份</span><br><span class="line">angles = np.linspace(0,2*np.pi,dataLength,endpoint=False)</span><br><span class="line"></span><br><span class="line"># scores.append(scores[0])</span><br><span class="line"># angles = np.append(angles,angles[0])</span><br><span class="line"></span><br><span class="line"># 绘制雷达图</span><br><span class="line">plt.polar(angles,scores,&#x27;rv--&#x27;, linewidth =2)</span><br><span class="line"></span><br><span class="line"># 设置角度网络标签</span><br><span class="line">plt.thetagrids(angles[:8]*180/np.pi,courses,fontproperties = &#x27;simhei&#x27;)</span><br><span class="line"></span><br><span class="line"># 填充雷达图内部</span><br><span class="line">plt.fill(angles,scores,facecolor = &#x27;skyblue&#x27;,alpha = 0.6)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这俩行代码真心觉得没啥用，有他没他效果都是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># scores.append(scores[0])</span><br><span class="line"># angles = np.append(angles,angles[0])</span><br></pre></td></tr></table></figure><p>这里是一张效果图</p><img src="/post/9026a025/2.png" class title="This is an image">]]></content>
      
      
      <categories>
          
          <category> matplotlib小项目合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib基础知识</title>
      <link href="/post/8710c1f.html"/>
      <url>/post/8710c1f.html</url>
      
        <content type="html"><![CDATA[<p><strong>这里全是博主在网上学习是搜到的笔记，如有侵权请联系删除。</strong></p><p>数据可视化</p><p>Matplotlib图形组成<br>Matplotlib 生成的图形主要由以下几个部分构成：</p><p>Figure：指整个图形，您可以把它理解成一张画布，它包括了所有的元素，比如标题、轴线等；</p><p>Axes：绘制 2D 图像的实际区域，也称为轴域区，或者绘图区；</p><p>Axis：指坐标系中的垂直轴与水平轴，包含轴的长度大小（图中轴长为 7）、轴标签（指 x 轴，y轴）和刻度标签；</p><p>Artist：您在画布上看到的所有元素都属于 Artist 对象，比如文本对象（title、xlabel、ylabel）、Line2D 对象（用于绘制2D图像）等。</p><h4 id="Matplotlib-pyplot接口汇总"><a href="#Matplotlib-pyplot接口汇总" class="headerlink" title="Matplotlib.pyplot接口汇总"></a>Matplotlib.pyplot接口汇总</h4><p>Matplotlib 中的 pyplot 模块是一个类似命令风格的函数集合，这使得 Matplotlib 的工作模式和 MATLAB 相似。</p><p>pyplot 模块提供了可以用来绘图的各种函数，比如创建一个画布，在画布中创建一个绘图区域，或是在绘图区域添加一些线、标签等。以下表格对这些函数做了简单地介绍。</p><h5 id="绘图类型"><a href="#绘图类型" class="headerlink" title="绘图类型"></a>绘图类型</h5><p>Bar<br>绘制条形图</p><p>Barh<br>绘制水平条形图</p><p>Boxplot<br>绘制箱型图</p><p>Hist<br>绘制直方图</p><p>his2d<br>绘制2D直方图</p><p>Pie<br>绘制饼状图</p><p>Plot<br>在坐标轴上画线或者标记</p><p>Polar<br>绘制极坐标图</p><p>Scatter<br>绘制x与y的散点图</p><p>Stackplot<br>绘制堆叠图</p><p>Stem<br>用来绘制二维离散数据绘制（又称为“火柴图”）</p><p>Step<br>绘制阶梯图</p><p>Quiver<br>绘制一个二维按箭头</p><h5 id="Image函数"><a href="#Image函数" class="headerlink" title="Image函数"></a>Image函数</h5><p>Imread<br>从文件中读取图像的数据并形成数组。</p><p>Imsave<br>将数组另存为图像文件。</p><p>Imshow<br>在数轴区域内显示图像。</p><h5 id="Axis函数"><a href="#Axis函数" class="headerlink" title="Axis函数"></a>Axis函数</h5><p>Axes<br>在画布(Figure)中添加轴</p><p>Text<br>向轴添加文本</p><p>Title<br>设置当前轴的标题</p><p>Xlabel<br>设置x轴标签</p><p>Xlim<br>获取或者设置x轴区间大小</p><p>Xscale<br>设置x轴缩放比例</p><p>Xticks<br>获取或设置x轴刻标和相应标签</p><p>Ylabel<br>设置y轴的标签</p><p>Ylim<br>获取或设置y轴的区间大小</p><p>Yscale<br>设置y轴的缩放比例</p><p>Yticks<br>获取或设置y轴的刻标和相应标签</p><h5 id="Figure函数"><a href="#Figure函数" class="headerlink" title="Figure函数"></a>Figure函数</h5><p>Figtext<br>在画布上添加文本</p><p>Figure<br>创建一个新画布</p><p>Show<br>显示数字</p><p>Savefig<br>保存当前画布</p><p>Close<br>关闭画布窗口</p><h4 id="第一个Matplotlib绘图程序"><a href="#第一个Matplotlib绘图程序" class="headerlink" title="第一个Matplotlib绘图程序"></a>第一个Matplotlib绘图程序</h4><p>首先导入 Matplotlib 包中的 Pyplot 模块，并以 as 别名的形式简化引入包的名称。import matplotlib.pyplot as plt</p><p>使用 NumPy 提供的函数 arange() 创建一组数据来绘制图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#引入numpy包</span><br><span class="line">import numpy as np</span><br><span class="line">#获得0到2π之间的ndarray对象</span><br><span class="line">x = np.arange(0, math.pi*2, 0.05)</span><br></pre></td></tr></table></figure><p>上述所得 x 的值作用到 x 轴上，而该值对应的正弦值，也就是 y 值，使用以下方法获取：y &#x3D; np.sin(x)</p><p>使用 plot() 函数对 x、y 进行绘制。plt.plot(x,y)</p><p>主要的绘图工作已经完成，不过还需要绘制一些细节，需要我们补充一下，比如图像的标题(title)、x 轴与 y 轴的标签（label）等。<br>plt.xlabel(“angle”)<br>plt.ylabel(“sine”)<br>plt.title(‘sine wave’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">#调用math.pi方法弧度转为角度</span><br><span class="line">x = np.arange(0, math.pi*2, 0.05)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.xlabel(&quot;angle&quot;)</span><br><span class="line">plt.ylabel(&quot;sine&quot;)</span><br><span class="line">plt.title(&#x27;sine wave&#x27;)</span><br><span class="line">#使用show展示图像</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="PyLab绘制曲线图"><a href="#PyLab绘制曲线图" class="headerlink" title="PyLab绘制曲线图"></a>PyLab绘制曲线图</h4><p>PyLab 是一个面向 Matplotlib 的绘图库接口，其语法和 MATLAB 十分相近。它和 Pyplot 模快都够实现 Matplotlib 的绘图功能。PyLab 是一个单独的模块，随 Matplotlib 软件包一起安装，该模块的导包方式和 Pyplot 不同，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Pyplot导包方式</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">#PyLab导包有两种方式</span><br><span class="line">import pylab</span><br><span class="line">from pylab import *</span><br></pre></td></tr></table></figure><p>PyLab 是一个很便捷的模块，下面对它的使用方法做相应的介绍。<br>基本绘图</p><p>提供一对相同长度的数组（或序列），然后使用plot()绘制曲线：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from numpy import *</span><br><span class="line">from pylab import *</span><br><span class="line">x = linspace(-3, 3, 30)</span><br><span class="line">y = x**2</span><br><span class="line">plot(x, y)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>如果您要绘制特殊类型的线条，并想添加一些颜色，PyLab 提供了如下方法：</p><img src="/post/8710c1f/359.png" class title="This is an image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pylab import *</span><br><span class="line">x = linspace(-3, 3, 30)</span><br><span class="line">y = x**2</span><br><span class="line">plot(x, y, &#x27;r.&#x27;)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>如果您想在同一绘图区域内绘制多个图形，只需要使用多个绘图命令。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pylab import *</span><br><span class="line">plot(x, sin(x))</span><br><span class="line">plot(x, cos(x), &#x27;r-&#x27;)</span><br><span class="line">plot(x, -sin(x), &#x27;g--&#x27;)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure><p>如果您想清除图像，直接在程序末尾调用 clf() 方法即可</p><h4 id="Matplotlib-figure图形对象"><a href="#Matplotlib-figure图形对象" class="headerlink" title="Matplotlib figure图形对象"></a>Matplotlib figure图形对象</h4><p>在 Matplotlib 中，面向对象编程的核心思想是创建图形对象。通过图形对象来调用其它的方法和属性，这样有助于我们更好地处理多个画布。在这个过程中，pyplot 负责生成图形对象，并通过该对象来添加一个或多个 axes 对象（即绘图区域）。</p><p>Matplotlib 提供了matplotlib.figure图形类模块，它包含了创建图形对象的方法。</p><p>通过调用 pyplot 模块中 figure() 函数来实例化 figure 对象。<br>如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">#创建图形对象</span><br><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><p>figsize<br>指定画布的大小，(宽度,高度)，单位为英寸。</p><p>dpi<br>指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。</p><p>facecolor<br>背景颜色。</p><p>dgecolor<br>边框颜色。</p><p>frameon<br>是否显示边框。</p><p>下面使用 figure() 创建一个空白画布：fig &#x3D; plt.figure()</p><p>我们使用 add_axes() 将 axes 轴域添加到画布中。如下所示：ax&#x3D;fig.add_axes([0,0,1,1])</p><p>add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。</p><p>设置 x 和 y 轴的标签以及标题，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax.set_title(&quot;sine wave&quot;)</span><br><span class="line">ax.set_xlabel(&#x27;angle&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;sine&#x27;)</span><br></pre></td></tr></table></figure><p>调用 axes 对象的 plot() 方法，对 x 、 y 数组进行绘图操作：ax.plot(x,y)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">x = np.arange(0, math.pi*2, 0.05)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">ax.plot(x,y)</span><br><span class="line">ax.set_title(&quot;sine wave&quot;)</span><br><span class="line">ax.set_xlabel(&#x27;angle&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;sine&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-axes类使用详解"><a href="#Matplotlib-axes类使用详解" class="headerlink" title="Matplotlib axes类使用详解"></a>Matplotlib axes类使用详解</h4><p>Matplotlib 定义了一个 axes 类（轴域类），该类的对象被称为 axes 对象（即轴域对象），它指定了一个有数值范围限制的绘图区域。在一个给定的画布（figure）中可以包含多个 axes 对象，但是同一个 axes 对象只能在一个画布中使用。<br>2D 绘图区域（axes）包含两个轴（axis）对象；如果是 3D 绘图区域，则包含三个。</p><p>通过调用 add_axes() 方法能够将 axes 对象添加到画布中，该方法用来生成一个 axes 轴域对象，对象的位置由参数rect决定。</p><p>rect 是位置参数，接受一个由 4 个元素组成的浮点数列表，形如 [left, bottom, width, height] ，它表示添加到画布中的矩形区域的左下角坐标(x, y)，以及宽度和高度。如下所示：</p><p>ax&#x3D;fig.add_axes([0.1,0.1,0.8,0.8])</p><p>注意：每个元素的值是画布宽度和高度的分数。即将画布的宽、高作为 1 个单位。比如，[ 0.1, 0.1, 0.8, 0.8]，它代表着从画布 10% 的位置开始绘制, 宽高是画布的 80%。</p><p>下面介绍 axes 类的其他成员函数，这些函数在绘图过程中都承担着不同的作用。</p><p>legend()绘制图例</p><p>axes 类的 legend() 方法负责绘制画布中的图例，它需要三个参数<br>ax.legend(handles, labels, loc)</p><p>labels<br>是一个字符串序列，用来指定标签的名称；</p><p>loc<br>是指定图例位置的参数，其参数值可以用字符串或整数来表示；</p><p>handles<br>参数，它也是一个序列，它包含了所有线型的实例；</p><p>下面是 loc 参数的表示方法，分为字符串和整数两种，如下所示：<img src="/post/8710c1f/360.png" class title="This is an image"></p><p>axes.plot()</p><p>这是 axes 类的基本方法，它将一个数组的值与另一个数组的值绘制成线或标记，plot() 方法具有可选格式的字符串参数，用来指定线型、标记颜色、样式以及大小。<br>颜色代码如下表：<img src="/post/8710c1f/361.png" class title="This is an image"></p><p>标记符号如下表：</p><img src="/post/8710c1f/362.png" class title="This is an image"><p>线型表示字符，如下表：</p><img src="/post/8710c1f/363.png" class title="This is an image"><p>下面的例子，以直线图的形式展示了电视、智能手机广告费与其所带来产品销量的关系图。其中描述电视的是带有黄色和方形标记的实线，而代表智能手机的则是绿色和圆形标记的虚线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">y = [1, 4, 9, 16, 25,36,49, 64]</span><br><span class="line">x1 = [1, 16, 30, 42,55, 68, 77,88]</span><br><span class="line">x2 = [1,6,12,18,28, 40, 52, 65]</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#使用简写的形式color/标记符/线型</span><br><span class="line">l1 = ax.plot(x1,y,&#x27;ys-&#x27;) </span><br><span class="line">l2 = ax.plot(x2,y,&#x27;go--&#x27;) </span><br><span class="line">ax.legend(labels = (&#x27;tv&#x27;, &#x27;Smartphone&#x27;), loc = &#x27;lower right&#x27;) # legend placed at lower right</span><br><span class="line">ax.set_title(&quot;Advertisement effect on sales&quot;)</span><br><span class="line">ax.set_xlabel(&#x27;medium&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;sales&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-subplot-函数用法"><a href="#Matplotlib-subplot-函数用法" class="headerlink" title="Matplotlib subplot()函数用法"></a>Matplotlib subplot()函数用法</h4><p>如何在同一画布上绘制多个子图。</p><p>matplotlib.pyplot模块提供了一个 subplot() 函数，它可以均等地划分画布，该函数的参数格式如下：plt.subplot(nrows, ncols, index)</p><p>nrows 与 ncols 表示要划分几行几列的子区域</p><p>nrows*nclos  表示子图数量）</p><p>index 的初始值为1，用来选定具体的某个子区域。</p><p>如果新建的子图与现有的子图重叠，那么重叠部分的子图将会被自动删除，因为它们不可以共享绘图区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.plot([1,2,3])</span><br><span class="line">#现在创建一个子图，它表示一个有2行1列的网格的顶部图。</span><br><span class="line">#因为这个子图将与第一个重叠，所以之前创建的图将被删除</span><br><span class="line">plt.subplot(2,1,1)</span><br><span class="line">plt.plot(range(12))</span><br><span class="line">#创建带有黄色背景的第二个子图</span><br><span class="line">plt.subplot(2,1,2, facecolor=&#x27;y&#x27;)</span><br><span class="line">plt.plot(range(12))</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果不想覆盖之前的图</strong>，需要使用 add_subplot() 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(111)</span><br><span class="line">ax1.plot([1,2,3])</span><br><span class="line">ax2 = fig.add_subplot(2,2,1, facecolor=&#x27;y&#x27;)</span><br><span class="line">ax2.plot([1,2,3])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过给画布添加 axes 对象可以实现在同一画布中插入另外的图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">x = np.arange(0, math.pi*2, 0.05)</span><br><span class="line">fig=plt.figure()</span><br><span class="line">axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # main axes</span><br><span class="line">axes2 = fig.add_axes([0.55, 0.55, 0.3, 0.3]) # inset axes</span><br><span class="line">y = np.sin(x)</span><br><span class="line">axes1.plot(x, y, &#x27;b&#x27;)</span><br><span class="line">axes2.plot(x,np.cos(x),&#x27;r&#x27;)</span><br><span class="line">axes1.set_title(&#x27;sine&#x27;)</span><br><span class="line">axes2.set_title(&quot;cosine&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-subplots-函数"><a href="#Matplotlib-subplots-函数" class="headerlink" title="Matplotlib subplots()函数"></a>Matplotlib subplots()函数</h4><p>matplotlib.pyplot模块提供了一个 subplots() 函数，它的使用方法和 subplot() 函数类似。其不同之处在于，subplots() <strong>既创建了一个包含子图区域的画布，又创建了一个 figure 图形对象，而 subplot() 只是创建一个包含子图区域的画布。</strong></p><p>subplots 的函数格式如下：fig , ax &#x3D; plt.subplots(nrows, ncols)</p><p>nrows 与 ncols 表示两个整数参数，它们指定子图所占的行数、列数。</p><p>函数的返回值是一个元组，包括一个图形对象和所有的 axes 对象。其中 axes 对象的数量等于 nrows * ncols，且每个 axes 对象均可通过索引值访问（从1开始）。</p><p>下面我们创建了一个 2 行 2 列的子图，并在每个子图中显示 4 个不同的图像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig,a =  plt.subplots(2,2)</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.arange(1,5)</span><br><span class="line">#绘制平方函数</span><br><span class="line">a[0][0].plot(x,x*x)</span><br><span class="line">a[0][0].set_title(&#x27;square&#x27;)</span><br><span class="line">#绘制平方根图像</span><br><span class="line">a[0][1].plot(x,np.sqrt(x))</span><br><span class="line">a[0][1].set_title(&#x27;square root&#x27;)</span><br><span class="line">#绘制指数函数</span><br><span class="line">a[1][0].plot(x,np.exp(x))</span><br><span class="line">a[1][0].set_title(&#x27;exp&#x27;)</span><br><span class="line">#绘制对数函数</span><br><span class="line">a[1][1].plot(x,np.log10(x))</span><br><span class="line">a[1][1].set_title(&#x27;log&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-subplot2grid-函数"><a href="#Matplotlib-subplot2grid-函数" class="headerlink" title="Matplotlib subplot2grid()函数"></a>Matplotlib subplot2grid()函数</h4><p>matplotlib.pyplot 模块提供了 subplot2grid() ，该函数能够在画布的特定位置创建 axes 对象（即绘图区域）<br>不仅如此，它还可以使用不同数量的行、列来创建跨度不同的绘图区域。与 subplot() 和 subplots() 函数不同，subplot2gird() 函数以非等分的形式对画布进行切分，并按照绘图区域的大小来展示最终绘图结果。</p><p>函数语法格式如下：</p><p>plt.subplot2grid(shape, location, rowspan, colspan)</p><p>shape：把该参数值规定的网格区域作为绘图区域；</p><p>location：在给定的位置绘制图形，初始位置 (0,0) 表示第1行第1列；</p><p>rowsapan&#x2F;colspan：这两个参数用来设置让子区跨越几行几列。</p><p>下面，在画布（figure）中添加了行、列跨度均不相同的绘图子区域，然后在每个绘图区上，绘制不同的图形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#使用 colspan指定列，使用rowspan指定行</span><br><span class="line">a1 = plt.subplot2grid((3,3),(0,0),colspan = 2)</span><br><span class="line">a2 = plt.subplot2grid((3,3),(0,2), rowspan = 3)</span><br><span class="line">a3 = plt.subplot2grid((3,3),(1,0),rowspan = 2, colspan = 2)</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.arange(1,10)</span><br><span class="line">a2.plot(x, x*x)</span><br><span class="line">a2.set_title(&#x27;square&#x27;)</span><br><span class="line">a1.plot(x, np.exp(x))</span><br><span class="line">a1.set_title(&#x27;exp&#x27;)</span><br><span class="line">a3.plot(x, np.log(x))</span><br><span class="line">a3.set_title(&#x27;log&#x27;)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-grid-设置网格格式"><a href="#Matplotlib-grid-设置网格格式" class="headerlink" title="Matplotlib grid()设置网格格式"></a>Matplotlib grid()设置网格格式</h4><p>通过 Matplotlib axes 对象提供的 grid() 方法可以开启或者关闭画布中的网格（即是否显示网格）以及网格的主&#x2F;次刻度。除此之外，grid() 函数还可以设置网格的颜色、线型以及线宽等属性。</p><p>grid() 的函数使用格式如下：grid(color&#x3D;’b’, ls &#x3D; ‘-.’, lw &#x3D; 0.25)</p><p>color：表示网格线的颜色；<br>ls：表示网格线的样式；<br>lw：表示网格线的宽度；</p><p>网格在默认状态下是关闭的，通过调用上述函数，网格会被自动开启，如果您只是想开启不带任何样式的网格，可以通过 grid(True) 来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">#fig画布；axes子图区域</span><br><span class="line">fig, axes = plt.subplots(1,3, figsize = (12,4))</span><br><span class="line">x = np.arange(1,11)</span><br><span class="line">axes[0].plot(x, x**3, &#x27;g&#x27;,lw=2)</span><br><span class="line">#开启网格</span><br><span class="line">axes[0].grid(True)</span><br><span class="line">axes[0].set_title(&#x27;default grid&#x27;)</span><br><span class="line">axes[1].plot(x, np.exp(x), &#x27;r&#x27;)</span><br><span class="line">#设置网格的颜色，线型，线宽</span><br><span class="line">axes[1].grid(color=&#x27;b&#x27;, ls = &#x27;-.&#x27;, lw = 0.25)</span><br><span class="line">axes[1].set_title(&#x27;custom grid&#x27;)</span><br><span class="line">axes[2].plot(x,x)</span><br><span class="line">axes[2].set_title(&#x27;no grid&#x27;)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib坐标轴格式"><a href="#Matplotlib坐标轴格式" class="headerlink" title="Matplotlib坐标轴格式"></a>Matplotlib坐标轴格式</h4><p>在一个函数图像中，有时自变量 x 与因变量 y 是指数对应关系，这时需要将坐标轴刻度设置为对数刻度。Matplotlib 通过 axes 对象的xscale或yscale属性来实现对坐标轴的格式设置。</p><p>右侧的子图显示对数刻度，左侧子图则显示标量刻度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">fig, axes = plt.subplots(1, 2, figsize=(10,4))</span><br><span class="line">x = np.arange(1,5)</span><br><span class="line">axes[0].plot( x, np.exp(x))</span><br><span class="line">axes[0].plot(x,x**2)</span><br><span class="line">axes[0].set_title(&quot;Normal scale&quot;)</span><br><span class="line">axes[1].plot (x, np.exp(x))</span><br><span class="line">axes[1].plot(x, x**2)</span><br><span class="line">#设置y轴</span><br><span class="line">axes[1].set_yscale(&quot;log&quot;)</span><br><span class="line">axes[1].set_title(&quot;Logarithmic scale (y)&quot;)</span><br><span class="line">axes[0].set_xlabel(&quot;x axis&quot;)</span><br><span class="line">axes[0].set_ylabel(&quot;y axis&quot;)</span><br><span class="line">axes[0].xaxis.labelpad = 10</span><br><span class="line">#设置x、y轴标签</span><br><span class="line">axes[1].set_xlabel(&quot;x axis&quot;)</span><br><span class="line">axes[1].set_ylabel(&quot;y axis&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>轴是连接刻度的线，也就是绘图区域的边界，在绘图区域（axes 对象）的顶部、底部、左侧和右侧都有一个边界线（轴）。</p><p>通过指定轴的颜色和宽度，从而对进行显示格式设置，比如将所有轴的颜色设置为 None，那么它们都会成为隐藏状态，或者也可以给轴添加相应的颜色。</p><p>以下示例为左侧轴、底部轴分别设置了红色、蓝色，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#为左侧轴，底部轴添加颜色</span><br><span class="line">ax.spines[&#x27;bottom&#x27;].set_color(&#x27;blue&#x27;)</span><br><span class="line">ax.spines[&#x27;left&#x27;].set_color(&#x27;red&#x27;)</span><br><span class="line">ax.spines[&#x27;left&#x27;].set_linewidth(2)</span><br><span class="line">#将侧轴、顶部轴设置为None</span><br><span class="line">ax.spines[&#x27;right&#x27;].set_color(None)</span><br><span class="line">ax.spines[&#x27;top&#x27;].set_color(None)</span><br><span class="line">ax.plot([1,2,3,4,5])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-坐标轴范围"><a href="#Matplotlib-坐标轴范围" class="headerlink" title="Matplotlib 坐标轴范围"></a>Matplotlib 坐标轴范围</h4><p>Matplotlib 可以根据自变量与因变量的取值范围，自动设置 x 轴与 y 轴的数值大小。当然，也可以用自定义的方式，通过 set_xlim() 和 set_ylim() 对 x、y 轴的数值范围进行设置。</p><p>当对 3D 图像进行设置的时，会增加一个 z 轴，此时使用 set_zlim() 可以对 z 轴进行设置。</p><p>下面示例分别对自动设置和自定义设置做了演示：第一种 Matplotlib 自动设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加绘图区域</span><br><span class="line">a1 = fig.add_axes([0,0,1,1])</span><br><span class="line">#准备数据</span><br><span class="line">x = np.arange(1,10)</span><br><span class="line">#绘制函数图像</span><br><span class="line">a1.plot(x, np.exp(x))</span><br><span class="line">#添加题目</span><br><span class="line">a1.set_title(&#x27;exp&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>第二种：自定义设置，set_xlim() 将 x 轴的数值范围设置为（0到10)； set_ylim() 将 y 轴的范围设置为（0到10000）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">a1 = fig.add_axes([0,0,1,1])</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.arange(1,10)</span><br><span class="line">a1.plot(x, np.exp(x),&#x27;r&#x27;)</span><br><span class="line">a1.set_title(&#x27;exp&#x27;)</span><br><span class="line">#设置y轴</span><br><span class="line">a1.set_ylim(0,10000)</span><br><span class="line">#设置x轴</span><br><span class="line">a1.set_xlim(0,10)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-刻度和刻度标签"><a href="#Matplotlib-刻度和刻度标签" class="headerlink" title="Matplotlib 刻度和刻度标签"></a>Matplotlib 刻度和刻度标签</h4><p>刻度指的是轴上数据点的标记，Matplotlib 能够自动的在 x 、y 轴上绘制出刻度。这一功能的实现得益于 Matplotlib 内置的刻度定位器和格式化器（两个内建类）。在大多数情况下，这两个内建类完全能够满足我们的绘图需求，但是在某些情况下，刻度标签或刻度也需要满足特定的要求，比如将刻度设置为“英文数字形式”或者“大写阿拉伯数字”，此时就需要对它们重新设置。</p><p>xticks() 和 yticks() 函数接受一个列表对象作为参数，列表中的元素表示对应数轴上要显示的刻度。</p><p>如下所示：ax.set_xticks([2,4,6,8,10])</p><p>x 轴上的刻度标记，依次为 2，4，6，8，10。</p><p>您也可以分别通过 set_xticklabels() 和 set_yticklabels() 函数设置与刻度线相对应的刻度标签。</p><p>下面示例对刻度和标签的使用方法做了说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">import math</span><br><span class="line">x = np.arange(0, math.pi*2, 0.05)</span><br><span class="line">#生成画布对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加绘图区域</span><br><span class="line">ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])</span><br><span class="line">y = np.sin(x)</span><br><span class="line">ax.plot(x, y)</span><br><span class="line">#设置x轴标签</span><br><span class="line">ax.set_xlabel(&#x27;angle&#x27;)</span><br><span class="line">ax.set_title(&#x27;sine&#x27;)</span><br><span class="line">ax.set_xticks([0,2,4,6])</span><br><span class="line">#设置x轴刻度标签</span><br><span class="line">ax.set_xticklabels([&#x27;zero&#x27;,&#x27;two&#x27;,&#x27;four&#x27;,&#x27;six&#x27;])</span><br><span class="line">#设置y轴刻度</span><br><span class="line">ax.set_yticks([-1,0,1])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib中文乱码解决方案"><a href="#Matplotlib中文乱码解决方案" class="headerlink" title="Matplotlib中文乱码解决方案"></a>Matplotlib中文乱码解决方案</h4><p>Matplotlib 默认不支持中文字体，这因为 Matplotlib 只支持 ASCII 字符，但中文标注更加符合中国人的阅读习惯。因此，本节重点讲解如何在 Windows 环境下让 Matplotlib 显示中文。</p><p>Matplotlib中文乱码</p><p>当不对 Matplotlib 进行设置，而直接使用中文时，绘制的图像会出现中文乱码。</p><p>下面给出了两种解决中文乱码方案：第一种是临时解决方案，第二种是一劳永逸的解决方案。</p><p>重写配置文件</p><p>通过临时重写配置文件的方法，可以解决 Matplotlib 显示中文乱码的问题，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体</span><br><span class="line">plt.rcParams[&quot;axes.unicode_minus&quot;]=False #该语句解决图像中的“-”负号的乱码问题</span><br></pre></td></tr></table></figure><p>将上述代码添加到您的绘图程序中，即可解决中文乱码的问题。这是一种非常灵活、便捷的解决方法。完整的程序代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#绘制折线图</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体</span><br><span class="line">plt.rcParams[&quot;axes.unicode_minus&quot;]=False #正常显示负号</span><br><span class="line">year = [2017, 2018, 2019, 2020]</span><br><span class="line">people = [20, 40, 60, 70]</span><br><span class="line">#生成图表</span><br><span class="line">plt.plot(year, people)</span><br><span class="line">plt.xlabel(&#x27;年份&#x27;)</span><br><span class="line">plt.ylabel(&#x27;人口&#x27;)</span><br><span class="line">plt.title(&#x27;人口增长&#x27;)</span><br><span class="line">#设置纵坐标刻度</span><br><span class="line">plt.yticks([0, 20, 40, 60, 80])</span><br><span class="line">#设置填充选项：参数分别对应横坐标，纵坐标，纵坐标填充起始值，填充颜色</span><br><span class="line">plt.fill_between(year, people, 20, color = &#x27;green&#x27;)</span><br><span class="line">#显示图表</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>不过上述解决方案适用于所有操作系统，其唯一弊端是每编写一个绘图程序就要添加一次相同的代码。</p><p>修改配置文件</p><p>下面介绍第二种方式：通过直接修改配置文件的方法，可以一劳永逸的解决 Matplotlib 的中文乱码问题。注意此过程在 Windows 环境下进行。</p><p>Matplotlib 从配置文件 matplotlibrc 中读取相关配置信息，比如字体、样式等，因此我们需要对该配置文件进行更改。首先查看 matplotlibrc 所在的目录，使用如下代码确定目录位置：</p><p>import matplotlib<br>matplotlib.matplotlib_fname()</p><p>然后修改配置文件 matplotlibrc。打开配置文件后，找到以下信息：<br>#font.family: sans-serif</p><p>#font.serif: DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</p><p>将上述配置项前面的#去掉，并修改的配置项，如下所示：</p><p>font.family   :  Microsoft YaHei, sans-serif<br>font.serif: Microsoft YaHei, DejaVu Serif, Bitstream Vera Serif, Computer Modern Roman, New Century Schoolbook, Century Schoolbook L, Utopia, ITC Bookman, Bookman, Nimbus Roman No9 L, Times New Roman, Times, Palatino, Charter, serif</p><p>最后，在以下目录中复制中文字体微软雅黑：C:\Windows\Fonts\Microsoft YaHei UI</p><p>复制完成后，将字体粘贴至以下路径文件中：D:\python\python37\lib\site-packages\matplotlib\mpl-data\fonts\ttf</p><p>字体粘贴后会出现一个 MSYH.ttc 的字体文件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.linspace(-8, 8, 1024)</span><br><span class="line">y1 = 0.618 * np.abs(x) - 0.8 * np.sqrt(64 - x ** 2)</span><br><span class="line">y2 = 0.618 * np.abs(x) + 0.8 * np.sqrt(64 - x ** 2)</span><br><span class="line">plt.plot(x, y1, color=&#x27;r&#x27;)</span><br><span class="line">plt.plot(x, y2, color=&#x27;r&#x27;)</span><br><span class="line">plt.title(&quot;我爱C语言中文网&quot;,fontsize=20,color=&quot;b&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib双轴图"><a href="#Matplotlib双轴图" class="headerlink" title="Matplotlib双轴图"></a>Matplotlib双轴图</h4><p>在一些应用场景中，有时需要绘制两个 x 轴或两个 y 轴，这样可以更直观地显现图像，从而获取更有效的数据。Matplotlib 提供的 twinx() 和 twiny() 函数，除了可以实现绘制双轴的功能外，还可以使用不同的单位来绘制曲线，比如一个轴绘制对函数，另外一个轴绘制指数函数。</p><p>下面示例绘制了一个具有两个 y 轴的图形，一个显示指数函数 exp(x)，另一个显示对数函数 log(x)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">#创建图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加子图区域</span><br><span class="line">a1 = fig.add_axes([0,0,1,1])</span><br><span class="line">#准备数据</span><br><span class="line">x = np.arange(1,11)</span><br><span class="line">#绘制指数函数</span><br><span class="line">a1.plot(x,np.exp(x))</span><br><span class="line">a1.set_ylabel(&#x27;exp&#x27;)</span><br><span class="line">#添加双轴</span><br><span class="line">a2 = a1.twinx()</span><br><span class="line">#‘ro’表示红色圆点</span><br><span class="line">a2.plot(x, np.log(x),&#x27;ro-&#x27;)</span><br><span class="line">#绘制对数函数</span><br><span class="line">a2.set_ylabel(&#x27;log&#x27;)</span><br><span class="line">#绘制图例</span><br><span class="line">fig.legend(labels = (&#x27;exp&#x27;,&#x27;log&#x27;),loc=&#x27;upper left&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib柱状图"><a href="#Matplotlib柱状图" class="headerlink" title="Matplotlib柱状图"></a>Matplotlib柱状图</h4><p>柱状图是一种用矩形柱来表示数据分类的图表，柱状图可以垂直绘制，也可以水平绘制，它的高度与其所表示的数值成正比关系。柱状图显示了不同类别之间的比较关系，图表的水平轴 X 指定被比较的类别，垂直轴 Y 则表示具体的类别值</p><p>Matplotlib 提供了bar()函数来绘制柱状图，它可以应用在 MATLAB 样式以及面向对象的绘图方法中。当它与 axes 对象一起使用时</p><p>其语法格式如下：ax.bar(x, height, width, bottom, align)</p><p>x<br>一个标量序列，代表柱状图的x坐标，默认x取值是每个柱状图所在的中点位置，或者也可以是柱状图左侧边缘位置。</p><p>height<br>一个标量或者是标量序列，代表柱状图的高度。</p><p>width<br>可选参数，标量或类数组，柱状图的默认宽度值为 0.8。</p><p>bottom<br>可选参数，标量或类数组，柱状图的y坐标默认为None。</p><p>algin<br>有两个可选项 {“center”,”edge”}，默认为 ‘center’，该参数决定 x 值位于柱状图的位置。</p><p>该函数的返回值是一个 Matplotlib 容器对象，该对象包含了所有柱状图。</p><p>下面是一个关于 Matplotlib 柱状图的简单示例。它用来显示了不同编程语言的学习人数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#创建图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加子图区域，参数值表示[left, bottom, width, height ]</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#准备数据</span><br><span class="line">langs = [&#x27;C&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;, &#x27;Python&#x27;, &#x27;PHP&#x27;]</span><br><span class="line">students = [23,17,35,29,12]</span><br><span class="line">#绘制柱状图</span><br><span class="line">ax.bar(langs,students)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过调整柱状图的宽度，可以实现在同一 x 轴位置绘制多个柱状图。可以将它们设置成不同的颜色，从而使它们更容易区分。</p><p>下面示例描述了某工程学院过去四年中，三个专业录取的统招学生数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#准备数据</span><br><span class="line">data = </span><br><span class="line">[[30, 25, 50, 20],</span><br><span class="line">[40, 23, 51, 17],</span><br><span class="line">[35, 22, 45, 19]]</span><br><span class="line">X = np.arange(4)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加子图区域</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#绘制柱状图</span><br><span class="line">ax.bar(X + 0.00, data[0], color = &#x27;b&#x27;, width = 0.25)</span><br><span class="line">ax.bar(X + 0.25, data[1], color = &#x27;g&#x27;, width = 0.25)</span><br><span class="line">ax.bar(X + 0.50, data[2], color = &#x27;r&#x27;, width = 0.25)</span><br></pre></td></tr></table></figure><p>柱状图除了上述使用方法外，还有另外一种堆叠柱状图。所谓堆叠柱状图就是将不同数组别的柱状图堆叠在一起，堆叠后的柱状图高度显示了两者相加的结果值。</p><p>bar() 函数提供了一个可选参数bottom，该参数可以指定柱状图开始堆叠的起始值，一般从底部柱状图的最大值开始，依次类推。</p><p>下面是一个不同国家参加奥林匹克运动会所得奖牌（金银铜）的柱状堆叠图示例，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">countries = [&#x27;USA&#x27;, &#x27;India&#x27;, &#x27;China&#x27;, &#x27;Russia&#x27;, &#x27;Germany&#x27;] </span><br><span class="line">bronzes = np.array([38, 17, 26, 19, 15]) </span><br><span class="line">silvers = np.array([37, 23, 18, 18, 10]) </span><br><span class="line">golds = np.array([46, 27, 26, 19, 17]) </span><br><span class="line"># 此处的 _ 下划线表示将循环取到的值放弃，只得到[0,1,2,3,4]</span><br><span class="line">ind = [x for x, _ in enumerate(countries)] </span><br><span class="line">#绘制堆叠图</span><br><span class="line">plt.bar(ind, golds, width=0.5, label=&#x27;golds&#x27;, color=&#x27;gold&#x27;, bottom=silvers+bronzes) </span><br><span class="line">plt.bar(ind, silvers, width=0.5, label=&#x27;silvers&#x27;, color=&#x27;silver&#x27;, bottom=bronzes) </span><br><span class="line">plt.bar(ind, bronzes, width=0.5, label=&#x27;bronzes&#x27;, color=&#x27;#CD853F&#x27;) </span><br><span class="line">#设置坐标轴</span><br><span class="line">plt.xticks(ind, countries) </span><br><span class="line">plt.ylabel(&quot;Medals&quot;) </span><br><span class="line">plt.xlabel(&quot;Countries&quot;) </span><br><span class="line">plt.legend(loc=&quot;upper right&quot;) </span><br><span class="line">plt.title(&quot;2019 Olympics Top Scorers&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在上述代码中，第一次调用plt.bar()绘制了黄色柱状图， 第二次调用plot.bar()时绘制了灰色柱状图，最后一次调用plt.bar()则绘制最底部的柱状图。两个柱状图相接触的位置就是顶部与底部的位置，这样就构成了柱状堆叠图。</p><h4 id="Matplotlib直方图"><a href="#Matplotlib直方图" class="headerlink" title="Matplotlib直方图"></a>Matplotlib直方图</h4><p>直方图（Histogram），又称质量分布图，它是一种条形图的一种，由一系列高度不等的纵向线段来表示数据分布的情况。 直方图的横轴表示数据类型，纵轴表示分布情况。</p><p>首先，我们需要了解柱状图和直方图的区别。<br>直方图用于概率分布，它显示了一组数值序列在给定的数值范围内出现的概率；而柱状图则用于展示各个类别的频数。</p><p>例如，我们对某工厂的员工年龄做直方图统计，首先我们要统计出每一位员工的年龄，然后设定一个 20 至 65 的数值范围，并将该数值范围细分为 4 个区间段 (20,35),(35,45),(45,55),(55,65) , 最后通过直方图的形式，展示该工厂员工在相应年龄区间的分布情况。</p><p>如果想要构建直方图，必须遵循以下步骤：<br>将整个值范围划分为一系列区间。<br>区间值（bin）的取值，不可遗漏数据；<br>计算每个区间中有多少个值。</p><p>通常将 bin 指定为连续且不重叠的数值区间，而 bin 值指区间开始和结束的数值。</p><p>可以使用下面的函数来绘制直方图：matplotlib.pyplot.hist（）</p><p>x<br>必填参数，数组或者数组序列。</p><p>bins<br>可选参数，整数或者序列，bins 表示每一个间隔的边缘（起点和终点）默认会生成10个间隔。</p><p>range<br>指定全局间隔的下限与上限值 (min,max)，元组类型，默认值为 None。</p><p>density<br>如果为 True，返回概率密度直方图；默认为 False，返回相应区间元素的个数的直方图。</p><p>histtype<br>要绘制的直方图类型，默认值为“bar”，可选值有 barstacked(堆叠条形图)、step(未填充的阶梯图)、stepfilled(已填充的阶梯图)。</p><p>以下示例绘制了班级学生得分情况的直方图。其中定义了四个区间（bins）分别是：0-25、26-50、51-75 和 76-100。直方图显示了相应范围的学生人数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">#创建图形对象和轴域对象</span><br><span class="line">fig,ax = plt.subplots(1,1)</span><br><span class="line">a = np.array([22,87,5,43,56,73,55,54,11,20,51,5,79,31,27])</span><br><span class="line">#绘制直方图</span><br><span class="line">ax.hist(a, bins = [0,25,50,75,100])</span><br><span class="line">#设置坐标轴</span><br><span class="line">ax.set_title(&quot;histogram of result&quot;)</span><br><span class="line">ax.set_xticks([0,25,50,75,100])</span><br><span class="line">ax.set_xlabel(&#x27;marks&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;no.of students&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib饼状图"><a href="#Matplotlib饼状图" class="headerlink" title="Matplotlib饼状图"></a>Matplotlib饼状图</h4><p>饼状图用来显示一个数据系列，具体来说，饼状图显示一个数据系列中各项目的占项目总和的百分比。<br>Matplotlib 提供了一个 pie() 函数，该函数可以生成数组中数据的饼状图。</p><p>可使用 x&#x2F;sum(x) 来计算各个扇形区域占饼图总和的百分比。</p><p>pie() 函数的参数说明如下：</p><p>X<br>数组序列，数组元素对应扇形区域的数量大小。</p><p>labels<br>列表字符串序列，为每个扇形区域备注一个标签名字。</p><p>color<br>为每个扇形区域设置颜色，默认按照颜色周期自动设置。</p><p>autopct<br>格式化字符串”fmt%pct”，使用百分比的格式设置每个扇形<br>区的标签，并将其放置在扇形区内。</p><p>以下示例：关于不同计算机语言学习人数的饼状图。</p><p>autopct 参数设置为 %1.2f% ，并将各项所占总和的百分比显示在相对应的扇形区内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">#添加图形对象</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#使得X/Y轴的间距相等</span><br><span class="line">ax.axis(&#x27;equal&#x27;)</span><br><span class="line">#准备数据</span><br><span class="line">langs = [&#x27;C&#x27;, &#x27;C++&#x27;, &#x27;Java&#x27;, &#x27;Python&#x27;, &#x27;PHP&#x27;]</span><br><span class="line">students = [23,17,35,29,12]</span><br><span class="line">#绘制饼状图</span><br><span class="line">ax.pie(students, labels = langs,autopct=&#x27;%1.2f%%&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib折线图"><a href="#Matplotlib折线图" class="headerlink" title="Matplotlib折线图"></a>Matplotlib折线图</h4><p>折线图（line chart）是我们日常工作、学习中经常使用的一种图表，它可以直观的反映数据的变化趋势。与绘制柱状图、饼状图等图形不同，Matplotlib 并没有直接提供绘制折线图的函数，因此本节着重讲解如何绘制一幅折线图。</p><p>绘制单条折线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#准备绘制数据</span><br><span class="line">x = [&quot;Mon&quot;, &quot;Tues&quot;, &quot;Wed&quot;, &quot;Thur&quot;, &quot;Fri&quot;,&quot;Sat&quot;,&quot;Sun&quot;]</span><br><span class="line">y = [20, 40, 35, 55, 42, 80, 50]</span><br><span class="line"># &quot;g&quot; 表示红色，marksize用来设置&#x27;D&#x27;菱形的大小</span><br><span class="line">plt.plot(x, y, &quot;g&quot;, marker=&#x27;D&#x27;, markersize=5, label=&quot;周活&quot;)</span><br><span class="line">#显示图例</span><br><span class="line">plt.legend(loc=&quot;lower right&quot;)</span><br><span class="line">#调用 text()在图像上绘制注释文本</span><br><span class="line">#x1、y1表示文本所处坐标位置，ha参数控制水平对齐方式, va控制垂直对齐方式，str(y1)表示要绘制的文本</span><br><span class="line">for x1, y1 in zip(x, y):</span><br><span class="line">    plt.text(x1, y1, str(y1), ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;, fontsize=10)</span><br><span class="line">#保存图片</span><br><span class="line">plt.savefig(&quot;1.jpg&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>绘制多条折线图<br>当学习完如何绘制单条折线的绘制后，再绘制多条折线也变的容易，只要准备好绘制多条折线图的数据即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#对比两天内同一时刻温度的变化情况</span><br><span class="line">x = [5, 8, 12, 14, 16, 18, 20]</span><br><span class="line">y1 = [18, 21, 29, 31, 26, 24, 20]</span><br><span class="line">y2 = [15, 18, 24, 30, 31, 25, 24]</span><br><span class="line">#绘制折线图，添加数据点，设置点的大小</span><br><span class="line"># * 表示绘制五角星；此处也可以不设置线条颜色，matplotlib会自动为线条添加不同的颜色</span><br><span class="line">plt.plot(x, y1, &#x27;r&#x27;,marker=&#x27;*&#x27;, markersize=10)</span><br><span class="line">plt.plot(x, y2, &#x27;b&#x27;, marker=&#x27;*&#x27;,markersize=10)</span><br><span class="line">plt.title(&#x27;温度对比折线图&#x27;)  # 折线图标题</span><br><span class="line">plt.xlabel(&#x27;时间(h)&#x27;)  # x轴标题</span><br><span class="line">plt.ylabel(&#x27;温度(℃)&#x27;)  # y轴标题</span><br><span class="line">#给图像添加注释，并设置样式</span><br><span class="line">for a, b in zip(x, y1):</span><br><span class="line">    plt.text(a, b, b, ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;, fontsize=10)</span><br><span class="line">for a, b in zip(x, y2):</span><br><span class="line">    plt.text(a, b, b, ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;, fontsize=10)</span><br><span class="line"></span><br><span class="line">#绘制图例</span><br><span class="line">plt.legend([&#x27;第一天&#x27;, &#x27;第二天&#x27;])</span><br><span class="line">#显示图像</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Python-Matplotlib散点图"><a href="#Python-Matplotlib散点图" class="headerlink" title="Python Matplotlib散点图"></a>Python Matplotlib散点图</h4><p>散点图用于在水平轴和垂直轴上绘制数据点，它表示了因变量随自变量变化的趋势。通俗地讲，它反映的是一个变量受另一个变量的影响程度。</p><p>散点图将序列显示为一组点，其中每个散点值都由该点在图表中的坐标位置表示。对于不同类别的点，则由图表中不同形状或颜色的标记符表示。同时，您也可以设置标记符的颜色或大小。</p><p>下面示例，绘制了学生考试成绩的散点图，其中蓝色代表男孩成绩，红色表示女孩的成绩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">girls_grades = [89, 90, 70, 89, 100, 80, 90, 100, 80, 34]</span><br><span class="line">boys_grades = [30, 29, 49, 48, 100, 48, 38, 45, 20, 30]</span><br><span class="line">grades_range = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span><br><span class="line">fig=plt.figure()</span><br><span class="line">#添加绘图区域</span><br><span class="line">ax=fig.add_axes([0,0,1,1])</span><br><span class="line">ax.scatter(grades_range, girls_grades, color=&#x27;r&#x27;,label=&quot;girls&quot;)</span><br><span class="line">ax.scatter(grades_range, boys_grades, color=&#x27;b&#x27;,label=&quot;boys&quot;)</span><br><span class="line">ax.set_xlabel(&#x27;Grades Range&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;Grades Scored&#x27;)</span><br><span class="line">ax.set_title(&#x27;scatter plot&#x27;)</span><br><span class="line">#添加图例</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib等高线图"><a href="#Matplotlib等高线图" class="headerlink" title="Matplotlib等高线图"></a>Matplotlib等高线图</h4><p>等高线图（也称“水平图”）是一种在二维平面上显示 3D 图像的方法。等高线有时也被称为 “Z 切片”，如果您想要查看因变量 Z 与自变量 X、Y 之间的函数图像变化（即 Z&#x3D;f(X,Y)），那么采用等高线图最为直观。</p><p>自变量 X 和 Y 需要被限制在矩形网格内，您可以将 x 、y 数组作为参数传递给 numpy.meshgrid() 函数来构建一个网格点矩阵。</p><p>Matplotlib API 提供了绘制等高线（contour）与填充等高线（ contourf）的函数。这两个函数都需要三个参数，分别是 X、Y 与 Z。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#创建xlist、ylist数组</span><br><span class="line">xlist = np.linspace(-3.0, 3.0, 100)</span><br><span class="line">ylist = np.linspace(-3.0, 3.0, 100)</span><br><span class="line">#将上述数据变成网格数据形式</span><br><span class="line">X, Y = np.meshgrid(xlist, ylist)</span><br><span class="line">#定义Z与X,Y之间的关系</span><br><span class="line">Z = np.sqrt(X**2 + Y**2)</span><br><span class="line">fig,ax=plt.subplots(1,1)</span><br><span class="line">#填充等高线颜色</span><br><span class="line">cp = ax.contourf(X, Y, Z)</span><br><span class="line">fig.colorbar(cp) # 给图像添加颜色柱</span><br><span class="line">ax.set_title(&#x27;Filled Contours Plot&#x27;)</span><br><span class="line">ax.set_xlabel(&#x27;x (cm)&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;y (cm)&#x27;)</span><br><span class="line">#画等高线</span><br><span class="line">plt.contour(X,Y,Z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>左侧图像绘制了两个变量 X、Y ，右侧的颜色柱（colorbar）则表示 X 的取值，颜色越深表示值越小，中间深色部分的圆心点表示 x&#x3D;0，y&#x3D;0，z&#x3D;0。</p><h4 id="Matplotlib振动图"><a href="#Matplotlib振动图" class="headerlink" title="Matplotlib振动图"></a>Matplotlib振动图</h4><p>振动图也叫磁场图，或量场图，其图像的表现形式是一组矢量箭头，其数学含义是在点 (x,y) 处具有分向量 (u,v)。</p><p>Matplotlib 提供绘制量场图的函数，如下所示：quiver(x,y,u,v)</p><p>上述函数表示，在指定的 (x,y) 坐标上以箭头的形式绘制向量，参数说明如下：</p><p>x<br>一维、二维数组或者序列，表示箭头位置的x坐标。</p><p>y<br>一维、二维数组或者序列，表示箭头位置的y坐标。</p><p>u<br>一维、二维数组或者序列，表示箭头向量的x分量。</p><p>v<br>一维、二维数组或者序列，表示箭头向量的y分量。</p><p>c<br>一维、二维数组或者序列，表示箭头颜色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">x,y = np.meshgrid(np.arange(-2, 2, 0.2), np.arange(-2, 2, 0.25))</span><br><span class="line">z = x*np.exp(-x**2 - y**2)</span><br><span class="line">#计算数组中元素的梯度</span><br><span class="line">v, u = np.gradient(z, 0.2, 0.2)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">q = ax.quiver(x,y,u,v)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib提琴图"><a href="#Matplotlib提琴图" class="headerlink" title="Matplotlib提琴图"></a>Matplotlib提琴图</h4><p>小提琴图（Violin Plot）是用来展示数据分布状态以及概率密度的图表。这种图表结合了箱形图和密度图的特征。小提琴图跟箱形图类似，不同之处在于小提琴图还显示数据在不同数值下的概率密度。</p><p>小提琴图使用核密度估计（KDE）来计算样本的分布情况，图中要素包括了中位数、四分位间距以及置信区间。在数据量非常大且不方便一一展示的时候，小提琴图特别适用。</p><p>概率密度估计、置信区间、四分位间距都属于统计学中的概念，可自行查阅，这里不做说明。</p><p>小提琴图比箱型图能提供了更多的信息。虽然箱型图显示了均值、中位数和上、下四分位数等统计信息，但是小提琴图却显示了数据的完整分布情况，这更利于数据的分析与比对。下面是小提琴图的使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">np.random.seed(10)</span><br><span class="line">collectn_1 = np.random.normal(100, 10, 200)</span><br><span class="line">collectn_2 = np.random.normal(80, 30, 200)</span><br><span class="line">collectn_3 = np.random.normal(90, 20, 200)</span><br><span class="line">collectn_4 = np.random.normal(70, 25, 200)</span><br><span class="line">#创建绘制小提琴图的数据序列</span><br><span class="line">data_to_plot = [collectn_1, collectn_2, collectn_3, collectn_4]</span><br><span class="line">#创建一个画布</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#创建一个绘图区域</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line"># 创建一个小提琴图</span><br><span class="line">bp = ax.violinplot(data_to_plot)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Python-Matplotlib-3D绘图详解"><a href="#Python-Matplotlib-3D绘图详解" class="headerlink" title="Python Matplotlib 3D绘图详解"></a>Python Matplotlib 3D绘图详解</h4><p>最初开发的 Matplotlib，仅支持绘制 2d 图形，后来随着版本的不断更新， Matplotlib 在二维绘图的基础上，构建了一部分较为实用的 3D 绘图程序包，比如 mpl_toolkits.mplot3d，通过调用该程序包一些接口可以绘制 3D散点图、3D曲面图、3D线框图等</p><p>面编写第一个三维绘图程序。首先创建一个三维绘图区域， plt.axes() 函数提供了一个参数projection，将其参数值设置为 “3d”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits import mplot3d</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#创建3d绘图区域</span><br><span class="line">ax = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">#从三个维度构建</span><br><span class="line">z = np.linspace(0, 1, 100)</span><br><span class="line">x = z * np.sin(20 * z)</span><br><span class="line">y = z * np.cos(20 * z)</span><br><span class="line">#调用 ax.plot3D创建三维线图</span><br><span class="line">ax.plot3D(x, y, z, &#x27;gray&#x27;)</span><br><span class="line">ax.set_title(&#x27;3D line plot&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上述代码中的 ax.plot3D() 函数可以绘制各种三维图形，这些三维图都要根据(x，y，z)三元组类来创建。</p><p>3D散点图</p><p>通过 ax.scatter3D() 函数可以绘制 3D 散点图，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits import mplot3d</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#创建绘图区域</span><br><span class="line">ax = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">#构建xyz</span><br><span class="line">z = np.linspace(0, 1, 100)</span><br><span class="line">x = z * np.sin(20 * z)</span><br><span class="line">y = z * np.cos(20 * z)</span><br><span class="line">c = x + y</span><br><span class="line">ax.scatter3D(x, y, z, c=c)</span><br><span class="line">ax.set_title(&#x27;3d Scatter plot&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>3D等高线图</p><p>ax.contour3D() 可以用来创建三维等高线图，该函数要求输入数据均采用二维网格式的矩阵坐标。同时，它可以在每个网格点(x,y)处计算出一个 z 值。</p><p>以下示例展示了如何绘制三维正弦等高线图。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits import mplot3d</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">def f(x, y):</span><br><span class="line">   return np.sin(np.sqrt(x ** 2 + y ** 2))</span><br><span class="line">#构建x、y数据</span><br><span class="line">x = np.linspace(-6, 6, 30)</span><br><span class="line">y = np.linspace(-6, 6, 30)</span><br><span class="line">#将数据网格化处理</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">#50表示在z轴方向等高线的高度层级，binary颜色从白色变成黑色</span><br><span class="line">ax.contour3D(X, Y, Z, 50, cmap=&#x27;binary&#x27;)</span><br><span class="line">ax.set_xlabel(&#x27;x&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;y&#x27;)</span><br><span class="line">ax.set_zlabel(&#x27;z&#x27;)</span><br><span class="line">ax.set_title(&#x27;3D contour&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>3D线框图</p><p>线框图同样要采用二维网格形式的数据，与绘制等高线图类似。线框图可以将数据投影到指定的三维表面上，并输出可视化程度较高的三维效果图。通过 plot_wireframe() 能够绘制 3D 线框图。代码如下：</p><figure class="highlight plaintext"><figcaption><span>mpl_toolkits import mplot3d</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#要绘制函数图像</span><br><span class="line">def f(x, y):</span><br><span class="line">   return np.sin(np.sqrt(x ** 2 + y ** 2))</span><br><span class="line">#准备x,y数据</span><br><span class="line">x = np.linspace(-6, 6, 30)</span><br><span class="line">y = np.linspace(-6, 6, 30)</span><br><span class="line">#生成x、y网格化数据</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">#准备z值</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">#绘制图像</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">#调用绘制线框图的函数plot_wireframe()</span><br><span class="line">ax.plot_wireframe(X, Y, Z, color=&#x27;black&#x27;)</span><br><span class="line">ax.set_title(&#x27;wireframe&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>3D曲面图<br>曲面图表示一个指定的因变量y与两个自变量x和z之间的函数关系。3D 曲面图是一个三维图形，它非常类似于线框图。不同之处在于，线框图的每个面都由多边形填充而成。Matplotlib 提供的 plot_surface() 函数可以绘制 3D 曲面图，该函数需要接受三个参数值 x，y 和 z 。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from mpl_toolkits import mplot3d</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">#求向量积(outer()方法又称外积)</span><br><span class="line">x = np.outer(np.linspace(-2, 2, 30), np.ones(30))</span><br><span class="line">#矩阵转置</span><br><span class="line">y = x.copy().T </span><br><span class="line">#数据z</span><br><span class="line">z = np.cos(x ** 2 + y ** 2)</span><br><span class="line">#绘制曲面图</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection=&#x27;3d&#x27;)</span><br><span class="line">调用plot_surface()函数</span><br><span class="line">ax.plot_surface(x, y, z,cmap=&#x27;viridis&#x27;, edgecolor=&#x27;none&#x27;)</span><br><span class="line">ax.set_title(&#x27;Surface plot&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib-绘制文本"><a href="#Matplotlib-绘制文本" class="headerlink" title="Matplotlib 绘制文本"></a>Matplotlib 绘制文本</h4><p>Matplotlib 支持广泛的文本格式，比如 TTF 页面语言、Unicode 字符等。这是因为 Matplotlib 内置了 matplotlib.font_manager 字体管理器，它是一个实现了跨平台，并符合 W3C 字体查找算法的字体集合。TTF（TrueType Font） 是苹果公司和微软公司合作开发的页面描述语言，用来描述字符的轮廓，结合了光栅技术和矢量技术的优点。用户可以对文本属性进行控制，比如字体大小、粗细、位置和颜色等。</p><p>与此同时，Matplotlib 也支持绘制 TeX 包含的数学符号。TeX 是一套功能强大、十分灵活的排版语言，它可以用来绘制文本、符号、数学表达式等。</p><p>通过下面的方法可以绘制出相应的内容：</p><p>text<br>在绘图区域的任意位置添加文本。</p><p>annotate<br>在绘图区域的任意位置添加带有可选箭头的注释。</p><p>xlabel<br>在绘图区域的 x 轴上添加标签。</p><p>ylabel<br>在绘图区域的 y 轴上添加标签。</p><p>title<br>为绘图区域添加标题。</p><p>figtext<br>在画布的任意位置添加文本。</p><p>suptitle<br>为画布中添加标题。</p><p>Matplotlib 使用pyplot模块中的 text() 函数绘制文本<br>函数的语法格式如下：plt.text(x, y, string, weight&#x3D;”bold”, color&#x3D;”b”)</p><p>x:<br>注释文本内容所在位置的横坐标；<br>y：<br>注释文本内容所在位置的纵坐标；<br>string：<br>注释文本内容；<br>weight：<br>注释文本内容的粗细风格；</p><p>下面使用 text() 函数会创建一个文本对象。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">plt.rcParams[&quot;font.sans-serif&quot;]=[&quot;SimHei&quot;] #设置字体</span><br><span class="line">plt.rcParams[&quot;axes.unicode_minus&quot;]=False #正常显示负号</span><br><span class="line">fig = plt.figure()</span><br><span class="line">#添加绘图区域</span><br><span class="line">ax = fig.add_axes([0,0,1,1])</span><br><span class="line">#设置格式</span><br><span class="line">ax.set_title(&#x27;axes title&#x27;)</span><br><span class="line">ax.set_xlabel(&#x27;xlabel&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;ylabel&#x27;)</span><br><span class="line"># 3,8 表示x，y的坐标点；style设置字体样式为斜体；bbox用来设置盒子的属性，比如背景色</span><br><span class="line">ax.text(3, 8, &#x27;啊啊啊&#x27;, style=&#x27;italic&#x27;,bbox = &#123;&#x27;facecolor&#x27;: &#x27;yellow&#x27;&#125;,fontsize=15)</span><br><span class="line">#绘制数学表达式,用$符包裹</span><br><span class="line">ax.text(2, 6, r&#x27;an equation: $E = mc^2$&#x27;, fontsize = 15)</span><br><span class="line">#添加文字，并设置样式</span><br><span class="line">ax.text(4, 0.05, &#x27;344f969&#x27;,verticalalignment = &#x27;bottom&#x27;, color = &#x27;green&#x27;, fontsize = 15)</span><br><span class="line">ax.plot([2], [1], &#x27;o&#x27;)</span><br><span class="line">#xy为点的坐标；xytext为注释内容坐标；arrowprops设置箭头的属性</span><br><span class="line">ax.annotate(&#x27;C, xy = (2, 1), xytext = (3, 4),arrowprops = dict(facecolor = &#x27;blue&#x27;, shrink = 0.1))</span><br><span class="line">#设置坐标轴x,y</span><br><span class="line">ax.axis([0, 10, 0, 10])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="Matplotlib数学表达式"><a href="#Matplotlib数学表达式" class="headerlink" title="Matplotlib数学表达式"></a>Matplotlib数学表达式</h4><p>Matplotlib 中的文本字符串都可以使用 Text Markup（一种文本标记语言）显现出来，具体的使用方法是将文本标记符放在一对美元符号$内，语法格式如下：<br>#数学表达式<br>plt.title(r’$\alpha &gt; \beta$’)</p><p>如果要绘制下标和上标，您需要使用’_’和’^’符号，下面是一个简单的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#绘制表达式 r&#x27;$\alpha_i&gt; \beta_i$&#x27;</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">t = np.arange(0.0, 2.0, 0.01)</span><br><span class="line">s = np.sin(2*np.pi*t)</span><br><span class="line">#绘制函数图像</span><br><span class="line">plt.plot(t,s)</span><br><span class="line">#设置标题</span><br><span class="line">plt.title(r&#x27;$\alpha_i&gt; \beta_i$&#x27;, fontsize=20)</span><br><span class="line">#设置数学表达式</span><br><span class="line">plt.text(0.6, 0.6, r&#x27;$\mathcal&#123;A&#125;\mathrm&#123;sin&#125;(2 \omega t)$&#x27;, fontsize = 20)</span><br><span class="line">#设置数学表达式</span><br><span class="line">plt.text(0.1, -0.5, r&#x27;$\sqrt&#123;2&#125;$&#x27;, fontsize=10)</span><br><span class="line">plt.xlabel(&#x27;time (s)&#x27;)</span><br><span class="line">plt.ylabel(&#x27;volts (mV)&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>从上述示例可以看出，虽然数学表达式种类繁多，但是 Matplotlib 对各种数学符号都做了良好的支持。</p><h4 id="Matplotlib-image图像处理"><a href="#Matplotlib-image图像处理" class="headerlink" title="Matplotlib image图像处理"></a>Matplotlib image图像处理</h4><p>Matplotlib 软件包中的image模块提供了加载、缩放和显示图像的功能，该模块只能支持 PNG 格式的图片，如果格式不符，需要对图片的格式进行转换</p><p>下面示例，imread() 函数用于读取图像数据并形成 ndarray 数组 ，其数据类型为 float32</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import matplotlib.image as mpimg</span><br><span class="line">import numpy as np</span><br><span class="line">img = mpimg.imread(&#x27;mtplogo.png&#x27;)</span><br></pre></td></tr></table></figure><p>通过执行 imsave() 函数，可以将包含图像数据的 ndarray 数组保存到磁盘文件中。</p><p>plt.imsave(“logo.png”, img, cmap &#x3D; ‘gray’, origin &#x3D; ‘lower’)</p><p>如下所示，将 imsave()方法的origin参数设置为 lower 实现了原始图像的垂直翻转。</p><p>通过 imshow() 函数可以在 Matplotlib 查看器上绘制出相应的图像。其函数格式如下：imgplot &#x3D; plt.imshow(img)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br><span class="line">fig=plt.figure()</span><br><span class="line">ax1=fig.add_subplot(221)</span><br><span class="line">ax2=fig.add_subplot(222)</span><br><span class="line">ax3=fig.add_subplot(223)</span><br><span class="line">ax4=fig.add_subplot(224)</span><br><span class="line">#准备数据</span><br><span class="line">#绘制z = sqrt(x^2+y^2)图像</span><br><span class="line">points=np.arange(-5,5,0.01)</span><br><span class="line"># meshgrid 接受两个一维数组，然后产生两个二维矩阵</span><br><span class="line">xs,ys=np.meshgrid(points,points)</span><br><span class="line">#绘制图像</span><br><span class="line">z=np.sqrt(xs**2+ys**2)</span><br><span class="line">ax = fig.add_subplot(221)</span><br><span class="line">#默认</span><br><span class="line">ax.imshow(z)</span><br><span class="line">ax = fig.add_subplot(222)</span><br><span class="line">ax.imshow(z,cmap = &quot;gray&quot;)</span><br><span class="line">ax = fig.add_subplot(223)</span><br><span class="line">ax.imshow(z,cmap=&quot;cool&quot;)</span><br><span class="line">ax = fig.add_subplot(224)</span><br><span class="line">ax.imshow(z,cmap=&quot;hot&quot;)</span><br><span class="line">#显示图像</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># from PIL import Image</span><br><span class="line"># import matplotlib.pyplot as plt</span><br><span class="line"># img=Image.open(&#x27;E:/My/python1/12.png&#x27;)</span><br><span class="line"># plt.figure(&quot;dog&quot;)</span><br><span class="line"># plt.imshow(img)</span><br><span class="line"># plt.show()</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import matplotlib.image as pli</span><br><span class="line">image = plt.imread(&#x27;E:/My/python1/12.png&#x27;)    </span><br><span class="line">plt.imshow(image)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Matplotlib转换对象"><a href="#Matplotlib转换对象" class="headerlink" title="Matplotlib转换对象"></a>Matplotlib转换对象</h4><p>Matplotlib 是一款轻量级的图形转换框架，它通过转换对象轻松地实现了数据坐标系、轴域坐标系、图形坐标系，以及显示坐标系四者之间的相互转换，由于这种转换是 Matplotlib 自动完成的，因此无需考虑其底层原理。</p><p>坐标系转换对象</p><p>下面对四种坐标系做简单说明，其中ax代表轴域对象的实例；fig代表图形对象的实例。</p><img src="/post/8710c1f/364.png" class title="This is an image"><p>转换对象作用就是在不同对象之间架起一座沟通的桥梁。输入一组数据最终以图像的形式显示，这个过程就是依靠转换对象来实现的。</p><p>上表中的 Data、Axes、Figure，这三个转换对象都可以接受一组数据，它们会将接受的数据转换到显示坐标系中，即 Display。在这个过程中，显示坐标系只是充当数据的接收者，因此显示坐标系不存在转换对象。</p><p>示例说明<br>下面举一个简单的示例，现有文本“my text”放置在数据点 (x,y) 位置处：<br>axes.text(x,y,”my text”) </p><p>通过 Axes 转换对象，我们可以指定文本的位置。使用以下代码，将文本移动至在坐标系的中心位置：axes.text(0.5, 0.5, “middle of graph”, transform&#x3D;axes.transAxes)</p>]]></content>
      
      
      <categories>
          
          <category> matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言常见函数</title>
      <link href="/post/25258312.html"/>
      <url>/post/25258312.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h4 id="一-lt-ctype-h-gt-函数原型功能"><a href="#一-lt-ctype-h-gt-函数原型功能" class="headerlink" title="一. &lt;ctype.h&gt;函数原型功能"></a>一. &lt;ctype.h&gt;函数原型功能</h4><p>int iscntrl(int c)<br>判断字符c是否为控制字符。</p><p>int isalnum(int c)<br>判断字符c是否为字母或数字</p><p>int isalpha(int c)<br>判断字符c是否为英文字母</p><p>int isascii(int c)<br>判断字符c是否为ascii码</p><p>int isblank(int c)<br>判断字符c是否为TAB或空格</p><p>int isdigit(int c)<br>判断字符c是否为数字</p><p>int isgraph(int c)<br>判断字符c是否为除空格外的可打印字符</p><p>int islower(int c)<br>判断字符c是否为小写英文字母</p><p>int isprint(int c)<br>判断字符c是否为可打印字符（含空格）</p><p>int ispunct(int c)<br>判断字符c是否为标点符号</p><p>int isspace(int c)<br>判断字符c是否为空白符</p><p>int isupper(int c)<br>判断字符c是否为大写英文字母</p><p>int isxdigit(int c)<br>判断字符c是否为十六进制数字</p><p>int toascii(int c)<br>将字符c转换为ascii码</p><p>int tolower(int c)<br>将字符c转换为小写英文字母</p><p>int toupper(int c)<br>将字符c转换为大写英文字母</p><h4 id="二-lt-math-h-gt-函数原型功能"><a href="#二-lt-math-h-gt-函数原型功能" class="headerlink" title="二. &lt;math.h&gt;函数原型功能"></a>二. &lt;math.h&gt;函数原型功能</h4><p>float fabs(float x)<br>求浮点数x的绝对值</p><p>int abs(int x)<br>求整数x的绝对值</p><p>float acos(float x)<br>求x（弧度表示）的反余弦值</p><p>float asin(float x)<br>求x（弧度表示）的反正弦值</p><p>float atan(float x)<br>求x（弧度表示）的反正切值</p><p>float atan2(float y, float x)<br>求y&#x2F;x（弧度表示）的反正切值</p><p>float ceil(float x)<br>不小于x的最小整数</p><p>float cos(float x)<br>求x（弧度表示）的余弦值</p><p>float cosh(float x)<br>求x的双曲余弦值</p><p>float exp(float x)<br>求e的x次幂</p><p>float floor(float x)<br>求不大于x的最大整数</p><p>float fmod(float x, float y)<br>计算x&#x2F;y的余数</p><p>float frexp(float x, int *exp)<br>把浮点数x分解成尾数和指数</p><p>float ldexp(float x, int exp)<br>返回x*2^exp的值</p><p>float modf(float num, float *i)<br>将浮点数num分解成整数部分和小数部分</p><p>float hypot(float x, float y)<br>对于给定的直角三角形的两个直角边，求其斜边的长度</p><p>float log(float x)<br>计算x的自然对数</p><p>float log10(float x)<br>计算x的常用对数</p><p>float pow(float x, float y)<br>计算x的y次幂</p><p>float pow10(float x)<br>计算10的x次幂</p><p>float sin(float x)<br>计算x（弧度表示）的正弦值</p><p>float sinh(float x)<br>计算x（弧度表示）的双曲正弦值</p><p>float sqrt(float x)<br>计算x的平方根</p><p>float tan(float x)<br>计算x（弧度表示）的正切值</p><p>float tanh(float x)<br>求x的双曲正切值</p><h4 id="三-lt-stdio-h-gt-函数原型功能"><a href="#三-lt-stdio-h-gt-函数原型功能" class="headerlink" title="三. &lt;stdio.h&gt;函数原型功能"></a>三. &lt;stdio.h&gt;函数原型功能</h4><p>int printf(char *format…)<br>产生格式化输出的函数</p><p>int getchar(void)<br>从键盘上读取一个键，并返回该键的键值</p><p>int putchar(char c)<br>在屏幕上显示字符</p><p>cFILE *fopen(char *filename, char *type)<br>打开一个文件</p><p>FILE *freopen(char *filename, char *type,FILE *fp)<br>打开一个文件，并将该文件关联到fp指定的流</p><p>int fflush(FILE *stream)<br>清除一个流</p><p>int fclose(FILE *stream)<br>关闭一个文件</p><p>int remove(char *filename)<br>删除一个文件</p><p>int rename(char *oldname, char *newname)<br>重命名文件</p><p>FILE *tmpfile(void)<br>以二进制方式打开暂存文件</p><p>char *tmpnam(char *sptr)<br>创建一个唯一的文件名</p><p>int setvbuf(FILE *stream, char *buf, int type, unsigned size)<br>把缓冲区与流相关</p><p>int fprintf(FILE *stream, char *format[, argument,…])<br>传送格式化输出到一个流中</p><p>int scanf(char *format[,argument,…])<br>执行格式化输入</p><p>int fscanf(FILE *stream, char *format[,argument…])<br>从一个流中执行格式化输入</p><p>int fgetc(FILE *stream)<br>从流中读取字符</p><p>char *fgets(char *string, int n, FILE *stream)<br>从流中读取一字符串</p><p>int fputc(int ch, FILE *stream)<br>送一个字符到一个流中</p><p>int fputs(char *string, FILE *stream)<br>送一个字符到一个流中</p><p>int getc(FILE *stream)<br>从流中取字符</p><p>int getchar(void)<br>从 stdin 流中读字符</p><p>char *gets(char *string)<br>从流中取一字符串</p><p>int putchar(int ch)<br>在 stdout 上输出字符</p><p>int puts(char *string)<br>送一字符串到流中</p><p>int ungetc(char c, FILE *stream)<br>把一个字符退回到输入流中</p><p>int fread(void *ptr, int size, int nitems, FILE *stream)<br>从一个流中读数据</p><p>int fwrite(void *ptr, int size, int nitems, FILE *stream)<br>写内容到流中</p><p>int fseek(FILE *stream, long offset, int fromwhere)<br>重定位流上的文件指针</p><p>long ftell(FILE *stream)<br>返回当前文件指针</p><p>int rewind(FILE *stream)<br>将文件指针重新指向一个流的开头</p><p>int fgetpos(FILE *stream)<br>取得当前文件的句柄</p><p>int fsetpos(FILE *stream, const fpos_t *pos)<br>定位流上的文件指针</p><p>void clearerr(FILE *stream)<br>复位错误标志</p><p>int feof(FILE *stream)<br>检测流上的文件结束符</p><p>int ferror(FILE *stream)<br>检测流上的错误</p><p>void perror(char *string)<br>系统错误信息</p><h4 id="四-lt-stdlib-h-gt-函数原型功能"><a href="#四-lt-stdlib-h-gt-函数原型功能" class="headerlink" title="四. &lt;stdlib.h&gt;函数原型功能"></a>四. &lt;stdlib.h&gt;函数原型功能</h4><p>char *itoa(int i)<br>把整数i转换成字符串</p><p>void exit(int retval)<br>结束程序</p><p>double atof(const char *s)<br>将字符串s转换为double类型</p><p>int atoi(const char *s)<br>将字符串s转换为int类型</p><p>long atol(const char *s)<br>将字符串s转换为long类型</p><p>double strtod (const char*s,char **endp)<br>将字符串s前缀转换为double型</p><p>long strtol(const char*s,char **endp,int base)<br>将字符串s前缀转换为long型</p><p>unsinged long strtol(const char*s,char **endp,int base)<br>将字符串s前缀转换为 </p><p>unsinged long型int rand(void)<br>产生一个0~RAND_MAX之间的伪随机数</p><p>void srand(unsigned int seed)<br>初始化随机数发生器</p><p>void *calloc(size_t nelem, size_t elsize)<br>分配主存储器</p><p>void *malloc(unsigned size)<br>内存分配函数</p><p>void *realloc(void *ptr, unsigned newsize)<br>重新分配主存</p><p>void free(void *ptr)<br>释放已分配的块</p><p>void abort(void)<br>异常终止一个进程</p><p>void exit(int status)<br>终止应用程序</p><p>int atexit(atexit_t func)<br>注册终止函数</p><p>char *getenv(char *envvar)<br>从环境中取字符串</p><p>void *bsearch(const void *key, const void *base, size_t *nelem, size_t width, int(*fcmp)(const void *, const *))<br>二分法搜索函数</p><p>void qsort(void *base, int nelem, int width, int (*fcmp)())<br>使用快速排序例程进行排序</p><p>int abs(int i)<br>求整数的绝对值</p><p>long labs(long n)<br>取长整型绝对值</p><p>div_t div(int number, int denom)<br>将两个整数相除 , 返回商和余数</p><p>ldiv_t ldiv(long lnumer, long ldenom)<br>两个长整型数相除 , 返回商和余数</p><h4 id="五-lt-time-h-gt-函数原型功能"><a href="#五-lt-time-h-gt-函数原型功能" class="headerlink" title="五. &lt;time.h&gt;函数原型功能"></a>五. &lt;time.h&gt;函数原型功能</h4><p>clock_t clock(void)<br>确定处理器时间函数</p><p>time_t time(time_t *tp)<br>返回当前日历时间</p><p>double difftime(time_t time2, time_t time1)<br>计算两个时刻之间的时间差</p><p>time_t mktime(struct tm *tp)<br>将分段时间值转换为日历时间值</p><p>char *asctime(const struct tm *tblock)<br>转换日期和时间为ASCII码</p><p>char *ctime(const time_t *time)<br>把日期和时间转换为字符串</p><p>struct tm *gmtime(const time_t *timer)<br>把日期和时间转换为格林尼治标准时间</p><p>struct tm *localtime(const time_t *timer)<br>把日期和时间转变为结构</p><p>size_t strftime(char *s,size_t smax,const char *fmt, const struct tm *tp)<br>根据 fmt 的格式 要求将 *tp中的日期与时间转换为指定格式</p><h4 id="六-lt-string-h-gt-函数原型功能"><a href="#六-lt-string-h-gt-函数原型功能" class="headerlink" title="六. &lt;string.h&gt;函数原型功能"></a>六. &lt;string.h&gt;函数原型功能</h4><p>int bcmp(const void *s1, const void *s2, int n)<br>比较字符串s1和s2的前n个字节是否相等</p><p>void bcopy(const void *src, void *dest, int n)<br>将字符串src的前n个字节复制到dest中</p><p>void bzero(void *s, int n)<br>置字节字符串s的前n个字节为零</p><p>void *memccpy(void *dest, void *src, unsigned char ch, unsigned int count)<br>由src所指内存区域复制不多于count个字节到dest所指内存区域，如果遇到字符ch则停止复制</p><p>void *memcpy(void *dest, void *src, unsigned int count)<br>由src所指内存区域复制count个字节到dest所指内存区域</p><p>void *memchr(void *buf, char ch, unsigned count)<br>从buf所指内存区域的前count个字节查找字符</p><p>chint memcmp(void *buf1, void *buf2, unsigned int count)<br>比较内存区域buf1和buf2的前count个字节</p><p>int memicmp(void *buf1, void *buf2, unsigned int count)<br>比较内存区域buf1和buf2的前count个字节但不区分字母的大小写</p><p>void *memmove(void *dest, const void *src, unsigned int count)<br>由src所指内存区域复制count个字节到dest所指内存区域</p><p>void *memset(void *buffer, int c, int count)<br>把buffer所指内存区域的前count个字节设置成字符c</p><p>void setmem(void *buf, unsigned int count, char ch)<br>把buf所指内存区域前count个字节设置成字符ch</p><p>void movmem(void *src, void *dest, unsigned int count)<br>由src所指内存区域复制count个字节到dest所指内存区域</p><p>char *stpcpy(char *dest,char *src)<br>把src所指由NULL结束的字符串复制到dest所指的数组中</p><p>char *strcpy(char *dest,char *src)<br>把src所指由NULL结束的字符串复制到dest所指的数组中</p><p>char *strcat(char *dest,char *src)<br>把src所指字符串添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’</p><p>char *strchr(char *s,char c)<br>查找字符串s中首次出现字符c的位置</p><p>int strcmp(char *s1,char * s2)<br>比较字符串s1和s2</p><p>int strcmp(char *s1,char * s2)<br>比较字符串s1和s2</p><p>int stricmp(char *s1,char * s2)<br>比较字符串s1和s2，但不区分字母的大小写</p><p>int strcspn(char *s1,char *s2)<br>在字符串s1中搜寻s2中所出现的字符</p><p>char *strdup(char *s)复制字符串s</p><p>int strlen(char *s)<br>计算字符串s的长度</p><p>char *strlwr(char *s)<br>将字符串s转换为小写形式</p><p>char *strupr(char *s)<br>将字符串s转换为大写形式</p><p>char *strncat(char *dest,char *src,int n)<br>把src所指字符串的前n个字符添加到dest结尾处(覆盖dest结尾处的’\0’)并添加’\0’</p><p>int strcmp(char *s1,char * s2，int n)<br>比较字符串s1和s2的前n个字符</p><p>int strnicmp(char *s1,char * s2，int n)<br>比较字符串s1和s2的前n个字符但不区分大小写</p><p>char *strncpy(char *dest, char *src, int n)<br>把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中</p><p>char *strpbrk(char *s1, char *s2)<br>在字符串s1中寻找字符串s2中任何一个字符相匹配的第一个字符的位置，空字符NULL不包括在内</p><p>char *strrev(char *s)<br>把字符串s的所有字符的顺序颠倒过来（不包括空字符NULL）</p><p>char *strset(char *s, char c)<br>把字符串s中的所有字符都设置成字符c</p><p>char *strstr(char *haystack, char *needle)<br>从字符串haystack中寻找needle第一次出现的位置（不比较结束符NULL)</p><p>char *strtok(char *s, char *delim)<br>分解字符串为一组标记串。s为要分解的字符串，delim为分隔符字符串</p><p>int strnicmp(char *s1,char * s2，int n)<br>比较字符串s1和s2的前n个字符但不区分大小写</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（七）</title>
      <link href="/post/80ae9ac0.html"/>
      <url>/post/80ae9ac0.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy和Matplotlib绘图"><a href="#NumPy和Matplotlib绘图" class="headerlink" title="NumPy和Matplotlib绘图"></a>NumPy和Matplotlib绘图</h4><p>Matplotlib 是 Python 的绘图库，它经常与 NumPy 一起使用，从而提供一种能够代替 Matlab 的方案。不仅如此 Matplotlib 还可以与 PyQt 和 wxPython 等图形工具包一起使用。</p><p>绘制线性函数图像</p><p>Matplotlib 的子模块模块 pyplot 是用来绘制 2D 图像的重要模块。</p><p>绘制了函数 y &#x3D; 2x + 5 的图像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">x = np.arange(1,11)</span><br><span class="line">y = 2 * x + 5</span><br><span class="line">#绘制坐标标题</span><br><span class="line">plt.title(&quot;Matplotlib demo&quot;)</span><br><span class="line">#绘制x、y轴备注</span><br><span class="line">plt.xlabel(&quot;x axis&quot;)</span><br><span class="line">plt.ylabel(&quot;y axis&quot;)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>您可以向 plot() 函数中添加格式化字符，来实现不同样式的显示或标记。 </p><p>常用的格式化字符：</p><p>‘-‘<br>实线样式</p><p>‘–’<br>短横线样式</p><p>‘-.’<br>点划线样式</p><p>‘:’<br>虚线样式</p><p>‘.’<br>点标记</p><p>‘,’<br>像素标记</p><p>‘o’<br>圆标记</p><p>‘v’<br>倒三角标记</p><p>‘^’<br>正三角标记</p><p>‘&lt;’<br>左三角标记</p><p>‘&gt;’<br>右三角标记</p><p>‘1’<br>下箭头标记</p><p>‘2’<br>上箭头标记</p><p>‘3’<br>左箭头标记</p><p>‘4’<br>右箭头标记</p><p>‘s’<br>正方形标记</p><p>‘p’<br>五边形标记</p><p>‘*’<br>星形标记</p><p>‘h’<br>六边形标记 1</p><p>‘H’<br>六边形标记 2</p><p>‘+’<br>加号标记</p><p>‘x’<br>X 标记</p><p>‘D’<br>菱形标记</p><p>‘d’<br>窄菱形标记</p><p>‘|’<br>竖直线标记</p><p>‘_’<br>水平线标记</p><p>同时 Matplotlib 还定义了一些颜色字符</p><p>‘b’<br>蓝色</p><p>‘g’<br>绿色</p><p>‘r’<br>红色</p><p>‘c’<br>青色</p><p>‘m’<br>品红色</p><p>‘y’<br>黄色</p><p>‘k’<br>黑色</p><p>‘w’<br>白色</p><p>如果想要以圆点的样式，来代替图 1 中的线条样式，那么可以使用“ ob”作为 plot() 的格式化字符。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">x = np.arange(1,11)</span><br><span class="line">y = 2 * x + 5</span><br><span class="line">plt.title(&quot;Matplotlib demo1&quot;)</span><br><span class="line">plt.xlabel(&quot;x axis&quot;)</span><br><span class="line">plt.ylabel(&quot;y axis&quot;)</span><br><span class="line">plt.plot(x,y,&quot;ob&quot;)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure><p>绘制正弦波图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt </span><br><span class="line"># 计算正弦曲线上的x和y坐标</span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.title(&quot;sine wave image&quot;)</span><br><span class="line"># 使用matplotlib制图</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure><p>subplot()<br>subplot() 允许您在同一画布中的不同位置绘制多个图像，可以理解为对画布按行、列分割</p><p>函数的语法格式：</p><p>plt.subplot(nrows, ncols, index, **kwargs)</p><p>该函数使用三个整数描述子图的位置信息，这三个整数是行数、列数和索引值（此处索引值从1开始），子图将分布在设定的索引位置上。</p><p>从右上角增加到右下角。<br>plt.subplot(2, 3, 5) 表示子图位于 2 行 3 列 中的第 5 个位置上。</p><p>下面示例是在同一画布中绘制正弦和余弦图像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt </span><br><span class="line">  </span><br><span class="line">#计算正弦和余弦曲线上的点的 x 和 y 坐标 </span><br><span class="line">x = np.arange(0, 3 * np.pi, 0.1)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x) </span><br><span class="line">  </span><br><span class="line">#绘制subplot 网格为2行1列</span><br><span class="line">#激活第一个 subplot</span><br><span class="line">plt.subplot(2, 1, 1)</span><br><span class="line">#绘制第一个图像</span><br><span class="line">plt.plot(x, y_sin)</span><br><span class="line">plt.title(&#x27;Sine&#x27;) </span><br><span class="line"></span><br><span class="line">#将第二个 subplot 激活，并绘制第二个图像</span><br><span class="line">plt.subplot(2, 1, 2)</span><br><span class="line">plt.plot(x, y_cos)</span><br><span class="line">plt.title(&#x27;Cosine&#x27;)</span><br><span class="line">#展示图像</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>bar()柱状图</p><p>pyplot 子模块中提供了 bar() 函数来生成柱状图。</p><p>下面示例代码，生成了两组数据的柱状图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">#第一组数据</span><br><span class="line">x1 = [5,8,10]</span><br><span class="line">y1 = [12,16,6] </span><br><span class="line">#第二组数据</span><br><span class="line">x2 = [6,9,11]</span><br><span class="line">y2 = [6,15,7]</span><br><span class="line">plt.bar(x1, y1, align = &#x27;center&#x27;)</span><br><span class="line">plt.bar(x2, y2, color = &#x27;g&#x27;, align = &#x27;center&#x27;)</span><br><span class="line">plt.title(&#x27;Bar graph&#x27;)</span><br><span class="line">#设置x轴与y轴刻度</span><br><span class="line">plt.ylabel(&#x27;Y axis&#x27;)</span><br><span class="line">plt.xlabel(&#x27;X axis&#x27;) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>numpy.histogram()</p><p>直方图是一种表示数据概率分布的常用图形。</p><p>NumPy 提供了 histogram() 函数，它以直方图的形式表示一组数据的概率分布值。histogram() 函数有两个返回值，分别是 hist 与 bin_edges，分别代表直方图高度值与 bin 数值区间范围，</p><p>函数的语法格式如下：<br>histogram(array,bins&#x3D;10,range&#x3D;None,weights&#x3D;None,density&#x3D;False)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.arange(8) </span><br><span class="line">hist, bin_edges = np.histogram(a, density=True) </span><br></pre></td></tr></table></figure><p>numpy.histogram() 将输入数组 a 和 bins 作为两个参数，其中 bins 数组的连续元素作为 bin 区间的边界值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([22,87,5,43,56,73,55,54,11,20,51,5,79,31,27])</span><br><span class="line">np.histogram(a,bins = [0,20,40,60,80,100])</span><br><span class="line">hist,bins = np.histogram(a,bins = [0,20,40,60,80,100]) </span><br><span class="line">print(hist)</span><br><span class="line">print(bins)</span><br></pre></td></tr></table></figure><p>plt()<br>pyplot 子模块的 plt() 函数将一个输入数组和 bins 数组作为参数，并将其输出为直方图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib import pyplot as plt</span><br><span class="line">import numpy as np </span><br><span class="line">a = np.array([22,87,5,43,56,73,55,54,11,20,51,5,79,31,27])</span><br><span class="line">plt.hist(a, bins =  [0,20,40,60,80,100])</span><br><span class="line">plt.title(&quot;histogram&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="NumPy-IO操作"><a href="#NumPy-IO操作" class="headerlink" title="NumPy IO操作"></a>NumPy IO操作</h4><p>NumPy  IO 操作是以文件的形式从磁盘中加载 ndarray 对象。在这个过程中，NumPy 可以两种文件类型处理 ndarray 对象，一类是二进制文件（以.npy结尾），另一类是普通文本文件。</p><img src="/post/80ae9ac0/349.png" class title="This is an image"><p>我们知道，文件会被保存在不同的计算机上（比如 Linux、Windows、MacOSX 等）。为了不受的计算机架构影响，NumPy 开发团队给 ndarray 对象引入了一种.npy文件格式，通过它来件实现对 ndarray 对象的保存。</p><p>numpy.save() 方法将输入数组存储在.npy文件中。</p><p>numpy.save(file, arr, allow_pickle&#x3D;True, fix_imports&#x3D;True)</p><p>file：保存后的文件名称，其文件类型为.npy；</p><p>arr：要保存的数组</p><p>allow_pickle：可选项，布尔值参数，允许使用 pickle 序列化保存数组对象</p><p>fix_imports：可选项，为了便于在 Pyhton2 版本中读取 Python3 保存的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([1,2,3,4,5])</span><br><span class="line">np.save(&#x27;first&#x27;,a)</span><br></pre></td></tr></table></figure><p>使用 load() 从 first.npy 文件中加载数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">b = np.load(&#x27;outfile.npy&#x27;)</span><br><span class="line">print( b) </span><br></pre></td></tr></table></figure><p>savetxt()</p><p>savetxt() 和 loadtxt() 分别表示以文本格式存储数据或加载数据。</p><p>savetxt() 语法格式：<br>np.savetxt(‘filename文件路径’, self.task, fmt&#x3D;”%d”, delimiter&#x3D;” “)</p><p>filename：表示保存文件的路径<br>self.task： 要保存数组的变量名<br>fmt&#x3D;”%d”： 指定保存文件的格式，默认是十进制<br>delimiter&#x3D;” “表示分隔符，默认以空格的形式隔开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([1,2,3,4,5])</span><br><span class="line">np.savetxt(&#x27;second.txt&#x27;,a)</span><br><span class="line">#使用loadtxt重载数据</span><br><span class="line">b = np.loadtxt(&#x27;second.txt&#x27;)</span><br><span class="line">print(b) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（六）</title>
      <link href="/post/52aeed5f.html"/>
      <url>/post/52aeed5f.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy排序和搜索功能"><a href="#NumPy排序和搜索功能" class="headerlink" title="NumPy排序和搜索功能"></a>NumPy排序和搜索功能</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>NumPy 提供了多种排序函数， 这些排序函数可以实现不同的排序算法。<br>排序算法特征主要体现在以下四个方面：执行速度，最坏情况下的复杂度，所需的工作空间以及算法的稳定性。</p><p>下表列举了三种排序算法：</p><img src="/post/52aeed5f/347.png" class title="This is an image"><p>numpy.sort()</p><p>numpy.sort() 对输入数组执行排序，并返回一个数组副本<br>numpy.sort(a, axis, kind, order)</p><p>a：要排序的数组；<br>axis：沿着指定轴进行排序，如果没有指定 axis，默认在最后一个轴上排序，若 axis&#x3D;0 表示按列排序，axis&#x3D;1 表示按行排序<br>kind：默认为 quicksort（快速排序）<br>order：若数组设置了字段，则 order 表示要排序的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[3,7],[9,1]]) </span><br><span class="line">print(&#x27;a数组是：&#x27;)</span><br><span class="line">print(a)</span><br><span class="line">#调用sort()函数</span><br><span class="line">print(np.sort(a))</span><br><span class="line">#按列排序：</span><br><span class="line">print(np.sort(a, axis = 0))</span><br><span class="line">#设置在sort函数中排序字段</span><br><span class="line">dt = np.dtype([(&#x27;name&#x27;,  &#x27;S10&#x27;),(&#x27;age&#x27;,  int)])</span><br><span class="line">a = np.array([(&quot;raju&quot;,21),(&quot;anil&quot;,25),(&quot;ravi&quot;,  17),  (&quot;amar&quot;,27)], dtype = dt) </span><br><span class="line">#再次打印a数组</span><br><span class="line">print(a)</span><br><span class="line">#按name字段排序</span><br><span class="line">print(np.sort(a, order = &#x27;name&#x27;))</span><br></pre></td></tr></table></figure><p>numpy.argsort()</p><p>argsort() 沿着指定的轴，对输入数组的元素值进行排序，并返回排序后的<strong>元素索引数组</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([90, 29, 89, 12]) </span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">sort_ind = np.argsort(a) </span><br><span class="line">print(&quot;打印排序元素索引值&quot;,sort_ind) </span><br><span class="line">#使用索引数组对原数组排序</span><br><span class="line">sort_a = a[sort_ind] </span><br><span class="line">print(&quot;打印排序数组&quot;) </span><br><span class="line">for i in sort_ind: </span><br><span class="line">    print(a[i],end = &quot; &quot;)  </span><br></pre></td></tr></table></figure><p>numpy.lexsort()</p><p>numpy.lexsort() 按键序列对数组进行排序，它返回一个已排序的<strong>索引数组</strong>，类似于 numpy.argsort()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]) </span><br><span class="line">b = np.array([12, 90, 380, 12, 211]) </span><br><span class="line">ind = np.lexsort((a,b)) </span><br><span class="line">#打印排序元素的索引数组</span><br><span class="line">print(ind) </span><br><span class="line">#使用索引数组对数组进行排序</span><br><span class="line">for i in ind: </span><br><span class="line">    print(a[i],b[i])  </span><br></pre></td></tr></table></figure><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>NumPy 提供了许多可以在数组内执行搜索功能的函数。</p><p>numpy.nonzero()</p><p>该函数从数组中查找非零元素的索引位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">b = np.array([12, 90, 380, 12, 211]) </span><br><span class="line">print(&quot;原数组b&quot;,b) </span><br><span class="line">print(&quot;打印非0元素的索引位置&quot;) </span><br><span class="line">print(b.nonzero())  </span><br></pre></td></tr></table></figure><p>numpy.where()</p><p>numpy.where() 的返回值是满足了给定条件的元素索引值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">b = np.array([12, 90, 380, 12, 211]) </span><br><span class="line">print(np.where(b&gt;12)) </span><br><span class="line">c = np.array([[20, 24],[21, 23]]) </span><br><span class="line">print(np.where(c&gt;20))  </span><br></pre></td></tr></table></figure><p>numpy.extract()<br>该函数的返回值是满足了给定条件的元素值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.arange(9.).reshape(3, 3)</span><br><span class="line">打印数组x:&#x27;</span><br><span class="line">print(x) </span><br><span class="line">#设置条件选择偶数元素</span><br><span class="line">condition = np.mod(x,2)== 0</span><br><span class="line">#输出布尔值数组</span><br><span class="line">print(condition)</span><br><span class="line">#按condition提取满足条件的元素值</span><br><span class="line">print np.extract(condition, x)</span><br></pre></td></tr></table></figure><p>numpy.argmax()</p><p>该函数返回最大值的的索引，与其相反的函数是 argmin() 求最小值索引 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[30,40,70],[80,20,10],[50,90,60]]) </span><br><span class="line">#a数组</span><br><span class="line">print (a)</span><br><span class="line">#argmax() 函数</span><br><span class="line">print (np.argmax(a))</span><br><span class="line">#将数组以一维展开</span><br><span class="line">print (a.flatten())</span><br><span class="line">#沿轴 0 的最大值索引：</span><br><span class="line">maxindex = np.argmax(a, axis =  0) </span><br><span class="line">print (maxindex)</span><br><span class="line">#沿轴 1 的最大值索引</span><br><span class="line">maxindex = np.argmax(a, axis =  1) </span><br><span class="line">print (maxindex) </span><br></pre></td></tr></table></figure><p>numpy.argmin()</p><p>argmin() 求最小值索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">b= np.array([[3,4,7],[8,2,1],[5,9,6]]) </span><br><span class="line">print  (&#x27;数组b：&#x27;)</span><br><span class="line">print (b) </span><br><span class="line">#调用 argmin()函数</span><br><span class="line">minindex = np.argmin(b) </span><br><span class="line">print (minindex)</span><br><span class="line">#展开数组中的最小值：</span><br><span class="line">print (b.flatten()[minindex])</span><br><span class="line">#沿轴 0 的最小值索引：</span><br><span class="line">minindex = np.argmin(b, axis =  0) </span><br><span class="line">print (minindex)</span><br><span class="line">#沿轴 1 的最小值索引：</span><br><span class="line">minindex = np.argmin(b, axis =  1) </span><br><span class="line">print (minindex)</span><br></pre></td></tr></table></figure><h4 id="NumPy副本和视图"><a href="#NumPy副本和视图" class="headerlink" title="NumPy副本和视图"></a>NumPy副本和视图</h4><p>对 NumPy 数组执行些函数操作时，其中一部分函数会返回数组的副本，而另一部分函数则返回数组的视图。本节对数组的副本和视图做重点讲解。</p><p>其实从内存角度来说，副本就是对原数组进行深拷贝，新产生的副本与原数组具有不同的存储位置。而视图可理解为对数组的引用，它和原数组有着相同的内存位置。</p><p>赋值操作</p><p>赋值操作是数组引用的一种方法。比如，将 a 数组赋值给变量 b，被赋值后的变量 b 与 a 组具有相同的内存 id。因此，无论操作 a、b 中哪个数组，另一个数组也会受到影响。例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) </span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">print(&quot;a数组的ID:&quot;,id(a)) </span><br><span class="line">b = a</span><br><span class="line">print(&quot;数组b的id:&quot;,id(b)) </span><br><span class="line">b.shape = 4,3; </span><br><span class="line">print(&quot;b数组形状的更改也会反映到a数组上:&quot;) </span><br><span class="line">print(a)  </span><br></pre></td></tr></table></figure><p>ndarray.view()</p><p>ndarray.view() 返回一个新生成的数组副本，因此对该数组的操作，不会影响到原数组。下面看一组示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) </span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">print(&quot;数组a的ID:&quot;,id(a)) </span><br><span class="line">b = a.view() </span><br><span class="line">print(&quot;数组b的ID:&quot;,id(b)) </span><br><span class="line">#打印b数组</span><br><span class="line">print(b) </span><br><span class="line">#改变b数组形状</span><br><span class="line">b.shape = 4,3</span><br><span class="line">print(&quot;原数组a&quot;,a) </span><br><span class="line">print(&quot;新数组b&quot;,b) </span><br></pre></td></tr></table></figure><p>切片创建视图</p><p>使用切片可以创建视图数组，若要修改视图的就会影响到原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">arr = np.arange(10)</span><br><span class="line">print (&#x27;数组arr：&#x27;)</span><br><span class="line">print (arr)</span><br><span class="line">#创建切片修改原数组arr</span><br><span class="line">a=arr[3:]</span><br><span class="line">b=arr[3:]</span><br><span class="line">a[1]=123</span><br><span class="line">b[2]=234</span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure><p>ndarray.copy()</p><p>该方法返回原数组的副本，对副本的修改不会影响到原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2,3,4],[9,0,2,3],[1,2,3,19]]) </span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">print(&quot;a数组ID:&quot;,id(a)) </span><br><span class="line">b = a.copy() </span><br><span class="line">print(&quot;b数组ID:&quot;,id(b)) </span><br><span class="line">print(&quot;打印经过copy方法的b数组：&quot;) </span><br><span class="line">print(b) </span><br><span class="line">b.shape=4,3</span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">print(&quot;经过copy方法的b数组&quot;,b) </span><br></pre></td></tr></table></figure><h4 id="NumPy字节交换"><a href="#NumPy字节交换" class="headerlink" title="NumPy字节交换"></a>NumPy字节交换</h4><p>数据以字节的形式存储在计算机内存中，而存储规则可分为两类，即小端字节序与大端字节序。</p><p>小端字节序（little-endian），表示低位字节排放在内存的低地址端，高位字节排放在高地址段，它与大端字节序（big-endian）恰好相反。</p><p>对于二进制数 0x12345678，假设从地址 0x4000 开始存放，在大端和小端模式下，它们的字节排列顺序</p><img src="/post/52aeed5f/348.png" class title="This is an image"><p>numpy.ndarray.byteswap()</p><p>该函数将数组中每个元素的字节顺序进行大小端调换 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([1, 256, 8755], dtype = np.int16)</span><br><span class="line">#数组a</span><br><span class="line">print(a) </span><br><span class="line">#以16进制形式表示内存中的数据</span><br><span class="line">print(map(hex,a)) </span><br><span class="line">#byteswap()函数通过传递True参数在适当的位置进行转换</span><br><span class="line">#调用byteswap()函数</span><br><span class="line">print(a.byteswap(True))</span><br><span class="line">#十六进制形式</span><br><span class="line">print(map(hex,a))</span><br></pre></td></tr></table></figure><h4 id="NumPy-Matrix矩阵库"><a href="#NumPy-Matrix矩阵库" class="headerlink" title="NumPy Matrix矩阵库"></a>NumPy Matrix矩阵库</h4><p>NumPy 提供了一个 矩阵库模块numpy.matlib，该模块中的函数返回的是一个 matrix 对象，而非 ndarray 对象。矩阵由 m 行 n 列（m*n）元素排列而成，矩阵中的元素可以是数字、符号或数学公式等。</p><p>matlib.empty()</p><p>matlib.empty() 返回一个空矩阵，所以它的创建速度非常快。<br>numpy.matlib.empty(shape, dtype, order)</p><p>shape：以元组的形式指定矩阵的形状<br>dtype：表示矩阵的数据类型<br>order：有两种选择，C（行序优先） 或者 F（列序优先）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">#矩阵中会填充无意义的随机值</span><br><span class="line">print(np.matlib.empty((2,2)))</span><br></pre></td></tr></table></figure><p>numpy.matlib.zeros()</p><p>numpy.matlib.zeros() 创建一个以 0 填充的矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">print(np.matlib.zeros((2,2))) </span><br></pre></td></tr></table></figure><p>numpy.matlib.ones()<br>numpy.matlib.ones() 创建一个以 1 填充的矩阵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">print(np.matlib.ones((2,2)))</span><br></pre></td></tr></table></figure><p>numpy.matlib.eye()<br>numpy.matlib.eye() 返回一个对角线元素为 1，而其他元素为 0 的矩阵 。numpy.matlib.eye(n,M,k, dtype)</p><p>n：返回矩阵的行数；<br>M：返回矩阵的列数，默认为 n；<br>k：对角线的索引；<br>dtype：矩阵中元素数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">print (np.matlib.eye(n =  3, M =  4, k =  0, dtype =  float))</span><br></pre></td></tr></table></figure><p>numpy.matlib.identity()</p><p>该函数返回一个给定大小的单位矩阵，矩阵的对角线元素为 1，而其他元素均为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">print np.matlib.identity(5, dtype = float)</span><br></pre></td></tr></table></figure><p>numpy.matlib.rand()<br>创建一个以随机数填充，并给定维度的矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np</span><br><span class="line">print (np.matlib.rand(3,3))</span><br></pre></td></tr></table></figure><p>这里需要注意，因为 matrix 只能表示二维数据，而 ndarray 也可以是二维数组，所以两者可以互相转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建矩阵i</span><br><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np </span><br><span class="line">i = np.matrix(&#x27;1,2;3,4&#x27;) </span><br><span class="line">print (i)</span><br></pre></td></tr></table></figure><p>实现 matrix 与 ndarray 之间的转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy.matlib</span><br><span class="line">import numpy as np </span><br><span class="line">j = np.asarray(i) </span><br><span class="line">print (j)</span><br><span class="line">k = np.asmatrix (j)</span><br><span class="line">print (k)</span><br></pre></td></tr></table></figure><h4 id="NumPy线性代数"><a href="#NumPy线性代数" class="headerlink" title="NumPy线性代数"></a>NumPy线性代数</h4><p>NumPy 提供了 numpy.linalg 模块，该模块中包含了一些常用的线性代数计算方法</p><p>dot<br>两个数组的点积。</p><p>vdot<br>两个向量的点积。</p><p>inner<br>两个数组的内积。</p><p>matmul<br>两个数组的矩阵积。</p><p>det<br>计算输入矩阵的行列式。</p><p>solve<br>求解线性矩阵方程。</p><p>inv<br>计算矩阵的逆矩阵，逆矩阵与原始矩阵相乘，会得到单位矩阵。</p><p>numpy.dot()<br>按照矩阵的乘法规则，计算两个矩阵的点积运算结果。当输入一维数组时返回一个结果值，若输入的多维数组则同样返回一个多维数组结果。输入一维数组，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A=[1,2,3]</span><br><span class="line">B=[4,5,6]</span><br><span class="line">print(np.dot(A,B))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[100,200],</span><br><span class="line">             [23,12]]) </span><br><span class="line">b = np.array([[10,20],</span><br><span class="line">            [12,21]]) </span><br><span class="line">dot = np.dot(a,b) </span><br><span class="line">print(dot) </span><br></pre></td></tr></table></figure><p>点积运算就是将 a 数组的每一行元素与 b 数组的每一列元素相乘再相加。</p><p>numpy.vdot()</p><p>该函数用于计算两个向量的点积结果，与 dot() 函数不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[100,200],[23,12]]) </span><br><span class="line">b = np.array([[10,20],[12,21]]) </span><br><span class="line">vdot = np.vdot(a,b) </span><br><span class="line">print(vdot)  </span><br></pre></td></tr></table></figure><p>numpy.inner()</p><p>inner() 方法用于计算数组之间的内积。当计算的数组是一维数组时，它与 dot() 函数相同，若输入的是多维数组则两者存在不同，下面看一下具体的实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">A=[[1 ,10],</span><br><span class="line">    [100,1000]]</span><br><span class="line">B=[[1,2],</span><br><span class="line">    [3,4]]</span><br><span class="line">#inner函数</span><br><span class="line">print(np.inner(A,B))</span><br><span class="line">#dot函数</span><br><span class="line">print(np.dot(A,B))</span><br></pre></td></tr></table></figure><p>inner() 函数的计算过程是 A 数组的每一行与 B 数组的每一行相乘再相加，如下所示：<br>[[1<em>1+2</em>10  1<em>3+10</em>4 ]<br>[100<em>1+1000</em>2  100<em>3+1000</em>4]]dot() 则表示是 A 数组每一行与 B 数组的每一列相乘。</p><p>numpy.matmul()</p><p>该函数返回两个矩阵的乘积，假如两个矩阵的维度不一致，就会产生错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2,3],[4,5,6],[7,8,9]]) </span><br><span class="line">b = np.array([[23,23,12],[2,1,2],[7,8,9]]) </span><br><span class="line">mul = np.matmul(a,b) </span><br><span class="line">print(mul)  </span><br></pre></td></tr></table></figure><p>numpy.linalg.det()</p><p>该函数使用对角线元素来计算矩阵的行列式，计算 2*2（两行两列） 的行列式，示例如下：</p><p>[[1,2],<br> [3,4]]</p><p>通过对角线元素求行列式的结果（口诀：“一撇一捺”计算法）：</p><p>1<em>4-2</em>3&#x3D;-2</p><p>我们可以使用 numpy.linalg.det() 函数来完成计算。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2],[3,4]]) </span><br><span class="line">print(np.linalg.det(a))  </span><br></pre></td></tr></table></figure><p>numpy.linalg.solve()</p><p>该函数用于求解线性矩阵方程组，并以矩阵的形式表示线性方程的解，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3X  +  2 Y + Z =  10  </span><br><span class="line">X + Y + Z = 6</span><br><span class="line">X + 2Y - Z = 2</span><br></pre></td></tr></table></figure><p>首先将上述方程式转换为矩阵的表达形式：</p><p>方程系数矩阵：<br>3   2   1<br>1   1   1<br>1   2  -1<br>方程变量矩阵:<br>X<br>Y<br>Z<br>方程结果矩阵：<br>10<br>6<br>2</p><p>如果用  m 、x、n 分别代表上述三个矩阵，其表示结果如下：m*x&#x3D;n 或 x&#x3D;n&#x2F;m</p><p>将系数矩阵与结果矩阵传递给 numpy.solve() 函数，即可求出线程方程的解，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">m = np.array([[3,2,1],[1,1,1],[1,2,-1]])</span><br><span class="line">print (&#x27;数组 m：&#x27;)</span><br><span class="line">print (m)</span><br><span class="line">print (&#x27;矩阵 n：&#x27;)</span><br><span class="line">n = np.array([[10],[6],[2]])</span><br><span class="line">print (n)</span><br><span class="line">print (&#x27;计算：m^(-1)n：&#x27;)</span><br><span class="line">x = np.linalg.solve(m,n)</span><br><span class="line">print (x)</span><br></pre></td></tr></table></figure><p>numpy.linalg.inv()</p><p>该函数用于计算矩阵的逆矩阵，逆矩阵与原矩阵相乘得到单位矩阵。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[1,2],[3,4]]) </span><br><span class="line">print(&quot;原数组:&quot;,a) </span><br><span class="line">b = np.linalg.inv(a) </span><br><span class="line">print(&quot;求逆:&quot;,b)  </span><br></pre></td></tr></table></figure><h4 id="NumPy矩阵乘法"><a href="#NumPy矩阵乘法" class="headerlink" title="NumPy矩阵乘法"></a>NumPy矩阵乘法</h4><p>矩阵乘法是将两个矩阵作为输入值，并将 A 矩阵的行与 B 矩阵的列对应位置相乘再相加，从而生成一个新矩阵，如下图所示：<br>注意：必须确保第一个矩阵中的行数等于第二个矩阵中的列数，否则不能进行矩阵乘法运算。</p><p>矩阵乘法运算被称为向量化操作，向量化的主要目的是减少使用的 for 循环次数或者根本不使用。这样做的目的是为了加速程序的计算。下面介绍 NumPy 提供的三种矩阵乘法，从而进一步加深对矩阵乘法的理解。</p><p>逐元素矩阵乘法<br>multiple() 函数用于两个矩阵的逐元素乘法，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">array1=np.array([[1,2,3],[4,5,6],[7,8,9]],ndmin=3) </span><br><span class="line">array2=np.array([[9,8,7],[6,5,4],[3,2,1]],ndmin=3) </span><br><span class="line">result=np.multiply(array1,array2) </span><br><span class="line">result  </span><br></pre></td></tr></table></figure><p>矩阵乘积运算</p><p>matmul() 用于计算两个数组的矩阵乘积。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">array1=np.array([[1,2,3],[4,5,6],[7,8,9]],ndmin=3) </span><br><span class="line">array2=np.array([[9,8,7],[6,5,4],[3,2,1]],ndmin=3) </span><br><span class="line">result=np.matmul(array1,array2) </span><br><span class="line">print(result) </span><br></pre></td></tr></table></figure><p>矩阵点积</p><p>dot() 函数用于计算两个矩阵的点积。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">array1=np.array([[1,2,3],[4,5,6],[7,8,9]],ndmin=3) </span><br><span class="line">array2=np.array([[9,8,7],[6,5,4],[3,2,1]],ndmin=3) </span><br><span class="line">result=np.dot(array1,array2) </span><br><span class="line">print(result)  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（五）</title>
      <link href="/post/37a0a686.html"/>
      <url>/post/37a0a686.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy数学函数"><a href="#NumPy数学函数" class="headerlink" title="NumPy数学函数"></a>NumPy数学函数</h4><p>NumPy 中包含了大量的数学函数，它们用于执行各种数学运算，其中包括三角函数、舍入函数等等</p><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>NumPy 中提供了用于弧度计算的的 sin()（正弦）、cos()（余弦）和 tan()（正切）三角函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr = np.array([0, 30, 60, 90, 120, 150, 180]) </span><br><span class="line">#计算arr数组中给定角度的三角函数值</span><br><span class="line">#通过乘以np.pi/180将其转换为弧度</span><br><span class="line">print(np.sin(arr * np.pi/180)) </span><br><span class="line">print(np.cos(arr * np.pi/180)) </span><br><span class="line">print(np.tan(arr * np.pi/180))  </span><br></pre></td></tr></table></figure><h5 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h5><p>除了上述三角函数以外，NumPy 还提供了 arcsin，arcos 和 arctan 反三角函数。若要想验证反三角函数的结果，可以通过 numpy.degrees() 将弧度转换为角度来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr = np.array([0, 30, 60, 90]) </span><br><span class="line">#正弦值数组</span><br><span class="line">sinval = np.sin(arr*np.pi/180) </span><br><span class="line">print(sinval) </span><br><span class="line">#计算角度反正弦，返回值以弧度为单位</span><br><span class="line">cosec = np.arcsin(sinval) </span><br><span class="line">print(cosec) </span><br><span class="line">#通过degrees函数转化为角度进行验证</span><br><span class="line">print(np.degrees(cosec)) </span><br><span class="line">#余弦值数组</span><br><span class="line">cosval = np.cos(arr*np.pi/180) </span><br><span class="line">print(cosval) </span><br><span class="line">#计算反余弦值，以弧度为单位</span><br><span class="line">sec = np.arccos(cosval) </span><br><span class="line">print(sec) </span><br><span class="line">#通过degrees函数转化为角度进行验证</span><br><span class="line">print(np.degrees(sec)) </span><br><span class="line">#下面是tan()正切函数 </span><br><span class="line">tanval = np.tan(arr*np.pi/180) </span><br><span class="line">print(tanval) </span><br><span class="line">cot = np.arctan(tanval) </span><br><span class="line">print(cot) </span><br><span class="line">print(np.degrees(cot))  </span><br></pre></td></tr></table></figure><h5 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h5><p>NumPy 提供了三个舍入函数</p><ol><li>numpy.around()<br>该函数返回一个十进制值数，并将数值四舍五入到指定的小数位上</li></ol><p>numpy.around(a,decimals)</p><p>a：代表要输入的数组<br>decimals：要舍入到的小数位数。它的默认值为0，如果为负数，则小数点将移到整数左侧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr = np.array([12.202, 90.23120, 123.020, 23.202]) </span><br><span class="line">print(arr) </span><br><span class="line">print(&quot;数组值四舍五入到小数点后两位&quot;,np.around(arr, 2)) </span><br><span class="line">print(&quot;数组值四舍五入到小数点后-1位&quot;,np.around(arr, -1))  </span><br></pre></td></tr></table></figure><ol start="2"><li>numpy.floor()<br>该函数表示对数组中的每个元素向下取整数，即返回不大于数组中每个元素值的最大整数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([-1.8,  1.1,  -0.4,  0.9,  18])</span><br><span class="line">#对数组a向下取整</span><br><span class="line">print (np.floor(a))</span><br></pre></td></tr></table></figure><ol start="3"><li>numpy.ceil()<br>该函数与 floor 函数相反，表示向上取整<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([-1.8,  1.1,  -0.4,  0.9,  18])</span><br><span class="line">#对数组a向上取整</span><br><span class="line">print (np.ceil(a))</span><br></pre></td></tr></table></figure></li></ol><h4 id="NumPy算术运算"><a href="#NumPy算术运算" class="headerlink" title="NumPy算术运算"></a>NumPy算术运算</h4><p>NumPy 数组的“加减乘除”算术运算，分别对应 add()、subtract()、multiple() 以及 divide() 函数。</p><p><strong>注意：</strong>做算术运算时，输入数组必须具有相同的形状，或者符合数组的广播规则，才可以执行运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(9, dtype = np.float_).reshape(3,3)</span><br><span class="line">#数组a</span><br><span class="line">print(a)</span><br><span class="line">#数组b</span><br><span class="line">b = np.array([10,10,10])</span><br><span class="line">print(b)</span><br><span class="line">#数组加法运算</span><br><span class="line">print(np.add(a,b))</span><br><span class="line">#数组减法运算</span><br><span class="line">print(np.subtract(a,b))</span><br><span class="line">#数组乘法运算</span><br><span class="line">print(np.multiply(a,b))</span><br><span class="line">#数组除法运算</span><br><span class="line">print(np.divide(a,b))</span><br></pre></td></tr></table></figure><p>numpy.reciprocal()</p><p>该函数对数组中的每个元素取倒数，并以数组的形式将它们返回。</p><p>当数组元素的数据类型为整型（int）时，对于绝对值小于 1 的元素，返回值为 0，而当数组中包含 0 元素时，返回值将出现 overflow（inf） 溢出提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#注意此处有0</span><br><span class="line">a = np.array([0.25, 1.33, 1, 0, 100])</span><br><span class="line">#数组a默认为浮点类型数据</span><br><span class="line">print(a)</span><br><span class="line">#对数组a使用求倒数操作</span><br><span class="line">print (np.reciprocal(a))</span><br><span class="line">#b数组的数据类型为整形int</span><br><span class="line">b = np.array([100], dtype = int)</span><br><span class="line">print(b)</span><br><span class="line">#对数组b使用求倒数操作</span><br><span class="line">print( np.reciprocal(b) )</span><br></pre></td></tr></table></figure><p>numpy.power(a,b)</p><p>该函数将 a 数组中的元素作为底数，把 b 数组中与 a 相对应的元素作幂 ，最后以数组形式返回两者的计算结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([10,100,1000])</span><br><span class="line">#a数组</span><br><span class="line">print (&#x27;我们的数组是；&#x27;)</span><br><span class="line">#调用 power 函数</span><br><span class="line">print (np.power(a,2))</span><br><span class="line"># b数组</span><br><span class="line">b = np.array([1,2,3])</span><br><span class="line">print (b)</span><br><span class="line"># 调用 power 函数</span><br><span class="line">print (np.power(a,b))</span><br></pre></td></tr></table></figure><p>numpy.mod()</p><p>返回两个数组相对应位置上元素相除后的余数，它与 numpy.remainder() 的作用相同 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([11,22,33])</span><br><span class="line">b = np.array([3,5,7])</span><br><span class="line">#a与b相应位置的元素做除法</span><br><span class="line">print( np.mod(a,b))</span><br><span class="line">#remainder方法一样</span><br><span class="line">print(np.remainder(a,b)) </span><br></pre></td></tr></table></figure><h5 id="复数数组处理函数"><a href="#复数数组处理函数" class="headerlink" title="复数数组处理函数"></a>复数数组处理函数</h5><p>NumPy 提供了诸多处理复数类型数组的函数，主要有以下几个：</p><p>numpy.real()<br>返回复数数组的实部；</p><p>numpy.imag()<br>返回复数数组的虚部；</p><p>numpy.conj()<br>通过更改虚部的符号，从而返回共轭复数；</p><p>numpy.angle()<br>返回复数参数的角度，该函数的提供了一个 deg 参数，如果  deg&#x3D;True，则返回的值会以角度制来表示，否则以以弧度制来表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([-5.6j, 0.2j, 11. , 1+1j])</span><br><span class="line">print(a)</span><br><span class="line">#real() </span><br><span class="line">print np.real(a)</span><br><span class="line">#imag() </span><br><span class="line">print np.imag(a)</span><br><span class="line">#conj()</span><br><span class="line">print np.conj(a)</span><br><span class="line">#angle() </span><br><span class="line">print np.angle(a)</span><br><span class="line">#angle() 带参数deg</span><br><span class="line">print np.angle(a, deg = True)</span><br></pre></td></tr></table></figure><h4 id="NumPy统计函数"><a href="#NumPy统计函数" class="headerlink" title="NumPy统计函数"></a>NumPy统计函数</h4><p>NumPy 提供了许多统计功能的函数，比如查找数组元素的最值、百分位数、方差以及标准差等。</p><p>numpy.amin() 和 numpy.amax()</p><p>这两个函数用于计算数组沿指定轴的最小值与最大值：<br>amin() 沿指定的轴，查找数组中元素的最小值，并以数组形式返回；<br>amax() 沿指定的轴，查找数组中元素的最大值，并以数组形式返回。</p><p>对于二维数组来说，axis&#x3D;1 表示沿着水平方向，axis&#x3D;0 表示沿着垂直方向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[3,7,5],[8,4,3],[2,4,9]]) </span><br><span class="line">print (&#x27;数组a是：&#x27;)</span><br><span class="line">print(a)</span><br><span class="line">#amin()函数</span><br><span class="line">print (np.amin(a))</span><br><span class="line">#调用 amin() 函数，axis=1</span><br><span class="line">print(np.amin(a,1))</span><br><span class="line">#调用amax()函数</span><br><span class="line">print(np.amax(a))</span><br><span class="line">#再次调用amax()函数</span><br><span class="line">print(np.amax(a,axis=0))</span><br></pre></td></tr></table></figure><p>numpy.ptp()</p><p>numpy.ptp() 用于计算数组元素中最值之差值，也就是（最大值 - 最小值）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[2,10,20],[80,43,31],[22,43,10]]) </span><br><span class="line">print(&quot;原数组&quot;,a) </span><br><span class="line">print(&quot;沿着axis 1:&quot;,np.ptp(a,1)) </span><br><span class="line">print(&quot;沿着axis 0:&quot;,np.ptp(a,0)) </span><br></pre></td></tr></table></figure><p>numpy.percentile()</p><p>百分位数，是统计学中使用的一种度量单位。该函数表示沿指定轴，计算数组中任意百分比分位数</p><p>语法格式：<br>numpy.percentile(a, q, axis)</p><p>a：输入数组<br>q：要计算的百分位数，在 0~100 之间<br>axis：沿着指定的轴计算百分位数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = np.array([[2,10,20],[80,43,31],[22,43,10]]) </span><br><span class="line">print(&quot;数组a:&quot;,a) </span><br><span class="line">print(&quot;沿着axis=0计算百分位数&quot;,np.percentile(a,10,0)) </span><br><span class="line">print(&quot;沿着axis=1计算百分位数&quot;,np.percentile(a,10,1))</span><br></pre></td></tr></table></figure><p>numpy.median()</p><p>numpy.median() 用于计算 a 数组元素的中位数（中值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[30,65,70],[80,95,10],[50,90,60]])</span><br><span class="line">#数组a:</span><br><span class="line">print(a)</span><br><span class="line">#median()</span><br><span class="line">print np.median(a)</span><br><span class="line">#axis 0</span><br><span class="line">print np.median(a, axis = 0)</span><br><span class="line">#axis 1:</span><br><span class="line">print(np.median(a, axis = 1))</span><br></pre></td></tr></table></figure><p>numpy.mean()</p><p>该函数表示沿指定的轴，计算数组中元素的算术平均值（即元素之总和除以元素数量）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2,3],[3,4,5],[4,5,6]]) </span><br><span class="line">print (&#x27;我们的数组是：&#x27;)</span><br><span class="line">print (a)</span><br><span class="line"></span><br><span class="line">print (&#x27;调用 mean() 函数：&#x27;)</span><br><span class="line">print (np.mean(a))</span><br><span class="line"></span><br><span class="line">print (&#x27;沿轴 0 调用 mean() 函数：&#x27;)</span><br><span class="line">print (np.mean(a, axis =  0))</span><br><span class="line"></span><br><span class="line">print (&#x27;沿轴 1 调用 mean() 函数：&#x27;)</span><br><span class="line">print (np.mean(a, axis =  1))</span><br></pre></td></tr></table></figure><p>numpy.average()</p><p>加权平均值是将数组中各数值乘以相应的权数，然后再对权重值求总和，最后以权重的总和除以总的单位数（即因子个数）。numpy.average() 根据在数组中给出的权重，计算数组元素的加权平均值。该函数可以接受一个轴参数 axis，如果未指定，则数组被展开为一维数组。</p><p>示例：<br>现有数组 [1,2,3,4] 和相应的权重数组 [4,3,2,1]，它的加权平均值计算如下：加权平均值&#x3D;（1 * 4 + 2 * 3 + 3 * 2 + 4 * 1）&#x2F;（4 + 3 + 2 + 1）</p><p>使用 average() 计算加权平均值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([1,2,3,4]) </span><br><span class="line">print(&#x27;a数组是：&#x27;)</span><br><span class="line">print(a)</span><br><span class="line">#average()函数：</span><br><span class="line">print (np.average(a))</span><br><span class="line"># 若不指定权重相当于对数组求均值</span><br><span class="line">we = np.array([4,3,2,1]) </span><br><span class="line">#调用 average() 函数：&#x27;)</span><br><span class="line">print(np.average(a,weights = we))</span><br><span class="line">#returned 为Ture，则返回权重的和 </span><br><span class="line">prin(np.average([1,2,3,4],weights =  [4,3,2,1], returned =  True))</span><br></pre></td></tr></table></figure><p>在多维数组中，您也可以指定 axis 轴参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(6).reshape(3,2) </span><br><span class="line">#多维数组a</span><br><span class="line">print (a)</span><br><span class="line">#修改后数组</span><br><span class="line">wt = np.array([3,5]) </span><br><span class="line">print (np.average(a, axis = 1, weights = wt))</span><br><span class="line">#修改后数组</span><br><span class="line">print (np.average(a, axis = 1, weights = wt, returned =  True))</span><br></pre></td></tr></table></figure><p>方差np.var() </p><p>方差，在统计学中也称样本方差，如何求得方差呢？首先我们要知道全体样本的的平均值，然后再求得每个样本值与均值之差的平方和，最后对差的平方和求均值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print (np.var([1,2,3,4]))</span><br></pre></td></tr></table></figure><p>标准差np.std()</p><p>标准差是方差的算术平方根，用来描述一组数据平均值的分散程度。若一组数据的标准差较大，说明大部分的数值和其平均值之间差异较大；若标准差较小，则代表这组数值比较接近平均值。它的公式如下：</p><p>std &#x3D; sqrt(mean((x - x.mean())**2</p><p>NumPy 中使用 np.std() 计算标准差。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print (np.std([1,2,3,4]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（四）</title>
      <link href="/post/583e63c1.html"/>
      <url>/post/583e63c1.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy数组元素增删改查"><a href="#NumPy数组元素增删改查" class="headerlink" title="NumPy数组元素增删改查"></a>NumPy数组元素增删改查</h4><p>NumPy 数组元素的增删改查主要有以下方法：</p><p>resize<br>返回指定形状的新数组。</p><p>append<br>将元素值添加到数组的末尾。</p><p>insert<br>沿规定的轴将元素值插入到指定的元素前。</p><p>delete<br>删掉某个轴上的子数组，并返回删除后的新数组。</p><p>argwhere<br>返回数组内符合条件的元素的索引值。</p><p>unique<br>用于删除数组中重复的元素，并按元素值<strong>由大到小</strong>返回一个新数组。</p><ol><li>numpy.resize()</li></ol><p>numpy.resize() 返回指定形状的新数组</p><p>numpy.resize(arr, shape)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">print(a)</span><br><span class="line">#a数组的形状</span><br><span class="line">print(a.shape)</span><br><span class="line">b = np.resize(a,(3,2))</span><br><span class="line">#b数组</span><br><span class="line">print (b)</span><br><span class="line">#b数组的形状</span><br><span class="line">print(b.shape)</span><br><span class="line">#修改b数组使其形状大于原始数组，会在那些比原来多的位置上重复前面的元素</span><br><span class="line">b = np.resize(a,(3,3))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>这里需要区别 resize() 和 reshape() 的使用方法，它们看起来相似，实则不同。resize 仅对原数组进行修改，没有返回值，而 reshape 不仅对原数组进行修改，同时返回修改后的结果。</p><ol start="2"><li>numpy.append()</li></ol><p>在数组的末尾添加值，它返回一个一维数组。</p><p>numpy.append(arr, values, axis&#x3D;None)</p><p>arr：输入的数组；</p><p>values：向 arr 数组中添加的值，需要和 arr 数组的形状保持一致；</p><p>axis：默认为 None，返回的是一维数组；当 axis &#x3D;0 时，追加的值会被添加到行，而列数保持不变，若 axis&#x3D;1 则与其恰好相反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">#向数组a添加元素</span><br><span class="line">print (np.append(a, [7,8,9]))</span><br><span class="line"></span><br><span class="line">#沿轴 0 添加元素</span><br><span class="line">print (np.append(a, [[7,8,9]],axis = 0))</span><br><span class="line">#沿轴 1 添加元素</span><br><span class="line">print (np.append(a, [[5,5,5],[7,8,9]],axis = 1))</span><br></pre></td></tr></table></figure><ol start="3"><li>numpy.insert()</li></ol><p>表示沿指定的轴，在给定索引值的前一个位置插入相应的值，如果没有提供轴，则输入数组被展开为一维数组。numpy.insert(arr, obj, values, axis)</p><p>arr：要输入的数组<br>obj：表示索引值，在该索引值之前插入<br>values 值；values：要插入的值<br>axis：指定的轴，如果未提供，则输入数组会被展开为一维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2],[3,4],[5,6]])</span><br><span class="line"></span><br><span class="line">#不提供axis的情况，会将数组展开</span><br><span class="line">print (np.insert(a,3,[11,12]))</span><br><span class="line"></span><br><span class="line">#沿轴 0 水平方向</span><br><span class="line">print (np.insert(a,1,[11],axis = 0))</span><br><span class="line"></span><br><span class="line">#沿轴 1 垂直方向</span><br><span class="line">print (np.insert(a,1,11,axis = 1))</span><br></pre></td></tr></table></figure><ol start="4"><li>numpy.delete()</li></ol><p>该方法表示从输入数组中删除指定的子数组，并返回一个新数组。它与 insert() 函数相似，若不提供 axis 参数，则输入数组被展开为一维数组。</p><p>numpy.delete(arr, obj, axis)</p><p>arr：要输入的数组<br>obj：整数或者整数数组，表示要被删除数组元素或者子数组<br>axis：沿着哪条轴删除子数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(12).reshape(3,4)</span><br><span class="line">#a数组</span><br><span class="line">print(a)</span><br><span class="line">#不提供axis参数情况</span><br><span class="line">print(np.delete(a,5))</span><br><span class="line"></span><br><span class="line">#删除第二列</span><br><span class="line">print(np.delete(a,1,axis = 1))</span><br><span class="line"></span><br><span class="line">#删除经切片后的数组</span><br><span class="line">a = np.array([1,2,3,4,5,6,7,8,9,10])</span><br><span class="line">print (np.delete(a, np.s_[::2]))</span><br></pre></td></tr></table></figure><ol start="5"><li>numpy.argwhere()</li></ol><p>该函数返回数组中非 0 元素的索引，若是多维数组则返回行、列索引组成的索引坐标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.arange(6).reshape(2,3)</span><br><span class="line">print(x)</span><br><span class="line">#返回所有大于1的元素索引组成的数组</span><br><span class="line">y=np.argwhere(x&gt;1)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><ol start="6"><li>numpy.unique()</li></ol><p>用于删除数组中重复的元素</p><p>语法格式：numpy.unique(arr, return_index, return_inverse, return_counts)</p><p>arr：输入数组，若是多维数组则以一维数组形式展开；</p><p>return_index：如果为 True，则返回新数组元素在原数组中的位置（索引）；</p><p>return_inverse：如果为 True，则返回原数组元素在新数组中的位置（索引）；</p><p>return_counts：如果为 True，则返回去重后的数组元素在原数组中出现的次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([5,2,6,2,7,5,6,8,2,9])</span><br><span class="line">print (a)</span><br><span class="line">#对a数组的去重</span><br><span class="line">uq = np.unique(a)</span><br><span class="line">print (uq)</span><br><span class="line"></span><br><span class="line">#数组去重后的索引数组</span><br><span class="line">u,indices = np.unique(a, return_index = True)</span><br><span class="line">#打印去重后数组的索引</span><br><span class="line">print(indices)</span><br><span class="line"></span><br><span class="line">#去重数组的下标：</span><br><span class="line">ui,indices = np.unique(a,return_inverse = True)</span><br><span class="line">print (ui)</span><br><span class="line">#打印下标</span><br><span class="line">print (indices)</span><br><span class="line"></span><br><span class="line">#返回去重元素的重复数量</span><br><span class="line">uc,indices = np.unique(a,return_counts = True)</span><br><span class="line">print (uc)</span><br><span class="line">元素出现次数：</span><br><span class="line">print (indices)</span><br></pre></td></tr></table></figure><h4 id="NumPy位运算"><a href="#NumPy位运算" class="headerlink" title="NumPy位运算"></a>NumPy位运算</h4><p>NumPy 中提供了以下按位运算函数：</p><img src="/post/583e63c1/342.png" class title="This is an image"><p>bitwise_and()<br>该函数对数组中整数的二进制数进行“按位与”运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a = 10 </span><br><span class="line">b = 12 </span><br><span class="line">print(&quot;a的二进制数:&quot;,bin(a)) </span><br><span class="line">print(&quot;b的二进制数:&quot;,bin(b)) </span><br><span class="line">print(&quot;将a与b执行按位与操作:&quot;,np.bitwise_and(a,b))  </span><br></pre></td></tr></table></figure><p>如果两个的二进制数相对应的位都为 1，那么执行位与运算后，该位的结果就为 1，否则就为 0。</p><p>上述示例：a 与 b 位与运算的结果为 1000，因此它的十进制结果为 8。</p><img src="/post/583e63c1/343.png" class title="This is an image"><p>bitwise_or()</p><p>bitwise_or() 对数组中整数的二进制数执行“按位或”运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a,b = 13,17</span><br><span class="line">print (&#x27;13 和 17 的二进制数：&#x27;)</span><br><span class="line">print (bin(a), bin(b))</span><br><span class="line"></span><br><span class="line">print (&#x27;13 和 17 的位或：&#x27;)</span><br><span class="line">print (np.bitwise_or(13, 17))</span><br></pre></td></tr></table></figure><p>对于按位或运算，只要相对应的二进制位上有一个为 1，那么它的运算结果就位 1，否则为 0，其真值表如下：</p><img src="/post/583e63c1/344.png" class title="This is an image"><p>Invert()</p><p>该方法对数组中整数做按位取反运算，也就是 0 变成 1，1 变为 0。若是有符号的负整数，取其二进制数的补码，并执行 +1 操作。对于有符号二进制数，其最高位为 0， 表示正数；最高位为 1， 表示负数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">#数据类型为无符号整型uint8</span><br><span class="line">arr = np.array([20],dtype = np.uint8) </span><br><span class="line">print(&quot;二进制表示:&quot;,np.binary_repr(20,8)) </span><br><span class="line">print(np.invert(arr)) </span><br><span class="line">#进行取反操作</span><br><span class="line">print(&quot;二进制表示: &quot;, np.binary_repr(235,8))  </span><br></pre></td></tr></table></figure><p>注意：上述示例中，np.binary_repr 函数用来设置二进制数的位数。若对补码概念不熟悉，可参考百度百科《补码》。</p><p>left_shift()</p><p>该方法把数组元素的二进制数向左移动到指定位置，而其返回值所对应的二进制数，则会从右侧追加相等数量的 0（移动了多少位便追加多少个0）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#移动三位后的输出值</span><br><span class="line">print (np.left_shift(20,3)</span><br><span class="line">#打印移动后20的二进制数</span><br><span class="line">print (np.binary_repr(20, width = 8))</span><br><span class="line">#函数返回值的二进制数</span><br><span class="line">print (np.binary_repr(160, width = 8))</span><br></pre></td></tr></table></figure><p>right_shift()</p><p>right_shift() 将数组中元素的二进制数向右移动到指定位置，其返回值对应的二进制数会从左侧追加相等数量的 0。该函数使用与 left_shift() 恰好相反。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#将40右移两位后返回值：</span><br><span class="line">print (np.right_shift(40,2))</span><br><span class="line">#移动后40的二进制数：</span><br><span class="line">print (np.binary_repr(40, width = 8))</span><br><span class="line">#移动后返回值的二进制数：</span><br><span class="line">print (np.binary_repr(10, width = 8))</span><br></pre></td></tr></table></figure><h4 id="NumPy字符串处理函数"><a href="#NumPy字符串处理函数" class="headerlink" title="NumPy字符串处理函数"></a>NumPy字符串处理函数</h4><p>NumPy 提供了许多字符串处理函数，它们被定义在用于处理字符串数组的 numpy.char 这个类中，这些函数的操作对象是 string_ 或者 unicode_ 字符串数组。</p><p>add()<br>对两个数组相应位置的字符串做连接操作。</p><p>multiply()<br>返回多个字符串副本，比如将字符串“ hello”乘以3，则返回字符串“ hello hello hello”。</p><p>center()<br>用于居中字符串，并将指定的字符，填充在原字符串的左右两侧。</p><p>capitalize()<br>将字符串第一个字母转换为大写。</p><p>title()<br>标题样式，将每个字符串的第一个字母转换为大写形式。</p><p>lower()<br>将数组中所有的字符串的大写转换为小写。</p><p>upper()<br>将数组中所有的字符串的小写转换为大写。</p><p>split()<br>通过指定分隔符对字符串进行分割，并返回一个数组序列，默认分隔符为空格。</p><p>splitlines()<br>以换行符作为分隔符来分割字符串，并返回数组序列。</p><p>strip()<br>删除字符串开头和结尾处的空字符。</p><p>join()<br>返回一个新的字符串，该字符串是以指定分隔符来连接数组中的所有元素。</p><p>replace()<br>用新的字符串替换原数组中指定的字符串。</p><p>decode()<br>用指定的编码格式对数组中元素依次执行解码操作。</p><p>encode()<br>用指定的编码格式对数组中元素依次执行编码操作。</p><p>numpy.char.add()</p><p>numpy.char.add() 将两个数组对应位置的字符串元素进行连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(np.char.add([&#x27;welcome&#x27;,&#x27;url&#x27;], [&#x27; to 漂亮鬼 net&#x27;,&#x27;is 1yzf2zst.github.io&#x27;] ))  </span><br></pre></td></tr></table></figure><p>numpy.char.multiply()<br>该函数将指定的字符串进行多次拷贝，并将拷贝结果返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print (np.char.multiply(&#x27;1yzf2zst.github.io&#x27;&#x27;,3))</span><br></pre></td></tr></table></figure><p>numpy.char.center()</p><p>numpy.char.center() 用于居中字符串</p><p>语法格式：np.char.center(string, width, fillchar) </p><p>string: 代表字符串，width: 表示长度，fillchar: 要填充的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(np.char.center(&quot;1yzf2zst.github.io&quot;, 20, &#x27;*&#x27;))  </span><br></pre></td></tr></table></figure><p>numpy.char.capitalize()</p><p>numpy.char.capitalize() 将字符串的第一个字母转换为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print (np.char.capitalize(&#x27;python&#x27;))</span><br></pre></td></tr></table></figure><p>numpy.char.title()</p><p>numpy.char.title() 将字符串数组中每个元素的第一个字母转换为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(np.char.title(&quot;welcome to china&quot;)) </span><br></pre></td></tr></table></figure><p>numpy.char.lower()</p><p>numpy.char.lower() 将字符串数组中每个元素转换为小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(np.char.lower(&quot;WELCOME TO MYHOME&quot;)) </span><br></pre></td></tr></table></figure><p>numpy.char.upper()<br>numpy.char.upper() 将数组中的每个元素转换为大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print(np.char.upper(&quot;Welcome To Python&quot;)) </span><br></pre></td></tr></table></figure><p>numpy.char.split()</p><p>该函数通过指定分隔符对字符串进行分割，并返回数组序列<br>默认情况下，分隔符为空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(np.char.split(&quot;Welcome To Python&quot;),sep = &quot; &quot;)  </span><br></pre></td></tr></table></figure><p>numpy.char.splitlines()<br>以换行符作为分隔符来分割字符串，并返回一个数组序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(&quot;Splitting the String line by line..&quot;) </span><br><span class="line">print(np.char.splitlines(&quot;Welcome\nTo\nPython&quot;))  </span><br></pre></td></tr></table></figure><p>numpy.char.strip()<br>用于移除开头或结尾处的空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np  </span><br><span class="line">print(&quot;原字符串:&quot;,str)  </span><br><span class="line">str = &quot;     welcome to Python     &quot; </span><br><span class="line">print(np.char.strip(str))  </span><br></pre></td></tr></table></figure><p>numpy.char.join()</p><p>numpy.char.join() 通过指定的分隔符来连接数组中的元素或字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">print (np.char.join(&#x27;:&#x27;,&#x27;Love&#x27;))</span><br><span class="line">#也可指定多个分隔符</span><br><span class="line">print (np.char.join([&#x27;:&#x27;,&#x27;-&#x27;],[&#x27;Love&#x27;,&#x27;Python&#x27;]))</span><br></pre></td></tr></table></figure><p>numpy.char.replace()<br>numpy.char.replace() 使用新字符替换字符串中的指定字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">str = &quot;Welcome to China&quot; </span><br><span class="line">print(&quot;原字符串:&quot;,str) </span><br><span class="line">#更改后字符串</span><br><span class="line">print(np.char.replace(str, &quot;Welcome to&quot;,&quot;Hello&quot;))  </span><br></pre></td></tr></table></figure><p>numpy.char.encode()与decode()<br>默认以utf-8的形式进行编码与解码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">#cp500国际编码</span><br><span class="line">encode_str = np.char.encode(&quot;Welcome to China&quot;, &#x27;cp500&#x27;) </span><br><span class="line">decode_str =np.char.decode(encode_str, &#x27;cp500&#x27;) </span><br><span class="line">print(encode_str) </span><br><span class="line">print(decode_str)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（三）</title>
      <link href="/post/ef137aa4.html"/>
      <url>/post/ef137aa4.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy广播机制"><a href="#NumPy广播机制" class="headerlink" title="NumPy广播机制"></a>NumPy广播机制</h4><p>NumPy 中的广播机制（Broadcast）旨在解决不同形状数组之间的算术运算问题。我们知道，如果进行运算的两个数组形状完全相同，它们直接可以做相应的运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([0.1,0.2,0.3,0.4])</span><br><span class="line">b = np.array([10,20,30,40])</span><br><span class="line">c = a * b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>但如果两个形状不同的数组呢？它们之间就不能做算术运算了吗？当然不是！为了保持数组形状相同，NumPy 设计了一种广播机制，这种机制的核心是对形状较小的数组，在横向或纵向上进行一定次数的重复，使其与形状较大的数组拥有相同的维度。</p><p>当进行运算的两个数组形状不同，Numpy 会自动触发广播机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[ 0, 0, 0],</span><br><span class="line">           [10,10,10],</span><br><span class="line">           [20,20,20],</span><br><span class="line">           [30,30,30]])</span><br><span class="line">#b数组与a数组形状不同</span><br><span class="line">b = np.array([1,2,3])</span><br><span class="line">print(a + b)</span><br></pre></td></tr></table></figure><img src="/post/ef137aa4/340.png" class title="This is an image"><h4 id="NumPy遍历数组"><a href="#NumPy遍历数组" class="headerlink" title="NumPy遍历数组"></a>NumPy遍历数组</h4><p>NumPy 提供了一个 nditer 迭代器对象，它可以配合 for 循环完成对数组元素的遍历。</p><p>使用 arange() 函数创建一个 3*4 数组，并使用 nditer 生成迭代器对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4)</span><br><span class="line">#使用nditer迭代器,并使用for进行遍历</span><br><span class="line">for x in np.nditer(a):</span><br><span class="line">   print(x)</span><br></pre></td></tr></table></figure><h5 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h5><p>在内存中，Numpy 数组提供了两种存储数据的方式，分别是 C-order（行优先顺序）与 Fortrant-order（列优先顺序）。nditer 迭代器选择了一种与数组内存布局一致的顺序，之所以这样做，是为了提升数据的访问效率。</p><p>在默认情况下，当我们遍历数组中元素的时候，不需要考虑数组的存储顺序，这一点可以通过遍历上述数组的转置数组来验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4)</span><br><span class="line">#a的转置数组</span><br><span class="line">b = a.T</span><br><span class="line">print (b)</span><br><span class="line">for x in np.nditer(b):</span><br><span class="line">   print(x，end=&quot;,&quot;)</span><br></pre></td></tr></table></figure><p>从示例的输出结果可以看出，a 和 a.T 的遍历顺序是一样的，也就是说，它们在内存中的存储顺序是一样的。</p><p>下面以 C 样式访问转置数组的副本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5).reshape(3,4)</span><br><span class="line">#copy方法生成数组副本</span><br><span class="line">for x in np.nditer(a.T.copy(order=&#x27;C&#x27;)):</span><br><span class="line">    print (x, end=&quot;, &quot; )</span><br></pre></td></tr></table></figure><p>通过示例可知 a.T.copy(order &#x3D; ‘C’) 的遍历结果与前面的数组遍历结果不一样。究其原因，就是因为它们在内存中的存储方式不一样。</p><h5 id="指定遍历顺序"><a href="#指定遍历顺序" class="headerlink" title="指定遍历顺序"></a>指定遍历顺序</h5><p>您可以通过 nditer 对象的order参数来指定数组的遍历的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">for x in np.nditer(a, order = &#x27;C&#x27;):</span><br><span class="line">   print (x,end=&quot;,&quot;) </span><br><span class="line"></span><br><span class="line">for x in np.nditer(a, order = &#x27;F&#x27;):</span><br><span class="line">   print (x,end=&quot;,&quot;)</span><br></pre></td></tr></table></figure><h5 id="修改数组元素值"><a href="#修改数组元素值" class="headerlink" title="修改数组元素值"></a>修改数组元素值</h5><p>nditer 对象提供了一个可选参数op_flags，它表示能否在遍历数组时对元素进行修改。它提供了三种模式</p><ol><li>read-only</li></ol><p>只读模式，在这种模式下，遍历时不能修改数组中的元素。</p><ol start="2"><li><p>read-write<br>读写模式，遍历时可以修改元素值。</p></li><li><p>write-only<br>只写模式，在遍历时可以修改元素值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4) </span><br><span class="line">print (&quot;原数组是:&quot;,a)</span><br><span class="line">for x in np.nditer(a, op_flags=[&#x27;readwrite&#x27;]):</span><br><span class="line">    x[...]=2*x</span><br><span class="line">print (&#x27;修改后的数组是：&#x27;,a)</span><br></pre></td></tr></table></figure></li></ol><h5 id="外部循环使用"><a href="#外部循环使用" class="headerlink" title="外部循环使用"></a>外部循环使用</h5><p>nditer 对象的构造函数有一个“flags”参数，它可以接受以下参数值：</p><p>c_index<br>可以跟踪 C 顺序的索引。<br>f_index<br>可以跟踪 Fortran 顺序的索引。<br>multi_index<br>每次迭代都会跟踪一种索引类型。<br>external_loop<br>返回的遍历结果是具有多个值的一维数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4)</span><br><span class="line">print(&quot;原数组&quot;,a)</span><br><span class="line">#修改后数组</span><br><span class="line">for x in np.nditer(a, flags = [&#x27;external_loop&#x27;], order = &#x27;F&#x27;):</span><br><span class="line">   print(x)</span><br></pre></td></tr></table></figure><h5 id="迭代多个数组"><a href="#迭代多个数组" class="headerlink" title="迭代多个数组"></a>迭代多个数组</h5><p>如果两个数组都能够被广播，那么 nditer 对象就可以同时对它们迭代。</p><p>假设数组 a 的维度是 3<em>4，另一个数组 b 的维度是 1</em>4 （即维度较小的数组 b 可以被广播到数组 a 中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(0,60,5)</span><br><span class="line">a = a.reshape(3,4)</span><br><span class="line">print (a)</span><br><span class="line">b = np.array([1, 2, 3, 4], dtype = int)</span><br><span class="line">print (b） </span><br><span class="line">#广播迭代</span><br><span class="line">for x,y in np.nditer([a,b]):</span><br><span class="line">    print (&quot;%d:%d&quot; % (x,y),end=&quot;,&quot;)</span><br></pre></td></tr></table></figure><h4 id="NumPy相关数组操作"><a href="#NumPy相关数组操作" class="headerlink" title="NumPy相关数组操作"></a>NumPy相关数组操作</h4><p>NumPy 中包含了一些处理数组的常用方法，大致可分为以下几类：</p><p>数组变维操作<br>数组转置操作<br>修改数组维度操作<br>连接与分割数组操作</p><h5 id="数组变维操作"><a href="#数组变维操作" class="headerlink" title="数组变维操作"></a>数组变维操作</h5><p>reshape<br>在不改变数组元素的条件下，修改数组的形状。</p><p>flat<br>返回是一个迭代器，可以用 for 循环遍历其中的每一个元素。</p><p>flatten<br>以一维数组的形式返回一份数组的副本，对副本的操作不会影响到原数组。</p><p>ravel<br>返回一个连续的扁平数组（即展开的一维数组），与 flatten不同，它返回的是数组视图（修改视图会影响原数组）。</p><ol><li><p>numpy.ndarray.flat<br>numpy.ndarray.flat 返回一个数组迭代器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(9).reshape(3,3)</span><br><span class="line">for row in a:</span><br><span class="line">    print (row)</span><br><span class="line">#使用flat属性：</span><br><span class="line">for ele in a.flat:</span><br><span class="line">    print (ele,end=&quot;，&quot;)</span><br></pre></td></tr></table></figure></li><li><p>numpy.ndarray.flatten()</p></li></ol><p>numpy.ndarray.flatten 返回一份数组副本，对副本修改不会影响原始数组</p><p>语法格式：ndarray.flatten(order&#x3D;’C’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(8).reshape(2,4)</span><br><span class="line">print (a)</span><br><span class="line">#默认按行C风格展开的数组</span><br><span class="line">print (a.flatten())</span><br><span class="line">#以F风格顺序展开的数组</span><br><span class="line">print (a.flatten(order = &#x27;F&#x27;))</span><br></pre></td></tr></table></figure><ol start="3"><li>numpy.ravel()</li></ol><p>numpy.ravel() 将多维数组中的元素以一维数组的形式展开，该方法返回数组的视图（view），如果修改，则会影响原始数组。</p><p>numpy.ravel(a, order&#x3D;’C’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(8).reshape(2,4)</span><br><span class="line">print (&#x27;原数组：&#x27;)</span><br><span class="line">print (a)</span><br><span class="line"></span><br><span class="line">print (&#x27;调用 ravel 函数后：&#x27;)</span><br><span class="line">print (a.ravel())</span><br><span class="line"></span><br><span class="line">print (&#x27;F 风格顺序调用 ravel 函数之后：&#x27;)</span><br><span class="line">print (a.ravel(order = &#x27;F&#x27;))</span><br></pre></td></tr></table></figure><h5 id="数组转置操作"><a href="#数组转置操作" class="headerlink" title="数组转置操作"></a>数组转置操作</h5><p>transpose<br>将数组的维度值进行对换，比如二维数组维度(2,4)使用该方法后为(4,2)。</p><p>ndarray.T<br>与 transpose 方法相同。</p><p>rollaxis<br>沿着指定的轴向后滚动至规定的位置。</p><p>swapaxes<br>对数组的轴进行对换。</p><ol><li>numpy.transpose()</li></ol><p>numpy.transpose() 用于对换多维数组的维度，比如二维数组使用此方法可以实现矩阵转置</p><p>语法格式：numpy.transpose(arr, axes)</p><p>arr：要操作的数组</p><p>axes：可选参数，元组或者整数列表，将会按照该参数进行转置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(12).reshape(3,4)</span><br><span class="line">print (a)</span><br><span class="line">print (np.transpose(a))</span><br></pre></td></tr></table></figure><ol start="2"><li>numpy.rollaxis()</li></ol><p>该方法表示沿着指定的轴，向后滚动至一个特定位置</p><p>格式如下：numpy.rollaxis(arr, axis, start)</p><p>arr：要传入的数组；<br>axis：沿着哪条轴向后滚动，其它轴的相对位置不会改变；<br>start：默认以 0 轴开始，可以根据数组维度调整它的值。</p><ol start="3"><li>numpy.swapaxes()</li></ol><p>该方法用于交换数组的两个轴，</p><p>语法格式：numpy.swapaxes(arr, axis1, axis2) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 创建了三维的 ndarray</span><br><span class="line">a = np.arange(27).reshape(3,3,3)</span><br><span class="line">print (a)</span><br><span class="line">#对换0轴与2轴</span><br><span class="line">print(np.swapaxes(a,2,0))</span><br></pre></td></tr></table></figure><h5 id="修改数组维度操作"><a href="#修改数组维度操作" class="headerlink" title="修改数组维度操作"></a>修改数组维度操作</h5><p>修改数组维度的操作，主要有以下方法：</p><p>broadcast<br>生成一个模拟广播的对象。</p><p>broadcast_to<br>将数组广播为新的形状。</p><p>expand_dims<br>扩展数组的形状。</p><p>squeeze<br>从数组的形状中删除一维项。</p><ol><li>numpy.broadcast()</li></ol><p>返回值是数组被广播后的对象，该函数以两个数组作为输入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1], [2], [3]])</span><br><span class="line">b = np.array([4, 5, 6]) </span><br><span class="line"># 对b广播a</span><br><span class="line">d = np.broadcast(a,b) </span><br><span class="line">#d它拥有 iterator 属性</span><br><span class="line">r,c = d.iters</span><br><span class="line">print (next(r), next(c))</span><br><span class="line">print (next(r), next(c))</span><br><span class="line"># 使用broadcast将a与b相加</span><br><span class="line">e = np.broadcast(a,b)</span><br><span class="line">f=np.empty(e.shape)</span><br><span class="line">f.flat=[x+y for (x,y) in e]</span><br><span class="line">print(f)</span><br><span class="line">print(a+b)</span><br></pre></td></tr></table></figure><ol start="2"><li>numpy.broadcast_to()</li></ol><p>该函数将数组广播到新形状中，它在原始数组的基础上返回一个只读视图。 如果新形状不符合 NumPy 的广播规则，则会抛出 ValueError 异常。函数的语法格式如下：numpy.broadcast_to(array, shape, subok)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(4).reshape(1,4)</span><br><span class="line">print(&quot;原数组&quot;,a)</span><br><span class="line">print (&#x27;调用 broadcast_to 函数之后：&#x27;)</span><br><span class="line">print (np.broadcast_to(a,(4,4)))</span><br></pre></td></tr></table></figure><ol start="3"><li>numpy.expand_dims()</li></ol><p>在指定位置插入新的轴，从而扩展数组的维度，语法格式如下:numpy.expand_dims(arr, axis)</p><p>参数说明：arr：输入数组axis：新轴插入的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.array(([1,2],[3,4]))</span><br><span class="line">print (&#x27;数组 x：&#x27;)</span><br><span class="line">print (x)</span><br><span class="line"># 在 0 轴处插入新的轴</span><br><span class="line">y = np.expand_dims(x, axis = 0)</span><br><span class="line">print (&#x27;数组 y：&#x27;)</span><br><span class="line">print (y)</span><br><span class="line">print (&#x27;\n&#x27;)</span><br><span class="line">print (&#x27;数组 x 和 y 的形状：&#x27;)</span><br><span class="line">print (x.shape, y.shape)</span><br></pre></td></tr></table></figure><ol start="4"><li>numpy.squeeze()<br>删除数组中维度为 1 的项，例如，一个数组的 shape 是 (5,1)，经此函数后，shape 变为 (5,) 。其函数语法格式如下：</li></ol><p>numpy.squeeze(arr, axis)</p><p>参数说明：arr：输入数的组；axis：取值为整数或整数元组，用于指定需要删除的维度所在轴，指定的维度值必须为 1 ，否则将会报错，若为 None，则删除数组维度中所有为 1 的项。</p><p>下面是带有 axis 参数的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = np.array([[[0], [1], [2]]])</span><br><span class="line">&gt;&gt;&gt; x.shape</span><br><span class="line">(1, 3, 1)</span><br><span class="line">&gt;&gt;&gt; np.squeeze(x).shape</span><br><span class="line">(3,)</span><br><span class="line">&gt;&gt;&gt; np.squeeze(x, axis=(2,)).shape</span><br><span class="line">(1, 3)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(9).reshape(1,3,3)</span><br><span class="line">print (a)</span><br><span class="line">b = np.squeeze(a)</span><br><span class="line">print (b)</span><br><span class="line">print (&#x27;数组 a 和 b 的形状：&#x27;)</span><br><span class="line">print (x.shape, y.shape)</span><br></pre></td></tr></table></figure><h5 id="连接与分割数组操作"><a href="#连接与分割数组操作" class="headerlink" title="连接与分割数组操作"></a>连接与分割数组操作</h5><p>连接与分割数组是数组的两种操作方式</p><img src="/post/ef137aa4/341.png" class title="This is an image"><h6 id="1-连接数组操作-numpy-concatenate"><a href="#1-连接数组操作-numpy-concatenate" class="headerlink" title="1) 连接数组操作  numpy.concatenate()"></a>1) 连接数组操作  numpy.concatenate()</h6><p>沿指定轴连接相同形状的两个或多个数组<br>格式如下：numpy.concatenate((a1, a2, …), axis)</p><p>a1, a2, …：表示一系列相同类型的数组；<br>axis：沿着该参数指定的轴连接数组，默认为 0。</p><p>创建两个 a 、b 数组，并沿指定轴将它们连接起来。注意两个数组的形状要保持一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#创建数组a</span><br><span class="line">a = np.array([[10,20],[30,40]])</span><br><span class="line">print (a)</span><br><span class="line">#创建数组b</span><br><span class="line">b = np.array([[50,60],[70,80]])</span><br><span class="line">print (b)</span><br><span class="line">#沿轴 0 连接两个数组</span><br><span class="line">print (np.concatenate((a,b)))</span><br><span class="line">#沿轴 1 连接两个数组</span><br><span class="line">print (np.concatenate((a,b),axis = 1))</span><br></pre></td></tr></table></figure><p>数组连接操作至少需要两个维度相同的数组，才允许对它们进行垂直或者水平方向上的操作。在垂直方向堆叠数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2],[3,4]])</span><br><span class="line">b = np.array([[5,6],[7,8]])</span><br><span class="line">#垂直堆叠</span><br><span class="line">c = np.vstack((a,b))</span><br><span class="line">print (c)</span><br></pre></td></tr></table></figure><h6 id="2-分割数组操作"><a href="#2-分割数组操作" class="headerlink" title="2) 分割数组操作"></a>2) 分割数组操作</h6><p>numpy.split() 沿指定的轴将数组分割为多个子数组</p><p>语法格式：numpy.split(ary, indices_or_sections, axis)</p><p>ary：被分割的数组<br>indices_or_sections：若是一个整数，代表用该整数平均切分，若是一个数组，则代表沿轴切分的位置（左开右闭）；<br>axis：默认为0，表示横向切分；为1时表示纵向切分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(6)</span><br><span class="line">#原数组</span><br><span class="line">print (a)</span><br><span class="line">#将数组分为二个形状大小相等的子数组</span><br><span class="line">b = np.split(a,2)</span><br><span class="line">print (b)</span><br><span class="line">#将数组在一维数组中标明要位置分割</span><br><span class="line">b = np.split(a,[3,4])</span><br><span class="line">print (b)</span><br></pre></td></tr></table></figure><p>最后看一下 hsplit() 的使用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#arr1数组</span><br><span class="line">arr1 = np.floor(10 * np.random.random((2, 6)))</span><br><span class="line">print(arr1)</span><br><span class="line">#拆分后数组</span><br><span class="line">print(np.hsplit(arr1, 3))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（二）</title>
      <link href="/post/a20dd9f6.html"/>
      <url>/post/a20dd9f6.html</url>
      
        <content type="html"><![CDATA[<h4 id="Numpy创建数组"><a href="#Numpy创建数组" class="headerlink" title="Numpy创建数组"></a>Numpy创建数组</h4><p>创建 ndarray 数组的基本方法，除了使用 array() 方法外，NumPy 还提供了其他创建 ndarray 数组的方法。</p><h5 id="numpy-empty"><a href="#numpy-empty" class="headerlink" title="numpy.empty()"></a>numpy.empty()</h5><p>numpy.empty() 创建未初始化的数组，可以指定创建数组的形状（shape）和数据类型（dtype）</p><p>语法格式：</p><h5 id="numpy-empty-shape-dtype-x3D-float-order-x3D-‘C’"><a href="#numpy-empty-shape-dtype-x3D-float-order-x3D-‘C’" class="headerlink" title="numpy.empty(shape, dtype &#x3D; float, order &#x3D; ‘C’)"></a>numpy.empty(shape, dtype &#x3D; float, order &#x3D; ‘C’)</h5><p>它接受以下参数：<br>shape：指定数组的形状；<br>dtype：数组元素的数据类型，默认值是值 float；<br>order：指数组元素在计算机内存中的储存顺序，默认顺序是“C”(行优先顺序)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr = np.empty((3,2), dtype = int) </span><br><span class="line">print(arr) </span><br></pre></td></tr></table></figure><p>切记 empty 并非创建空数组。</p><h5 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros()"></a>numpy.zeros()</h5><p>该函数用来创建元素均为 0 的数组，同时还可以指定被数组的形状<br>语法格式：<br>numpy. zeros(shape,dtype&#x3D;float,order&#x3D;”C”)</p><p>shape指定数组的形状大小。<br>dtype可选项，数组的数据类型<br>order“C”代表以行顺序存储，“F”则表示以列顺序存储</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#默认数据类型为浮点数</span><br><span class="line">a=np.zeros(6)</span><br><span class="line">print(a)</span><br><span class="line">b=np.zeros(6,dtype=&quot;complex64&quot; )</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>也可以使用自定义的数据类型创建数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = np.zeros((3,3), dtype = [(&#x27;x&#x27;, &#x27;i4&#x27;), (&#x27;y&#x27;, &#x27;i4&#x27;)]) </span><br><span class="line">print(c)</span><br><span class="line">#输出x,y，并指定的数据类型</span><br></pre></td></tr></table></figure><h5 id="numpy-ones"><a href="#numpy-ones" class="headerlink" title="numpy.ones()"></a>numpy.ones()</h5><p>返回指定形状大小与数据类型的新数组，并且新数组中每项元素均用 1 填充<br>numpy.ones(shape, dtype &#x3D; None, order &#x3D; ‘C’)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr1 = np.ones((3,2), dtype = int) </span><br><span class="line">print(arr1)  </span><br></pre></td></tr></table></figure><h5 id="numpy-asarray"><a href="#numpy-asarray" class="headerlink" title="numpy.asarray()"></a>numpy.asarray()</h5><p>asarray() 与 array() 类似，但是它比 array() 更为简单。asarray() 能够将一个 Python 序列转化为 ndarray 对象</p><p>语法格式：<br>numpy.asarray（sequence，dtype &#x3D; None ，order &#x3D; None ）</p><p>sequence：接受一个 Python 序列，可以是列表或者元组；<br>dtype：可选参数，数组的数据类型；<br>order：数组内存布局样式，可以设置为 C 或者 F，默认是 C。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">l=[1,2,3,4,5,6,7] </span><br><span class="line">a = np.asarray(l); </span><br><span class="line">print(type(a)) </span><br><span class="line">print(a) </span><br></pre></td></tr></table></figure><p>使用嵌套列表创建多维数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">l=[[1,2,3,4,5,6,7],[8,9]] </span><br><span class="line">a = np.asarray(l); </span><br><span class="line">print(type(a)) </span><br><span class="line">print(a)  </span><br></pre></td></tr></table></figure><h5 id="numpy-frombuffer"><a href="#numpy-frombuffer" class="headerlink" title="numpy.frombuffer()"></a>numpy.frombuffer()</h5><p>表示使用指定的缓冲区创建数组</p><p>numpy.frombuffer(buffer, dtype &#x3D; float, count &#x3D; -1, offset &#x3D; 0)</p><p>buffer：将任意对象转换为流的形式读入缓冲区；<br>dtype：返回数组的数据类型，默认是<br>float32；count：要读取的数据数量，默认为 -1 表示读取所有数据；<br>offset：读取数据的起始位置，默认为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">#字节串类型</span><br><span class="line">l = b&#x27;hello world&#x27; </span><br><span class="line">print(type(l)) </span><br><span class="line">a = np.frombuffer(l, dtype = &quot;S1&quot;) </span><br><span class="line">print(a) </span><br><span class="line">print(type(a)) </span><br></pre></td></tr></table></figure><h5 id="numpy-fromiter"><a href="#numpy-fromiter" class="headerlink" title="numpy.fromiter()"></a>numpy.fromiter()</h5><p>该方法可以把迭代对象转换为 ndarray 数组，其返回值是一个一维数组。</p><p>numpy.fromiter(iterable, dtype, count &#x3D; -1)</p><p>iterable可迭代对象。<br>dtype返回数组的数据类型。<br>count读取的数据数量，默认为 -1，读取所有数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"># 使用 range 函数创建列表对象 </span><br><span class="line">list=range(6)</span><br><span class="line">#生成可迭代对象i</span><br><span class="line">i=iter(list)</span><br><span class="line">#使用i迭代器，通过fromiter方法创建ndarray</span><br><span class="line">array=np.fromiter(i, dtype=float)</span><br><span class="line">print(array)</span><br></pre></td></tr></table></figure><h4 id="NumPy创建区间数组"><a href="#NumPy创建区间数组" class="headerlink" title="NumPy创建区间数组"></a>NumPy创建区间数组</h4><p>所谓区间数组，是指数组元素的取值位于某个范围内，并且数组元素之间可能会呈现某种规律，比如等比数列、递增、递减等。</p><ol><li>numpy.arange()</li></ol><p>可以使用 arange() 来创建给定数值范围的数组</p><p>语法格式：numpy.arange(start, stop, step, dtype)</p><p>start起始值，默认是 0。<br>stop终止值，注意生成的数组元素值不包含终止值。</p><p>step步长，默认为 1。<br>dtype可选参数，指定 ndarray 数组的数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.arange(8) </span><br><span class="line">print (x)</span><br></pre></td></tr></table></figure><p>设置 start 、stop 值以及步长，最终输出 0-10 中的奇数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.arange(1,10,2) </span><br><span class="line">print (x)</span><br></pre></td></tr></table></figure><ol start="2"><li>numpy.linspace()</li></ol><p>表示在指定的数值区间内，返回均匀间隔的一维等差数组，默认均分 50 份</p><p>语法格式：<br>np.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None)</p><p>start：代表数值区间的起始值；<br>stop：代表数值区间的终止值；<br>num：表示数值区间内要生成多少个均匀的样本。默认值为 50；<br>endpoint：默认为 True，表示数列包含 stop 终止值，反之不包含；<br>retstep：默认为 True，表示生成的数组中会显示公差项，反之不显示；<br>dtype：代表数组元素值的数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#生成10个样本</span><br><span class="line">a = np.linspace(1,10,10)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><ol start="3"><li>numpy.logspace</li></ol><p>该函数同样返回一个 ndarray 数组，它用于创建等比数组</p><p>语法格式：</p><p>np.logspace(start, stop, num&#x3D;50, endpoint&#x3D;True, base&#x3D;10.0, dtype&#x3D;None)</p><p>其中 base 代表对数函数的底数，默认为 10。<br>start序列的起始值：base<strong>start。<br>stop序列的终止值：base</strong>stop。<br>num数值范围区间内样本数量，默认为 50。<br>endpoint默认为 True 包含终止值，反之不包含。<br>base对数函数的 log 底数，默认为10。<br>dtype可选参数，指定 ndarray 数组的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.logspace(1.0,2.0, num = 10)</span><br><span class="line">print (a)</span><br></pre></td></tr></table></figure><h4 id="Numpy索引和切片"><a href="#Numpy索引和切片" class="headerlink" title="Numpy索引和切片"></a>Numpy索引和切片</h4><p>在 NumPy 中，如果想要访问，或修改数组中的元素，您可以采用索引或切片的方式，比如使用从 0 开始的索引依次访问数组中的元素，这与 Python 的 list 列表是相同的。</p><p>NumPy 提供了多种类型的索引方式，常用方式有两种：基本切片与高级索引</p><p>基本切片</p><p>NumPy 内置函数 slice() 可以用来构造切片对象，该函数需要传递三个参数值分别是 start（起始索引）、stop（终止索引） 和 step（步长） ，通过它可以实现从原数组的上切割出一个新数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(5,100)</span><br><span class="line">#生成切片对象</span><br><span class="line">s = slice(2,9,3)#从索引2开始到索引9停止，间隔时间为2</span><br><span class="line">print(a[s])</span><br></pre></td></tr></table></figure><p>也可以通过冒号来分割切片参数，最终也能获得相同结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(10)</span><br><span class="line">b = a[2:9:2]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h4 id="NumPy高级索引"><a href="#NumPy高级索引" class="headerlink" title="NumPy高级索引"></a>NumPy高级索引</h4><p>在 NumPy 中还可以使用高级索引方式，比如整数数组索引、布尔索引以及花式索引</p><h5 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h5><p>整数数组索引，它可以选择数组中的任意一个元素，比如，选择第几行第几列的某个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#创建二维数组</span><br><span class="line">x = np.array([[1,  2],  [3,  4],  [5,  6]])</span><br><span class="line">#[0,1,2]代表行索引;[0,1,0]代表列索引</span><br><span class="line">y = x[[0,1,2],[0,1,0]] </span><br><span class="line">print (y)</span><br></pre></td></tr></table></figure><p>对上述示例做简单分析：将行、列索引组合会得到 (0,0)、(1,1) 和 (2,0)<br>它们分别对应着输出结果在原数组中的索引位置</p><p>下面再看一组示例：获取了 4*3 数组中的四个角上元素，它们对应的行索引是 [0,0] 和 [3,3]，列索引是 [0,2] 和 [0,2]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">b = np.array([[ 0, 1, 2],</span><br><span class="line">              [ 3, 4, 5],</span><br><span class="line">              [ 6, 7, 8],</span><br><span class="line">              [ 9,10,11]])</span><br><span class="line">r = np.array([[0,0],[3,3]])</span><br><span class="line">c = np.array([[0,2],[0,2]])</span><br><span class="line">#获取四个角的元素</span><br><span class="line">c = b[r,c]</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>也可以将切片所使用的:或省略号…与整数数组索引结合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">d = np.array([[ 0,  1,  2],</span><br><span class="line">              [ 3,  4,  5],</span><br><span class="line">              [ 6,  7,  8],</span><br><span class="line">              [ 9, 10, 11]])</span><br><span class="line">#对行列分别进行切片</span><br><span class="line">e = d[1:4,1:3]</span><br><span class="line">print(e)</span><br><span class="line">#行使用基础索引，对列使用高级索引</span><br><span class="line">f = d[1:4,[1,2]]</span><br><span class="line">#显示切片后结果</span><br><span class="line">print (f)</span><br><span class="line">#对行使用省略号</span><br><span class="line">h=d[...,1:]</span><br><span class="line">print(h)</span><br></pre></td></tr></table></figure><h5 id="布尔数组索引"><a href="#布尔数组索引" class="headerlink" title="布尔数组索引"></a>布尔数组索引</h5><p>当输出的结果需要经过布尔运算（如比较运算）时，此时会使用到另一种高级索引方式，即布尔数组索引。</p><p>下面示例返回数组中大于 6 的的所有元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#返回所有大于6的数字组成的数组</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.array([[ 0,  1,  2],[ 3,  4,  5],[ 6,  7,  8],[ 9, 10, 11]])</span><br><span class="line">print (x[x &gt; 6])</span><br></pre></td></tr></table></figure><p>我们可以使用补码运算符来去除 NaN（即非数字元素）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([np.nan, 1,2,np.nan,3,4,5])</span><br><span class="line">print(a[~np.isnan(a))</span><br></pre></td></tr></table></figure><p>下面示例，删除数组中整数元素，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([1, 2+6j, 5, 3.5+5j])</span><br><span class="line">print( a[np.iscomplex(a)])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy（一）</title>
      <link href="/post/921b352e.html"/>
      <url>/post/921b352e.html</url>
      
        <content type="html"><![CDATA[<h4 id="NumPy-ndarray对象"><a href="#NumPy-ndarray对象" class="headerlink" title="NumPy ndarray对象"></a>NumPy ndarray对象</h4><p>创建ndarray对象</p><p>通过 NumPy 的内置函数 array() 可以创建 ndarray 对象，其语法格式如下</p><p>numpy.array(object, dtype &#x3D; None, copy &#x3D; True, order &#x3D; None,ndmin &#x3D; 0)</p><p>object表示一个数组序列。<br>dtype可选参数，通过它可以更改数组的数据类型。<br>copy可选参数，表示数组能否被复制，默认是 True。<br>order以哪种内存布局创建数组，有 3 个可选值，分别是 C(行序列)&#x2F;F(列序列)&#x2F;A(默认)。<br>ndim用于指定数组的维度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">a=numpy.array([1,2,3])#使用列表构建一维数组</span><br><span class="line">print(a)</span><br><span class="line">print(type(a))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b=numpy.array([[1,2,3],[4,5,6]]) #创建多维数组</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>如果要改变数组元素的数据类型，可以使用通过设置 dtype，如下所示：c&#x3D;numpy.array([2,4,6,8],dtype&#x3D;”数据类型名称”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=numpy.array([2,4,6,8],dtype=&quot;complex&quot;)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h5 id="ndim查看数组维数"><a href="#ndim查看数组维数" class="headerlink" title="ndim查看数组维数"></a>ndim查看数组维数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">arr = np.array([[1, 2, 3, 4], [4, 5, 6, 7], [9, 10, 11, 23]]) </span><br><span class="line">print(arr.ndim) </span><br></pre></td></tr></table></figure><p>也可以使用 ndim 参数创建不同维度的数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#输出一个二维数组</span><br><span class="line">import numpy as np</span><br><span class="line">a = np.array([1, 2, 3,4,5], ndim = 2)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="reshape数组变维"><a href="#reshape数组变维" class="headerlink" title="reshape数组变维"></a>reshape数组变维</h5><p>数组的形状指的是多维数组的行数和列数。Numpy 模块提供 reshape() 函数可以改变多维数组行数和列数，从而达到数组变维的目的。因此数组变维即对数组形状的重塑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">e = np.array([[1,2],[3,4],[5,6]]) </span><br><span class="line">print(&quot;原数组&quot;,e) </span><br><span class="line">e=e.reshape(2,3) </span><br><span class="line">print(&quot;新数组&quot;,e)  </span><br></pre></td></tr></table></figure><h4 id="NumPy数据类型"><a href="#NumPy数据类型" class="headerlink" title="NumPy数据类型"></a>NumPy数据类型</h4><img src="/post/921b352e/338.png" class title="This is an image"><p>数据类型对象<br>数据类型对象，主要用来描述数组元素的数据类型、大小以及字节顺序。</p><p>语法格式如下：<br>np.dtype(object)</p><p>创建一个 dtype 对象可以使用下列方法：a&#x3D; np.dtype(np.int64)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">a= np.dtype(np.int64) </span><br><span class="line">print(a)  </span><br></pre></td></tr></table></figure><p>数据类型标识码</p><img src="/post/921b352e/339.png" class title="This is an image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建数据类型score</span><br><span class="line">import numpy as np</span><br><span class="line">dt = np.dtype([(&#x27;score&#x27;,&#x27;i1&#x27;)])</span><br><span class="line">print(dt) </span><br></pre></td></tr></table></figure><p>定义结构化数据</p><p>通常情况下，结构化数据使用字段的形式来描述某个对象的特征。以下示例描述一位老师的姓名、年龄、工资的特征，该结构化数据其包含以下字段：str 字段：nameint 字段：agefloat 字段：salary</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">teacher = np.dtype([(&#x27;name&#x27;,&#x27;S20&#x27;), (&#x27;age&#x27;, &#x27;i1&#x27;), (&#x27;salary&#x27;, &#x27;f4&#x27;)])</span><br><span class="line">#输出结构化数据teacher</span><br><span class="line">print(teacher)</span><br><span class="line">#将其应用于ndarray对象</span><br><span class="line">b = np.array([(&#x27;ycs&#x27;, 32, 6357.50),(&#x27;jxe&#x27;, 28, 6856.80)], dtype = teacher) </span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h4 id="NumPy数组属性"><a href="#NumPy数组属性" class="headerlink" title="NumPy数组属性"></a>NumPy数组属性</h4><h5 id="ndarray-shape"><a href="#ndarray-shape" class="headerlink" title="ndarray.shape"></a>ndarray.shape</h5><p>shape 属性的返回值一个由数组维度构成的元组，比如 2 行 3 列的二维数组可以表示为(2,3)，该属性可以用来调整数组维度的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[2,4,6],[3,5,7]])</span><br><span class="line">print(a.shape)</span><br></pre></td></tr></table></figure><p>通过 shape 属性修改数组的形状大小： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">a.shape = (3,2)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="ndarray-reshape"><a href="#ndarray-reshape" class="headerlink" title="ndarray.reshape()"></a>ndarray.reshape()</h5><p>NumPy 还提供了一个调整数组形状的 reshape() 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.array([[1,2,3],[4,5,6]])</span><br><span class="line">b = a.reshape(3,2)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h5 id="ndarray-ndim"><a href="#ndarray-ndim" class="headerlink" title="ndarray.ndim"></a>ndarray.ndim</h5><p>该属性返回的是数组的维数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">#随机生成一个一维数组</span><br><span class="line">c = np.arange(24)</span><br><span class="line">print(c)</span><br><span class="line">print(c.ndim)</span><br><span class="line">#对数组进行变维操作</span><br><span class="line">e = c.reshape(2,4,3)</span><br><span class="line">print(e) </span><br><span class="line">print(e.ndim)</span><br></pre></td></tr></table></figure><h5 id="ndarray-itemsize"><a href="#ndarray-itemsize" class="headerlink" title="ndarray.itemsize"></a>ndarray.itemsize</h5><p>返回数组中每个元素的大小（以字节为单位)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#数据类型为int8，代表1字节</span><br><span class="line">import numpy as np</span><br><span class="line">x = np.array([1,2,3,4,5], dtype = np.int8)</span><br><span class="line">print (x.itemsize)</span><br></pre></td></tr></table></figure><h5 id="ndarray-flags"><a href="#ndarray-flags" class="headerlink" title="ndarray.flags"></a>ndarray.flags</h5><p>返回 ndarray 数组的内存信息，比如 ndarray 数组的存储方式，以及是否是其他数组的副本等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.array([1,2,3,4,5])</span><br><span class="line">print (x.flags)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析三剑客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/post/7f1ae6d2.html"/>
      <url>/post/7f1ae6d2.html</url>
      
        <content type="html"><![CDATA[<h4 id="Java编程规范（命名规则）"><a href="#Java编程规范（命名规则）" class="headerlink" title="Java编程规范（命名规则）"></a>Java编程规范（命名规则）</h4><p>命名规则包括以下几点</p><p>包 的名称由一个小写字母序列组成。</p><p>类 的名称由大写字母开头，其他字母都由小写的单词组成。</p><p>类的实例 的名称由一个小写字母开头，后面的单词由大写字母开头。</p><p>常量 的名称都大写，并且指出完整含义。</p><p>参数的 名称无其他具体规定。数组的命名使用“类型[] 数组名”的形式。</p><p>另外，编码格式规定如下。</p><p>程序最开始编写导入包和类语句，即 import 语句。import 语句可以有多行，编写完 import 语句后空一行。</p><p>定义 public 类，顶格书写。类的主体左括号“{”不换行书写，右括号“}”顶格书写。</p><p>定义 public 类中的变量，缩进书写。</p><p>定义方法用缩进书写，方法的左括号“{”不换行书写，右括号“}”和方法首行第一个字符对齐。方法体要再次缩进书写，最后一个变量定义和第一个方法定义之间、方法和方法之间最好空一行。</p><p>提示：在单一的语句后有“;”，在一对括号“{}“之外无“;”。</p><p>方法调用名和紧跟在其后的左括号“(”无空格，该左括号和其后的标识符之间无空格。</p><p>多个参数之间的逗号和前一个参数紧靠，与后一个参数空一格。</p><h4 id="Java标识符和关键字"><a href="#Java标识符和关键字" class="headerlink" title="Java标识符和关键字"></a>Java标识符和关键字</h4><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>Java 中标识符是为方法、变量或其他用户定义项所定义的名称。标识符可以有一个或多个字符。</p><p>标识符的构成规则如下：</p><p>标识符由数字（0<del>9）和字母（A</del>Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。</p><p>标识符的<strong>第一个</strong>符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。</p><p>另外，Java 区分大小写</p><p>提示：标识符命名时，切记不能以数字开头，也不能使用任何 Java 关键字作为标识符，而且不能赋予标识符任何标准的方法名。</p><p>标识符分为两类，分别为关键字和用户自定义标识符。</p><p>关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。</p><p>提示：标识符可以包含关键字，但不能与关键字重名。</p><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>关键字（或者保留字）是对编译器有特殊意义的固定单词，不能在程序中做其他目的使用。关键字具有专门的意义和用途，和自定义的标识符不同，不能当作一般的标识符来使用</p><h4 id="Java注释：单行、多行和文档注释"><a href="#Java注释：单行、多行和文档注释" class="headerlink" title="Java注释：单行、多行和文档注释"></a>Java注释：单行、多行和文档注释</h4><p>单行注释</p><p>以双斜杠“&#x2F;&#x2F;”标识，只能注释一行内容</p><p>多行注释</p><p>包含在“&#x2F;<em>”和“</em>&#x2F;”之间，能注释很多行的内容。</p><p>注意：多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。</p><p>文档注释</p><p>文档注释以&#x2F;*<em>开头，并以</em>&#x2F;结束，可以通过 Javadoc 生成 API 帮助文档，Java 帮助文档主要用来说明类、成员变量和方法的功能。</p><p>包含在“&#x2F;*<em>”和“</em>&#x2F;”之间，也能注释多行内容，一般用在类、方法和变量上面，用来描述其作用。注释后，鼠标放在类和变量上面会自动显示出我们注释的内容</p><p>文档注释只放在类、接口、成员变量、方法之前，因为 Javadoc 只处理这些地方的文档注释，而忽略其它地方的文档注释。</p><p>API 帮助文档相当于产品说明书，而说明书只需要介绍那些供用户使用的部分，所以 Javadoc 默认只提取 public、protected 修饰的部分。如果要提取 private 修饰的部分，需要使用 -private。</p><p>Javadoc标签</p><p>avadoc 工具可以识别文档注释中的一些特殊标签，这些标签一般以@开头，后跟一个指定的名字，有的也以{@开头，以}结束。</p><p>Javadoc 可以识别的标签如下表所示：</p><img src="/post/7f1ae6d2/365.png" class title="This is an image"><p>对两种标签格式的说明：</p><p>@tag 格式的标签（不被{ }包围的标签）为块标签，只能在主要描述（类注释中对该类的详细说明为主要描述）后面的标签部分（如果块标签放在主要描述的前面，则生成 API 帮助文档时会检测不到主要描述）。<br>{@tag} 格式的标签（由{ }包围的标签）为内联标签，可以放在主要描述中的任何位置或块标签的注释中。</p><p>Javadoc 标签注意事项：</p><p>Javadoc 标签必须从一行的开头开始，否则将被视为普通文本。</p><p>一般具有相同名称的标签放在一起。</p><p>Javadoc 标签区分大小写，代码中对于大小写错误的标签不会发生编译错误，但是在生成 API 帮助文档时会检测不到该注释内容。</p><p>Javadoc命令</p><p>Javadoc 用法格式如下：javadoc [options] [packagenames] [sourcefiles]</p><p>options 表示 Javadoc 命令的选项；<br>packagenames 表示包名；<br>sourcefiles 表示源文件名。</p><p>在 cmd（命令提示符）中输入javadoc -help就可以看到 Javadoc 的用法和选项（前提是安装配置了JDK），下面列举 Javadoc 命令的常用选项：</p><p>下面列举 Javadoc 命令的常用选项：</p><p>-public仅显示 public 类和成员</p><p>-protected显示 protected&#x2F;public 类和成员（默认值）</p><p>-package显示 package&#x2F;protected&#x2F;public 类和成员</p><p>-private显示所有类和成员</p><p>-d <directory>输出文件的目标目录</directory></p><p>-version包含 @version 段</p><p>-author包含 @author 段</p><p>-splitindex将索引分为每个字母对应一个文件</p><p>-windowtitle <text>文档的浏览器窗口标题</text></p><p>文档注释的格式</p><p>在编写文档注释的过程中，有时需要添加 HTML 标签，比如：需要换行时，应该使用<br>，而不是一个回车符；需要分段时，应该使用</p><p>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author 42&lt;br&gt;</span><br><span class="line">*         1232</span><br><span class="line">* @version 14.28.0&lt;br&gt;</span><br><span class="line">*          1.92.04</span><br><span class="line">*/</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;123123123&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javadoc 并不是将代码中的文档注释直接复制到帮助文档的 HTML 文件中，而是读取每一行后，删除前面的<em>号及</em>以前的空格再输入到 HTML 文档。</p><p>注释前面的<em>号允许连续使用多个，其效果和使用一个</em>号一样，但多个<em>前不能有其他字符分隔，否则分隔符及后面的</em>号都将作为文档的内容。</p><h4 id="Java常量：Java常量的定义和分类"><a href="#Java常量：Java常量的定义和分类" class="headerlink" title="Java常量：Java常量的定义和分类"></a>Java常量：Java常量的定义和分类</h4><p>在这里要注意常量和常量值是不同的概念，常量值是常量的具体和直观的表现形式，常量是形式化的表现。</p><h5 id="整型常量值"><a href="#整型常量值" class="headerlink" title="整型常量值"></a>整型常量值</h5><p>Java 的整型常量值主要有如下 3 种形式。</p><p>十进制数形式：如 54、-67、0。</p><p>八进制数形式：Java 中的八进制常数的表示以 0 开头，如 0125 表示十进制数 85，-013 表示十进制数 -11。</p><p>十六进制数形式：Java 中的十六进制常数的表示以 0x 或 0X 开头，如 0x100 表示十进制数 256，-0x16 表示十进制数 -22。</p><p>整型（int）常量默认在内存中占 32 位，是具有整数类型的值，当运算过程中所需值超过 32 位长度时，可以把它表示为长整型（long）数值。长整型类型则要在数字后面加 L 或 1， 如 697L，表示一个长整型数，它在内存中占 64 位。</p><h5 id="实型常量值"><a href="#实型常量值" class="headerlink" title="实型常量值"></a>实型常量值</h5><p>Java 的实型常量值主要有如下两种形式。</p><p>十进制数形式：由数字和小数点组成，且必须有小数点，如 12.34、-98.0。科学记数法形式：如 1.75e5 或 32&amp;E3，其中 e 或 E 之前必须有数字，且 e 或 E 之后的数字必须为整数。</p><p>Java 实型常量默认在内存中占 64 位，是具有双精度型（double）的值。如果考虑到需要节省运行时的系统资源，而运算时的数据值取值范围并不大且运算精度要求不太高的情况，可以把它表示为单精度型（float）的数值。</p><p>单精度型数值一般要在该常数后面加 F 或 f，如 69.7f，表示一个 float 型实数，它在内存中占 32 位（取决于系统的版本高低）。</p><h5 id="布尔型常量值"><a href="#布尔型常量值" class="headerlink" title="布尔型常量值"></a>布尔型常量值</h5><p>Java 的布尔型常量只有两个值，即 false（假）和 true（真）。</p><h5 id="字符型和字符串常量值"><a href="#字符型和字符串常量值" class="headerlink" title="字符型和字符串常量值"></a>字符型和字符串常量值</h5><p>Java 的字符型常量值是用单引号引起来的一个字符，如 ‘e’、E’。需要注意的是，<strong>Java 字符串常量值中的单引号和双引号不可混用</strong>。双引号用来表示字符串，像 “11”、”d” 等都是表示单个字符的字符串。</p><p>除了以上所述形式的字符常量值之外，Java 还允许使用一种特殊形式的字符常量值来表示一些难以用一般字符表示的字符，这种特殊形式的字符是以开头的字符序列，称为转义字符。</p><p>Java 中常用的转义字符及其表示的意义</p><p>\ddd<br>1~3 位八进制数所表示的字符</p><p>\uxxxx<br>1~4 位十六进制数所表示的字符</p><p>&#39;<br>单引号字符</p><p>&quot;<br>双引号字符</p><p>\<br>双斜杠字符</p><p>\r<br>回车</p><p>\n<br>换行</p><p>\b<br>退格</p><p>\t<br>横向跳格</p><h5 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h5><p>常量不同于常量值，它可以在程序中用符号来代替常量值使用，因此在使用前必须先定义。</p><p><strong>即在声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。</strong></p><p>它的声明格式为：Java 语言使用 final 关键字来定义一个常量</p><p>语法如下所示：final dataType variableName &#x3D; value</p><p>其中，final 是定义常量的关键字，dataType 指明常量的数据类型，variableName 是变量的名称，value 是初始值。</p><p>final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    // 静态常量</span><br><span class="line">    public static final double PI = 3.14;</span><br><span class="line">    // 声明成员常量</span><br><span class="line">    final int y = 10;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 声明局部常量</span><br><span class="line">        final double x = 3.3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量有三种类型：静态常量、成员常量和局部常量。</p><p>代码第 3 行的是声明静态常量，使用在 final 之前 public static 修饰。</p><p>public static 修饰的常量作用域是全局的，不需要创建对象就可以访问它，在类外部访问形式为 HelloWorld. PI。这种常量在编程中使用很多。</p><p>代码第 5 行声明成员常量，作用域类似于成员变量，但不能修改。代码第 9 行声明局部常量，作用域类似于局部变量，但不能修改。</p><p>在定义常量时，需要注意如下内容：</p><p>在定义常量时就需要对该常量进行初始化。final 关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。为了与变量区别，常量取名一般都用大写字符。</p><p>当常量被设定后，一般情况下不允许再进行更改，如果更改其值将提示错误</p><h4 id="Java变量的声明和初始化"><a href="#Java变量的声明和初始化" class="headerlink" title="Java变量的声明和初始化"></a>Java变量的声明和初始化</h4><p>Java 语言是强类型（Strongly Typed）语言，强类型包含以下两方面的含义：</p><p>所有的变量必须先声明、后使用。</p><p>指定类型的变量只能接受类型与之匹配的值。</p><p>这意味着每个变量和每个表达式都有一个在编译时就确定的类型。类型限制了一个变量能被赋的值，限制了一个表达式可以产生的值，限制了在这些值上可以进行的操作，并确定了这些操作的含义。</p><h5 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h5><p>在 java 中用户可以通过指定数据类型和标识符来声明变量，其基本语法如下所示：</p><p>DataType identifier;<br>或者DataType identifier&#x3D;value;</p><p>DataType、 identifier 和 value，其具体说明如下：</p><p>DataType：变量类型，如 int、string、 char 和 double 等。<br>identifier：标识符，也叫变量名称。<br>value：声明变量时的值。</p><p>变量标识符的命名规范如下：</p><p>首字符必须是字母、下划线（―）、美元符号（$）或者人民币符号（¥）。标识符由数字（0<del>9）、大写字母（A</del>Z）、小写字母（a~z）、下划线（―）、美元符号（$）、人民币符号（¥）以及所有在十六进制 0xc0 前的 ASCII 码组成。不能把关键字、保留字作为标识符。标识符的长度没有限制。标识符区分大小写。</p><p>如下代码分别声明了 String、boolean 和 int 类型的变量。</p><p>String employee;    &#x2F;&#x2F; String 类型的变量<br>boolean isSave;    &#x2F;&#x2F; boolean 类型的变量<br>int create_at;    &#x2F;&#x2F; int 类型的变量</p><h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p>初始化变量是指为变量指定一个明确的初始值。初始化变量有两种方式：一种是声明时直接赋值，一种是先声明、后赋值。</p><p>如下代码分别使用两种方式对变量进行了初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char usersex=&#x27;女&#x27;;    // 直接赋值</span><br><span class="line"></span><br><span class="line">String username;    // 先声明</span><br><span class="line">username =&quot;琪琪&quot;;    // 后赋值</span><br></pre></td></tr></table></figure><p>另外，多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String username,address,phone,tel; // 声明多个变量</span><br><span class="line">int num1=12,num2=23,result=35; // 声明并初始化多个变量</span><br></pre></td></tr></table></figure><p>Java 中初始化变量时需要注意以下事项：</p><p>变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。方法中的变量必须显式地初始化，否则在使用该变量时就会出错。</p><h4 id="Java变量的作用域：静态变量、全局变量和局部变量"><a href="#Java变量的作用域：静态变量、全局变量和局部变量" class="headerlink" title="Java变量的作用域：静态变量、全局变量和局部变量"></a>Java变量的作用域：静态变量、全局变量和局部变量</h4><p>根据作用域的不同，一般将变量分为不同的类型：成员变量和局部变量</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>Java 的成员变量有两种，分别是全局变量和静态变量（类变量）。定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类。</p><img src="/post/7f1ae6d2/366.png" class title="This is an image"><p>假设在一个类中声明了 4 个变量，下面编写一个测试类输出引起变量的值改变的示例代码。</p><p>变量声明代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class DataClass &#123;</span><br><span class="line">    String name; // 成员变量、实例变量</span><br><span class="line">    int age; // 成员变量、实例变量</span><br><span class="line"></span><br><span class="line">    static final String website = &quot;C345&quot;; // 成员变量、静态变量(类变量)</span><br><span class="line">    static String URL = &quot;123456789&quot;; // 成员变量、静态变量(类变量)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建类的对象</span><br><span class="line">        DataClass dc = new DataClass();</span><br><span class="line">        // 对象名.变量名调用实例变量（全局变量）</span><br><span class="line">        System.out.println(dc.name);</span><br><span class="line">        System.out.println(dc.age);</span><br><span class="line"></span><br><span class="line">        // 对象名.变量名调用静态变量（类变量）</span><br><span class="line">        System.out.println(dc.website);</span><br><span class="line">        System.out.println(dc.URL);</span><br><span class="line"></span><br><span class="line">        // 类名.变量名调用静态变量（类变量）</span><br><span class="line">        System.out.println(DataClass.website);</span><br><span class="line">        System.out.println(DataClass.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例的第一段代码中定义了 4 个成员变量，由输出结果可以看出，name 和 age 显示系统默认初始化的值，website 和 URL 显示初始化的值。<strong>且用 static final 修饰的变量必须赋予初始值。</strong></p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：<br>方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。</p><p>局部变量在使用前必须被程序员主动初始化值。</p><p>1）方法局部变量</p><p>声明两个局部变量并输出其值，其实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 7;</span><br><span class="line">        if (5 &gt; 3) &#123;</span><br><span class="line">            int s = 3; // 声明一个 int 类型的局部变量</span><br><span class="line">            System.out.println(&quot;s=&quot; + s);</span><br><span class="line">            System.out.println(&quot;a=&quot; + a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;a=&quot; + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实例中定义了 a 和 s 两个局部变星，其中 int 类型的 a 的作用域是整个 main() 方法，而 int 类型的变量 s 的作用域是 if 语句的代码块内</p><p>如果在 if 方法外调用变量 s，则会报无法解析该变量的错误。</p><p>2）方法参数变量</p><p>作为方法参数声明的变量的作用域是整个方法。</p><p>声明一个方法参数变量，实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public static void testFun(int n) &#123;</span><br><span class="line">        System.out.println(&quot;n=&quot; + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testFun(3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实例中定义了一个 testFun() 方法，该方法中包含一个 int 类型的参数变量 n，其作用域是 testFun() 方法体内。当调用方法时传递进了一个参数 3，因此其输出控制台的 n 值是 3。</p><p>3）代码块局部变量</p><p>代码块局部变量常用于 try catch 代码块中，成为异常处理参数变量。</p><p>异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。</p><p>声明一个异常处理语句，实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test4 &#123;</span><br><span class="line">    public static void test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;Hello!Exception!&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123; // 异常处理块，参数为 Exception 类型</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实例中定义了异常处理语句，异常处理块 catch 的参数为 Exception 类型的变量 e，作用域是整个 catch 块。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>帅到没朋友---团队程序设计天梯赛</title>
      <link href="/post/6690b918.html"/>
      <url>/post/6690b918.html</url>
      
        <content type="html"><![CDATA[<p><strong>输入格式：</strong></p><p>输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。</p><p><strong>注意</strong>：<br>    没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。</p><p><strong>输出格式：</strong><br>按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。</p><p><strong>注意</strong>：同一个人可以被查询多次，但只输出一次。</p><p><strong>输入样例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 11111 22222 55555</span><br><span class="line">2 33333 44444</span><br><span class="line">4 55555 66666 99999 77777</span><br><span class="line">8</span><br><span class="line">55555 44444 10000 88888 22222 11111 23333 88888</span><br></pre></td></tr></table></figure><p><strong>输出样例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000 88888 23333</span><br></pre></td></tr></table></figure><p><strong>输入样例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 11111 22222 55555</span><br><span class="line">2 33333 44444</span><br><span class="line">4 55555 66666 99999 77777</span><br><span class="line">4</span><br><span class="line">55555 44444 22222 11111</span><br></pre></td></tr></table></figure><p><strong>输出样例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No one is handsome</span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[100000] = &#123;0&#125;; // 因为题给的id是五位数，所以博主这里定义一个10万的数组</span><br><span class="line">    int b[100000] = &#123;0&#125;; // 为了纪录待查找的id出现的次数</span><br><span class="line">    int n,m;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int count,id,sum = 0;</span><br><span class="line">    for(int i = 0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;count);</span><br><span class="line">        for(int j = 0;j&lt;count;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;id);</span><br><span class="line">            if(count&gt;1)//朋友圈中只有一个人的是没有朋友的</span><br><span class="line">                a[id] = 1; //如果有这个id对应位置的值给他改变成1</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;m); // 输入待查找的id个数</span><br><span class="line">    // 判断待查找的id是否在出现过在给出的id中</span><br><span class="line">for(int i = 0; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;id);</span><br><span class="line">if(a[id] == 0)//该id在之前没有进行过输入或他的朋友圈内只有他一人</span><br><span class="line">&#123;</span><br><span class="line">if(b[id]==0&amp;&amp;sum==0)//待查询的id从未被查询过且是第一个准备输出的id</span><br><span class="line">printf(&quot;%05d&quot;,id); // 这里有一个格式输出问题，如果不写的话只能得15分</span><br><span class="line">else if(b[id]==0&amp;&amp;sum&gt;0)//待查询的id从未被查询过且不是第一个准备输出的id</span><br><span class="line">printf(&quot; %05d&quot;,id); // 这里主要是有个输出格式问题</span><br><span class="line">            b[id] = 1;//改变标志变量的值</span><br><span class="line">a[id] = 1;</span><br><span class="line">            sum++;//每有一个符合的，就+1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否没有人太帅</span><br><span class="line">if(sum==0)</span><br><span class="line">printf(&quot;No one is handsome\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有不明白的点可以私信博主</p>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A-B---团体程序设计天梯赛</title>
      <link href="/post/cf9951a9.html"/>
      <url>/post/cf9951a9.html</url>
      
        <content type="html"><![CDATA[<p><strong>题：</strong><br>本题要求你计算A−B。不过麻烦的是，A和B都是字符串 —— 即从字符串A中把字符串B所包含的字符全删掉，剩下的字符组成的就是字符串A−B。</p><p><strong>输入格式</strong>：</p><p>输入在2行中先后给出字符串A和B。两字符串的长度都不超过10的4次方，并且保证每个字符串都是由可见的ASCII码和空白字符组成，最后以换行符结束。</p><p><strong>输出格式</strong>：</p><p>在一行中打印出A−B的结果字符串。</p><p><strong>输入样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I love GPLT!  It&#x27;s a fun game!</span><br><span class="line">aeiou</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I lv GPLT!  It&#x27;s  fn gm!</span><br></pre></td></tr></table></figure><p>题解1是博主当时练习的时候写的，只得了15分，欢迎各位小伙伴指正哪里 有问题</p><p>题解2是老师说了一下strchr函数，博主改的，是满分<br><strong>题解1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char A[100000], B[100000];</span><br><span class="line">    int i = 0, j= 0,n; // n的主要作用就是在移动元素的时候记录一下下标</span><br><span class="line">    gets(A);</span><br><span class="line">    gets(B);</span><br><span class="line">    // 这里就是一种遍历的思路（俩个while的使用），当有俩个变量需要比较的时候</span><br><span class="line">    while(B[i] != &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        while(A[j] != &#x27;\0&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            if(A[j] == B[i])</span><br><span class="line">            &#123;</span><br><span class="line">                n = j;</span><br><span class="line">                while(A[n] != &#x27;\0&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    A[n] = A[n+1];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        j = 0;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题解2：</strong><br>这里介绍一下strchr函数</p><p>strchr 搜索字符串中字符</p><p>原　　型：char *strchr(const char *s, int c);</p><p>头 文 件：string.h</p><p>返 回 值：指向字符的指针，此字符是s所指向的字符串的前n个字符中第一个遇到的字符c。如果没有找到c，则返回空指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">char A[100000],B[100000];</span><br><span class="line">gets(A);</span><br><span class="line">gets(B);</span><br><span class="line">for(int i=0;i&lt;strlen(A);i++)</span><br><span class="line">&#123;</span><br><span class="line">if(strchr(B,A[i])) // 在B字符串中找是否有A[i]字符，如果有就执行continue语句没有就直接输出</span><br><span class="line">continue;</span><br><span class="line">else </span><br><span class="line">printf(&quot;%c&quot;,A[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N个数求和----团队程序设计天梯赛</title>
      <link href="/post/7f15dfd4.html"/>
      <url>/post/7f15dfd4.html</url>
      
        <content type="html"><![CDATA[<h4 id="L1-009-N个数求和"><a href="#L1-009-N个数求和" class="headerlink" title="L1-009 N个数求和"></a>L1-009 N个数求和</h4><p><strong>题：</strong><br>本题的要求很简单，就是求N个数字的和。麻烦的是，这些数字是以有理数分子&#x2F;分母的形式给出的，你输出的和也必须是有理数的形式。</p><p><strong>输入格式</strong>：<br>输入第一行给出一个正整数N（≤100）。随后一行按格式a1&#x2F;b1 a2&#x2F;b2 …给出N个有理数。题目保证所有分子和分母都在长整型范围内。另外，负数的符号一定出现在分子前面。</p><p><strong>输出格式</strong>：</p><p>输出上述数字和的最简形式 —— 即将结果写成整数部分 分数部分，其中分数部分写成分子&#x2F;分母，要求分子小于分母，且它们没有公因子。如果结果的整数部分为0，则只输出分数部分。</p><p><strong>这里的输出样例就是告诉我们，有三种输出情况，我们都要考虑进去</strong><br>输出样例1：有整数也有分数<br>输出样例2：只有整数<br>输出样例3：只有分数</p><p><strong>输入样例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2/5 4/15 1/30 -2/60 8/3</span><br></pre></td></tr></table></figure><p><strong>输出样例1</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 1/3</span><br></pre></td></tr></table></figure><p><strong>输入样例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4/3 2/3</span><br></pre></td></tr></table></figure><p><strong>输出样例2</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输入样例3</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1/3 -1/6 1/8</span><br></pre></td></tr></table></figure><p><strong>输出样例3</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7/24</span><br></pre></td></tr></table></figure><p>博主这里使用的是c语言写的，如果需要python解答的可以私信博主要<br><strong>题解：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int maxGongYue(long long x,long long y)</span><br><span class="line">&#123;</span><br><span class="line">int temp = (x%y == 0) ? y : maxGongYue(y, x % y); //这里使用三目运算符传出最大公约数</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long a = 0, b = 0,fenzi=0,fenmu=1,maxgy=0;</span><br><span class="line">int n = 0,i=0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">//进行通分化简运算</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%lld/%lld&quot;, &amp;a, &amp;b);</span><br><span class="line">// 这下面三行代码其实就是给俩个分式通分用的</span><br><span class="line">fenzi =fenzi*b;</span><br><span class="line">fenzi = fenzi + a * fenmu;</span><br><span class="line">fenmu =fenmu *b;</span><br><span class="line">maxgy = maxGongYue(fenzi, fenmu);//每一次运算后都进行一次化简，便与运算，控制数据的范围，防止超出数据类型范围</span><br><span class="line">fenzi /= maxgy;</span><br><span class="line">fenmu /= maxgy;</span><br><span class="line">i++;</span><br><span class="line">&#125; while (i &lt; n);</span><br><span class="line">//输出样例2的那种情况</span><br><span class="line">if (fenzi % fenmu == 0)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%lld&quot;, fenzi / fenmu);</span><br><span class="line">&#125;</span><br><span class="line">//输出样例3的那种情况</span><br><span class="line">else if (fenzi &amp;&amp; (fenzi / fenmu == 0))</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%lld/%lld&quot;, fenzi, fenmu);</span><br><span class="line">&#125;</span><br><span class="line">//输出样例1；</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%lld %lld/%lld&quot;, fenzi / fenmu, fenzi%fenmu, fenmu);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎小伙伴们提供更简单的解题方法</p>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求整数段和---团体程序设计天梯赛（超详细）</title>
      <link href="/post/973ad644.html"/>
      <url>/post/973ad644.html</url>
      
        <content type="html"><![CDATA[<h4 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h4><p>给定两个整数A和B，输出从A到B的所有整数以及这些数的和。</p><p><strong>输入格式：</strong><br>输入在一行中给出2个整数A和B，其中−100≤A≤B≤100，其间以空格分隔。</p><p><strong>输出格式：</strong><br>首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum &#x3D; X的格式输出全部数字的和X。</p><p><strong>输入样例：</strong></p><blockquote><p>-3 8</p></blockquote><p><strong>输出样例：</strong></p><blockquote><p>-3   -2   -1    0    1<br>2    3    4    5    6<br>7    8<br>Sum &#x3D; 30</p></blockquote><h4 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h4><p><em><strong>关键步骤在代码中有注释</strong></em></p><ol><li>解决输出每个数字占5个字符宽度，向右对齐</li><li>5个数字占一行的，换行操作</li><li><strong>易被疏漏的一点</strong> 判断输出完A~~B之间的所有数后是否还要换行</li></ol><h4 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int A, B;</span><br><span class="line">    int i, sum =0, num =0;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;A, &amp;B);</span><br><span class="line">    // 按顺序 输出A~~B之间的所有数</span><br><span class="line">    for (i = A; i &lt;= B; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%5d&quot;, i); //每5个数字占一行，每个数字占5个字符宽度，向右对齐， 默认是向右对齐的，如果想要向左对齐就在5d前面加一个负号；</span><br><span class="line">        sum = sum+i;</span><br><span class="line">        num++;</span><br><span class="line">        // 进行换行操作</span><br><span class="line">        if(num % 5 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">            num =0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断输出完A~~B之间的所有数后是否还要换行，再输出sum。</span><br><span class="line">    if(num != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\nSum = %d\n&quot;,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;Sum = %d\n&quot;,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续因子----团体程序设计天梯赛</title>
      <link href="/post/b69b66fd.html"/>
      <url>/post/b69b66fd.html</url>
      
        <content type="html"><![CDATA[<h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><p> 一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p><h5 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h5><p>输入在一行中给出一个正整数 N（1&lt;N&lt;231）。</p><h5 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h5><p>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1<em>因子2</em>……*因子k 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><blockquote><p>630</p></blockquote><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h5><blockquote><p>3<br>5*6*7</p></blockquote><h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><h6 id="代码当中有注释较详细的解析"><a href="#代码当中有注释较详细的解析" class="headerlink" title="代码当中有注释较详细的解析"></a>代码当中有注释较详细的解析</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">int i = 0,j=0, a = 0, sum=0,num = 0,temp=0,qidian1=0,qidian2=0;</span><br><span class="line">int x = sqrt(n);// 连续因子当中最大的那一个 一定会小于这个正整数的平方根</span><br><span class="line">//找连续因子</span><br><span class="line">for (i = 2;i &lt;= x;i++)</span><br><span class="line">&#123;</span><br><span class="line">num = 0;// num 是使用来记录 满足条件的连续数的个数 ，每次使用完后要初始化为0 ，</span><br><span class="line">sum = n;</span><br><span class="line">qidian1 = i; //记录最开始连续的是哪一个数</span><br><span class="line">//判断 i 是否满足是连续的</span><br><span class="line">for (j = i;sum%j==0&amp;&amp;sum!=0;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum /= j;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">//筛选最长因子个数</span><br><span class="line">if (num &gt; temp)</span><br><span class="line">&#123;</span><br><span class="line">temp = num;</span><br><span class="line">qidian2 = qidian1; // 记录最长连续因子的 起点</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否有连续因子</span><br><span class="line">if (temp == 0)</span><br><span class="line">printf(&quot;1\n%d&quot;, n);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, temp);</span><br><span class="line">i = qidian2;</span><br><span class="line">while (i &lt; qidian2 + temp)</span><br><span class="line">&#123;</span><br><span class="line">if (i != qidian2)</span><br><span class="line">printf(&quot;*&quot;);</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>l1-002打印沙漏------团体程序设计天梯赛</title>
      <link href="/post/c8f1bb7.html"/>
      <url>/post/c8f1bb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="L1-002-打印沙漏"><a href="#L1-002-打印沙漏" class="headerlink" title="L1-002 打印沙漏"></a>L1-002 打印沙漏</h1><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印.<br><code>*****</code><br><code> ***</code><br> <code> *</code><br><code>***</code><br><code> *****</code><br>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><pre><code>19 *</code></pre><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><p><code>*****</code><br><code> ***</code><br> <code> *</code><br><code>***</code><br><code> *****</code><br><code>2</code></p><p><em><strong>基本原理 都在代码注释里面可以体现</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> s;</span><br><span class="line">    <span class="type">int</span> left; <span class="comment">//剩下的符号个数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//每一行要打印符号的个数</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;<span class="comment">//总共能打印的符号个数</span></span><br><span class="line">    <span class="type">int</span> j, k;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>, &amp;num, &amp;s);</span><br><span class="line">    <span class="keyword">while</span> (n &lt;= num &amp;&amp; i &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i+<span class="number">2</span>;</span><br><span class="line">        n = n + <span class="number">2</span> * i; </span><br><span class="line">    &#125;</span><br><span class="line">    n = n - <span class="number">2</span> * i;</span><br><span class="line">    i = i - <span class="number">2</span>;</span><br><span class="line">    left = num - n;</span><br><span class="line">    <span class="comment">// 上半部分符号打印，包括1个的哪一行</span></span><br><span class="line">    <span class="keyword">for</span> (j = i; j &gt;= <span class="number">1</span>; j = j - <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 判断是否要输出空格，以及输出空格的个数</span></span><br><span class="line">        total = (i - j) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (total) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (total)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                total--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出对应行要打印的符号</span></span><br><span class="line">        <span class="keyword">for</span> (count = j; count &gt;= <span class="number">1</span>; count--)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下半部分符号的打印，从3开始</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">3</span>; k &lt;= i; k = k+<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// 判断是否要输出空格，以及输出空格的个数</span></span><br><span class="line">        total = (i - k) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (total)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                total--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (count = k; count &gt;=<span class="number">1</span>; count--)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, left);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c/c++刷题记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c/c++重要基础知识点</title>
      <link href="/post/7ac5b90a.html"/>
      <url>/post/7ac5b90a.html</url>
      
        <content type="html"><![CDATA[<h4 id="C-命名空间（名字空间）详解"><a href="#C-命名空间（名字空间）详解" class="headerlink" title="C++命名空间（名字空间）详解"></a>C++命名空间（名字空间）详解</h4><p>命名冲突问题，C++ 引入了命名空间（Namespace）的概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace Li&#123; </span><br><span class="line">    FILE* fp = NULL;</span><br><span class="line">&#125;</span><br><span class="line">namespace Han&#123;  </span><br><span class="line">    FILE* fp = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>namespace 是C++中的关键字，用来定义一个命名空间<br>语法格式为：<br>namespace name{    &#x2F;&#x2F;variables, functions, classes}</p><p>name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。</p><p>使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Li::fp = fopen(&quot;one.txt&quot;, &quot;r&quot;); </span><br><span class="line">Han::fp = fopen(&quot;two.txt&quot;, &quot;rb+&quot;); </span><br></pre></td></tr></table></figure><p>:: 是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。</p><p>除了直接使用域解析操作符，还可以采用 using 关键字声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using Li::fp;</span><br><span class="line">fp = fopen(&quot;one.txt&quot;, &quot;r&quot;);  </span><br><span class="line">Han :: fp = fopen(&quot;two.txt&quot;, &quot;rb+&quot;); </span><br></pre></td></tr></table></figure><p>在代码的开头用using声明了 Li::fp，它的意思是，using 声明以后的程序中如果出现了未指明命名空间的 fp，就使用 Li::fp；但是若要使用小韩定义的 fp，仍然需要 Han::fp。</p><p>using 声明不仅可以针对命名空间中的一个变量，也可以用于声明整个命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using namespace Li;</span><br><span class="line">fp = fopen(&quot;one.txt&quot;, &quot;r&quot;);  </span><br><span class="line">Han::fp = fopen(&quot;two.txt&quot;, &quot;rb+&quot;); </span><br></pre></td></tr></table></figure><p>如果命名空间 Li 中还定义了其他的变量，那么同样具有 fp 变量的效果。在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。</p><p>命名空间内部不仅可以声明或定义变量，对于其它能在命名空间以外声明或定义的名称，同样也都能在命名空间内部进行声明或定义，例如类、函数、typedef、#define 等都可以出现在命名空间中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//将类定义在命名空间中</span><br><span class="line">namespace Diy&#123;</span><br><span class="line">    class Student&#123;</span><br><span class="line">    public:</span><br><span class="line">        char *name;</span><br><span class="line">        int age;</span><br><span class="line">        float score;</span><br><span class="line">    public:</span><br><span class="line">        void say()&#123;</span><br><span class="line">            printf(&quot;%s的年龄是 %d，成绩是 %f\n&quot;, name, age, score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Diy::Student stu1;</span><br><span class="line">    stu1.name = &quot;小明&quot;;</span><br><span class="line">    stu1.age = 15;</span><br><span class="line">    stu1.score = 92.5f;</span><br><span class="line">    stu1.say();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-头文件和std命名空间"><a href="#C-头文件和std命名空间" class="headerlink" title="C++头文件和std命名空间"></a>C++头文件和std命名空间</h4><p>和C语言一样，C++ 头文件仍然以.h为后缀，它们所包含的类、函数、宏等都是全局范围的。</p><p>后来 C++ 引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间，这个命名空间的名字就是std。</p><p>C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。</p><p>为了避免头文件重名，<strong>新版 C++ 库也对头文件的命名做了调整，去掉了后缀.h</strong>，所以老式 C++ 的iostream.h变成了iostream，fstream.h变成了fstream。<br>而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字母，所以C语言的stdio.h变成了cstdio，stdlib.h变成了cstdlib。</p><p>总结的 C++ 头文件的现状：</p><ol><li><p>旧的 C++ 头文件，如 iostream.h、fstream.h 等将会继续被支持，尽管它们不在官方标准中。这些头文件的内容<strong>不在命名空间 std 中</strong>。</p></li><li><p>新的 C++ 头文件，如 iostream、fstream 等包含的基本功能和对应的旧版头文件相似，但头文件的内容在命名空间 std 中。</p></li></ol><p>注意：在标准化的过程中，库中有些部分的细节被修改了，所以旧的头文件和新的头文件不一定完全对应。</p><ol start="3"><li><p>标准C头文件如 stdio.h、stdlib.h 等继续被支持。头文件的内容不在 std 中。</p></li><li><p>具有C库功能的新C++头文件具有如 cstdio、cstdlib 这样的名字。它们提供的内容和相应的旧的C头文件相同，只是内容在 std 中。</p></li></ol><h5 id="使用C-的头文件"><a href="#使用C-的头文件" class="headerlink" title="使用C++的头文件"></a>使用C++的头文件</h5><p>在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明。</p><p>很多教程中都是这样做的，将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，我推荐在函数内部声明 std。</p><h5 id="C-输入输出（cin和cout）"><a href="#C-输入输出（cin和cout）" class="headerlink" title="C++输入输出（cin和cout）"></a>C++输入输出（cin和cout）</h5><p>在C++语言中，C语言的这一套输入输出库我们仍然能使用，但是 C++ 又增加了一套新的、更容易使用的输入输出库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x;</span><br><span class="line">    float y;</span><br><span class="line">    cout&lt;&lt;&quot;Please input an int number:&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    cout&lt;&lt;&quot;The int number is x= &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;Please input a float number:&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;y;</span><br><span class="line">    cout&lt;&lt;&quot;The float number is y= &quot;&lt;&lt;y&lt;&lt;endl;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 中的输入与输出可以看做是一连串的数据流，输入即可视为从文件或键盘中输入程序中的一串数据流，而输出则可以视为从程序中输出一连串的数据流到显示屏或文件中。</p><p>在编写 C++ 程序时，如果需要使用输入输出时，则需要包含头文件iostream，它包含了用于输入输出的对象</p><p>cout 和 cin 都是 C++ 的<strong>内置对象，而不是关键字</strong>。C++ 库定义了大量的类（Class），程序员可以使用它们来创建对象，cout 和 cin 就分别是 ostream 和 istream 类的对象，只不过它们是由标准库的开发者提前创建好的，可以直接拿来使用。这种在 C++ 中提前创建好的对象称为内置对象。</p><p>使用 cout 进行输出时需要   &lt;&lt;      运算符</p><p>使用 cin 进行输入时需要    &gt;&gt;  运算符</p><p>这两个运算符可以自行分析所处理的数据类型，因此无需像使用 scanf 和 printf 那样给出格式控制字符串。</p><p>第 6 行代码表示输出”Please input a int number:”这样的一个字符串，以提示用户输入整数，</p><p>endl表示换行，与C语言里的\n作用相同。<br>这段代码中也可以用\n来替代endl，这样就得写作：<br>cout&lt;&lt;”Please input an int number:\n”;</p><p><strong>第 7 行代码表示从标准输入（键盘）中读入一个 int 型的数据并存入到变量 x 中。如果此时用户输入的不是 int 型数据，则会被强制转化为 int 型数据。</strong></p><p>第 8 行代码将输入的整型数据输出。从该语句中我们可以看出 cout 能够连续地输出。</p><p>cin 也是支持对多个变量连续输入的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x;</span><br><span class="line">    float y;</span><br><span class="line">    cout&lt;&lt;&quot;Please input an int number and a float number:&quot;&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    cout&lt;&lt;&quot;The int number is x= &quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;The float number is y= &quot;&lt;&lt;y&lt;&lt;endl;   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 7 行代码连续从标准输入中读取一个整型和一个浮点型数字（<strong>默认以空格分隔</strong>），分别存入到 x 和 y 中。输入运算符&gt;&gt;在读入下一个输入项前会忽略前一项后面的空格，所以数字 8 和 7.4 之间要有一个空格，当 cin 读入 8 后忽略空格，接着读取 7.4。</p><h5 id="C-布尔类型（bool）"><a href="#C-布尔类型（bool）" class="headerlink" title="C++布尔类型（bool）"></a>C++布尔类型（bool）</h5><p>在C语言中，关系运算和逻辑运算的结果有两种，真和假：0 表示假，非 0 表示真。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a, b, flag;</span><br><span class="line">    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);</span><br><span class="line">    flag = a &gt; b; </span><br><span class="line">    printf(&quot;flag = %d\n&quot;, flag);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言并没有彻底从语法上支持“真”和“假”，只是用 0 和非 0 来代表。这点在 C++ 中得到了改善<br>C++ 新增了 bool 类型（布尔类型），它一般占用 1 个字节长度。</p><p>bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”。</p><p>bool 是类型名字，也是 C++ 中的关键字，它的用法和 int、char、long 是一样的</p><p>在 C++ 中使用 cout 输出 bool 变量的值时还是用数字 1 和 0 表示，而不是 true 或 false。</p><h4 id="C-new和delete运算符简介"><a href="#C-new和delete运算符简介" class="headerlink" title="C++ new和delete运算符简介"></a>C++ new和delete运算符简介</h4><p>在C语言中，动态分配内存用 malloc() 函数，释放内存用 free() 函数。如下所示：</p><p>int <em>p &#x3D; (int</em>) malloc( sizeof(int) * 10 );  &#x2F;&#x2F;分配10个int型的内存空间<br>free(p);  &#x2F;&#x2F;释放内存</p><p>int *p &#x3D; new int;  &#x2F;&#x2F;分配1个int型的内存空间<br>delete p;  &#x2F;&#x2F;释放内存</p><p>new 操作符会根据后面的数据类型来推断所需空间的大小。</p><p>如果希望分配一组连续的数据，可以使用 new[]：</p><p>int *p &#x3D; new int[10];  &#x2F;&#x2F;分配10个int型的内存空间<br>delete[] p;</p><p>用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。</p><h4 id="C-string详解，C-字符串详解"><a href="#C-string详解，C-字符串详解" class="headerlink" title="C++ string详解，C++字符串详解"></a>C++ string详解，C++字符串详解</h4><p>C++ 大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    string s2 = &quot;c plus plus&quot;;</span><br><span class="line">    string s3 = s2;</span><br><span class="line">    string s4 (5, &#x27;s&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是””，也即空字符串。</p><p>变量 s2 在定义的同时被初始化为”c plus plus”。与C风格的字符串不同，string 的结尾没有结束标志’\0’。</p><p>变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是”c plus plus”。</p><p>变量 s4 被初始化为由 5 个’s’字符组成的字符串，也就是”sssss”。</p><p>从上面的代码可以看出，string 变量可以直接<strong>通过赋值操作符&#x3D;进行赋值</strong>。<br>string 变量也可以用C风格的字符串进行赋值，例如，s2 是用一个字符串常量进行初始化的，而 s3 则是通过 s2 变量进行初始化的。</p><p>与C风格的字符串不同，当我们需要知道字符串长度时，可以调用 string 类提供的 length() 函数。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = &quot;http://c.biancheng.net&quot;;</span><br><span class="line">int len = s.length();</span><br><span class="line">cout&lt;&lt;len&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>string 的末尾没有’\0’字符，所以 length() 返回的是字符串的真实长度，而不是长度 +1</strong></p><h6 id="转换为C风格的字符串"><a href="#转换为C风格的字符串" class="headerlink" title="转换为C风格的字符串"></a>转换为C风格的字符串</h6><p>虽然 C++ 提供了 string 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径）<br>string 类为我们提供了一个转换函数 c_str()，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string path = &quot;D:\\demo.txt&quot;;</span><br><span class="line">FILE *fp = fopen(path.c_str(), &quot;rt&quot;);</span><br></pre></td></tr></table></figure><p>为了使用C语言中的 fopen() 函数打开文件，必须将 string 字符串转换为C风格的字符串。</p><h6 id="string-字符串的输入输出"><a href="#string-字符串的输入输出" class="headerlink" title="string 字符串的输入输出"></a>string 字符串的输入输出</h6><p>string 类重载了输入输出运算符，可以像对待普通变量那样对待 string 变量，也就是用&gt;&gt;进行输入，用&lt;&lt;进行输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;  //输入字符串</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;  //输出字符串</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="访问字符串中的字符"><a href="#访问字符串中的字符" class="headerlink" title="访问字符串中的字符"></a>访问字符串中的字符</h6><p>string 字符串也可以像C风格的字符串一样按照下标来访问其中的每一个字符。string 字符串的起始下标仍是从 0 开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s = &quot;1234567890&quot;;</span><br><span class="line">    for(int i=0,len=s.length(); i&lt;len; i++)&#123;</span><br><span class="line">        cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    s[5] = &#x27;5&#x27;;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h6><p>有了 string 类，可以使用     +  或    +&#x3D;  运算符来直接拼接字符串，非常方便，也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，不用担心空间不够会溢出了。</p><p>用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 = &quot;first &quot;;</span><br><span class="line">    string s2 = &quot;second &quot;;</span><br><span class="line">    char *s3 = &quot;third &quot;;</span><br><span class="line">    char s4[] = &quot;fourth &quot;;</span><br><span class="line">    char ch = &#x27;@&#x27;;</span><br><span class="line"></span><br><span class="line">    string s5 = s1 + s2;</span><br><span class="line">    string s6 = s1 + s3;</span><br><span class="line">    string s7 = s1 + s4;</span><br><span class="line">    string s8 = s1 + ch;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;s5&lt;&lt;endl&lt;&lt;s6&lt;&lt;endl&lt;&lt;s7&lt;&lt;endl&lt;&lt;s8&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="string-字符串的增删改查"><a href="#string-字符串的增删改查" class="headerlink" title="string 字符串的增删改查"></a>string 字符串的增删改查</h6><p>插入字符串</p><p>insert() 函数可以在 string 字符串中指定的位置插入另一个字符串<br>它的一种原型为：<br>string&amp; insert (size_t pos, const string&amp; str);</p><p>pos 表示要插入的位置，也就是下标；<br>str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = s2 = &quot;1234567890&quot;;</span><br><span class="line">    s3 = &quot;aaa&quot;;</span><br><span class="line">    s1.insert(5, s3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    s2.insert(5, &quot;bbb&quot;);</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除字符串</p><p>erase() 函数可以删除 string 中的一个子字符串。<br>它的一种原型为：<br>string&amp; erase (size_t pos &#x3D; 0, size_t len &#x3D; npos);</p><p>pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。<br>如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1, s2, s3;</span><br><span class="line">    s1 = s2 = s3 = &quot;1234567890&quot;;</span><br><span class="line">    s2.erase(5);</span><br><span class="line">    s3.erase(5, 3);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s3 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提取子字符串</p><p>substr() 函数<br>用于从 string 字符串中提取子字符串<br>它的原型为：<br>string substr (size_t pos &#x3D; 0, size_t len &#x3D; npos) const;</p><p>pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 = &quot;first second third&quot;;</span><br><span class="line">    string s2;</span><br><span class="line">    s2 = s1.substr(6, 6);</span><br><span class="line">    cout&lt;&lt; s1 &lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统对 substr() 参数的处理和 erase() 类似：如果 pos 越界，会抛出异常；如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。</p><p>字符串查找</p><p>string 类提供了几个与字符串查找有关的函数</p><ol><li>find() 函数</li></ol><p>find() 函数用于在 string 字符串中查找子字符串出现的位置<br>它其中的两种原型为：<br>size_t find (const string&amp; str, size_t pos &#x3D; 0) const;<br>size_t find (const char* s, size_t pos &#x3D; 0) const;</p><p>第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 = &quot;first second third&quot;;</span><br><span class="line">    string s2 = &quot;second&quot;;</span><br><span class="line">    int index = s1.find(s2,5);</span><br><span class="line">    if(index &lt; s1.length())</span><br><span class="line">        cout&lt;&lt;&quot;Found at index : &quot;&lt;&lt; index &lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;Not found&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。<br>本例最终是在下标6处找到了 s2 字符串。如果没有查找到子字符串，那么会返回一个无穷大值 4294967295。</p><ol start="2"><li>rfind() 函数</li></ol><p>rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 = &quot;first second third&quot;;</span><br><span class="line">    string s2 = &quot;second&quot;;</span><br><span class="line">    int index = s1.rfind(s2,6);</span><br><span class="line">    if(index &lt; s1.length())</span><br><span class="line">        cout&lt;&lt;&quot;Found at index : &quot;&lt;&lt; index &lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;Not found&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>find_first_of() 函数</li></ol><p>find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s1 = &quot;first second second third&quot;;</span><br><span class="line">    string s2 = &quot;asecond&quot;;</span><br><span class="line">    int index = s1.find_first_of(s2);</span><br><span class="line">    if(index &lt; s1.length())</span><br><span class="line">        cout&lt;&lt;&quot;Found at index : &quot;&lt;&lt; index &lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;Not found&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h4><p>参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。</p><p>在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用</p><p>引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。</p><p>引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序</p><p>引用的定义方式类似于指针，只是用&amp;取代了*，语法格式为：type &amp;name &#x3D; data;</p><p>type 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。<br><strong>引用必须在定义的同时初始化</strong>，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 99;</span><br><span class="line">    int &amp;r = a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; &quot;, &quot; &lt;&lt; &amp;r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以说变量 r 是变量 a 的另一个名字。从输出结果可以看出，a 和 r 的地址一样，都是0x28ff44；或者说地址为0x28ff44的内存有两个名字，a 和 r，想要访问该内存上的数据时，使用哪个名字都行。</p><p>注意，引用在定义时需要添加&amp;，在使用时不能添加&amp;，使用时添加&amp;表示取地址。了这两种用法，&amp;还可以表示位运算中的与运算。</p><p>由于引用 r 和原始变量 a 都是指向同一地址，所以通过引用也可以修改原始变量中所存储的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 99;</span><br><span class="line">    int &amp;r = a;</span><br><span class="line">    r = 47;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用作为函数参数</strong></p><p>在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap1(int a, int b);</span><br><span class="line">void swap2(int *p1, int *p2);</span><br><span class="line">void swap3(int &amp;r1, int &amp;r2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num1, num2;</span><br><span class="line">    cout &lt;&lt; &quot;Input two integers: &quot;;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    swap1(num1, num2);</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Input two integers: &quot;;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    swap2(&amp;num1, &amp;num2);</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Input two integers: &quot;;</span><br><span class="line">    cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">    swap3(num1, num2);</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接传递参数内容</span><br><span class="line">void swap1(int a, int b) &#123;</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//传递指针</span><br><span class="line">void swap2(int *p1, int *p2) &#123;</span><br><span class="line">    int temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//按引用传参</span><br><span class="line">void swap3(int &amp;r1, int &amp;r2) &#123;</span><br><span class="line">    int temp = r1;</span><br><span class="line">    r1 = r2;</span><br><span class="line">    r2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种交换变量的值的方法：</p><ol><li><p>swap1() 直接传递参数的内容，不能达到交换两个数的值的目的。对于 swap1() 来说，a、b 是形参，是作用范围仅限于函数内部的局部变量，它们有自己独立的内存，和 num1、num2 指代的数据不一样。调用函数时分别将 num1、num2 的值传递给 a、b，此后 num1、num2 和 a、b 再无任何关系，在 swap1() 内部修改 a、b 的值不会影响函数外部的 num1、num2，更不会改变 num1、num2 的值。</p></li><li><p>swap2() 传递的是指针，能够达到交换两个数的值的目的。调用函数时，分别将 num1、num2 的指针传递给 p1、p2，此后 p1、p2 指向 a、b 所代表的数据，在函数内部可以通过指针间接地修改 a、b 的值。我们在《C语言指针变量作为函数参数》中也对比过第 1)、2) 中方式的区别。</p></li><li><p>swap3() 是按引用传递，能够达到交换两个数的值的目的。调用函数时，分别将 r1、r2 绑定到 num1、num2 所指代的数据，此后 r1 和 num1、r2 和 num2 就都代表同一份数据了，通过 r1 修改数据后会影响 num1，通过 r2 修改数据后也会影响 num2。</p></li></ol><p>从以上代码的编写中可以发现，按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，我鼓励读者大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），C++ 标准库也是这样做的。</p><p>C++引用作为函数返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int &amp;plus10(int &amp;r) &#123;</span><br><span class="line">    r += 10;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = plus10(num1);</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int &amp;plus10(int &amp;r) &#123;</span><br><span class="line">    int m = r + 10;</span><br><span class="line">    return m;  //返回局部数据的引用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num1 = 10;</span><br><span class="line">    int num2 = plus10(num1);</span><br><span class="line">    cout &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line">    int &amp;num3 = plus10(num1);</span><br><span class="line">    int &amp;num4 = plus10(num3);</span><br><span class="line">    cout &lt;&lt; num3 &lt;&lt; &quot; &quot; &lt;&lt; num4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plus10() 返回一个对局部变量 m 的引用，这是导致运行结果非常怪异的根源，因为函数是在栈上运行的，并且运行结束后会放弃对所有局部数据的管理权，后面的函数调用会覆盖前面函数的局部数据。本例中，第二次调用 plus10() 会覆盖第一次调用 plus10() 所产生的局部数据，第三次调用 plus10() 会覆盖第二次调用 plus10() 所产生的局部数据。</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>l1-002-打印沙漏（python版）</title>
      <link href="/post/609e352d.html"/>
      <url>/post/609e352d.html</url>
      
        <content type="html"><![CDATA[<p>博主之前刷题都是使用的c&#x2F;c++去的，但是当我看得到python会就改成使用python刷题了。但是python刷题有些在网上没有很好的答案 ，所以这里博主就准备自己写一个专栏，就专门用来记录使用python刷的题（难度在中等以上），欢迎其他小伙伴一起交流。</p><p><strong>这里因为使用的是python所以大家一定要注意那个时间限制</strong></p><h4 id="这下面是题"><a href="#这下面是题" class="headerlink" title="这下面是题"></a>这下面是题</h4><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19 *</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>代码长度限制</p><p>16 KB</p><p>时间限制</p><p>400 ms</p><p>内存限制</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>解释一下里面的关键步骤</p><ol><li>这里我用的是等差数列的办法确定层数的，应该还有其他的方法。</li></ol><img src="/post/609e352d/1.png" class title="This is an image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#确定层数</span><br><span class="line">while True:    </span><br><span class="line">    if a*a*2-1&lt;= n:</span><br><span class="line">        a +=1</span><br><span class="line">    elif a*a*2-1&gt; n:</span><br><span class="line">        a = a-1</span><br><span class="line">        break</span><br></pre></td></tr></table></figure><ol start="2"><li><p>这里使用一个count 记录层数因为在打印正三角的时候会用到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#记录层数</span><br><span class="line">count =a</span><br></pre></td></tr></table></figure></li><li><p>这个j的作用是记录每一行一个输出的空格数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = 2*count-1</span><br></pre></td></tr></table></figure></li><li><p>使用了rjust函数 来填充空格，如果不使用的话，也可以使用c&#x2F;c++的那种方法，就是不使用的。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(f.rjust(j))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">str1 = input().split()</span><br><span class="line">n = int(str1[0])</span><br><span class="line">s = str1[1]</span><br><span class="line">a = 1</span><br><span class="line">#确定层数</span><br><span class="line">while True:    </span><br><span class="line">    if a*a*2-1&lt;= n:</span><br><span class="line">        a +=1</span><br><span class="line">    elif a*a*2-1&gt; n:</span><br><span class="line">        a = a-1</span><br><span class="line">        break</span><br><span class="line">#记录层数</span><br><span class="line">count =a</span><br><span class="line">#为输出空格数做准备</span><br><span class="line">j = 2*count-1</span><br><span class="line"># 如果只给的个数 小于2</span><br><span class="line">if n &lt;=1:</span><br><span class="line">    print(s*n)</span><br><span class="line">    print(n-a)</span><br><span class="line"># </span><br><span class="line">else:</span><br><span class="line">    # 打印倒三角</span><br><span class="line">    while True:</span><br><span class="line">        f=s*(2*a-1)</span><br><span class="line">        print(f.rjust(j))</span><br><span class="line">        a=a-1</span><br><span class="line">        if a==0:</span><br><span class="line">            break</span><br><span class="line">        j=j-1</span><br><span class="line">    c =2</span><br><span class="line">    #打印正三角</span><br><span class="line">    while True:</span><br><span class="line">        if count&lt;2:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            j=j+1</span><br><span class="line">            g=s*(2*c-1)</span><br><span class="line">            print(g.rjust(j))</span><br><span class="line">            c=c+1</span><br><span class="line">            if c&gt;count:</span><br><span class="line">                break</span><br><span class="line">    print(n - (count*count*2-1))</span><br></pre></td></tr></table></figure><p>这里再给一个[lucky lures]<a href="https://blog.csdn.net/weixin_43862765?type=blog)%E7%BB%99%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82">https://blog.csdn.net/weixin_43862765?type=blog)给的答案。</a></p><p>他的答案里面给的注解非常详细，有不理解的小伙伴们可以滴滴博主</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> # 获取到数字和字符</span><br><span class="line">lst = input().split()</span><br><span class="line">num,char = lst</span><br><span class="line"></span><br><span class="line"># 获取打印最大行数</span><br><span class="line">num = int(num)</span><br><span class="line">total = 1</span><br><span class="line">if num == 1:</span><br><span class="line">print(char)</span><br><span class="line"># 没用到的数字个数</span><br><span class="line">print(num - total)</span><br><span class="line">else:</span><br><span class="line">i = 1</span><br><span class="line">while total &lt;= num:</span><br><span class="line">i += 2</span><br><span class="line">total += 2*i</span><br><span class="line"> # 最终行数和没用到的字符数</span><br><span class="line">total -= 2*i</span><br><span class="line">i -= 2</span><br><span class="line"># 打印上三角形部分</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">行数 字符数 左半部分空格数</span><br><span class="line">1 5 0</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 表空格数 0 1 2，也能用作行数</span><br><span class="line">j = i // 2</span><br><span class="line">for k in range(j+1):</span><br><span class="line">print(&quot; &quot;*k,end=&quot;&quot;)</span><br><span class="line">print(char *(i - 2 *k))</span><br><span class="line"># 打印下三角形部分</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">行数 字符数 左半部分空格数</span><br><span class="line">4 3 1</span><br><span class="line">5 5 0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">for j in range(1,i+1,2):</span><br><span class="line">if j == 1:</span><br><span class="line">continue</span><br><span class="line">print(&quot; &quot;*((i - j) // 2),end=&quot;&quot;)</span><br><span class="line">print(char*j)</span><br><span class="line">print(num - total)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python刷题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人爱好</title>
      <link href="/post/bb328bf0.html"/>
      <url>/post/bb328bf0.html</url>
      
        <content type="html"><![CDATA[<h3 id="文"><a href="#文" class="headerlink" title="文"></a>文</h3><h4 id="凤求凰"><a href="#凤求凰" class="headerlink" title="凤求凰"></a>凤求凰</h4><p><strong>有一美人兮，见之不忘。</strong></p><p><strong>一日不见兮，思之如狂。</strong></p><p>凤飞翱翔兮，四海求凰。</p><p>无奈佳人兮，不在东墙。</p><p>将琴代语兮，聊写衷肠。</p><p>何时见许兮，慰我彷徨。</p><p>愿言配德兮，携手相将。</p><p>不得於飞兮，使我沦亡。 </p><p>凤兮凤兮归故乡，遨游四海求其凰。</p><p>时未遇兮无所将，何悟今兮升斯堂！</p><p>有艳淑女在闺房，室迩人遐毒我肠。</p><p>何缘交颈为鸳鸯，胡颉颃兮共翱翔！</p><p>凰兮凰兮从我栖，得托孳尾永为妃。</p><p>交情通意心和谐，中夜相从知者谁？</p><p>双翼俱起翻高飞，无感我思使余悲。</p><p><strong>译文</strong></p><p><strong>其一</strong></p><p>有位俊秀漂亮的女子啊，我见了她的容貌就难以忘怀。</p><p>我如果一天见不到她啊，心中牵念得像是要发狂一般。</p><p>我就像高飞盘旋的凤鸟，在天下各处苦苦寻觅着凰鸟。</p><p>可惜那个娴静的美人啊，没有居住在我那东墙的附近。</p><p>我以琴声替代心中情语，姑且描写我内心衷切的情意。</p><p>什么时候可以允诺婚事，慰藉我往返徘徊的相思之情？</p><p>望我的德行能与你相配，与你携手同在而成百年好合。</p><p>无法比翼偕飞的结果啊，令我沦陷於这情愁而欲丧亡。</p><p><strong>其二</strong></p><p>凤鸟啊凤鸟啊回到了家乡，行踪无定游览天下寻求心中凰鸟。</p><p>未遇凰鸟之时啊不知所往，怎能悟解今日登门后心中之所感！</p><p>有美丽娴静的女子在居室，居处虽近人却远而残虐我的心肠。</p><p>如何能做恩爱的交颈鸳鸯，使我这凤鸟与你这凰鸟一同翔游！</p><p>凰鸟啊凰鸟啊愿你我相依，共同哺育生子并永远做我的配偶。</p><p>情投意合而两心和睦谐顺，半夜与我互相追随又有谁能知晓？</p><p>展开双翼一起远走而高飞，徒然为你感念相思而使我心悲伤。</p><p>这个太惊艳了，高中的时候第一次读到这个吧作品，就喜欢上了。</p><p>还有就是，引起了我对司马相如的兴趣。</p><p>当时看完司马相如的故事，第一句，就是 kao 这个货tmd的太牛逼了</p><h4 id="美人赋"><a href="#美人赋" class="headerlink" title="美人赋"></a>美人赋</h4><p>司马相如，美丽闲都，游于梁王，梁王悦之。邹阳谮之于王曰：“相如美则美矣，然服色容冶，妖丽不忠，将欲媚辞取悦，游王后宫，王不察之乎？”王问相如曰：“子好色乎？”相如曰：“臣不好色也。”王曰：“子不好色，何若孔墨乎？”<strong>相如曰：“古之避色，孔墨之徒，闻齐馈女而遐逝，望朝歌而回车。譬犹防火水中，避溺山隅。此乃未见其可欲，何以明不好色乎？</strong>若臣者，少长西土，鳏处独居，室宇辽廓，莫与为娱。<strong>臣之东邻，有一女子，云发丰艳，蛾眉皓齿，颜盛色茂，景曜光起</strong>（我东边的邻居，有一个姑娘，如云卷浓发似的，体态丰满，细长的眉毛，洁白的牙齿。漂亮的容貌，真是光艳动人）。恒翘翘而西顾，欲留臣而共止。登垣而望臣，三年于兹矣，臣弃而不许。窃慕大王之高义，命驾东来，途出郑、卫，道由桑中，朝发溱、洧，暮宿上宫。上宫闲馆，寂寞云虚，门阁昼掩，暧若神居。臣排其户而造其室，芳香芬烈，黼帐高张。<strong>有女独处，婉然在床。奇葩逸丽，淑质艳光</strong>。睹臣迁延，微笑而言曰：‘上客何国之公子？所从来无乃远乎？’遂设旨酒，进鸣琴。臣遂抚琴，为幽兰白雪之曲。女乃歌曰：‘独处室兮廓无依，思佳人兮情伤悲。有美人兮来何迟？日既暮兮华色衰。敢托身兮长自思。’<strong>玉钗挂臣冠，罗袖拂臣衣</strong>。时日西夕，玄阴晦冥，流风惨冽，素雪飘零，闲房寂谧，不闻人声。于是寝具既陈，服玩珍奇，金鉔薰香，黼帐低垂。裀褥重陈，角枕横施。女乃驰其上服，表其亵衣。皓体呈露，弱骨丰肌。时来亲臣，柔滑如脂。臣乃脉定于内，心正于怀，信誓旦旦，秉志不回。翻然高举，与彼长辞。”</p><p>这小子 娶了卓文君后，当上官了，好一阵风光，到处沾花惹草，还在这里说自己不好女色。</p><p>部分注解（这里的基本上是博主不知道的一些）</p><ol><li>闲都：文雅美好。</li><li>谮：说坏话</li><li>服色容冶：服饰华丽</li><li>游：出入</li><li>恒：经常</li><li>排：推开</li><li>造：进入</li><li>闻齐馈（kuì）女而遐逝：《<a href="https://baike.baidu.com/item/%E8%AE%BA%E8%AF%AD/372830?fromModule=lemma_inlink">论语</a>·微子》：“齐人归（馈）女乐，季桓子受之，三日不朝，孔子行。”《史记·孔子世家》谓孔子由大司寇摄行相事，齐国怕鲁国因此强大，送美女良马给鲁君，季桓子出面受礼，鲁君由此怠于政事，孔子离职去鲁至卫。</li><li>望朝（zhāo）歌而回车：朝歌，商朝都城。商纣王在朝歌淫乐导致身死国亡。《淮南子·说山训》：“墨子非乐，不入朝歌之邑。”今《<a href="https://baike.baidu.com/item/%E5%A2%A8%E5%AD%90/245?fromModule=lemma_inlink">墨子</a>》无此内容。</li><li>鳏（guān）：无妻。辽廓：宽广的样子。</li><li>翘翘：仰首。</li><li>郑、卫：西周至春秋的两个诸侯国。</li><li>溱（zhēn）、洧（wěi）：二水名。在郑国（今河南境内）。</li><li>上宫：《诗经·<a href="https://baike.baidu.com/item/%E9%84%98%E9%A3%8E%C2%B7%E6%A1%91%E4%B8%AD/19671472?fromModule=lemma_inlink">鄘风·桑中</a>》：“期我乎桑中，要我乎上宫。”取以代指淫乐之地。</li><li>云虚：云雾空中。言其寂静。</li><li>暧（ài）：幽暗不明。</li><li>黼（fǔ）：帐幔。</li><li>迁延：拖延，迟疑。</li><li>廓：空。</li><li>玄阴：冬气。</li><li>谧：静。</li><li>金鉔（zā）：金属香炉，以机环扣合，成球形，能旋转滚动而其体恒平。</li><li>亵（xiè）衣：内衣。</li><li>脉定：血脉稳定，平静不激动。</li><li>秉：持，守。</li></ol><p>这是百度上对这首赋的一个背景介绍</p><p>《美人赋》是西汉辞赋家<a href="https://baike.baidu.com/item/%E5%8F%B8%E9%A9%AC%E7%9B%B8%E5%A6%82/1112941?fromModule=lemma_inlink">司马相如</a>创作的一篇赋。此赋开头假设自己（第一人称）受诽谤，引出下文自己不好色，而且用古代圣贤作衬托，重点写赴梁途中的艳遇，再次突出自己不好色，从而表现作者坚守高洁品格的思想。全赋语言清丽华妙，调动多种感官来完成对美女的铺写，在艺术手法上颇有独到之处。</p><h5 id="典故"><a href="#典故" class="headerlink" title="典故"></a>典故</h5><h5 id="琴挑文君"><a href="#琴挑文君" class="headerlink" title="琴挑文君"></a>琴挑文君</h5><h5 id="犬子由来"><a href="#犬子由来" class="headerlink" title="犬子由来"></a>犬子由来</h5><p>据太史公《<a href="https://baike.baidu.com/item/%E5%8F%B2%E8%AE%B0?fromModule=lemma_inlink">史记</a>》的记载，司马相如“少时好读书，学击剑，故其亲名之曰“犬子”。也就是说“犬子”其实是他的乳名，或者名字。就像“二毛”、“小胖”之类，难登大雅之堂。他长大后，也觉得名字不好听，加上又仰慕蔺相如的为人，自己便更名为相如。 [11] </p><p>最开始，“犬子”之称，其实并无小名之意，只是司马相如的父母为了小儿好养活，便特意选一个低贱的字词为之命名，以远离鬼魅，但因为司马相如长大后自己改了名字，“犬子”才成了小名。</p><h4 id="白头吟"><a href="#白头吟" class="headerlink" title="白头吟"></a>白头吟</h4><p>皑如山上雪，皎若云间月。</p><p>闻君有两意，故来相决绝。</p><p>今日斗酒会，明旦沟水头。</p><p>躞蹀御沟上，沟水东西流。</p><p>凄凄复凄凄，嫁娶不须啼。</p><p><strong>愿得一心人，白头不相离。</strong></p><p>竹竿何嫋嫋，鱼尾何簁簁！</p><p><strong>男儿重意气，何用钱刀为</strong></p><p><strong>译文</strong></p><p>洁白犹如山上雪，纯洁就像云间月。</p><p>听说你已生二心，所以来与你决绝。</p><p>今日相会饮斗酒，明日沟边两分别。</p><p>小步徘徊御沟上，沟水东西在流淌。</p><p>孤寂凄凉又悲伤，我嫁你娶莫哭嚷。</p><p>只愿诚得一心人，白头到老不相忘。</p><p>竹竿柔弱有多长，鱼尾摇动多欢畅！</p><p>男儿本应重情义，为何恃富将我忘？</p><h4 id="诀别书"><a href="#诀别书" class="headerlink" title="诀别书"></a>诀别书</h4><p>“春华竞芳，五色凌素，<strong>琴尚在御，而新声代故</strong>！</p><p><strong>锦水有鸳，汉宫有木，</strong>彼物而新，嗟世之人兮，瞀于淫而不悟！</p><p><strong>朱弦断，明镜缺，朝露晞，芳时歇，白头吟，伤离别，努力加餐勿念妾，锦水汤汤，与君长诀</strong>！”</p><p>这个译文，有点意思，哈哈</p><p><strong>译文</strong></p><p>春天百花盛开,争奇斗艳,绚烂的色彩掩盖了素洁的颜色.</p><p>琴声依旧在奏响,但已经不是原来的人在弹奏了.</p><p>锦江中有相伴游泳的鸳鸯，汉宫中有<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%8F%B4?fromModule=lemma_inlink">交援</a>伸展的枝条。</p><p>他们都不曾离弃伴侣。</p><p>慨叹世上的人，却迷惑于美色，喜新厌旧。</p><p>朱弦断，知音绝。</p><p>明镜缺，夫妻分。</p><p>朝露晞，缘分尽。</p><p>芳时歇，人分离。</p><p>白头吟，伤离别。</p><p>希望您吃的好好的不要挂念我。</p><p>对着浩浩荡荡的锦水发誓，从今以后和你永远诀别。</p><p>最后几句简直绝了</p><h4 id="兰亭集序"><a href="#兰亭集序" class="headerlink" title="兰亭集序"></a>兰亭集序</h4><p>永和九年，岁在癸丑，暮春之初，会于会稽山阴之兰亭，修禊事也。群贤毕至，少长咸集。此地有崇山峻岭，茂林修竹，又有清流激湍，映带左右。引以为流觞曲水，列坐其次。虽无丝竹管弦之盛，一觞一咏，亦足以畅叙幽情。</p><p>是日也，天朗气清，惠风和畅。仰观宇宙之大，俯察品类之盛，所以游目骋怀，足以极视听之娱，信可乐也。</p><p>夫人之相与，俯仰一世。或取诸怀抱，悟言一室之内；或因寄所托，放浪形骸之外。虽趣舍万殊，静躁不同，当其欣于所遇，暂得于己， 快（怏）然自足，（曾 [1] ）不知老之将至。及其所之既倦，情随事迁，感慨系之矣。向之所欣，俯仰之间，已为陈迹，犹不能不以之兴怀。况修短随化，终期于尽。古人云：“死生亦大矣！”岂不痛哉！</p><p>每览昔人兴感之由，若合一契，未尝不临文嗟悼，不能喻之于怀。固知一死生为虚诞，齐彭殇为妄作。后之视今，亦犹今之视昔，悲夫！故列叙时人，录其所述。虽世殊事异，所以兴怀，其致一也。后之览者，亦将有感于斯文。</p><p>注释</p><ol><li>永和：东晋皇帝<a href="https://baike.baidu.com/item/%E5%8F%B8%E9%A9%AC%E8%81%83?fromModule=lemma_inlink">司马聃</a>（晋穆帝）的年号，从公元345—356年共12年。永和九年上巳节，王羲之与谢安，孙绰等41人。举行禊礼，饮酒赋诗，事后将作品结为一集，由王羲之写了这篇序总述其事。</li><li>暮春：阴历三月。暮，晚。</li><li>会：集会。</li><li>会稽（kuài jī）：郡名，今浙江绍兴。</li><li>山阴：今绍兴越城区。</li><li>修禊（xì）事也：（为了做）禊礼这件事。古代习俗，于阴历三月上旬的巳日（魏以后定为三月三日），人们群聚于水滨嬉戏洗濯，以祓除不祥和求福。实际上这是古人的一种游春活动。</li><li>群贤：诸多贤士能人。指谢安等三十二位社会的名流。贤：形容词做名词。</li><li>毕至：全到。毕，全、都。</li><li>少长：如王羲之的儿子王凝之、王徽之是少；谢安、王羲之等是长。</li><li>咸：都。</li><li>崇山峻岭：高峻的山岭。</li><li>修竹：高高的竹子。修，高高的样子。</li><li>激湍：流势很急的水。</li><li>映带左右：辉映点缀在亭子的周围。映带，映衬、围绕。</li><li>流觞（shāng）曲（qū）水：用漆制的酒杯盛酒，放入弯曲的水道中任其飘流，杯停在某人面前，某人就引杯饮酒。这是古人一种劝酒取乐的方式。流，使动用法。曲水，引水环曲为渠，以流酒杯。</li><li>列坐其次：列坐在曲水之旁。列坐，排列而坐。次，旁边，水边。</li><li>丝竹管弦之盛：演奏音乐的盛况。盛，盛大。</li><li>一觞一咏：喝着酒作着诗。</li><li>幽情：幽深内藏的感情。</li><li>是日也：这一天。</li><li>惠风：和风。</li><li>和畅，缓和。</li><li>品类之盛：万物的繁多。品类，指自然界的万物。</li><li>所以：用来。</li><li>骋：使······奔驰。</li><li>极：穷尽。</li><li>信：实在。</li><li>夫人之相与，俯仰一世：人与人相交往，很快便度过一生。夫，句首发语词，不译。相与，相处、相交往。俯仰，表示时间的短暂。</li><li>取诸：取之于，从······中取得。</li><li>悟言：面对面的交谈。悟，通“晤”，指心领神会的妙悟之言。</li><li>因寄所托，放浪形骸之外：就着自己所爱好的事物，寄托自己的情怀，不受约束，放纵无羁的生活。因，依、随着。寄，寄托。所托，所爱好的事物。放浪，放纵、无拘束。形骸，身体、形体。</li><li>趣（qu）舍万殊：各有各的爱好。趣舍，即取舍，爱好。趣，通“取”。万殊，千差万别。</li><li>静躁：安静与躁动。</li><li>暂：短暂，一时。</li><li>快（怏）然自足：感到高兴和满足。然，······的样子。</li><li>不知老之将至：（竟）不知道衰老将要到来。语出《论语·述而》：“其为人也，发愤忘食，乐以忘忧，不知老之将至云尔。”一本有“曾”在句前。</li><li>所之既倦：（对于）所喜爱或得到的事物已经厌倦。之，往、到达。</li><li>情随事迁：感情随着事物的变化而变化。迁，变化。</li><li>感慨系之：感慨随着产生。系，附着。</li><li>向：过去、以前。</li><li>陈迹：旧迹。</li><li>以之兴怀：因它而引起心中的感触。以，因。之，指“向之所欣……以为陈迹”。兴，发生、引起。</li><li>修短随化：寿命长短听凭造化。化，自然。</li><li>期：至，及。</li><li>死生亦大矣：死生是一件大事啊。语出《庄子·德充符》。</li><li>契：符契，古代的一种信物。在符契上刻上字，剖而为二，各执一半，作为凭证。</li><li>临文嗟（jiē）悼：读古人文章时叹息哀伤。临，面对。</li><li>喻：明白。</li><li>固知一死生为虚诞，齐彭殇为妄作：本来知道把死和生等同起来的说法是不真实的，把长寿和短命等同起来的说法是妄造的。固，本来、当然。一，把……看作一样；齐，把……看作相等，都用作动词。虚诞，虚妄荒诞的话。殇，未成年死去的人。妄作，妄造、胡说。一生死，齐彭殇，都是庄子的看法。出自《齐物论》。</li><li>列叙时人：一个一个记下当时与会的人。</li><li>录其所述：录下他们作的诗。</li><li>其致一也：人们的思想情趣是一样的。</li><li>后之览者：后世的读者。</li><li>斯文：这次集会的诗文。</li></ol><h3 id="心–哲–行"><a href="#心–哲–行" class="headerlink" title="心–哲–行"></a>心–哲–行</h3><h4 id="鲨鱼效应"><a href="#鲨鱼效应" class="headerlink" title="鲨鱼效应"></a>鲨鱼效应</h4><p>在海洋中的鱼类，依靠鳔才能在大海中自由沉浮。</p><p>但是天生就没有鳔的鲨鱼，为了不使自己下沉，只能不停地游动。</p><p>长此以往，鲨鱼的身体肌肉越来越强壮，体格也愈发强大，成为“海洋霸王”。</p><p>每个人都有自己的短板，也有自己的所长。</p><p>然而，短板的存在，并不代表我们人生的上限。</p><p>真正厉害的人，懂得发掘自己的长板，将劣势转换为优势。</p><p>当你拥有了“<strong>长板思维</strong>”，方能不断强大自己，寻找到属于自己的高光。</p><p><strong>决定一个人上限的，不是短板</strong></p><h4 id="禁果效应"><a href="#禁果效应" class="headerlink" title="禁果效应"></a>禁果效应</h4><p>越是禁止的东西，人们越要得到手。</p><p>越希望掩盖某个信息不让别人知道，却越勾起别人的好奇心和探求欲，</p><p>反而促使别人试图利用一切渠道来获取被掩盖的信息。这种由于单方面的禁止和掩饰而造成的逆反现象</p><h4 id="毛驴效应"><a href="#毛驴效应" class="headerlink" title="毛驴效应"></a>毛驴效应</h4><p><a href="https://baike.baidu.com/item/%E5%B8%83%E9%87%8C%E4%B8%B9?fromModule=lemma_inlink">布里丹</a>养了一头小毛驴，他每天要向附近的农民买一堆草料来喂。</p><p>这天，送草的农民出于对哲学家的景仰，额外多送了一堆草料放在旁边。这下子，毛驴站在两堆数量、质量和与它的距离完全相等的干草之间，可为难坏了。它虽然享有充分的选择自由，但由于两堆干草价值相等，客观上无法分辨优劣，于是它左看看，右瞅瞅，始终无法分清究竟选择哪一堆好。</p><p>于是，这头可怜的毛驴就这样站在原地，一会儿考虑数量，一会儿考虑质量，一会儿分析颜色，一会儿分析新鲜度，犹犹豫豫，来来回回，在无所适从中活活地饿死了。</p><h4 id="南风效应"><a href="#南风效应" class="headerlink" title="南风效应"></a>南风效应</h4><p>法国作家<a href="https://baike.baidu.com/item/%E6%8B%89%E5%B0%81%E4%B8%B9/1497385?fromModule=lemma_inlink">拉封丹</a>曾写过一则寓言，讲的是北风和南风比威力，看谁能把行人身上的大衣脱掉。</p><p>北风首先来一个冷风凛凛、寒冷刺骨，结果行人为了抵御北风的侵袭，便把大衣裹得紧紧的。</p><p>南风则徐徐吹动，顿时风和日丽，行人因为觉得很暖和，所以开始解开纽扣，继而脱掉大衣。结果很明显，南风获得了胜利。</p><h4 id="白熊效应"><a href="#白熊效应" class="headerlink" title="白熊效应"></a>白熊效应</h4><p>美国哈佛大学社会心理学家的一个实验，他要求参与者尝试不要想象一只白色的熊，结果人们的思维出现强烈反弹，大家很快在脑海中浮现出一只白熊的形象。</p><h4 id="野马效应"><a href="#野马效应" class="headerlink" title="野马效应"></a>野马效应</h4><p>在非洲草原上有一种动物——吸血蝙蝠，它们靠吸食动物的血液生存。这种蝙蝠常常会叮在野马的腿上吸血，而每当这时，野马就会陷入暴怒、狂奔，会像疯了一样摇头甩尾。但是不管野马怎样挣扎都无法摆脱吸血蝙蝠，因为这种蝙蝠动作迅速，它们可以快速的在野马身体的各个部位间移动，直到它们吸饱了血才从容离开，而不少野马就被它们活活折磨死。</p><p>动物学家对野马的死因进行研究，他们发现蝙蝠吸走的血量远不足以导致野马死亡，野马的真正死因是它们的暴怒和狂奔。野马被蝙蝠叮咬后陷入剧烈的情绪反应，身体内各项腺素分泌陷入异常，而剧烈的狂奔又导致力竭，最终死于非命。</p><h4 id="甜柠檬效应"><a href="#甜柠檬效应" class="headerlink" title="甜柠檬效应"></a>甜柠檬效应</h4><p>在挫折心理学中，人们把个体在追求预期目标而失败时，为了冲淡自己内心的不安，就百般提高现己实现的目标价值，从而达到了心理平衡、心安理得的现象，称之为甜柠檬效应。这一术语来源于伊索寓言的故事：有只狐狸原想找些可口的食物，但遍觅不着，只找到一只酸柠檬，这实在是一件不得已而为之的事，但它却说：“这柠檬是甜的，正是我想吃的。”这种只能得到柠檬就说柠檬是甜的自我安慰现象，有人也称甜柠檬心理或甜柠檬作用，其实质是一样的，都是为了变恶性刺激为良性刺激，以达自我心理平衡，免去自我苦恼与痛苦。</p><h4 id="大象思维"><a href="#大象思维" class="headerlink" title="大象思维"></a>大象思维</h4><p>在泰国的驯象场上，有一个奇怪的现象：</p><p>千斤重的大象，被一条细细的铁链子拴得老老实实。</p><p>为什么大象不挣脱呢？</p><p>原来驯象人在大象幼年的时候，就开始用铁链拴着幼象，当时的幼象拼命挣扎也无法挣脱铁链。</p><p>久而久之，大象习惯了被铁链拴着的状态，即使长大后力量早已翻了几倍，也不再尝试挣脱，甘心受铁链的限制</p><h4 id="花盆效应"><a href="#花盆效应" class="headerlink" title="花盆效应"></a>花盆效应</h4><p>花盆效应又称局部生境效应。<a href="https://baike.baidu.com/item/%E8%8A%B1%E7%9B%86/4774938?fromModule=lemma_inlink">花盆</a>是一个半人工、半自然的小生境。首先，它在空间上有很大的局限性；其次，由于人为地创造出非常适宜的的环境条件，在一段时间内，作物和花卉可以长得很好，但一离开人的精心照料，经不起温度的变化，更经不起风吹雨打。在教育生态中，花盆效应表现得尤为明显；在学校教育中，由于封闭或半封闭的教育体制的影响，使学生整天被关在教室里，与沸腾的现实生活脱节，加之教学内容、教学方法陈旧落后，从书本到书本，进行封锁式小循环。</p><h4 id="麦穗效应"><a href="#麦穗效应" class="headerlink" title="麦穗效应"></a>麦穗效应</h4><p>有一天，古希腊著名哲学家苏格拉底的三个弟子向他请教：“如何才能找到称心如意的伴侣?</p><p>”苏格拉底没有直接回答，而是把弟子们带到一块麦地边，让他们在一块麦地中每人选一个最大的麦穗，条件是要从麦地的一边走到另一边，只能往前走不能往回走。大弟子刚走几步便摘了自认为是最大的麦穗(其实并不是最大的麦穗)；二弟子一开始就左顾右盼下不了手，总想也许后面有更大的麦穗，一直到终点时才发现，前面的几个大麦穗已经错过了；三弟子与二位师兄不同，先在三分之一路程时注意验证，在最后三分之一路程时摘下了经过反复比较的最大麦穗。</p><p>由此可见，大弟子的盲目轻率和二弟子的犹豫不绝，都不能摘到最大的麦穗；只有像三弟子那样在调查研究的基础上，并根据客观规律制订周密的行动方案，才能摘到最大麦穗。</p><h4 id="鸟笼效应"><a href="#鸟笼效应" class="headerlink" title="鸟笼效应"></a>鸟笼效应</h4><p>1907年，詹姆斯从<a href="https://baike.baidu.com/item/%E5%93%88%E4%BD%9B%E5%A4%A7%E5%AD%A6?fromModule=lemma_inlink">哈佛大学</a>退休，同时退休的还有他的好友物理学家卡尔森。一天，两人打赌。詹姆斯说：“我一定会让你不久就养上一只鸟的。”卡尔森不以为然：“我不信！因为我从来就没有想过要养一只鸟。”没过几天，恰逢卡尔森生日，詹姆斯送上了礼物——一只精致的鸟笼。卡尔森笑了：“我只当它是一件漂亮的工艺品。你就别费劲了。”从此以后，只要客人来访，看见书桌旁那只空荡荡的鸟笼，他们几乎都会无一例外地问：“<a href="https://baike.baidu.com/item/%E6%95%99%E6%8E%88/18291?fromModule=lemma_inlink">教授</a>，你养的鸟什么时候死了？”卡尔森只好一次次地向客人解释：“我从来就没有养过鸟。”然而，这种回答每每换来的却是客人困惑而有些不信任的目光。无奈之下，卡尔森教授只好买了一只鸟，詹姆斯的“鸟笼效应”奏效了。实际上，在我们的身边，包括我们自己，很多时候先在自己的心里挂上一只笼子，然后再不由自主地朝其中填满一些什么东西。</p><p>鸟笼效应”是一个很有意思的规律，人们会在偶然获得一件物品后，会继续添加更多与之相关而的东西。鸟笼效应：假如一个人买了一只空鸟笼放在家里，那么一段时间后，他一般会为了用这只笼子再买一只鸟回来养而不会把笼子丢掉，也就是这个人反而被笼子给异化掉了，成为笼子的俘虏</p><h4 id="沸腾效应"><a href="#沸腾效应" class="headerlink" title="沸腾效应"></a>沸腾效应</h4><p>烧水烧到 99 度时，还不能算开水，其价值有限；若再添一把火，在 99 度的水温基础上再烧使它再升高 1 度，它就会使水沸腾，并产生大量水蒸气可用来开动机器，从而获得巨大的经济效益。这里的 1 度就是关键的因素，这 1 度就能使水发生质的变化，从液体变化为气体。</p><h4 id="穿针效应"><a href="#穿针效应" class="headerlink" title="穿针效应"></a>穿针效应</h4><p>在给小小的缝衣针穿线的时候，你越是全神贯注地努力，线越不容易穿入。在科学界，这种现象也被称为“目的颤抖”，意思是说由于做事过度用力和意念过于集中，反而将平素可以轻松完成的事情搞糟了。　</p><p>　当对某件事情过于重视时，心理就会紧张，而一紧张，往往就会出现心跳加速、精力分散、动作失调等不良反应。很多人在人生的关口失手，心理紧张与焦虑是重要原因之一。</p><h4 id="榴莲效应"><a href="#榴莲效应" class="headerlink" title="榴莲效应"></a>榴莲效应</h4><p>每一个成年人，都如同一个榴莲。</p><p>喜欢的人自然喜欢，不喜欢的人，任凭使出浑身解数，仍难以下咽。</p><p>与人来往，我们更是深陷“榴莲定律”之中。与有些人的关系，总是很容易进入非常微妙的状态。</p><h3 id="话–诗–词–句"><a href="#话–诗–词–句" class="headerlink" title="话–诗–词–句"></a>话–诗–词–句</h3><h5 id="落入归山海，烟火向星辰，所愿皆成真。"><a href="#落入归山海，烟火向星辰，所愿皆成真。" class="headerlink" title="落入归山海，烟火向星辰，所愿皆成真。"></a>落入归山海，烟火向星辰，所愿皆成真。</h5><h5 id="眼中有山河万里，何惧几分秋凉。"><a href="#眼中有山河万里，何惧几分秋凉。" class="headerlink" title="眼中有山河万里，何惧几分秋凉。"></a>眼中有山河万里，何惧几分秋凉。</h5><h4 id="牡丹亭（节选部分）"><a href="#牡丹亭（节选部分）" class="headerlink" title="牡丹亭（节选部分）"></a>牡丹亭（节选部分）</h4><p>惊觉相思不露，原来只因已入骨</p><p>恨不知所起，一往情深</p><p>恨不知所踪，一笑而泯</p><p>人世间有百媚千红</p><p>唯独你，我情有所钟</p><h6 id="站在山巅与日月星辰对话，潜在海底和江河湖底晤谈，和每一颗树握手，和每一株草私语，方知宇宙浩瀚，自然可畏-，生命可敬。"><a href="#站在山巅与日月星辰对话，潜在海底和江河湖底晤谈，和每一颗树握手，和每一株草私语，方知宇宙浩瀚，自然可畏-，生命可敬。" class="headerlink" title="站在山巅与日月星辰对话，潜在海底和江河湖底晤谈，和每一颗树握手，和每一株草私语，方知宇宙浩瀚，自然可畏 ，生命可敬。"></a>站在山巅与日月星辰对话，潜在海底和江河湖底晤谈，和每一颗树握手，和每一株草私语，方知宇宙浩瀚，自然可畏 ，生命可敬。</h6><h5 id="流水不争先，争的是滔滔不绝"><a href="#流水不争先，争的是滔滔不绝" class="headerlink" title="流水不争先，争的是滔滔不绝"></a>流水不争先，争的是滔滔不绝</h5><p>历史书太小，装不下一个波澜壮阔的一生。</p><p>历史书太大，装下了华夏上下五千年</p><p>你随手翻过的一页，用笔划过的内容</p><p>很可能就是他们的一生</p><h4 id="蝴蝶—-破茧后的美丽"><a href="#蝴蝶—-破茧后的美丽" class="headerlink" title="蝴蝶—-破茧后的美丽"></a>蝴蝶—-破茧后的美丽</h4><p>​我感到背后隐隐的痛，转过头去，惊奇的看到一双金色的翅膀。</p><p>​原来我正在一步步接近爱亲近美好，才会认识美好。</p><p>​当我冷眼旁观时，生命是一只蓝色的蛹，当我热情相拥时，生命是一只金色的蝴蝶，破茧而出的过程，也是感情变化的过程，亲近世界过程，用爱的眼睛看世界，我也如此美丽。</p><p>一种现象，就是，即使套上垃圾袋，也没有人觉得垃圾桶很干净。 人呢？</p><h4 id="垓下歌"><a href="#垓下歌" class="headerlink" title="垓下歌"></a>垓下歌</h4><p>力拔山兮气盖世，时不利兮骓不逝。</p><p>骓不逝兮可奈何，虞兮虞兮奈若何！</p><h4 id="题菊花"><a href="#题菊花" class="headerlink" title="题菊花"></a>题菊花</h4><p>飒飒西风满院栽，蕊寒香冷蝶难来。</p><p>他年我若为青帝，报与桃花一处开</p><h4 id="不第后赋菊"><a href="#不第后赋菊" class="headerlink" title="不第后赋菊"></a>不第后赋菊</h4><p>待到秋来九月八，我花开后百花杀。</p><p>冲天香阵透长安，满城尽带黄金甲</p><h4 id="定风波"><a href="#定风波" class="headerlink" title="定风波"></a>定风波</h4><p>王定国歌儿曰柔奴，姓宇文氏，眉目娟丽，善应对，家世住京师。定国南迁归，余问柔：“广南风土， 应是不好？”柔对曰：“此心安处，便是吾乡。”因为缀词云。</p><p>常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。(天应乞与 一作：天教分付； 尽道 一作：自作)<br>万里归来颜愈少。微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。</p><h5 id="横空出世，莽昆仑，阅尽人间春色。"><a href="#横空出世，莽昆仑，阅尽人间春色。" class="headerlink" title="横空出世，莽昆仑，阅尽人间春色。"></a>横空出世，莽昆仑，阅尽人间春色。</h5><p>​—–毛泽东</p><h5 id="他日若逐凌云志，敢笑黄巢不丈夫。"><a href="#他日若逐凌云志，敢笑黄巢不丈夫。" class="headerlink" title="他日若逐凌云志，敢笑黄巢不丈夫。"></a>他日若逐凌云志，敢笑黄巢不丈夫。</h5><p>​—–  施耐安</p><h5 id="凡日月所照，江河所至，皆为汉土。"><a href="#凡日月所照，江河所至，皆为汉土。" class="headerlink" title="凡日月所照，江河所至，皆为汉土。"></a>凡日月所照，江河所至，皆为汉土。</h5><p>​——– 刘洵</p><h5 id="正是江南好景，落花时节又逢君。"><a href="#正是江南好景，落花时节又逢君。" class="headerlink" title="正是江南好景，落花时节又逢君。"></a>正是江南好景，落花时节又逢君。</h5><p>​——- 杜甫</p><h5 id="醉后不知天在水，满船清梦压星河。"><a href="#醉后不知天在水，满船清梦压星河。" class="headerlink" title="醉后不知天在水，满船清梦压星河。"></a>醉后不知天在水，满船清梦压星河。</h5><p>​—— 唐</p><h5 id="云想衣裳花想容，-春风拂槛露华浓。"><a href="#云想衣裳花想容，-春风拂槛露华浓。" class="headerlink" title="云想衣裳花想容， 春风拂槛露华浓。"></a>云想衣裳花想容， 春风拂槛露华浓。</h5><p>​——- 李白</p><h5 id="你走，我不送你；你来，无论多大风雨我都要去接你。"><a href="#你走，我不送你；你来，无论多大风雨我都要去接你。" class="headerlink" title="你走，我不送你；你来，无论多大风雨我都要去接你。"></a>你走，我不送你；你来，无论多大风雨我都要去接你。</h5><p>​—— 梁秋实</p><h5 id="唤起一天明月，照我满怀冰雪，浩荡百川流。"><a href="#唤起一天明月，照我满怀冰雪，浩荡百川流。" class="headerlink" title="唤起一天明月，照我满怀冰雪，浩荡百川流。"></a>唤起一天明月，照我满怀冰雪，浩荡百川流。</h5><p>​—– 辛弃疾</p><h5 id="春宵一刻值千金，花有清香月有阴。"><a href="#春宵一刻值千金，花有清香月有阴。" class="headerlink" title="春宵一刻值千金，花有清香月有阴。"></a>春宵一刻值千金，花有清香月有阴。</h5><p>​</p><h5 id="近水楼台先得月，向阳花木易为春。"><a href="#近水楼台先得月，向阳花木易为春。" class="headerlink" title="近水楼台先得月，向阳花木易为春。"></a>近水楼台先得月，向阳花木易为春。</h5><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>朴树真的  这个笑容 太治愈了</p><iframe src="//player.bilibili.com/player.html?aid=35306111&bvid=BV1Fb411A7Kj&cid=61878827&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>一个有趣的姑娘，哈哈 歌声也非常有趣</p><iframe src="//player.bilibili.com/player.html?aid=812485653&bvid=BV1534y157eb&cid=746826440&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>关于郑州这个也非常好听</p><iframe src="//player.bilibili.com/player.html?aid=426085561&bvid=BV143411K7ph&cid=587984469&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>郭郭的这首 情非得已 666</p><iframe src="//player.bilibili.com/player.html?aid=333753207&bvid=BV1Vw411o7DK&cid=359661944&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      
      
      <categories>
          
          <category> 爱好 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人爱好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iuv_5g组网问题表</title>
      <link href="/post/cb9ba91b.html"/>
      <url>/post/cb9ba91b.html</url>
      
        <content type="html"><![CDATA[<p>这篇文章博主会持续更新，主要都是一些博主和小伙伴们在组网过程中遇到的相关问题</p><h4 id="软件更新带来的相关问题"><a href="#软件更新带来的相关问题" class="headerlink" title="软件更新带来的相关问题"></a>软件更新带来的相关问题</h4><h5 id="无线核心网设备连线问题"><a href="#无线核心网设备连线问题" class="headerlink" title="无线核心网设备连线问题"></a>无线核心网设备连线问题</h5><p>1、 BBU与ITBBU之间连线问题</p><p>2、 BBU中用于连接SPN的两个接口连线问题</p><h5 id="核心网问题"><a href="#核心网问题" class="headerlink" title="核心网问题"></a>核心网问题</h5><p>1、 核心网信令链路故障</p><p>2、开户信息错误</p><p>3、无线公共参数错误</p><p>4、 N2链路故障</p><h5 id="无线网络问题"><a href="#无线网络问题" class="headerlink" title="无线网络问题"></a>无线网络问题</h5><p>1、 S1-C链路故障</p><p>2、5G网络不可用</p><p>2、 DU小区不可用</p><p>3、X2&#x2F;F1&#x2F;E1链路故障无5G信号</p><p>4、SCG分流通道缺失</p><h5 id="承载网问题"><a href="#承载网问题" class="headerlink" title="承载网问题"></a>承载网问题</h5><p>1、 直连地址PING不通的原因软件问题</p><h5 id="无线核心网设备连线问题-1"><a href="#无线核心网设备连线问题-1" class="headerlink" title="无线核心网设备连线问题"></a>无线核心网设备连线问题</h5><p>1、BBU与ITBBU之间连线问题</p><p>（1）因为软件升级后去掉了一种连接方式，目前BBU与ITBBU的通信主要通过SPN,现在连线方式主要是BBU接SPN,ITBBU接SPN。</p><p>（2）ITBBU中主要是CUCP与CUUP对接，CUCP需配置去BBU的控制面路由、CUUP需配置去BBU用户面的路由</p><p>2、BBU中用于连接SPN的两个接口连线问题<br>（1）BBU与SPN可以同时使用光纤和网线同时接线，但建议选择其中一种，如选择光纤接口，注意速率一定要连接GE的带宽，如果是其他速率业务会做不通</p><h5 id="核心网问题-1"><a href="#核心网问题-1" class="headerlink" title="核心网问题"></a>核心网问题</h5><p>1、核心网信令链路故障<br>（1）MME的接口地址、设备连线、SGW的接口地址、设备连线、PGW的接口地址、设备连线、HSS的接口地址、设备连线</p><p>（2）MME与BBU的偶联配置、双向路由</p><p>（3）MME与HSS的对接配置、双向路由</p><p>（4）MME与SGW的S11对接配置、双向路由</p><p>（5）接口IP配置， 与MME&#x2F;HSS对接配置</p><p>2、开户信息错误<br>（1）检查HSS中的APN参数是否与DU管理中的QOS保持一致</p><p>（2）检查终端是否与HSS中签约信息的IMSI保持一致</p><p>（3）检查APN是否与profile、用户签约标识一一对应</p><p>3、无线公共参数错误<br>（1）MME中MCC和MNC、SGW中PLMN相关MCC和MNC、PGW中相关MCC和MNC无线网问题是否与无线部分MCC和MNC对应，涉及到MCC和MNC的参数都需要检查Hhtp通信故障：</p><p>（1）检查八个网元的虚拟接口IP地址、VLAN</p><p>（2）检查第一项所说的http的IP地址是否对应</p><p>（3）检查所有的路由配置，双向需检查</p><p>4、N2链路故障<br>（1）检查AMF与CUCP对接配置、路由, SCTP等地方</p><p>（2）核心网服务器没有与交换机相连</p><h5 id="无线网络问题-1"><a href="#无线网络问题-1" class="headerlink" title="无线网络问题"></a>无线网络问题</h5><p>1、S1-C链路故障<br>（1）实验模式下检查MME与eNodeB的偶联配置、MME侧静态路由配置</p><p>（2）工程模式下检查MME与BBU的路由配置是否可以PING通</p><p>（3）排除以上两种后继续出现S1-C故障，是因为一个核心网下可以建立多个基站，其他站点没有配置的原因</p><p>2、5G网络不可用<br>(1)检查BBU中“NR邻接小区配置”参数，每一个小区需要和DU小区对应；</p><p>(2) 检查邻接关系配置中的参数是否与DU小区标识一致。</p><p>(3) 检查DU管理中的DU标识是否与前两项一致。</p><p>(4) DU小区中物理小区ID与BBU中的TDD小区PCI一致</p><p>2、DU小区不可用<br>（1）检查DU小区配置所有参数需检查，频段、中心载频、带宽等</p><p>（2）检查BWPUL和BWPDL的参数是否与第一项对应</p><p>（3）检查PRACH、SRS信道中标识是否与第一项中参数对应、SLOT序号是否与帧结构类型对应</p><p>（4）检查小区业务参数配置中的帧结构、时间、符号等参数</p><p>（5）检查一下扇区载波</p><p>3、X2&#x2F;F1&#x2F;E1链路故障无5G信号</p><p>（1）检查BBU与CUCP之间的SCTP对接配置及路由配置、CUUP去BBU的路由配置、网关</p><p>（2）检查CUCP与DU之间的对接配置、及IP地址VLAN、网关等</p><p>（3）检查CUUP与CUCP之间的对接配置及IP地址VLAN、网关等</p><p>4、SCG分流通道缺失</p><p>（1）检查SGW与CUUP之间的对接配置、路由配置</p><p>（2）检查CUUP与SGW之间的路由配置</p><p>承载网问题</p><p>1、直连地址PING不通的原因</p><p>（1）检查设备连线端口速率、两端端口速率是否保持一致，如有ODF架检查一下ODF架的端口</p><p>（2）检查直连IP地址是否处于同一个网段，子网掩码有没有配置正确</p><h4 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h4><ol><li><p>找不到用户归属HSS<br>检查号码分析和diameter连接</p></li><li><p>数据传输中断检查<br>BBU-SGW，或者SGW -PGW的对接以及路由</p></li><li><p>cu部署错误检查<br>ITBBU的CUDU合设与分离问题</p></li><li><p>无线公共参数错误l<br>检查MCC，MNC，PLMN是否一致，检查基站标识，enodeB标识是否一致（同一个PLMN的基站标识不能一致），检查AAU频段是否与小区频段相符合，TDD小区配置</p></li><li><p>小区容量受限<br>小区接纳控制未配置或配置错误</p></li><li><p>s6a链路故障<br>检查MME跟HSS的设备配置，IP，对接路由</p></li><li><p>找不到相关的SGW<br>查找EPC地址解析:地址、协议、名称</p></li><li><p>找不到相关的PGW<br>查找APN地址解析:地址、协议、名称</p></li><li><p>S5S8控制面路由不可达<br>查找SGW与PGW的对接配置、路由:且的地址、下一跳</p></li><li><p>S11接口链路故障<br>查找SGW与MME的S11控制对接、路由</p></li><li><p>S1-ME核心网信令链路故障<br>查找ME与基站偶联配置:本端和对端端口、地址两端一定要对应、路由; MME物理接口地址、掩码;</p></li><li><p>vS1-C控制面链路不可达<br>实验模式下:查看BBU中SCTP与核心网MME的偶联对接参数<br>工程模式下:验证承载网通不通、对接参数路由问题</p></li><li><p>开户信息错误<br>查找HSS中用户签约数据中所有参数是否与终端对应、所有网元中MCC和MNC是否都保持一-致</p></li><li><p>找不到用户APN<br>查找所有出现APN名称的地方例如HSS中的APN名称是否和终端APN名称对应，地址池中的对应_</p></li><li><p>射频资源故障<br>频率范围要包含进去小区的频率范围。使能开关必须打开，承载链路和SPN连线相关，用光纤选择光亘</p></li><li><p>物理参数配置<br>5G-DU-物理信息-NPRACH-根序列索引，所有小区都要配置成不一样的数值,即使是另一个城市的也不</p></li><li><p>5G网络不可用<br>IDNR邻接关系中要和DU管理对应上，另外首先保证所有小区参数都是正确的，例如TAC是查和核心网保护</p></li><li><p>DU小区不可用<br>5G小区频率与4G BBU-NR邻接关系实际频点对应; 4G小区频率与AAU射频对应，只要出现频率的地方都:<br>小区参数配置等—对应的地方均可检查， 直接检查DU小区配置BWPUL, BWPDL, PRACH,SRS,小区业务参数配置等与DU小区相关配置。</p></li><li><p>E1、F1链路故障<br>看SCTP对接配置，端口、IP地址。CUUP到BBU的用户面路由没有配置。</p></li><li><p>无5G信号<br>5G小区频段接口连线cu du SCTP对接; CPS与ITBBU的连线， BBU中得IP配置</p></li><li><p>搜索不到小区信号<br>基站标识所有地方需对应</p></li><li><p>SCC分流通道缺失<br>检查SGW与CUUP的双向路由;分流模式选择SCC split模式;</p></li><li><p>网络模式错误<br>|检查BBU基本网元配置与ITBBU中网元配置是否一一对应:例如网络模式，时钟同步模式等</p></li><li><p>无线公共参数错误</p><p>检查Du管理，Cu管理，NR网元管理， 5G物理参数 mcc, mnc,plmn等公共参数，还有可能问题出在核心网哪里的公共参数问题。</p></li><li><p>http通信故障</p><p>检查http配置，虚拟路由配置，sw问题</p></li><li><p>N2链路故障</p><p>除了上面已经说过的问题还有，一个就是去检查一下 ITBBU 与spn设备之间的问题（博主这个问题检查了3个小时的数据配置，竟然忘了设备之间的连线了）</p></li><li><p>小区频率资源错误</p><p>这个 主要检查一下与频率相关的配置数据</p></li><li><p>分配用户地址失效</p><p>主要检查一下PGW,地址池配置等地方。</p></li><li><p>SBI接口故障</p><p>检查一下http配置</p></li><li><p>搜索不到小区</p><p>4G&#x2F;5G物理参数配置</p></li><li><p>小区有告警</p><p>检查NR网元，接纳控制配置，du小区</p></li><li><p>数据通道错误</p><p>检查承载网中的 spn</p></li><li><p>找不到HSS归属</p><p>检查一下MME中与HSS有关的配置 和 HSS中的相关配置</p></li><li><p>4G小区配置错误</p><p>检查 邻接关系表配置，NR邻接小区配置，TDD小区配置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 组网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iuv_5g </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫简单案例</title>
      <link href="/post/748fa00c.html"/>
      <url>/post/748fa00c.html</url>
      
        <content type="html"><![CDATA[<p>说明一下 这个文章博主会持续更新的。</p><p>主要是分享一些博主自己写的一些爬虫和网上其他博主分享的爬虫，。</p><p>有错误的地方 欢迎加联系方式一起交流。</p><h4 id="更新一"><a href="#更新一" class="headerlink" title="更新一"></a>更新一</h4><h5 id="爬虫实现在‘必应’上搜索和页面的保持"><a href="#爬虫实现在‘必应’上搜索和页面的保持" class="headerlink" title="爬虫实现在‘必应’上搜索和页面的保持"></a>爬虫实现在‘必应’上搜索和页面的保持</h5><p>这个小案例 主要使用的是urllib库的相关比较基础的的知识，适合初学者玩</p><p>代码可以直接运行</p><figure class="highlight plaintext"><figcaption><span>urllib import request</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line"></span><br><span class="line">def get_url(word):</span><br><span class="line">  url = &#x27;https://cn.bing.com/search?&#123;&#125;&#x27;</span><br><span class="line">  #此处使用urlencode()进行编码</span><br><span class="line">  params = parse.urlencode(&#123;&#x27;q&#x27; : &#x27;菜鸟&#x27;&#125;)</span><br><span class="line">  url = url.format(params)</span><br><span class="line">  return url</span><br><span class="line">#发请求,保存本地文件</span><br><span class="line">def request_url(url,filename):</span><br><span class="line">  headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&#x27;&#125;</span><br><span class="line">  req = request.Request(url=url,headers=headers)</span><br><span class="line">  res = request.urlopen(req)</span><br><span class="line">  html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">  #这里要注意这个编码格式 不然有可能回出现一堆乱码</span><br><span class="line">  with open(filename,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">    f.write(html)</span><br><span class="line"></span><br><span class="line">word = input(&#x27;请输入搜索内容:&#x27;)</span><br><span class="line">url = get_url(word)</span><br><span class="line">filename = word + &#x27;.html&#x27;</span><br><span class="line">request_url(url,filename)</span><br></pre></td></tr></table></figure><h5 id="爬取百度贴吧"><a href="#爬取百度贴吧" class="headerlink" title="爬取百度贴吧"></a>爬取百度贴吧</h5><p>这是爬的一个静态的网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request,parse</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from ua_info import ua_list #使用自定义的ua池</span><br><span class="line"></span><br><span class="line">class TiebaSpider(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url=&#x27;http://tieba.baidu.com/f?&#123;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">    def get_html(self,url):</span><br><span class="line">        req=request.Request(url=url,headers=&#123;&#x27;User-Agent&#x27;:random.choice(ua_list)&#125;)</span><br><span class="line">        res=request.urlopen(req)</span><br><span class="line">        html=res.read().decode(&quot;gbk&quot;,&quot;ignore&quot;)</span><br><span class="line">        return html</span><br><span class="line"></span><br><span class="line">    def save_html(self,filename,html):</span><br><span class="line">        with open(filename,&#x27;w&#x27;) as f:</span><br><span class="line">            f.write(html)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        name=input(&#x27;请输入贴吧名：&#x27;)</span><br><span class="line">        begin=int(input(&#x27;输入起始页：&#x27;))</span><br><span class="line">        stop=int(input(&#x27;输入终止页：&#x27;))</span><br><span class="line">        for page in range(begin,stop+1):</span><br><span class="line">            pn=(page-1)*50</span><br><span class="line">            params=&#123;</span><br><span class="line">                &#x27;kw&#x27;:name,</span><br><span class="line">                &#x27;pn&#x27;:str(pn)</span><br><span class="line">            &#125;</span><br><span class="line">            #拼接URL地址   </span><br><span class="line">            params=parse.urlencode(params)</span><br><span class="line">            url=self.url.format(params)</span><br><span class="line"></span><br><span class="line">            html=self.get_html(url)</span><br><span class="line"></span><br><span class="line">            filename=&#x27;&#123;&#125;-&#123;&#125;页.html&#x27;.format(name,page)</span><br><span class="line">            self.save_html(filename,html)</span><br><span class="line">            #提示</span><br><span class="line">            print(&#x27;第%d页抓取成功&#x27;%page)</span><br><span class="line">            #每爬取一个页面随机休眠1-2秒钟的时间，为不被抓了</span><br><span class="line">            time.sleep(random.randint(1,2))</span><br><span class="line">#统计程序运行的时间</span><br><span class="line">start=time.time()</span><br><span class="line">spider=TiebaSpider() </span><br><span class="line">spider.run() </span><br><span class="line">end=time.time()</span><br><span class="line">print(&#x27;执行时间:%.2f&#x27;%(end-start))  #爬虫执行时间</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="更新二"><a href="#更新二" class="headerlink" title="更新二"></a>更新二</h4><h5 id="爬取-豆瓣电影排行榜"><a href="#爬取-豆瓣电影排行榜" class="headerlink" title="爬取 豆瓣电影排行榜"></a>爬取 豆瓣电影排行榜</h5><p>这是静态网站，爬起来比较简单</p><p>主要使用了正则表达式和csv文件操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">from urllib import request</span><br><span class="line">import random</span><br><span class="line">from ua_info import ua_list</span><br><span class="line">import csv</span><br><span class="line">url = &#x27;https://movie.douban.com/chart&#x27;</span><br><span class="line">p = re.compile(&#x27;&lt;tr.*?title=&quot;(.*?)&quot;.*?&lt;p class=&quot;pl&quot;&gt;(.*?)&lt;/p&gt;.*?/tr&gt;&#x27;,re.S)</span><br><span class="line">headers = &#123;&#x27;User-Agent&#x27;:random.choice(ua_list)&#125;</span><br><span class="line">r = request.Request(url = url, headers=headers)</span><br><span class="line">res = request.urlopen(r)</span><br><span class="line">response = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line"># print(response)</span><br><span class="line"># print(p.findall(response)) </span><br><span class="line">w =p.findall(response)</span><br><span class="line">with open( &#x27;doupan.csv&#x27;,&#x27;w&#x27;,newline=&#x27;&#x27;,encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">    spamwriter = csv.writer(f, delimiter=&#x27; &#x27;,quotechar=&#x27;|&#x27;)</span><br><span class="line">    spamwriter.writerow([&#x27;电影&#x27;,&#x27;上映时间和演员&#x27;])</span><br><span class="line">    spamwriter.writerows(w)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="爬取-一页豆瓣电影排行top250电影名"><a href="#爬取-一页豆瓣电影排行top250电影名" class="headerlink" title="爬取 一页豆瓣电影排行top250电影名"></a>爬取 一页豆瓣电影排行top250电影名</h5><p>也是一个静态网站 属于基础操作系列</p><p>如果想爬取整个top250 也比较简单</p><p>先观察一下上面每一页的url的特征 ，再做出一定的更改就好了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">class Spider_douban:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.url=&#x27;https://movie.douban.com/top250&#x27;</span><br><span class="line">    self.headers=&#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&#x27;&#125;</span><br><span class="line">  </span><br><span class="line">  def requ(self):</span><br><span class="line">    html = requests.get(url = self.url, headers=self.headers).text</span><br><span class="line">    p = etree.HTML(html)</span><br><span class="line">    pa = &#x27;//a/img/@alt&#x27;</span><br><span class="line">    pb = str(p.xpath(pa))</span><br><span class="line">    with open(&#x27;xiaoyang.txt&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">      f.write(pb)</span><br><span class="line">  def run(self):</span><br><span class="line">    self.requ()</span><br><span class="line">    </span><br><span class="line">a = Spider_douban()</span><br><span class="line">a.run()</span><br></pre></td></tr></table></figure><h5 id="爬取百度图片"><a href="#爬取百度图片" class="headerlink" title="爬取百度图片"></a>爬取百度图片</h5><p>注意 博主这里用的是 以前翻页式的百度图片网站 。</p><p>这里使用的是requests库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">from urllib import parse</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">class BaiduImageSpider(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url = &#x27;https://image.baidu.com/search/flip?tn=baiduimage&amp;word=&#123;&#125;&#x27;</span><br><span class="line">        self.headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/4.0&#x27;&#125;</span><br><span class="line"></span><br><span class="line">    # 获取图片</span><br><span class="line">    def get_image(self,url,word):</span><br><span class="line">        #使用 requests模块得到响应对象</span><br><span class="line">        res= requests.get(url,headers=self.headers)</span><br><span class="line">        # 更改编码格式</span><br><span class="line">        res.encoding=&quot;utf-8&quot;</span><br><span class="line">        # 得到html网页</span><br><span class="line">        html=res.text</span><br><span class="line">        print(html)</span><br><span class="line">        #正则解析</span><br><span class="line">        pattern = re.compile(&#x27;&quot;hoverURL&quot;:&quot;(.*?)&quot;&#x27;,re.S)</span><br><span class="line">        img_link_list = pattern.findall(html)</span><br><span class="line">        #存储图片的url链接 </span><br><span class="line">        print(img_link_list)</span><br><span class="line"></span><br><span class="line">        # 创建目录，用于保存图片</span><br><span class="line">        directory = &#x27;D:/File/All/python/spider/image/&#123;&#125;/&#x27;.format(word)</span><br><span class="line">        # 如果目录不存在则创建，此方法常用</span><br><span class="line">        if not os.path.exists(directory):</span><br><span class="line">            os.makedirs(directory)</span><br><span class="line">        </span><br><span class="line">        #添加计数 D:\File\All\python\spider\爬虫.html</span><br><span class="line">        i = 1</span><br><span class="line">        for img_link in img_link_list:</span><br><span class="line">            filename = &#x27;&#123;&#125;&#123;&#125;_&#123;&#125;.jpg&#x27;.format(directory, word, i)</span><br><span class="line">            self.save_image(img_link,filename)</span><br><span class="line">            i += 1</span><br><span class="line">    #下载图片</span><br><span class="line">    def save_image(self,img_link,filename):</span><br><span class="line">        html = requests.get(url=img_link,headers=self.headers).content</span><br><span class="line">        with open(filename,&#x27;wb&#x27;) as f:</span><br><span class="line">            f.write(html)</span><br><span class="line">        print(filename,&#x27;下载成功&#x27;)</span><br><span class="line"></span><br><span class="line">    # 入口函数 </span><br><span class="line">    def run(self):</span><br><span class="line">        word = input(&quot;您想要谁的照片：&quot;)</span><br><span class="line">        word_parse = parse.quote(word)</span><br><span class="line">        url = self.url.format(word_parse)</span><br><span class="line">        self.get_image(url,word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spider = BaiduImageSpider()</span><br><span class="line">spider.run()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sys模块的简单使用</title>
      <link href="/post/9b841354.html"/>
      <url>/post/9b841354.html</url>
      
        <content type="html"><![CDATA[<p>sys模块使用的相对较少，这里博主的学习笔记也比较简单</p><h4 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h4><p>sys模块是与python解释器交互的一个接口</p><p>该模块提供对解释器使用或维护的一些变量的访问和获取</p><p>它提供了许多函数和变量来处理 Python 运行时环境的不同部分</p><p>常见用法介绍</p><h5 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h5><p>实现从程序的外部向程序传递参数</p><p>返回的是一个列表，第一个元素是程序文件名，后面的元素都是程序外部传入的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.argv)</span><br><span class="line">uu=sys.argv</span><br><span class="line">if uu==&quot;Jack&quot;:</span><br><span class="line">    print(f&quot;i am &#123;uu&#125;&quot;)</span><br><span class="line">else:</span><br><span class="line">    for i in range(1,len(sys.argv)):</span><br><span class="line">        print(f&quot;i am &#123;sys.argv&#125;&quot;)</span><br></pre></td></tr></table></figure><h5 id="sys-exit-n-退出程序"><a href="#sys-exit-n-退出程序" class="headerlink" title="sys.exit(n) 退出程序"></a>sys.exit(n) 退出程序</h5><p>退出程序, 正常退出时 sys.exit(0), 其他为异常退出一般情况下运行到主程序尾部, 解释器就正常退出了, 但如果想要中途退出, 就可以调用 sys.exit 函数</p><h5 id="sys-version-获取Python解释程序的版本信息"><a href="#sys-version-获取Python解释程序的版本信息" class="headerlink" title="sys.version 获取Python解释程序的版本信息"></a>sys.version 获取Python解释程序的版本信息</h5><h5 id="sys-platform-返回操作系统平台名称"><a href="#sys-platform-返回操作系统平台名称" class="headerlink" title="sys.platform 返回操作系统平台名称"></a>sys.platform 返回操作系统平台名称</h5><h5 id="sys-stdin-readline-与input"><a href="#sys-stdin-readline-与input" class="headerlink" title="sys.stdin.readline()与input"></a>sys.stdin.readline()与input</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"># sys.stdin.readline() 相当于input，区别在于input不会读入&#x27;\n&#x27;</span><br><span class="line">aa = sys.stdin.readline()# 输入数据多一个&#x27;\n&#x27;</span><br><span class="line">bb = input(&#x27;请输入：&#x27;)</span><br><span class="line"> </span><br><span class="line">print(len(aa))</span><br><span class="line">print(len(bb))</span><br></pre></td></tr></table></figure><p>可以看出：</p><p>sys.stdin.readline()方式与input方式的区别是：len(aa)元素中多了一个‘\n’换行符。即sys.stdin.readline()方式会读入换行符。</p><p>还有一个区别在于，input()里面可以直接传入文本，然后打印出来。</p><h5 id="sys-stdout与print"><a href="#sys-stdout与print" class="headerlink" title="sys.stdout与print"></a>sys.stdout与print</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.stdout.write(&#x27;hello&#x27; + &#x27;\n&#x27;)</span><br><span class="line">print(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># sys.stdin.readline() 相当于input，区别在于input不会读入&#x27;\n&#x27;</span><br><span class="line">aa = sys.stdin.readline()</span><br><span class="line">bb = input(&#x27;请输入：&#x27;)</span><br><span class="line"></span><br><span class="line">sys.stdout.write(str(len(aa)) + &#x27;\n&#x27;)  # 默认无法实现print方式的sep参数功能，所以需要手动在后面添加一个换行符</span><br><span class="line">print(len(bb))</span><br></pre></td></tr></table></figure><h5 id="sys模块中所有的函数"><a href="#sys模块中所有的函数" class="headerlink" title="sys模块中所有的函数"></a>sys模块中所有的函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Python中sys模块：该模块提供对解释器使用或维护的一些变量的访问，以及与解释器强烈交互的函数</span><br><span class="line"></span><br><span class="line"># sys.argv #命令行参数List，第一个元素是程序本身路径</span><br><span class="line"># sys.modules.keys() #返回所有已经导入的模块列表</span><br><span class="line"># sys.exc_info() #获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</span><br><span class="line"># sys.exit(n) #程序，正常退出时exit(0)</span><br><span class="line"># sys.hexversion #获取Python解释程序的版本值，16进制格式如：0x020403F0</span><br><span class="line"># sys.version #获取Python解释程序的版本信息</span><br><span class="line"># sys.maxint #最大的Int值</span><br><span class="line"># sys.maxunicode #最大的Unicode值</span><br><span class="line"># sys.modules #返回系统导入的模块字段，key是模块名，value是模块</span><br><span class="line"># sys.path #返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</span><br><span class="line"># sys.platform #返回操作系统平台名称</span><br><span class="line"># sys.stdout #标准输出</span><br><span class="line"># sys.stdin #标准输入</span><br><span class="line"># sys.stderr #错误输出</span><br><span class="line"># sys.exc_clear() #用来清除当前线程所出现的当前的或最近的错误信息</span><br><span class="line"># sys.exec_prefix #返回平台独立的python文件安装的位置</span><br><span class="line"># sys.byteorder #本地字节规则的指示器，big-endian平台的值是&#x27;big&#x27;,little-endian平台的值是&#x27;little&#x27;</span><br><span class="line"># sys.copyright #记录python版权相关的东西</span><br><span class="line"># sys.api_version #解释器的C的API版本</span><br><span class="line"># sys.version_info #获取Python解释器的版本信息</span><br><span class="line"># sys.getwindowsversion #获取Windows的版本</span><br><span class="line"># sys.getdefaultencoding #返回当前你所用的默认的字符编码格式</span><br><span class="line"># sys.getfilesystemencoding #返回将Unicode文件名转换成系统文件名的编码的名字</span><br><span class="line"># sys.setdefaultencoding(name) #用来设置当前默认的字符编码</span><br><span class="line"># sys.builtin_module_names #Python解释器导入的模块列表</span><br><span class="line"># sys.executable #Python解释程序路径</span><br><span class="line"># sys.stdin.readline #从标准输入读一行，sys.stdout.write(&quot;a&quot;) 屏幕输出a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见爬虫知识</title>
      <link href="/post/fa1e8add.html"/>
      <url>/post/fa1e8add.html</url>
      
        <content type="html"><![CDATA[<h4 id="简单的python爬虫程序"><a href="#简单的python爬虫程序" class="headerlink" title="简单的python爬虫程序"></a>简单的python爬虫程序</h4><p>使用 Python 内置的 urllib 库获取网页的 html 信息</p><p>获取网页html信息</p><ol><li>获取响应对象向百度（<a href="http://www.baidu.com/%EF%BC%89%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E9%A6%96%E9%A1%B5%E7%9A%84">http://www.baidu.com/）发起请求，获取百度首页的</a> HTML 信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"># urlopen()向URL发请求,返回响应对象</span><br><span class="line">response=urllib.request.urlopen(&#x27;http://www.baidu.com/&#x27;)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>其中 urlopen() 表示打开一个网页地址。</p><p><strong>注意：请求的 url 必须带有 http 或者 https 传输协议。</strong></p><ol start="2"><li>输出HTML信息</li></ol><p>在上述代码的基础上继续编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#提取响应内容</span><br><span class="line">html = response.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>通过调用 response 响应对象的 read() 方法提取 HTML 信息，该**方法返回的结果是字节串类型(bytes)**，因此需要使用 decode() 转换为字符串。</p><h4 id="urllib常用方法"><a href="#urllib常用方法" class="headerlink" title="urllib常用方法"></a>urllib常用方法</h4><p>爬虫库 urllib中的常用方法</p><ol><li>urlopen()表示向网站发起请求并获取响应对象</li></ol><p>urllib.request.urlopen(url,timeout)<br>参数说明：<br>url：表示要爬取数据的 url 地址<br>timeout：设置等待超时时间，指定时间内未得到响应则抛出超时异常</p><ol start="2"><li>Request()该方法用于创建请求对象、包装请求头，比如重构 User-Agent（即用户代理，指用户使用的浏览器）使程序更像人类的请求，而非机器。<br>urllib.request.Request(url,headers)</li></ol><p>参数说明：<br>url：请求的URL地址。<br>headers：重构请求头。</p><ol start="3"><li>html响应对象方法</li></ol><p>bytes &#x3D; response.read() # 返回结果为 bytes 数据类型</p><p>string &#x3D; response.read().decode() # decode()将字节串转换为 string 类型</p><p>url &#x3D; response.geturl() # 返回响应对象的URL地址</p><p>code &#x3D; response.getcode() # 返回请求时的HTTP响应码</p><ol start="4"><li>编码解码操作</li></ol><p>#字符串转换为字节码<br>string.encode(“utf-8”)<br>#字节码转换为字符串<br>bytes.decode(“utf-8”) </p><h4 id="User-Agent（用户代理）"><a href="#User-Agent（用户代理）" class="headerlink" title="User-Agent（用户代理）"></a>User-Agent（用户代理）</h4><p>User-Agent 即用户代理，简称“UA”，它是一个特殊字符串头<br>网站服务器通过识别 “UA”来确定用户所使用的操作系统版本、CPU 类型、浏览器版本等信息。而网站服务器则通过判断 UA 来给客户端发送不同的页面。</p><p>网站通过识别请求头中 User-Agent 信息来判断是否是爬虫访问网站。如果是，网站首先对该 IP 进行预警，对其进行重点监控，当发现该 IP 超过规定时间内的访问次数， 将在一段时间内禁止其再次访问网站</p><h5 id="爬虫程序UA信息"><a href="#爬虫程序UA信息" class="headerlink" title="爬虫程序UA信息"></a>爬虫程序UA信息</h5><p>通过向 HTTP 测试网站（<a href="http://httpbin.org/%EF%BC%89%E5%8F%91%E9%80%81">http://httpbin.org/）发送</a> GET 请求来查看请求头信息，从而获取爬虫程序的 UA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">#向网站发送get请求</span><br><span class="line">response=urllib.request.urlopen(&#x27;http://httpbin.org/get&#x27;)</span><br><span class="line">html = response.read().decode()</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：httpbin.org 这个网站能测试 HTTP 请求和响应的各种信息，比如 cookie、IP、headers 和登录验证等，且支持 GET、POST 等多种方法，对 Web 开发和测试很有帮助。</p><h5 id="重构爬虫UA信息"><a href="#重构爬虫UA信息" class="headerlink" title="重构爬虫UA信息"></a>重构爬虫UA信息</h5><p>ua信息可以百度得到 一大片然后再复制过来</p><p>下面使用urllib.request.Request()方法重构 User-Agent 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line">url = &#x27;http://httpbin.org/get&#x27; #向测试网站发送请求</span><br><span class="line">#重构请求头，伪装成 Mac火狐浏览器访问，可以使用上表中任意浏览器的UA信息</span><br><span class="line">headers = &#123;</span><br><span class="line">&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:65.0) Gecko/20100101 Firefox/65.0&#x27;&#125;</span><br><span class="line"></span><br><span class="line">#创建请求对象，包装ua信息</span><br><span class="line">req = request.Request(url=url,headers=headers)</span><br><span class="line">#发送请求，获取响应对象</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">html = res.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>上述代码重构了 User-Agent 字符串信息，这样就解决了网站通过识别 User-Agent 来封杀爬虫程序的问题。</p><p>重构 UA 也可以通过其他模块实现，比如 requests 模块。</p><h5 id="构建User-Agnet代理池"><a href="#构建User-Agnet代理池" class="headerlink" title="构建User-Agnet代理池"></a>构建User-Agnet代理池</h5><p>在编写爬虫程序时，一般都会构建一个 User-Agent （用户代理）池，就是把多个浏览器的 UA 信息放进列表中，然后再从中随机选择。构建用户代理池，能够避免总是使用一个 UA 来访问网站，因为短时间内总使用一个 UA 高频率访问的网站，可能会引起网站的警觉，从而封杀掉 IP。</p><p>自定义UA代理池</p><p>构建代理池的方法也非常简单，当前文件的工作目录中定义一个 py 文件，并将以下 UA 信息以列表的形式粘贴到该文件中再在需要的地方引用这个文件就好</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ua_list = [</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;,</span><br><span class="line">    &#x27;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;,</span><br><span class="line">    &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&#x27;,</span><br><span class="line">    &#x27; Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&#x27;,</span><br><span class="line">    &#x27; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>python中有专门的第三方的模块来随机获取浏览器 UA 信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from fake_useragent import UserAgent</span><br><span class="line">#实例化一个对象</span><br><span class="line">ua=UserAgent()</span><br><span class="line">#随机获取一个ie浏览器ua</span><br><span class="line">print(ua.ie)</span><br><span class="line">#随机获取一个火狐浏览器ua</span><br><span class="line">print(ua.firefox)</span><br></pre></td></tr></table></figure><h4 id="Python实现编码与解码"><a href="#Python实现编码与解码" class="headerlink" title="Python实现编码与解码"></a>Python实现编码与解码</h4><p>Python 的标准库urllib.parse模块中提供了用来编码和解码的方法，分别是 urlencode() 与 unquote() 方法。</p><p>urlencode()<br>该方法实现了对 url 地址的编码操作</p><p>unquote()<br>该方法将编码后的 url 地址进行还原，被称为解码</p><ol><li>编码urlencode()<br>打开百度首页，在搜索框中输入“爬虫”，然后点击“百度一下”。当搜索结果显示后，此时地址栏的 URL 信息，如下所示：<a href="https://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB&amp;rsv_spt=1&amp;rsv_iqid=0xa3ca348c0001a2ab&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ib&amp;rsv_sug3=8&amp;rsv_sug1=7&amp;rsv_sug7=101">https://www.baidu.com/s?wd=爬虫&amp;rsv_spt=1&amp;rsv_iqid=0xa3ca348c0001a2ab&amp;issp=1&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=2&amp;ie=utf8&amp;tn=baiduhome_pg&amp;rsv_enter=1&amp;rsv_dl=ib&amp;rsv_sug3=8&amp;rsv_sug1=7&amp;rsv_sug7=101</a></li></ol><p>可以看出 URL 中有很多的查询字符串，而第一个查询字符串就是“wd&#x3D;爬虫”，其中 wd 表示查询字符串的键，而“爬虫”则代表您输入的值。在网页地址栏中删除多余的查询字符串，最后显示的 URL 如下所示：<a href="https://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB">https://www.baidu.com/s?wd=爬虫</a></p><p>使用搜索修改后的 URL 进行搜索，依然会得到相同页面。因此可知“wd”参数是百度搜索的关键查询参数。</p><p>下面编写爬虫程序对 “wd&#x3D;爬虫”进行编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">#构建查询字符串字典</span><br><span class="line">query_string = &#123;&#x27;wd&#x27; : &#x27;爬虫&#x27;&#125;</span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line">#使用format函数格式化字符串，拼接url地址</span><br><span class="line">url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;.format(result)</span><br><span class="line">print(url)</span><br></pre></td></tr></table></figure><p>编码后的 URL 地址依然可以通过地网页址栏实现搜索功能。</p><p>除了使用 urlencode() 方法之外，也可以使用 quote(string) 方法实现编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">#注意url的书写格式，和 urlencode存在不同</span><br><span class="line">url = &#x27;http://www.baidu.com/s?wd=&#123;&#125;&#x27;</span><br><span class="line">word = input(&#x27;请输入要搜索的内容:&#x27;)</span><br><span class="line">#quote()只能对字符串进行编码</span><br><span class="line">query_string = parse.quote(word)</span><br><span class="line">print(url.format(query_string))</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：quote() 只能对字符串编码，而 urlencode() 可以直接对查询字符串字典进行编码。</p><p>因此在定义 URL 时，需要注意两者之间的差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#urllib.parse</span><br><span class="line">urllib.parse.urlencode(&#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;) #字典</span><br><span class="line">urllib.parse.quote(string) #字符串</span><br></pre></td></tr></table></figure><ol start="2"><li>解码unquote(string)解码是对编码后的 URL 进行还原的一种操作</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from urllib import parse</span><br><span class="line">string = &#x27;%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">result = parse.unquote(string)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ol start="3"><li>URL地址拼接方式</li></ol><p>介绍三种拼接 URL 地址的方法。除了使用 format() 函数外，还可以使用字符串相加，以及字符串占位符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1、字符串相加</span><br><span class="line">  baseurl = &#x27;http://www.baidu.com/s?&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = baseurl + params</span><br><span class="line"></span><br><span class="line"># 2、字符串格式化（占位符）</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?%s&#x27;% params</span><br><span class="line"></span><br><span class="line"># 3、format()方法</span><br><span class="line">  url = &#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span><br><span class="line">  params=&#x27;wd=%E7%88%AC%E8%99%AB&#x27;</span><br><span class="line">  url = url.format(params)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Python-re模块用法"><a href="#Python-re模块用法" class="headerlink" title="Python re模块用法"></a>Python re模块用法</h4><p>在 Python 爬虫过程中，实现网页元素解析的方法有很多，正则解析只是其中之一，常见的还有 BeautifulSoup 和 lxml，它们都支持网页 HTML 元素的解析操作。</p><p>re模块常用方法</p><p> re.compile()<br>该方法用来生成正则表达式对象</p><p>regex&#x3D;re.compile(pattern,flags&#x3D;0)<br>pattern：正则表达式对象<br>flags：代表功能标志位，扩展正则表达式的匹配。</p><p>re.findall()<br>根据正则表达式匹配目标字符串内容。</p><p>re.findall(pattern,string,flags&#x3D;0)<br>该函数的返回值是匹配到的内容列表，如果正则表达式有子组，则只能获取到子组对应的内容<br>pattern：正则表达式对象<br>string：目标字符串<br>flags：代表功能标志位，扩展正则表达式的匹配。</p><p>regex.findall()<br>该函数根据正则表达式对象匹配目标字符串内容。regex.findall(string,pos,endpos)<br>string 目标字符串。<br>pos 截取目标字符串的开始匹配位置。<br>endpos 截取目标字符串的结束匹配位置。</p><p>re.split()<br>该函数使用正则表达式匹配内容，切割目标字符串。返回值是切割后的内容列表。<br>re.split(pattern,string,flags &#x3D; 0)<br>pattern：正则表达式。<br>string：目标字符串。<br>flags：功能标志位,扩展正则表达式的匹配。</p><p>re.sub<br>该函数使用一个字符串替换正则表达式匹配到的内容。返回值是替换后的字符串。<br>re.sub(pattern,replace,string,max,flags &#x3D; 0)<br>pattern：正则表达式。<br>replace：替换的字符串。<br>string：目标字符串。<br>max：最多替换几处，默认替换全部，<br>flags：功能标志位,扩展正则表达式的匹配。</p><p>re.search()<br>匹配目标字符串<strong>第一个</strong>符合的内容，返回值为匹配的对象。re.search(pattern,string,flags&#x3D;0)<br>pattern：正则表达式<br>string：目标字符串<br>flags功能标志位</p><p>功能标志位的作用是扩展正则表达的匹配功能。常用的 flag </p><img src="/post/fa1e8add/81.png" class title="This is an image"><p>注意：可以同时使用福多个功能标志位，比如 flags&#x3D;re.I|re.S。</p><p>使用贪婪和非贪婪两种模式来匹配 HTML 元素，分别，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">html=&quot;&quot;&quot;</span><br><span class="line">&lt;div&gt;&lt;p&gt;www.biancheng.net&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&lt;p&gt;编程帮&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">#贪婪匹配，re.S可以匹配换行符</span><br><span class="line">pattern=re.compile(&#x27;&lt;div&gt;&lt;p&gt;.*&lt;/p&gt;&lt;/div&gt;&#x27;,re.S)</span><br><span class="line">re_list=pattern.findall(html)</span><br><span class="line">print(re_list)</span><br><span class="line"></span><br><span class="line">#非贪婪模式匹配，re.S可以匹配换行符</span><br><span class="line">pattern=re.compile(&#x27;&lt;div&gt;&lt;p&gt;.*?&lt;/p&gt;&lt;/div&gt;&#x27;,re.S)</span><br><span class="line">re_list=pattern.findall(html)</span><br><span class="line">print(re_list)</span><br></pre></td></tr></table></figure><h5 id="正则表达式分组"><a href="#正则表达式分组" class="headerlink" title="正则表达式分组"></a>正则表达式分组</h5><p>通过正则表达式分组可以从匹配的信息中提取出想要的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#正则表达式分组</span><br><span class="line">website=&quot;编程帮 www.biancheng.net&quot;</span><br><span class="line"></span><br><span class="line">#注意此时正则表达式的 &quot;.&quot; 需要转义因此使用 \.</span><br><span class="line">pattern_1=re.compile(&#x27;\w+\s+\w+\.\w+\.\w+&#x27;)</span><br><span class="line">print(pattern_1.findall(website))</span><br><span class="line"></span><br><span class="line">#提取匹配信息的第一项</span><br><span class="line">pattern_2=re.compile(&#x27;(\w+)\s+\w+\.\w+\.\w+&#x27;)</span><br><span class="line">print(pattern_2.findall(website))</span><br><span class="line"></span><br><span class="line">#有两个及以上的()则以元组形式显示</span><br><span class="line">pattern_3=re.compile(&#x27;(\w+)\s+(\w+\.\w+\.\w+)&#x27;)</span><br><span class="line">print(pattern_3.findall(website))</span><br></pre></td></tr></table></figure><p>正则表达式分组是提取信息的常用方式。当需要哪个特定信息的时候，就可以通过分组(也就是加括号)的方式获得。</p><h5 id="网页信息提取"><a href="#网页信息提取" class="headerlink" title="网页信息提取"></a>网页信息提取</h5><p>从下面的 HTML 代码中使用 re 模块提取出两部影片的名称和主演信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">html=&quot;&quot;&quot;</span><br><span class="line">&lt;div class=&quot;movie-item-info&quot;&gt;</span><br><span class="line">&lt;p class=&quot;name&quot;&gt;</span><br><span class="line">&lt;a title=&quot;你好，李焕英&quot;&gt;你好，李焕英&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;star&quot;&gt;</span><br><span class="line">主演：贾玲,张小斐,沈腾</span><br><span class="line">&lt;/p&gt;    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;movie-item-info&quot;&gt;</span><br><span class="line">&lt;p class=&quot;name&quot;&gt;</span><br><span class="line">&lt;a title=&quot;刺杀，小说家&quot;&gt;刺杀，小说家&lt;/a&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;star&quot;&gt;</span><br><span class="line">主演：雷佳音,杨幂,董子健,于和伟</span><br><span class="line">&lt;/p&gt;    </span><br><span class="line">&lt;/div&gt; </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 寻找HTML规律，书写正则表达式，使用正则表达式分组提取信息</span><br><span class="line">pattern=re.compile(r&#x27;&lt;div.*?&lt;a title=&quot;(.*?)&quot;.*?star&quot;&gt;(.*?)&lt;/p.*?div&gt;&#x27;,re.S)</span><br><span class="line">r_list=pattern.findall(html)</span><br><span class="line">print(r_list)</span><br><span class="line"># 整理数据格式并输出</span><br><span class="line">if  r_list:</span><br><span class="line">    for r_info in  r_list:</span><br><span class="line">        print(&quot;影片名称：&quot;,r_info[0])</span><br><span class="line">        print(&quot;影片主演：&quot;,r_info[1].strip())</span><br><span class="line">        print(20*&quot;*&quot;)</span><br></pre></td></tr></table></figure><p>这里给一些博主自己使用正则表达式的经验：<br>&lt;div.<em>?&lt;a title&#x3D;”(.*?)”.*?star”&gt;(.</em>?)&lt;&#x2F;p.*?div&gt;<br>比如说上面这个正则表达式<br>他就只能匹配下面这种类型里面的信息</p><div class="movie-item-info"><p class="name"><a title="你好，李焕英">你好，李焕英</a></p><p class="star">主演：贾玲,张小斐,沈腾</p>    </div><div class="movie-item-info"><p class="name"><a title="刺杀，小说家">刺杀，小说家</a></p><p class="star">主演：雷佳音,杨幂,董子健,于和伟</p>    </div><p>你如果需要匹配的对象(注意仔细看博主删减的那部分)是这样的（如下）<br>他就只能匹配到，第一部影片的信息第二部影片的信息好像匹配不到<br>而遇到这种情况 就使用xlme来匹配更好</p><div class="movie-item-info"><p class="name"><a title="你好，李焕英">你好，李焕英</a></p><p class="star">主演：贾玲,张小斐,沈腾</p>    </div><p class="name"><a title="刺杀，小说家">刺杀，小说家</a></p><p class="star">主演：雷佳音,杨幂,董子健,于和伟</p>    <h4 id="Python-csv模块（读写文件）"><a href="#Python-csv模块（读写文件）" class="headerlink" title="Python csv模块（读写文件）"></a>Python csv模块（读写文件）</h4><p>CSV 文件又称为逗号分隔值文件，是一种通用的、相对简单的文件格式，用以存储表格数据，包括数字或者字符。CSV 是电子表格和数据库中最常见的输入、输出文件格式</p><p>通过爬虫将数据抓取的下来，然后把数据保存在文件，或者数据库中，这个过程称为数据的持久化存储</p><h5 id="CSV文件写入"><a href="#CSV文件写入" class="headerlink" title="CSV文件写入"></a>CSV文件写入</h5><ol><li>csv.writer()<br>csv 模块中的 writer 类可用于读写序列化的数据<br>其语法格式如下：writer(csvfile, dialect&#x3D;’excel’, **fmtparams)</li></ol><p>csvfile：必须是支持迭代(Iterator)的对象，可以是文件(file)对象或者列表(list)对象。<br>dialect：编码风格，默认为 excel 的风格，也就是使用逗号,分隔。<br>fmtparam：格式化参数，用来覆盖之前</p><p>dialect 对象指定的编码风格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line"># 操作文件对象时，需要添加newline参数逐行写入，否则会出现空行现象</span><br><span class="line">with open(&#x27;eggs.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:</span><br><span class="line">    # delimiter 指定分隔符，默认为逗号，这里指定为空格</span><br><span class="line">    # quotechar 表示引用符</span><br><span class="line">    # writerow 单行写入，列表格式传入数据</span><br><span class="line">    spamwriter = csv.writer(csvfile, delimiter=&#x27; &#x27;,quotechar=&#x27;|&#x27;)</span><br><span class="line">    spamwriter.writerow([&#x27;www.biancheng.net&#x27;] * 5 + [&#x27;how are you&#x27;])</span><br><span class="line">    spamwriter.writerow([&#x27;hello world&#x27;, &#x27;web site&#x27;, &#x27;www.biancheng.net&#x27;])</span><br></pre></td></tr></table></figure><p>其中，quotechar 是引用符，当一段话中出现分隔符的时候，用引用符将这句话括起来，以能排除歧义。</p><p>如果想同时写入多行数据，需要使用 writerrows() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">with open(&#x27;aggs.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    # 注意传入数据的格式为列表元组格式</span><br><span class="line">    writer.writerows([(&#x27;hello&#x27;,&#x27;world&#x27;), (&#x27;I&#x27;,&#x27;love&#x27;,&#x27;you&#x27;)])</span><br></pre></td></tr></table></figure><ol start="2"><li>csv.DictWriter()当然也可使用 DictWriter 类以字典的形式读写数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">with open(&#x27;names.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;) as csvfile:</span><br><span class="line">    #构建字段名称，也就是key</span><br><span class="line">    fieldnames = [&#x27;first_name&#x27;, &#x27;last_name&#x27;]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    # 写入字段名，当做表头</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    # 多行写入</span><br><span class="line">    writer.writerows([&#123;&#x27;first_name&#x27;: &#x27;Baked&#x27;, &#x27;last_name&#x27;: &#x27;Beans&#x27;&#125;,&#123;&#x27;first_name&#x27;: &#x27;Lovely&#x27;, &#x27;last_name&#x27;: &#x27;Spam&#x27;&#125;])</span><br><span class="line">    # 单行写入</span><br><span class="line">    writer.writerow(&#123;&#x27;first_name&#x27;: &#x27;Wonderful&#x27;, &#x27;last_name&#x27;: &#x27;Spam&#x27;&#125;)</span><br></pre></td></tr></table></figure><h6 id="CSV文件读取"><a href="#CSV文件读取" class="headerlink" title="CSV文件读取"></a>CSV文件读取</h6><ol><li>csv,reader()<br>csv 模块中的 reader 类和  DictReader 类用于读取文件中的数据</li></ol><p>reader() ：<br>csv.reader(csvfile, dialect&#x3D;’excel’, **fmtparams)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">with open(&#x27;eggs.csv&#x27;, &#x27;r&#x27;, newline=&#x27;&#x27;) as csvfile:</span><br><span class="line">    spamreader = csv.reader(csvfile, delimiter=&#x27; &#x27;, quotechar=&#x27;|&#x27;)</span><br><span class="line">    for row in spamreader:</span><br><span class="line">        print(&#x27;, &#x27;.join(row))</span><br></pre></td></tr></table></figure><ol><li>csv.DictReader() ：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">with open(&#x27;names.csv&#x27;, newline=&#x27;&#x27;) as csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    for row in reader:</span><br><span class="line">        print(row[&#x27;first_name&#x27;], row[&#x27;last_name&#x27;])</span><br></pre></td></tr></table></figure><h4 id="Python-Requests库的使用"><a href="#Python-Requests库的使用" class="headerlink" title="Python Requests库的使用"></a>Python Requests库的使用</h4><p>Python 提供了多个用来编写爬虫程序的库，除了 urllib 库之外，还有一个很重的 Requests 库</p><p>Requests 库是在 urllib 的基础上开发而来，它使用 Python 语言编写，并且采用了 Apache2 Licensed（一种开源协议）的 HTTP 库。</p><p>与 urllib 相比，Requests 更加方便、快捷，因此在编写爬虫程序时 Requests 库使用较多。</p><h5 id="常用请求方法"><a href="#常用请求方法" class="headerlink" title="常用请求方法"></a>常用请求方法</h5><ol><li>requests.get()该方法用于 GET 请求，表示向网站发起请求，获取页面响应对象。</li></ol><p>res &#x3D; requests.get(url,headers&#x3D;headers,params,timeout)<br>参数说明如下：url：要抓取的 url 地址。<br>headers：用于包装请求头信息。<br>params：请求时携带的查询字符串参数。<br>timeout：超时时间，超过时间会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://baidu.com&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><p>获取带查询字符串参数的响应对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;name&#x27;: &#x27;编程帮&#x27;,</span><br><span class="line">    &#x27;url&#x27;: &quot;www.biancheng.net&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(&#x27;http://httpbin.org/get&#x27;, params=data)</span><br><span class="line">#直接拼接参数也可以</span><br><span class="line">#response = requests.get(http://httpbin.org/get?name=gemey&amp;age=22)</span><br><span class="line">#调用响应对象text属性，获取文本信息</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><ol start="2"><li>requests.post()</li></ol><p>该方法用于 POST 请求，先由用户向目标 url 提交数据，然后服务器返回一个 HttpResponse 响应对象，语法如下：<br>response&#x3D;requests.post(url,data&#x3D;{请求体的字典})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">#百度翻译</span><br><span class="line">url = &#x27;https://fanyi.baidu.com&#x27;</span><br><span class="line">#post请求体携带的参数，可通过开发者调试工具查看</span><br><span class="line">#查看步骤：NetWork选项-&gt;Headers选项-&gt;Form Data</span><br><span class="line">data = &#123;&#x27;from&#x27;: &#x27;zh&#x27;,</span><br><span class="line">        &#x27;to&#x27;: &#x27;en&#x27;,</span><br><span class="line">        &#x27;query&#x27;: &#x27;编程帮www.biancheng.net你好&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line">print(response)</span><br></pre></td></tr></table></figure><h5 id="常见对象属性"><a href="#常见对象属性" class="headerlink" title="常见对象属性"></a>常见对象属性</h5><p>当我们使用 Requests 模块向一个 URL 发起请求后会返回一个 HttpResponse 响应对象，该对象具有以下常用属性：</p><p>常用属性说明</p><p>encoding查看或者指定响应字符编码</p><p>status_code返回HTTP响应码</p><p>url查看请求的 url 地址</p><p>headers查看请求头信息</p><p>cookies查看cookies 信息</p><p>text以字符串形式输出</p><p><strong>content以字节流形式输出，若要保存下载图片需使用该属性。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">response = requests.get(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">print(response.encoding)</span><br><span class="line">response.encoding=&quot;utf-8&quot;    #更改为utf-8编码</span><br><span class="line">print(response.status_code)  # 打印状态码</span><br><span class="line">print(response.url)          # 打印请求url</span><br><span class="line">print(response.headers)      # 打印头信息</span><br><span class="line">print(response.cookies)      # 打印cookie信息</span><br><span class="line">print(response.text)  #以字符串形式打印网页源码</span><br><span class="line">print(response.content) #以字节流形式打印</span><br></pre></td></tr></table></figure><h5 id="Requests库常用方法及参数介绍"><a href="#Requests库常用方法及参数介绍" class="headerlink" title="Requests库常用方法及参数介绍"></a>Requests库常用方法及参数介绍</h5><p>Requests 库中定义了七个常用的请求方法，这些方法各自有着不同的作用，在这些请求方法中 requests.get() 与 requests.post() 方法最为常用。<br>请求方法如下所示：</p><p>requests.request()<br>构造一个请求对象，该方法是实现以下各个方法的基础。</p><p>requests.get()<br>获取HTML网页的主要方法，对应于 HTTP 的 GET 方法。</p><p>requests.head()<br>获取HTML网页头信息的方法，对应于 HTTP 的 HEAD 方法。</p><p>requests.post()<br>获取 HTML 网页提交 POST请求方法，对应于 HTTP 的 POST。</p><p>requests.put()<br>获取HTML网页提交PUT请求方法，对应于 HTTP 的 PUT。</p><p>requests.patch()<br>获取HTML网页提交局部修改请求，对应于 HTTP 的 PATCH。</p><p>requests.delete()<br>获取HTML页面提交删除请求，对应于 HTTP 的 DELETE。</p><p>上述方法都提供了相同的参数，其中某些参数已经使用过，比如headers和params，前者用来构造请求头，后者用来构建查询字符串。这些参数对于编写爬虫程序有着至关重要的作用</p><p>SSL认证-verify参数</p><p>SSL 证书是数字证书的一种，类似于驾驶证、护照和营业执照。因为配置在服务器上，也称为 SSL 服务器证书。SSL 证书遵守 SSL 协议，由受信任的数字证书颁发机构 CA（电子认证服务）颁发。 SSL 具有服务器身份验证和数据传输加密功能。</p><p>verify参数的作用是检查 SSL 证书认证，参数的默认值为 True，如果设置为 False 则表示不检查 SSL证书，此参数适用于没有经过 CA 机构认证的 HTTPS 类型的网站。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(</span><br><span class="line">  url=url,</span><br><span class="line">  params=params,</span><br><span class="line">  headers=headers,</span><br><span class="line">  verify=False</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>代理IP-proxies参数</p><p>一些网站为了限制爬虫从而设置了很多反爬策略，其中一项就是针对 IP 地址设置的。<br>比如，访问网站超过规定次数导致流量异常，或者某个时间段内频繁地更换浏览器访问，存在上述行为的 IP 极有可能被网站封杀掉。</p><p>代理 IP 就是解决上述问题的，它突破了 IP 地址的访问限制，隐藏了本地网络的真实 IP，而使用第三方 IP 代替自己去访问网站。</p><ol><li><p>代理IP池通过构建代理 IP 池可以让你编写的爬虫程序更加稳定，从 IP 池中随机选择一个 IP 去访问网站，而不使用固定的真实 IP。总之将爬虫程序伪装的越像人，它就越不容易被网站封杀。当然代理 IP 也不是完全不能被察觉，通过端口探测技等术识仍然可以辨别。</p></li><li><p>proxies参数Requests 提供了一个代理 IP 参数 proxies，该参数的语法结构如下：</p></li></ol><p>proxies &#x3D; {<br>      ‘协议类型(http&#x2F;https)’:’协议类型:&#x2F;&#x2F;IP地址:端口号’<br>    }</p><p>下面构建了两个协议版本的代理 IP，示例如下：</p><p>proxies &#x3D; {<br>   ‘http’:’<a href="http://IP:端口号&#39;">http://IP:端口号&#39;</a>,<br>   ‘https’:’<a href="https://IP:端口号&#39;">https://IP:端口号&#39;</a><br>}</p><ol start="3"><li>代理IP使用</li><li>下面通过简单演示如何使用proxies参数，示例如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://httpbin.org/get&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 网上找的免费代理ip</span><br><span class="line">proxies = &#123;</span><br><span class="line">    &#x27;http&#x27;:&#x27;http://191.231.62.142:8000&#x27;,</span><br><span class="line">    &#x27;https&#x27;:&#x27;https://191.231.62.142:8000&#x27;</span><br><span class="line">&#125;</span><br><span class="line">html = requests.get(url,proxies=proxies,headers=headers,timeout=5).text</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><p>由于上述示例使用的是免费代理 IP，因此其质量、稳定性较差，可能会随时失效。如果想构建一个稳定的代理 IP 池，就需要花费成本。</p><ol start="4"><li>付费代理IP网上有许多提供代理 IP 服务的网 站，比如快代理、代理精灵、齐云代理等。这些网站也提供了相关文档说明，以及 API 接口，爬虫程序通过访问 API 接口，就可以构建自己的代理 IP 池。付费代理 IP 按照资源类型可划分为：开发代理、私密代理、隧道代理、独享代理，其中最常使用的是开放代理与私密代理。</li><li>开放代理：开放代理是从公网收集的代理服务器，具有 IP 数量大，使用成本低的特点，全年超过 80% 的时间都能有 3000 个以上的代理 IP 可供提取使用。<br>私密代理：私密代理是基于云主机构建的高品质代理服务器，为您提供高速、可信赖的网络代理服务。私密代理每天可用 IP 数量超过 20 万个，可用率在 95 %以上，1 次可提取 IP 数量超过 700 个，可以为爬虫业务提供强大的助力。付费代理的收费标准根据 IP 使用的时间长短，以及 IP 的质量高低，从几元到几百元不等。89 免费代理（<a href="http://www.89ip.cn/%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%93%E9%97%A8%E6%8F%90%E4%BE%9B%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86">http://www.89ip.cn/）是一个专门提供免费代理</a> IP 的网站，不过想找到一个质量较高的免费代理好比大海捞针。</li></ol><p>用户认证-auth参数<br>Requests 提供了一个auth参数，该参数的支持用户认证功能，也就是适合那些需要验证用户名、密码的网站。auth 的参数形式是一个元组</p><p>格式:<br>auth &#x3D; (‘username’,’password’)</p><h4 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h4><p>在编写爬虫程序的过程中提取信息是非常重要的环节，但是有时使用正则表达式无法匹配到想要的信息，或者书写起来非常麻烦，此时就需要用另外一种数据解析方法， Xpath 表达式。</p><p>Xpath表达式</p><p>XPath（全称：XML Path Language）即 XML 路径语言，它是一门在 XML 文档中查找信息的语言，最初被用来搜寻 XML 文档，同时它也适用于搜索 HTML 文档。因此，在爬虫过程中可以使用 XPath 来提取相应的数据。</p><p>可以将 Xpath 理解为在XML&#x2F;HTML文档中检索、匹配元素节点的工具。</p><p>Xpath 使用路径表达式来选取XML&#x2F;HTML文档中的节点或者节点集。</p><p>Xpath 的功能十分强大，它除了提供了简洁的路径表达式外，还提供了100 多个内建函数，包括了处理字符串、数值、日期以及时间的函数。</p><p>因此 Xpath 路径表达式几乎可以匹配所有的元素节点。</p><p>Python 第三方解析库 lxml 对 Xpath 路径表达式提供了良好的支持，能够解析 XML 与 HTML 文档</p><p>Xpath节点</p><p>XPath 提供了多种类型的节点，常用的节点有：元素、属性、文本、注释以及文档节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;website&gt;</span><br><span class="line"></span><br><span class="line">&lt;site&gt;</span><br><span class="line">  &lt;title lang=&quot;zh-CN&quot;&gt;website name&lt;/title&gt;</span><br><span class="line">  &lt;name&gt;编程帮&lt;/name&gt;</span><br><span class="line">  &lt;year&gt;2010&lt;/year&gt;</span><br><span class="line">  &lt;address&gt;www.biancheng.net&lt;/address&gt;</span><br><span class="line">&lt;/site&gt;</span><br><span class="line"></span><br><span class="line">&lt;/website&gt;</span><br></pre></td></tr></table></figure><p>上面的 XML 文档中的节点例子：</p><p><website></website> （文档节点）<br><name></name> （元素节点）<br>lang&#x3D;”zh-CN” （属性节点） </p><p>节点关系XML 文档的节点关系和 HTML 文档相似，同样有父、子、同代、先辈、后代节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;website&gt;</span><br><span class="line"></span><br><span class="line">&lt;site&gt;</span><br><span class="line">  &lt;title lang=&quot;zh-CN&quot;&gt;website name&lt;/title&gt;</span><br><span class="line">  &lt;name&gt;编程帮&lt;/name&gt;</span><br><span class="line">  &lt;year&gt;2010&lt;/year&gt;</span><br><span class="line">  &lt;address&gt;www.biancheng.net&lt;/address&gt;</span><br><span class="line">&lt;/site&gt;</span><br><span class="line"></span><br><span class="line">&lt;/website&gt;</span><br></pre></td></tr></table></figure><p>上述示例分析后，会得到如下结果：title name year address 都是 site 的子节点<br>site 是 title name year address 父节点<br>title name year address 属于同代节点<br>title 元素的先辈节点是 site website<br>website 的后代节点是 site title name year address</p><h5 id="Xpath基本语法"><a href="#Xpath基本语法" class="headerlink" title="Xpath基本语法"></a>Xpath基本语法</h5><ol><li>基本语法使用<br>Xpath 使用路径表达式在文档中选取节点，下表列出了常用的表达式规则：</li></ol><p>表达式描述<br>node_name<br>选取此节点的所有子节点。</p><p>&#x2F;<br>绝对路径匹配，从根节点选取。</p><p>&#x2F;&#x2F;<br>相对路径匹配，从所有节点中查找当前选择的节点，包括子节点和后代节点，其第一个 &#x2F; 表示根节点。</p><p>.<br>取当前节点。</p><p>..<br>选取当前节点的父节点。</p><p>@<br>选取属性值，通过属性值选取数据。<br>常用元素属性有 @id 、@name、@type、@class、@tittle、@href。</p><p>下面讲解 Xpath 表达式的基本应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;BookList&quot;&gt;</span><br><span class="line">  &lt;li class=&quot;book1&quot; id=&quot;book_01&quot; href=&quot;http://www.biancheng.net/&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;name&quot;&gt;c语言小白变怪兽&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;model&quot;&gt;纸质书&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;price&quot;&gt;80元&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;color&quot;&gt;红蓝色封装&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;li class=&quot;book2&quot; id=&quot;book_02&quot; href=&quot;http://www.biancheng.net/&quot;&gt;</span><br><span class="line">        &lt;p class=&quot;name&quot;&gt;Python入门到精通&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;model&quot;&gt;电子书&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;price&quot;&gt;45元&lt;/p&gt;</span><br><span class="line">        &lt;p class=&quot;color&quot;&gt;蓝绿色封装&lt;/p&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>路径表达式以及相应的匹配内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">xpath表达式：//li</span><br><span class="line"></span><br><span class="line">匹配内容：</span><br><span class="line">c语言小白变怪兽</span><br><span class="line">纸质书</span><br><span class="line">80元</span><br><span class="line">红蓝色封装</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">Python入门到精通</span><br><span class="line">电子书</span><br><span class="line">45元</span><br><span class="line">蓝绿色封装</span><br><span class="line"></span><br><span class="line">xpath表达式：//li/p[@class=&quot;name&quot;]</span><br><span class="line">匹配内容：</span><br><span class="line">c语言小白变怪兽</span><br><span class="line">Python入门到精通</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xpath表达式：//li/p[@class=&quot;model&quot;]</span><br><span class="line">匹配内容：</span><br><span class="line">纸质书</span><br><span class="line">电子书</span><br><span class="line"></span><br><span class="line">xpath表达式：//ul/li/@href</span><br><span class="line">匹配内容：</span><br><span class="line">http://www.biancheng.net/</span><br><span class="line">http://www.biancheng.net/</span><br><span class="line"></span><br><span class="line">xpath表达式：//ul/li</span><br><span class="line">匹配内容：</span><br><span class="line">c语言小白变怪兽</span><br><span class="line">纸质书</span><br><span class="line">80元</span><br><span class="line">红蓝色封装</span><br><span class="line">  </span><br><span class="line">Python入门到精通</span><br><span class="line">电子书</span><br><span class="line">45元</span><br><span class="line">蓝绿色封装</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：当需要查找某个特定的节点或者选取节点中包含的指定值时需要使用[]<strong>方括号</strong>。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xpath表达式：//ul/li[@class=&quot;book2&quot;]/p[@class=&quot;price&quot;]</span><br><span class="line">匹配结果：45元</span><br></pre></td></tr></table></figure><ol start="2"><li>xpath通配符Xpath 表达式的<strong>通配符</strong>可以用来选取未知的节点元素，基本语法如下：<ul><li>匹配任意元素节点</li></ul></li></ol><p>@*<br>匹配任意属性节点</p><p>node()<br>匹配任意类型的节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xpath表达式：//li/*</span><br><span class="line"></span><br><span class="line">匹配内容：</span><br><span class="line">c语言小白变怪兽</span><br><span class="line">纸质书</span><br><span class="line">80元</span><br><span class="line">红蓝色封装</span><br><span class="line">Python入门到精通</span><br><span class="line">电子书</span><br><span class="line">45元</span><br><span class="line">蓝绿色封装</span><br></pre></td></tr></table></figure><ol start="3"><li>多路径匹配多个 Xpath 路径表达式可以同时使用，其语法如下：<br>xpath表达式1 | xpath表达式2 | xpath表达式3</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">表达式：//ul/li[@class=&quot;book2&quot;]/p[@class=&quot;price&quot;]|//ul/li/@href</span><br><span class="line"></span><br><span class="line">匹配内容：</span><br><span class="line">45元</span><br><span class="line">http://www.biancheng.net/</span><br><span class="line">http://www.biancheng.net/</span><br></pre></td></tr></table></figure><p>Xpath内建函数Xpath 提供 100 多个内建函数，这些函数给我们提供了很多便利，比如实现文本匹配、模糊匹配、以及位置匹配等，下面介绍几个常用的内建函数。</p><h4 id="Python-lxml库的使用"><a href="#Python-lxml库的使用" class="headerlink" title="Python lxml库的使用"></a>Python lxml库的使用</h4><p>lxml 是 Python 的第三方解析库，完全使用 Python 语言编写，它对 Xpath 表达式提供了良好的支持，因此能够了高效地解析 HTML&#x2F;XML 文档。</p><p>lxml使用流程</p><p>lxml 库提供了一个 etree 模块，该模块专门用来解析 HTML&#x2F;XML 文档</p><p>lxml 库的使用流程：</p><ol><li><p>导入模块<br>from lxml import etree</p></li><li><p>创建解析对象调用 etree 模块的 HTML() 方法来创建 HTML 解析对象。parse_html &#x3D; etree.HTML(html)</p></li></ol><p>HTML() 方法能够将 HTML 标签字符串解析为 HTML 文件，该方法可以自动修正 HTML 文本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line">html_str = &#x27;&#x27;&#x27;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">         &lt;li class=&quot;item1&quot;&gt;&lt;a href=&quot;link1.html&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;item2&quot;&gt;&lt;a href=&quot;link2.html&quot;&gt;Java&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site1&quot;&gt;&lt;a href=&quot;c.biancheng.net&quot;&gt;C语言中文网&lt;/a&gt;</span><br><span class="line">         &lt;li class=&quot;site2&quot;&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li class=&quot;site3&quot;&gt;&lt;a href=&quot;www.jd.com&quot;&gt;京东&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">html = etree.HTML(html_str)</span><br><span class="line"></span><br><span class="line"># tostring()将标签元素转换为字符串输出，注意：result为字节类型</span><br><span class="line">result = etree.tostring(html)</span><br><span class="line"></span><br><span class="line">print(result.decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure><p>上述 HTML 字符串存在缺少标签的情况，比如“C语言中文网”缺少一个  闭合标签，当使用了 HTML() 方法后，会将其自动转换为符合规范的 HTML 文档格式</p><ol start="3"><li>调用xpath表达式最后使用第二步创建的解析对象调用 xpath() 方法，完成数据的提取，如下所示：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_list = parse_html.xpath(&#x27;xpath表达式&#x27;)</span><br></pre></td></tr></table></figure><p>lxml库</p><p>数据提取下面通过一段 HTML 代码实例演示如何使用 lxml 库提取想要的数据。HTML 代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;www.biancheng.net/product/&quot; id=&quot;site&quot;&gt;website product&lt;/a&gt;</span><br><span class="line">    &lt;ul id=&quot;sitename&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.biancheng.net/&quot; title=&quot;编程帮&quot;&gt;编程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://world.sina.com/&quot; title=&quot;新浪娱乐&quot;&gt;微博&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;百度&quot;&gt;百度贴吧&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.taobao.com&quot; title=&quot;淘宝&quot;&gt;天猫淘宝&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.jd.com/&quot; title=&quot;京东&quot;&gt;京东购物&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://c.bianchneg.net/&quot; title=&quot;C语言中文网&quot;&gt;编程&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.360.com&quot; title=&quot;360科技&quot;&gt;安全卫士&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://www.bytesjump.com/&quot; title=字节&quot;&gt;视频娱乐&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://bzhan.com/&quot; title=&quot;b站&quot;&gt;年轻娱乐&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;http://hao123.com/&quot; title=&quot;浏览器&quot;&gt;搜索引擎&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ol><li>提取所有a标签内的文本信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"># 创建解析对象</span><br><span class="line">parse_html=etree.HTML(html)</span><br><span class="line"># 书写xpath表达式,提取文本最终使用text()</span><br><span class="line">xpath_bds=&#x27;//a/text()&#x27;</span><br><span class="line"># 提取文本数据，以列表形式输出</span><br><span class="line">r_list=parse_html.xpath(xpath_bds)</span><br><span class="line"># 打印数据列表</span><br><span class="line">print(r_list)</span><br></pre></td></tr></table></figure><ol start="2"><li>获取所有href的属性值</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"># 创建解析对象</span><br><span class="line">parse_html=etree.HTML(html)</span><br><span class="line"># 书写xpath表达式,提取文本最终使用text()</span><br><span class="line">xpath_bds=&#x27;//a/@href&#x27;</span><br><span class="line"># 提取文本数据，以列表形式输出</span><br><span class="line">r_list=parse_html.xpath(xpath_bds)</span><br><span class="line"># 打印数据列表</span><br><span class="line">print(r_list)</span><br></pre></td></tr></table></figure><ol start="3"><li>不匹配href&#x3D;” <a href="http://www.biancheng.net/priduct&quot;">www.biancheng.net/priduct&quot;</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from lxml import etree</span><br><span class="line"># 创建解析对象</span><br><span class="line">parse_html=etree.HTML(html)</span><br><span class="line"># 书写xpath表达式,提取文本最终使用text()</span><br><span class="line">xpath_bds=&#x27;//a/@href&#x27;</span><br><span class="line"># 提取文本数据，以列表形式输出</span><br><span class="line">xpath_bds=&#x27;//ul[@id=&quot;sitename&quot;]/li/a/@href&#x27;</span><br><span class="line"># 打印数据列表</span><br><span class="line">print(r_list)</span><br></pre></td></tr></table></figure><h4 id="Python-json模块常用方法"><a href="#Python-json模块常用方法" class="headerlink" title="Python json模块常用方法"></a>Python json模块常用方法</h4><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，遵循欧洲计算机协会制定的 JavaScript 规范（简称 ECMAScript）。</p><p>它常被作为网络、程序之间传递信息的标准语言，比如客户端与服务器之间信息交互就是以 JSON 格式传递的。</p><p>简单地说，JSON 可以将 JavaScript 对象表示的一组数据转换为字符串格式，以便于在网络、程序间传输这个字符串。</p><p>并且在需要的时候，您还可以将它转换为编程语言所支持的数据格式。本节主要介绍如何实现 JSON 数据与 Python 数据类型间的相互转换。</p><p>Python 语言内置了专门处理 JOSN 数据的模块 —— jons 模块，通过该模块就可以完成 JSON 与 Python 两种数据格式的相互转换。</p><p>json.dump()</p><p>它可以将 Python 对象（字典、列表等）转换为 json 字符串，并将转换后的数据写入到 json 格式的文件中 ，因此该方法必须操作<strong>文件</strong>流对象。</p><p>比如当使用爬虫程序完成数据抓取后，有时需要将数据保存为 json 格式，此时就用到了 json.dump() 方法，语法格式如下：</p><p>json.dump(object,f,inden&#x3D;0，ensure_ascii&#x3D;False)</p><p>object：Python 数据对象，比如字典，列表等</p><p>f：文件流对象，即文件句柄。</p><p>indent：格式化存储数据，使 JSON 字符串更易阅读。</p><p>ensure_ascii：是否使用 ascii 编码，当数据中出现中文的时候，需要将其设置为 False。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">ditc_info=&#123;&quot;name&quot; : &quot;c语言中文网&quot;,&quot;PV&quot; : &quot;50万&quot;,&quot;UV&quot; : &quot;20万&quot;,&quot;create_time&quot; : &quot;2010年&quot;&#125;</span><br><span class="line">with open(&quot;web.josn&quot;,&quot;a&quot;) as f:</span><br><span class="line">    json.dump(ditc_info,f,ensure_ascii=False)</span><br></pre></td></tr></table></figure><p>也可以将 Python 列表转换成 JSON 字符串，并保存至 json 文件中，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">item_list = []</span><br><span class="line">item = &#123;&#x27;website&#x27;: &#x27;C语言中文网&#x27;, &#x27;url&#x27;: &quot;c.biancheng.net&quot;&#125;</span><br><span class="line">for k,v in item.items():</span><br><span class="line">    item_list.append(v)</span><br><span class="line"></span><br><span class="line">with open(&#x27;info_web.json&#x27;, &#x27;a&#x27;) as f:</span><br><span class="line">    json.dump(item_list, f, ensure_ascii=False)</span><br></pre></td></tr></table></figure><p>json.load()</p><p>该方法用于操作文件流对象，不过它与 dump() 恰好相反，它表示从  json 文件中读取 JSON 字符串，并将读取内容转换为 Python 对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">site = &#123;&#x27;name&#x27;:&#x27;c语言中文网&#x27;,&quot;url&quot;:&quot;c.biancheng.net&quot;&#125;</span><br><span class="line">filename = &#x27;website.json&#x27;</span><br><span class="line">with open (filename,&#x27;w&#x27;) as f:</span><br><span class="line">    json.dump(site,f,ensure_ascii=False)</span><br><span class="line">with open (filename,&#x27;r&#x27;) as f:</span><br><span class="line">    print(json.load(f))</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>json.loads()</p><p>该方法可以将 json 格式的字符串转换成 Python 对象（比如列表、字典、元组、整型以及浮点型），其中最常用的是转换为字典类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf8</span><br><span class="line">import json</span><br><span class="line">#JOSN字符串</span><br><span class="line">website_info=&#x27;&#123;&quot;name&quot; : &quot;c语言中文网&quot;,&quot;PV&quot; : &quot;50万&quot;,&quot;UV&quot; : &quot;20万&quot;,&quot;create_time&quot; : &quot;2010年&quot;&#125;&#x27;</span><br><span class="line">py_dict=json.loads(website_info)</span><br><span class="line">print(&quot;python字典数据格式：%s；数据类型：%s&quot;% (py_dict,type(py_dict)))</span><br></pre></td></tr></table></figure><p>注意：上述示例中 JSON 字符串看上去和 Python 字典非常相似，但是其本质不同，JOSN 是字符串类型，而 Python 字典是 dict 类型。</p><p>json.dumps()<br>该方法可以将 Python 对象转换成 JSON 字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">#python字典</span><br><span class="line">item = &#123;&#x27;website&#x27;: &#x27;C语言中文网&#x27;, &#x27;rank&#x27;: 1&#125;</span><br><span class="line"># json.dumps之后</span><br><span class="line">item = json.dumps(item,ensure_ascii=False)</span><br><span class="line">print(&#x27;转换之后的数据类型为：&#x27;,type(item))</span><br><span class="line">print(item)</span><br></pre></td></tr></table></figure><p>方法作用json.dumps()将 Python 对象转换成 JSON 字符串。json.loads()将 JSON 字符串转换成 Python 对象。json.dump()将 Python 中的对象转化成 JSON 字符串储存到文件中。json.load()将文件中的 JSON 字符串转化成 Python 对象提取出来。</p><p>综上所述 json.load() 与 json.dump() 操作的是文件流对象，实现了 json 文件的读写操作，而 json.loads() 与 json.dumps() 操作的是 Python 对象或者 JOSN 字符串。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-random库</title>
      <link href="/post/86d4ae82.html"/>
      <url>/post/86d4ae82.html</url>
      
        <content type="html"><![CDATA[<p>random库</p><p>random模块实现了各种分布的伪随机数生成器，为什么称为伪随机数：即使人类使用算法等方式，以一个基准（也被叫做种子，最常用的就是时间戳）来构造一系列数字，这些数字的特控符合人们所理解的随机数。但因为是通过算法得到的，所以一旦算法和种子都确定，那么产生的随机数序列也是确定的，所以叫伪随机数</p><p>常用函数</p><p>random.seed(a)</p><p>设置初始化随机种子，可输出相同随机数序列；a取整数或浮点数，不设置时默认以系统时间为种子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">print(&quot;没有设置种子时&quot;)</span><br><span class="line">for i in range(5):</span><br><span class="line">    ret = random.randint(1, 10)</span><br><span class="line">    print(ret, end=&quot; &quot;)</span><br><span class="line">print()</span><br><span class="line">print(&quot;设置种子时&quot;)</span><br><span class="line">random.seed(1)</span><br><span class="line">for i in range(5):</span><br><span class="line">    ret = random.randint(1, 10)</span><br><span class="line">    print(ret, end=&quot; &quot;)</span><br></pre></td></tr></table></figure><p>没有显示设定种子时，每次输出的随机数都是不一样的；显示设置种子时，每次输出的随机数都是一样的。</p><p>random.random() # 用于生成一个0.0到1.0的随机数<br>print(random.random())</p><p>random.uniform(a, b) # 生成一个[a, b]之间的随机小数；a,b取整数或浮点数</p><p>print(random.uniform(10, 20))</p><p>random.randint(a, b)  # 生成一个[a, b]之间随机整数</p><p>print(random.randint(10, 20))</p><p>random.randrange(start, stop, [step])</p><p>#生成一个[start, stop]之间以step步数的随机整数：start,stop,step取整数,step不设置时默认值为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(random.randrange(1, 100))  # 随机生成1-100之间的整数</span><br><span class="line"> </span><br><span class="line">print(random.randrange(1, 100, 2))  # 随机生成1-100之间奇数</span><br><span class="line"> </span><br><span class="line">print(random.randrange(2, 100, 2))  # 随机生成1-100之间偶数</span><br></pre></td></tr></table></figure><p>random.getrandbits(k)  # 生成一个占内存k位以内的随机整数；k取长度的整数值</p><p>print(random.getrandbits(10))<br> 生成一个内存占k位以内的随机数；k取长度的整数值</p><p>random.choice(seq)  # 从序列类型seq中随机返回一个元素；seq取序列类型：如字符串、列表、元组<br>print(random.choice([1, ‘10’, 3, 5, 7, 1001]))</p><p>random.shuffle(seq)<br>将序列类型中元素随机排序，返回打乱后序列，seq被改变（改变原序列），shuffle为洗牌之意；seq取序列类型：如字符串，列表，元组<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]</span><br><span class="line">random.shuffle(list)</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def get_random_string(length):</span><br><span class="line">    # 随机生成字母和数字的位数</span><br><span class="line">    num_count = random.randint(1, length-1)</span><br><span class="line">    letter_count = length-num_count</span><br><span class="line">    # 随机抽样生成数字序列</span><br><span class="line">    num_list = [random.choice(string.digits) for _ in range(num_count)]</span><br><span class="line">    # 随机抽样生成字母序列</span><br><span class="line">    letter_list = [random.choice(string.ascii_letters) for _ in range(letter_count)]</span><br><span class="line">    # 合并字母和数字</span><br><span class="line">    all_list = num_list + letter_list</span><br><span class="line">    # 乱序</span><br><span class="line">    random.shuffle(all_list)</span><br><span class="line">    result = &quot;&quot;.join(i for i in all_list)</span><br><span class="line">    return result</span><br><span class="line"># 生成10位的密码</span><br><span class="line">password1 = get_random_string(10)</span><br><span class="line">print(password1)</span><br></pre></td></tr></table></figure><p>可以使用这种调用其的方式、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建随机数对象</span><br><span class="line">      Random random = new Random();</span><br><span class="line"></span><br><span class="line">      //随机产生一个int类型取值范围内的数字。</span><br><span class="line">      int num1 = random.nextInt();</span><br><span class="line">      System.out.println(num1);</span><br><span class="line"></span><br><span class="line">      //产生一个[0-100]之间的随机数</span><br><span class="line">      int num2 = random.nextInt(101);</span><br><span class="line">      System.out.println(num2);//不包括101</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tkinter-event事件</title>
      <link href="/post/f50e177a.html"/>
      <url>/post/f50e177a.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter-Event事件处理"><a href="#Tkinter-Event事件处理" class="headerlink" title="Tkinter Event事件处理"></a>Tkinter Event事件处理</h5><p>事件处理，是 GUI 程序中不可或缺的重要组成部分，相比来说，控件只是组成一台机器的零部件， 而事件处理则是驱动这台机器“正常”运转的关键所在，它能够将零部件之间“优雅”的贯穿起来，因此“事件处理”可谓是 GUI 程序的“灵魂”，同时它也是实现人机交互的关键。</p><p>在一款 GUI 程序中，我们将用户对软件的操作统称为“事件”，比如鼠标点击按钮、键盘输入文本以及窗口管理器触发的重绘事件等，这些事件有一个共同的特点，即都是由用户直接或者间接触发的。</p><p>事件绑定方法</p><p>Tkinter 提供的事件处理机制允许我们为“控件”绑定相应的事件和事件处理函数（即 callback函数），从而实现控件与用户的交互<br>语法格式：widget.bind(“<event>“,func)</event></p><p>widget 代表控件的实例对象，之后，采用 bind() 方法进行事件绑定<br>该函数有两个参数：<br><event>：一个字符串参数，表示事件的类型，并使用“尖括号”的形式进行包裹；<br>func：表示事件的处理函数（callback，即回调函数），当触发事件时，Tk 会携带事件对象（Event）去调用 func 方法。</event></p><p><strong>注意：bind() 方法可以完成事件与处理函数绑定，而使用 unbind() 方法可以将事件与处理函数解绑。</strong></p><p>常用事件类型</p><p>事件类型（也称事件码）是 Tkinter 模块规定的，主要包括鼠标、键盘、光标等相关事件</p><p>Tkinter 为其规定了相应的语法格式：</p><modifier-type-detail><p>上述语法由三部分组成：<br>&lt;&gt;：事件类型必须包含在“尖括号”内；</p><p>modifier：可选项，事件类型的修饰符，通常用于描述组合键、双击<Double-Button-1>、大写锁定键<Lock>以及<Alt-Shift>等；</Alt-Shift></Lock></Double-Button-1></p><p>type：是必不可少的一项，表示事件的具体类型；</p><p>detail：可选项，通常用于描述具体的哪个按键，比如 <Button-1> 表示鼠标左键；</Button-1></p><p>这里有必要对经常使用的 modifier 修饰符做简单的介绍，修饰符可以修改事件的激活条件，比如双击鼠标或者需要同时按下某个键才触发事件，常用的修饰符如下：</p><p>Control<br>事件发生时需按下 Control 键</p><p>Alt<br>事件发生时需按下 Alt 键</p><p>Shift<br>事件发生时需按下 Shift 键</p><p>Lock<br>事件发生时需处于大写锁定状态</p><p>Double<br>事件连续发生两次，比如双击鼠标</p><p>Triple<br>事件连续发生三次</p><p>Quadruple<br>事件连续发生四次</p><p> Tkinter 中经常使用的事件类型：</p><p><ButtonPress-1>单击鼠标左键，简写为<Button-1>，后面的数字可以是1&#x2F;2&#x2F;3，分别代表左键、中间滑轮、右键</Button-1></ButtonPress-1></p><ButtonRelease-1>释放鼠标左键，后面数字可以是1/2/3，分别代表释放左键、滑轮、右键<B1-Motion>按住鼠标左键移动，<B2-Motion>和<B3-Motion>分别表示按住鼠标滑轮移动、右键移动<MouseWheel>转动鼠标滑轮<Double-Button-1>双击鼠标左键<Enter>鼠标光标进入控件实例<Leave>鼠标光标离开控件实例<Key>按下键盘上的任意键<p>&lt;KeyPress-字母&gt;&#x2F;&lt;KeyPress-数字&gt;按下键盘上的某一个字母或者数字键</p><KeyRelease>释放键盘上的按键<Return>回车键，其他同类型键有<Shift>/<Tab>/<Control>/<Alt><Space>空格键<UP>/<Down>/<Left>/<Right>方向键<F1>...<F12>常用的功能键<Control-Alt>组合键，再比如<Control-Shift-KeyPress-T>，表示用户同时点击 Ctrl + Shift + T<FocusIn>当控件获取焦点时候触发<p>比如鼠标点击输入控件输入内容，可以调用 <strong>focus_set()</strong> 方法使控件获得焦点<br><FocusOut>当控件失去焦点时激活</FocusOut></p><p>比如当鼠标离开输入框的时候<Configure>控件的发生改变的时候触发事件</Configure></p><p>比如调整了控件的大小等<Deactivate>当控件的状态从“激活”变为“未激活”时触发事件</Deactivate></p><p><Destroy>当控件被销毁的时候触发执行事件的函数</Destroy></p><p><Expose>当窗口或组件的某部分不再被覆盖的时候触发事件</Expose></p><p><Visibility>当应用程序至少有一部分在屏幕中是可见状态时触发事件</Visibility></p><p>Event事件对象</p><p>当事件触发后，Tkinter 会自动将事件对象交给回调函数进行下步的处理<br>Event 对象包含常用属性：</p><p>widget<br>发生事件的是哪一个控件</p><p>x,y相对于窗口的左上角而言，当前鼠标的坐标位置</p><p>x_root,y_root<br>相对于屏幕的左上角而言，当前鼠标的坐标位置</p><p>char<br>用来显示所按键相对应的字符</p><p>keysym<br>查看按键名，比如 Control_L 表示左边的 Ctrl 按键keycode按键码，一个按键的数字编号，比如 Delete 按键码是107num1&#x2F;2&#x2F;3中的一个，表示点击了鼠标的哪个按键，按键分为左、中、右</p><p>width,height<br>控件的修改后的尺寸，对应着 <Configure>事件type事件类型</Configure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"># 定义事件函数，必须用event参数</span><br><span class="line">def show_key(event):</span><br><span class="line">    # 查看触发事件的按钮</span><br><span class="line">    s=event.keysym</span><br><span class="line">    # 将其显示在按钮控件上</span><br><span class="line">    lb.config(text=s)</span><br><span class="line"></span><br><span class="line">root=Tk()</span><br><span class="line">root.geometry(&#x27;450x350+300+200&#x27;)</span><br><span class="line"></span><br><span class="line"># 添加一个按钮控件</span><br><span class="line">lb=Label(root,text=&#x27;请按键&#x27;,fg=&#x27;blue&#x27;,font=(&#x27;微软雅黑&#x27;,15))</span><br><span class="line"># 给按钮控件绑定事件，按下任意键，然后调用事件处理函数。注意，此处需要在英文状态下进行输入</span><br><span class="line">lb.bind(&#x27;&lt;Key&gt;&#x27;,show_key)</span><br><span class="line"># 设置按钮获取焦点，这里必须使用这个</span><br><span class="line">lb.focus_set()</span><br><span class="line">lb.pack()</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>注意：只有当 Label 控件获取焦点后才能接收键盘事件，因此在给控件绑定事件和回调函数后，需要使用 focus_set() 方法来获取焦点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 定义事件函数</span><br><span class="line">from tkinter import *</span><br><span class="line">def handleMotion(event):</span><br><span class="line">    lb1[&#x27;text&#x27;] = &#x27;你移动了光标的所在位置&#x27;</span><br><span class="line">    lb2[&#x27;text&#x27;] = &#x27;目前光标位置：x =&#x27;+ str(event.x)+&#x27;;y=&#x27;+str(event.y)</span><br><span class="line">    print(&#x27;光标当前位置&#x27;,event.x,event.y)</span><br><span class="line">win = Tk()</span><br><span class="line">win.config(bg=&#x27;#87CEEB&#x27;)</span><br><span class="line">win.geometry(&#x27;450x350+300+200&#x27;)</span><br><span class="line"># 创建一个窗体容器frame</span><br><span class="line">frame = Frame (win, relief=RAISED, borderwidth=2, width=300,height=200)</span><br><span class="line">frame.bind(&#x27;&lt;Motion&gt;&#x27;,handleMotion)</span><br><span class="line">lb1 = Label(frame,text=&#x27;没有任何事件触发&#x27;, bg=&#x27;purple&#x27;, )</span><br><span class="line">lb1.place (x=20,y=20)</span><br><span class="line">lb2 = Label(frame,text=&#x27;&#x27;)</span><br><span class="line">lb2.place (x=16,y=60)</span><br><span class="line">frame.pack(side=TOP)</span><br><span class="line"># 显示窗口</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure></FocusIn></Control-Shift-KeyPress-T></Control-Alt></F12></F1></Right></Left></Down></UP></Space></Alt></Control></Tab></Shift></Return></KeyRelease></Key></Leave></Enter></Double-Button-1></MouseWheel></B3-Motion></B2-Motion></B1-Motion></ButtonRelease-1></modifier-type-detail>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python搞笑表白</title>
      <link href="/post/ce6b206b.html"/>
      <url>/post/ce6b206b.html</url>
      
        <content type="html"><![CDATA[<p>博主使用python 制作了一个网上经常看见的搞笑表白程序</p><p>本来是想将其打包成exe程序的，但是因为里面涉及有图片</p><p>所以打包起来非常的麻烦，所以博主这里就没有打包了</p><p>其实刚开始博主想制作的并不是现在做出来的这个程序 而是和用js css做出来的那种一样</p><p>但是由于 这里我主要使用的是tkinter这个GUI库，就里面的许多操作实现起来就比较麻烦</p><p>最后博主就做的这种的了</p><p>说说做这个的时候遇到的一些问题吧！</p><ol><li><p>在子页面加载图片问题</p><p>通过使用tkinter里面自带的加载图片工具是加载不了的</p><p>解决：通过 opencv里面的加载图片方法（下面的程序就是使用的这种方法）</p><p>​通过 PIL里面的加载图片方法，但是要注意加载的图片类型</p></li><li><p>不允许关闭主窗口问题</p><p>这个程序 ，你发给小姐姐，结果人家直接一个钢叉给你关闭了，你这白忙活一宿🤣 就尴尬了</p><p>解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from Tkinter import *</span><br><span class="line">import tkMessageBox</span><br><span class="line"> </span><br><span class="line">def callback():</span><br><span class="line">    if tkMessageBox.askokcancel(&quot;Quit&quot;, &quot;Do you really wish to quit?&quot;):</span><br><span class="line">        root.destroy()</span><br><span class="line"> </span><br><span class="line">root = Tk()</span><br><span class="line">root.protocol(&quot;WM_DELETE_WINDOW&quot;, callback)</span><br><span class="line"> </span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>可以参考一下上面这段代码，或者去廖雪峰老师的网站看一下</p><p>博主使用的就和上面这个有一定的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 让窗口不能关闭函数   </span><br><span class="line">def callback(event):</span><br><span class="line">    # 查看触发事件的按钮</span><br><span class="line">    s=event.keysym</span><br><span class="line">    if s == &quot;Escape&quot;:</span><br><span class="line">        root.destroy()</span><br><span class="line">root.protocol(&quot;WM_DELETE_WINDOW&quot;, callback)</span><br><span class="line">root.bind(&#x27;&lt;Key&gt;&#x27;,callback)</span><br><span class="line">root.focus_set()</span><br></pre></td></tr></table></figure></li><li><p>布局问题</p><p>​这里博主建议不会的小伙伴可以直接去看 这篇<a href="https://1yzf2zst.github.io/post/33f31c3e.html">文章</a></p><p>​博主这里就不说了，那边文章详细的介绍了布局</p></li><li><p>打包成exe程序问题</p><p>这个带图片的tkinterchengxu 打包成exe程序 有点太麻烦了，😥有操作比较流利的小伙伴可以教教博主、</p><p>解决：未解决</p></li></ol><p>这里博主给一个百度网盘的分享链接<a href="https://pan.baidu.com/s/1aYqFRZwmfcMtvudBGBBmLw">传送门</a><br>提取码：2111</p><p><strong>下面就直接给大家上源码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from PIL import Image, ImageTk</span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">import time</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">root.geometry(&quot;450x300&quot;)</span><br><span class="line">root.resizable(0,0)</span><br><span class="line">root.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">image=tk.PhotoImage(file=&quot;cp2.png&quot;)</span><br><span class="line"></span><br><span class="line"># 不同意按钮弹窗</span><br><span class="line">def disagree1():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;300x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&quot;我妈会游泳&quot;,font=(&#x27;楷书&#x27;,15))</span><br><span class="line">    l1.place(x=100,y=20)     </span><br><span class="line">    btn= tk.Button(root1,text=&quot;勉强接受&quot;,bg=&quot;#e09780&quot;,command=root1.destroy) </span><br><span class="line">    btn.place(x=100,y=80)</span><br><span class="line">    btn1= tk.Button(root,text=&#x27;勉强接受&#x27;,bg=&quot;#AAAAFF&quot;,command=disagree2)</span><br><span class="line">    btn1.place(x=300,y=200)</span><br><span class="line">    root1.mainloop()</span><br><span class="line">    </span><br><span class="line">def disagree2():</span><br><span class="line">    # messagebox.showinfo(&#x27;小姐姐我喜欢你&#x27;,&#x27;我妈会游泳&#x27;)</span><br><span class="line">    root2 = tk.Tk()</span><br><span class="line">    root2.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root2.geometry(&quot;300x200&quot;)</span><br><span class="line">    root2.resizable(0,0)</span><br><span class="line">    root2.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root2,text=&quot;保大&quot;,font=(&#x27;楷书&#x27;,25))</span><br><span class="line">    l1.place(x=100,y=20)     </span><br><span class="line">    btn= tk.Button(root2,text=&quot;还不错&quot;,bg=&quot;#e09780&quot;,command=root2.destroy) </span><br><span class="line">    btn.place(x=100,y=80)</span><br><span class="line">    btn2= tk.Button(root,text=&#x27;还不错&#x27;,bg=&quot;#AAAAFF&quot;,command=disagree3)</span><br><span class="line">    btn2.place(x=300,y=200)</span><br><span class="line">    root2.mainloop()</span><br><span class="line">def disagree3():</span><br><span class="line">    # messagebox.showinfo(&#x27;小姐姐我喜欢你&#x27;,&#x27;我妈会游泳&#x27;)</span><br><span class="line">    root3 = tk.Tk()</span><br><span class="line">    root3.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root3.geometry(&quot;300x200&quot;)</span><br><span class="line">    root3.resizable(0,0)</span><br><span class="line">    root3.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root3,text=&quot;房产证写你的名字&quot;,font=(&#x27;楷书&#x27;,15))</span><br><span class="line">    l1.place(x=50,y=20)     </span><br><span class="line">    btn= tk.Button(root3,text=&quot;还差点&quot;,bg=&quot;#e09780&quot;,command=root3.destroy) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    btn2= tk.Button(root,text=&#x27;还差点&#x27;,bg=&quot;#AAAAFF&quot;,command=disagree4)</span><br><span class="line">    btn2.place(x=300,y=200)</span><br><span class="line">    root3.mainloop()</span><br><span class="line">def disagree4():</span><br><span class="line">    # messagebox.showinfo(&#x27;小姐姐我喜欢你&#x27;,&#x27;我妈会游泳&#x27;)</span><br><span class="line">    root4 = tk.Tk()</span><br><span class="line">    root4.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root4.geometry(&quot;300x200&quot;)</span><br><span class="line">    root4.resizable(0,0)</span><br><span class="line">    root4.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root4,text=&quot;给你买冰淇淋&quot;,font=(&#x27;楷书&#x27;,15))</span><br><span class="line">    l1.place(x=100,y=20)     </span><br><span class="line">    btn= tk.Button(root4,text=&quot;这还差不多 哼&quot;,bg=&quot;#e09780&quot;,command=root4.destroy) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    btn2= tk.Button(root,text=&#x27;去你的&#x27;,bg=&quot;#AAAAFF&quot;,command=disagree1)</span><br><span class="line">    btn2.place(x=300,y=200)</span><br><span class="line">    root4.mainloop()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 同意按钮弹窗</span><br><span class="line">def agree1():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;300x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&quot;我就知道你会同意的 嘻嘻&quot;,font=(&#x27;楷书&#x27;,10))</span><br><span class="line">    l1.place(x=100,y=20)     </span><br><span class="line">    btn= tk.Button(root1,text=&quot;happy&quot;,bg=&quot;#e09780&quot;,command=agree2)</span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()</span><br><span class="line">def agree2():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;300x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&quot;走啦！我的小仙女 吃饭去&quot;,font=(&#x27;楷书&#x27;,15))</span><br><span class="line">    l1.place(x=20,y=20)     </span><br><span class="line">    btn= tk.Button(root1,text=&quot;走咯&quot;,bg=&quot;#e09780&quot;,command=agree3)</span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()   </span><br><span class="line">def agree3():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&quot;等等，我想牵着你的手手去  嘿嘿&quot;,font=(&#x27;楷书&#x27;,12))</span><br><span class="line">    l1.place(x=10,y=20)     </span><br><span class="line">    btn= tk.Button(root1,text=&quot;走咯&quot;,bg=&quot;#e09780&quot;,command=agree4) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()</span><br><span class="line"># 显示素描图片</span><br><span class="line">def agree4():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&#x27;等等 给你个惊喜哦！&#x27;)</span><br><span class="line">    l1.place(x=20,y=20)  </span><br><span class="line">    btn= tk.Button(root1, text=&quot;点我哦&quot;,bg=&quot;#e09780&quot;,command=agree5) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()</span><br><span class="line">def agree5():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&#x27;哈哈，骗你的小傻瓜！&#x27;)</span><br><span class="line">    l1.place(x=20,y=20)  </span><br><span class="line">    btn= tk.Button(root1, text=&quot;揍我?&quot;,bg=&quot;#e09780&quot;,command=agree6) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()</span><br><span class="line">def agree6():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&#x27;我怎么舍得骗我的xxx呢&#x27;)</span><br><span class="line">    l1.place(x=20,y=20)  </span><br><span class="line">    btn= tk.Button(root1, text=&quot;有惊喜哦&quot;,bg=&quot;#e09780&quot;,command=agree7) </span><br><span class="line">    btn.place(x=150,y=80)</span><br><span class="line">    root1.mainloop()</span><br><span class="line">def agree7():</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&#x27;嘿嘿 果然上当了 小笨蛋&#x27;)</span><br><span class="line">    l1.place(x=20,y=20)</span><br><span class="line">    root1.bind(&#x27;&lt;Motion&gt;&#x27;,agree8)</span><br><span class="line">    root1.focus_set()</span><br><span class="line">    root1.mainloop()  </span><br><span class="line">def agree8(event):</span><br><span class="line">    root1 = tk.Tk()</span><br><span class="line">    root1.title(&quot;小姐姐，我来表白啦，别跑呀&quot;)</span><br><span class="line">    root1.geometry(&quot;350x200&quot;)</span><br><span class="line">    root1.resizable(0,0)</span><br><span class="line">    root1.iconbitmap(&quot;icon.ico&quot;)</span><br><span class="line">    l1= tk.Label(root1,text=&#x27;当当当 别眨眼哦 惊喜在这呢&#x27;)</span><br><span class="line">    l1.place(x=20,y=20)</span><br><span class="line">    root1.bind(&#x27;&lt;Motion&gt;&#x27;,agree9)</span><br><span class="line">    root1.focus_set()</span><br><span class="line">    root1.mainloop() </span><br><span class="line"># 显示图片窗口 </span><br><span class="line">def agree9(event):</span><br><span class="line">    img = cv2.imread(&#x27;cp1.png&#x27;)</span><br><span class="line">    print(img)</span><br><span class="line">    cv2.imshow(&#x27;image&#x27;,img)</span><br><span class="line">    cv2.waitKey(5000)</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    # 这里是一个图片格式转换操作，如果使用PIL里面的方法显示图片的画有可能会出现格式错误打不开图片</span><br><span class="line">    # from PIL import Image</span><br><span class="line">    # img = Image.open(&quot;cp1.png&quot;)</span><br><span class="line">    # im= img.convert(&quot;RGB&quot;)</span><br><span class="line">    # im.save(&quot;D:\\File\\All\\python\\love\\image.jpg&quot;)</span><br><span class="line">    </span><br><span class="line"># 让窗口不能关闭函数   </span><br><span class="line">def callback(event):</span><br><span class="line">    # 查看触发事件的按钮</span><br><span class="line">    s=event.keysym</span><br><span class="line">    if s == &quot;Escape&quot;:</span><br><span class="line">        root.destroy()</span><br><span class="line">    </span><br><span class="line">text3= tk.Label(root,text=&quot;小姐姐我观察你好久了&quot;)</span><br><span class="line">text3.place(x=30,y=10)</span><br><span class="line">text4= tk.Label(root,text=&quot;做我女朋友好不好？&quot;,font=(&#x27;宋体&#x27;,20))</span><br><span class="line">text4.place(x=60,y=80)</span><br><span class="line"></span><br><span class="line">btn1= tk.Button(root,text=&#x27;我同意&#x27;,bg=&quot;#AAAAFF&quot;,command=agree1)</span><br><span class="line">btn1.place(x=100,y=200)</span><br><span class="line">btn1= tk.Button(root,text=&#x27;去你的&#x27;,bg=&quot;#AAAAFF&quot;,command=disagree1)</span><br><span class="line">btn1.place(x=300,y=200)</span><br><span class="line"></span><br><span class="line">img= tk.Label(root, image=image)</span><br><span class="line">img.place(x=300,y=40)</span><br><span class="line"></span><br><span class="line"># 让x不能关闭窗口只能点escape才能关闭窗口 </span><br><span class="line">root.protocol(&quot;WM_DELETE_WINDOW&quot;, callback)</span><br><span class="line">root.bind(&#x27;&lt;Key&gt;&#x27;,callback)</span><br><span class="line">root.focus_set()</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有问题的小伙伴可以直接私信博主（头像下面有联系方式哦）</p><p>展示（只放了一部分）</p><img src="/post/ce6b206b/1.png" class title="This is an image"><img src="/post/ce6b206b/2.png" class title="This is an image"><img src="/post/ce6b206b/3.png" class title="This is an image"><img src="/post/ce6b206b/4.png" class title="This is an image"><img src="/post/ce6b206b/5.png" class title="This is an image"><img src="/post/ce6b206b/6.png" class title="This is an image">]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搞笑表白 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter-布局管理器</title>
      <link href="/post/33f31c3e.html"/>
      <url>/post/33f31c3e.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter布局管理器（三种方法详解）"><a href="#Tkinter布局管理器（三种方法详解）" class="headerlink" title="Tkinter布局管理器（三种方法详解）"></a>Tkinter布局管理器（三种方法详解）</h5><p>布局管理指的是通过管理控件在窗口中的位置（排版），从而实现对窗口和控件布局的目的。Tkinter 提供了一系列布局管理的方法和容器控件。</p><p>Tkinter 提供了三种常用的布局管理器，分别是 pack()、grid() 以及 place()，如下：</p><p>方法说明<br>pack()按照控件的添加顺序其进行排列，遗憾的是此方法灵活性较差</p><p>grid()以行和列（网格）形式对控件进行排列，此种方法使用起来较为灵活</p><p>place()可以指定组件大小以及摆放位置，三个方法中最为灵活的布局方法</p><p>pack()</p><p>pack() 是一种较为简单的布局方法，在不使用任何参数的情况下，它会将控件以添加时的先后顺序，自上而下，一行一行的进行排列，并且默认居中显示。</p><h6 id="pack-方法的常用参数："><a href="#pack-方法的常用参数：" class="headerlink" title="pack() 方法的常用参数："></a>pack() 方法的常用参数：</h6><p>anchor<br>组件在窗口中的对齐方式，有 9 个方位参数值，比如”n”&#x2F;“w”&#x2F;“s”&#x2F;“e”&#x2F;“ne”，以及 “center” 等（这里的 e w s n分别代表，东西南北）</p><p>expand<br>是否可扩展窗口，参数值为 True（扩展）或者 False（不扩展），默认为 False，若设置为 True，则控件的位置始终位于窗口的中央位置</p><p>fill<br>参数值为 X&#x2F;Y&#x2F;BOTH&#x2F;NONE，表示允许控件在水平&#x2F;垂直&#x2F;同时在两个方向上进行拉伸，比如当 fill &#x3D; X 时，控件会占满水平方向上的所有剩余的空间。</p><p>ipadx,ipady<br>需要与 fill 参数值共同使用，表示组件与内容和组件边框的距离（内边距），比如文本内容和组件边框的距离，单位为像素(p)，或者厘米(c)、英寸(i)padx,pady用于控制组件之间的上下、左右的距离（外边距），单位为像素(p)，或者厘米(c)、英寸(i)</p><p>side<br>组件放置在窗口的哪个位置上，参数值 ‘top’,’bottom’,’left’,’right’。<br>注意，单词小写时需要使用字符串格式，若为大写单词则不必使用字符串格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import  *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;450x300+300+300&#x27;)</span><br><span class="line"></span><br><span class="line">lb_red = Label(win,text=&quot;红色&quot;,bg=&quot;Red&quot;,fg=&#x27;#ffffff&#x27;,relief=GROOVE)</span><br><span class="line"># 默认以top方式放置</span><br><span class="line">lb_red.pack()</span><br><span class="line"></span><br><span class="line">lb_blue = Label(win,text=&quot;蓝色&quot;,bg=&quot;blue&quot;,fg=&#x27;#ffffff&#x27;,relief=GROOVE)</span><br><span class="line"># 沿着水平方向填充，使用 pady 控制蓝色标签与其他标签的上下距离为 5 个像素</span><br><span class="line">lb_blue.pack(fill=X,pady=&#x27;5px&#x27;)</span><br><span class="line"></span><br><span class="line">lb_green = Label(win,text=&quot;绿色&quot;,bg=&quot;green&quot;,fg=&#x27;#ffffff&#x27;,relief=RAISED)</span><br><span class="line"># 将 标签所在区域都填充为黄色，当使用 fill 参数时，必须设置 expand = 1，否则不能生效</span><br><span class="line"></span><br><span class="line">lb_green.pack(side=LEFT,expand=1,fill = BOTH)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><h6 id="grid"><a href="#grid" class="headerlink" title="grid()"></a>grid()</h6><p>grid() 函数是一种基于网格式的布局管理方法，相当于把窗口看成了一张由行和列组成的表格。当使用该 grid 函数进行布局的时，表格内的每个单元格都可以放置一个控件。，从而实现对界面的布局管理。<br>注意：这里的所说的“表格”是虚拟出来，目的是便于大家理解，其实窗体并不会因为使用了 gird() 函数，而增加一个表格。</p><p>grid() 函数的常用参数：</p><p>column<br>控件位于表格中的第几列，窗体最左边的为起始列，默认为第 0 列</p><p>columnsapn<br>控件实例所跨的列数，默认为 1 列，通过该参数可以合并一行中多个领近单元格。</p><p>ipadx,ipady<br>用于控制内边距，在单元格内部，左右、上下方向上填充指定大小的空间。</p><p>padx,pady<br>用于控制外边距，在单元格外部，左右、上下方向上填充指定大小的空间。</p><p>row<br>控件位于表格中的第几行，窗体最上面为起始行，默认为第 0 行</p><p>rowspan<br>控件实例所跨的行数，默认为 1 行，通过该参数可以合并一列中多个领近单元格。</p><p>sticky<br>该属性用来设置控件位于单元格那个方位上，参数值和 anchor 相同，若不设置该参数则控件在单元格内居中</p><p>grid() 方法相比 pack() 方法来说要更加灵活，以网格的方式对组件进行布局管理，让整个布局显得非常简洁、优雅。如果说非要从三个布局管理器中选择一个使用的话，那么我推荐大家使用 grid() 方法。</p><p>这里有一点需要大家要特别注意，在一个程序中不能同时使用 pack() 和 grid() 方法，这两个方法只能二选一，否则程序会运行错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.config(bg=&#x27;#87CEEB&#x27;)</span><br><span class="line">win.geometry(&#x27;500x350+300+300&#x27;)</span><br><span class="line">#在窗口内创建按钮，以表格的形式依次排列</span><br><span class="line">for i in range (10):</span><br><span class="line">    for j in range (10):</span><br><span class="line">        Button (win, text=&quot; (&quot; + str(i) + &quot;,&quot;+ str(j)+ &quot;)&quot;,bg=&#x27;#D1EEEE&#x27;) .grid(row=i,column=j)</span><br><span class="line"># 在第5行第11列添加一个Label标签</span><br><span class="line">Label(win,text=&quot;qwer&quot;,fg=&#x27;blue&#x27;,font=(&#x27;楷体&#x27;,12,&#x27;bold&#x27;)).grid(row =4,column=11)</span><br><span class="line">#开始窗口的事件循环</span><br><span class="line">win. mainloop()</span><br></pre></td></tr></table></figure><p>当使用 grid 函数布局的时，其实就是为各个控件指定行号、列号的过程，我们不需要为每个单元格指定大小，因为 grid 会为每个单元格自动设置一个适合的尺寸。</p><p>通过 grid() 布局管理器制作一个简易的登录界面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import messagebox</span><br><span class="line"></span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.resizable(0,0)</span><br><span class="line"></span><br><span class="line">tk.Label(root, text=&quot;用户名&quot;).grid(row=0, sticky=&quot;w&quot;)</span><br><span class="line">tk.Label(root, text=&quot;密码&quot;).grid(row=1, sticky=&quot;w&quot;)</span><br><span class="line"></span><br><span class="line">tk.Entry(root).grid(row=0, column=1)</span><br><span class="line">tk.Entry(root, show=&quot;*&quot;).grid(row=1, column=1)</span><br><span class="line"></span><br><span class="line">tk.Label(root,text=&#x27;nihao&#x27;).grid(row=0, column=2, rowspan=2, padx=&#x27;4px&#x27;, pady=&#x27;5px&#x27;)</span><br><span class="line"></span><br><span class="line"># 编写一个回调函数</span><br><span class="line">def login():</span><br><span class="line">    messagebox.showinfo(&#x27;欢迎&#x27;)</span><br><span class="line"></span><br><span class="line"># 使用grid()函数来布局，并控制按钮的显示位置</span><br><span class="line">tk.Button(root, text=&quot;登录&quot;, width=10, command=login).grid(row=3, column=0, columnspan=2,sticky=&quot;w&quot;, padx=10, pady=5)</span><br><span class="line">tk.Button(root, text=&quot;退出&quot;, width=10, command=root.quit).grid(row=3, column=1, columnspan=2,sticky=&quot;e&quot;, padx=10, pady=5)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><h6 id="place"><a href="#place" class="headerlink" title="place()"></a>place()</h6><p>与前两种布局方法相比，采用 place() 方法进行布局管理要更加精细化，通过 place() 布局管理器可以直接指定控件在窗体内的绝对位置，或者相对于其他控件定位的相对位置。</p><p><strong>使用 place,设置第一个标签位于距离窗体左上角的位置和其大小（width，height）注意这里（x,y）位置坐标指的是标签左上角的位置（以NW左上角进行绝对定位，默认为NW）</strong></p><p>anchor<br>定义控件在窗体内的方位，参数值N&#x2F;NE&#x2F;E&#x2F;SE&#x2F;S&#x2F;SW&#x2F;W&#x2F;NW 或 CENTER，默认值是 NW</p><p>bordermode<br>定义控件的坐标是否要考虑边界的宽度，参数值为 OUTSIDE（排除边界） 或 INSIDE（包含边界），默认值 INSIDE。</p><p>x、y<br>定义控件在根窗体中水平和垂直方向上的<strong>起始</strong>绝对位置</p><p>relx、rely</p><ol><li>定义控件相对于根窗口（或其他控件）在水平和垂直方向上的相对位置（即位移比例），取值范围再 0.0~1.0 之间</li><li>可设置 in_ 参数项，相对于某个其他控件的位置</li></ol><p>height、width<br>控件自身的高度和宽度（单位为像素）</p><p>relheight、relwidth<br>控件高度和宽度相对于根窗体高度和宽度的比例，取值也在 0.0~1.0 之间</p><p>relx和rely参数指定的是控件相对于父组件的位置，而relwidth和relheight参数则是指定控件相对于父组件的尺寸大小。注意：这里父组件指的是当前可操作控件的上层组件，比如在没有使用容器控件（frame）的窗体中，控件的父组件就是主窗口本身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from tkinter import *</span><br><span class="line">#主窗口</span><br><span class="line">win = Tk()</span><br><span class="line"></span><br><span class="line">#创建一个frame窗体对象，用来包裹标签</span><br><span class="line">frame = Frame (win, relief=SUNKEN, borderwidth=2, width=450, height=250)</span><br><span class="line"># 在水平、垂直方向上填充窗体</span><br><span class="line">frame. pack (side=TOP, fill=BOTH, expand=1)</span><br><span class="line"></span><br><span class="line"># 创建 &quot;位置1&quot;</span><br><span class="line">Label1 = Label ( frame, text=&quot;位置1&quot;,bg=&#x27;blue&#x27;,fg=&#x27;white&#x27;)</span><br><span class="line"># 使用 place,设置第一个标签位于距离窗体左上角的位置（40,40）和其大小（width，height）</span><br><span class="line"># 注意这里（x,y）位置坐标指的是标签左上角的位置（以NW左上角进行绝对定位，默认为NW）</span><br><span class="line">Label1.place (x=40,y=40, width=60, height=30)</span><br><span class="line"></span><br><span class="line"># 设置标签2</span><br><span class="line">Label2 = Label (frame, text=&quot;位置2&quot;,bg=&#x27;purple&#x27;,fg=&#x27;white&#x27;)</span><br><span class="line"># 以右上角进行绝对值定位，anchor=NE，第二个标签的位置在距离窗体左上角的(180，80)</span><br><span class="line">Label2.place(x=180,y=80, anchor=NE, width=60, height=30)</span><br><span class="line"></span><br><span class="line"># 设置标签3</span><br><span class="line">Label3 = Label (frame, text=&quot;位置3&quot;,bg=&#x27;green&#x27;,fg=&#x27;white&#x27;)</span><br><span class="line"># 设置水平起始位置相对于窗体水平距离的0.6倍，垂直的绝对距离为80，大小为60，30</span><br><span class="line">Label3.place(relx=0.6,y=80, width=60, height=30)</span><br><span class="line"></span><br><span class="line"># 设置标签4</span><br><span class="line">Label4 = Label (frame, text=&quot;位置4&quot;,bg=&#x27;gray&#x27;,fg=&#x27;white&#x27;)</span><br><span class="line"># 设置水平起始位置相对于窗体水平距离的0.01倍，垂直的绝对距离为80，并设置高度为窗体高度比例的0.5倍，宽度为80</span><br><span class="line">Label4.place(relx=0.01,y=80,relheight=0.4,width=80)</span><br><span class="line">#开始事件循环</span><br><span class="line">win. mainloop()</span><br></pre></td></tr></table></figure><p>注意：在一个父组件中 place()方法可以与 grid() 方法混合使用，要与 pack() 进行区别。</p><p>一般博主推荐 简单的布局的画就使用pack 和 grid 就好了，相对较复杂的布局时就是用place</p><p>还有就是需要注意有时候使用grid布局 可能没有效果，这个需要自己分析一下，博主之际也遇到过这种情况</p>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os模块简单使用</title>
      <link href="/post/6ef6247d.html"/>
      <url>/post/6ef6247d.html</url>
      
        <content type="html"><![CDATA[<h5 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h5><p>作用：获取当前的工作路径；</p><h5 id="os-listdir-path"><a href="#os-listdir-path" class="headerlink" title="os.listdir(path)"></a>os.listdir(path)</h5><p>传入任意一个path路径，返回的是该路径下所有文件和目录组成的列表；</p><h5 id="os-walk-path"><a href="#os-walk-path" class="headerlink" title="os.walk(path)"></a>os.walk(path)</h5><p>传入任意一个path路径，深层次遍历指定路径下的所有子文件夹，返回的是一个由路径、文件夹列表、文件列表组成的元组。我代码中写的方式属于元组拆包；</p><p>元组拆包：就是将一个元组中的每个值，赋值给不同的变量；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path = r&quot;C:\Users\Desktop\publish\os模块&quot;</span><br><span class="line">for path,dirs,files in os.walk(path):</span><br><span class="line">    print(path)</span><br><span class="line">    print(dirs)</span><br><span class="line">    print(files)</span><br><span class="line">    print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure><h5 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os.path.exists(path)"></a>os.path.exists(path)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path1 = &#x27;C:\Users\Desktop\publish\os模块&#x27;</span><br><span class="line"></span><br><span class="line">if os.path.exists(path1):</span><br><span class="line">    print(&quot;指定文件夹存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;指定文件夹不存在&quot;)</span><br></pre></td></tr></table></figure><h5 id="os-mkdir-path"><a href="#os-mkdir-path" class="headerlink" title="os.mkdir(path)"></a>os.mkdir(path)</h5><p>含义：传入一个path路径，创建单层(单个)文件夹；</p><p>注意：如果文件夹已经存在，就会报错。因此创建文件夹之前，需要使用os.path.exists(path)函数判断文件夹是否存在；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()</span><br><span class="line">path1 = os.getcwd()+&quot;\\i&quot;</span><br><span class="line">os.mkdir(path1)</span><br></pre></td></tr></table></figure><h5 id="os-makedirs-path"><a href="#os-makedirs-path" class="headerlink" title="os.makedirs(path)"></a>os.makedirs(path)</h5><p>含义：传入一个path路径，生成一个递归的文件夹；<br>注意：如果文件夹存在，就会报错。因此创建文件夹之前，需要使用os.path.exists(path)函数判断文件夹是否存在；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.getcwd()</span><br><span class="line">path1 = os.getcwd()+&quot;\\ngei&quot;</span><br><span class="line">os.makedirs(path1)</span><br></pre></td></tr></table></figure><h5 id="os-rmdir-path"><a href="#os-rmdir-path" class="headerlink" title="os.rmdir(path)"></a>os.rmdir(path)</h5><p>含义：传入一个path路径，删除指定路径下的文件夹；</p><p>注意：该方法只能删除空文件夹，删除非空文件夹会报错；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path1 = os.getcwd()+&quot;\\i&quot;</span><br><span class="line">os.rmdir(path1)</span><br><span class="line">path2 = os.getcwd()+&quot;\\a\\b\\c&quot;</span><br><span class="line">os.rmdir(path2) </span><br></pre></td></tr></table></figure><h5 id="os-path-join-path1-path2"><a href="#os-path-join-path1-path2" class="headerlink" title="os.path.join(path1,path2)"></a>os.path.join(path1,path2)</h5><p>含义：传入两个path路径，将该路径拼接起来，形成一个新的完整路径；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = os.getcwd()</span><br><span class="line">lis = [&quot;a.jpg&quot;,&quot;b.jpg&quot;,&quot;c.jpg&quot;]</span><br><span class="line">for i in lis:</span><br><span class="line">    x = os.path.join(path,i)</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><h5 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path)"></a>os.path.split(path)</h5><p>含义：传入一个完整的path路径，将其拆分为绝对路径和文件名2部分；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = &#x27;D:\File\All\python\blog\jiemian.jpg&#x27;</span><br><span class="line">print(os.path.split(path))</span><br></pre></td></tr></table></figure><h5 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h5><p>含义：传入一个完整的文件路径，只获取其绝对路径；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path1 = r&quot;D:\File\All\python\blog\jiemian.jpg&quot;</span><br><span class="line">os.path.dirname(path1)</span><br></pre></td></tr></table></figure><h5 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h5><p>含义：传入一个完整的文件路径，只获取其文件名；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path1 = r&quot;D:\File\All\python\blog\jiemian.jpg&quot;</span><br><span class="line">os.path.basename(path1)</span><br></pre></td></tr></table></figure><h5 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os.path.isdir(path)"></a>os.path.isdir(path)</h5><p>含义：传入一个完整的文件路径，判断它是否是文件夹；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = os.getcwd()</span><br><span class="line">file_list = os.listdir()</span><br><span class="line">for file in file_list:</span><br><span class="line">    if os.path.isdir(file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h5 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path)"></a>os.path.isfile(path)</h5><p>含义：传入一个完整的文件路径，判断它是否是文件；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = os.getcwd()</span><br><span class="line">file_list = os.listdir()</span><br><span class="line">for file in file_list:</span><br><span class="line">    if os.path.isfile(file):</span><br><span class="line">        print(file)</span><br></pre></td></tr></table></figure><h5 id="os-path-sep"><a href="#os-path-sep" class="headerlink" title="os.path.sep"></a>os.path.sep</h5><p>含义：返回当前操作系统的路径分隔符；</p><p>print(os.path.sep)</p><h5 id="os-path-getsize-path"><a href="#os-path-getsize-path" class="headerlink" title="os.path.getsize(path)"></a>os.path.getsize(path)</h5><p>含义：传入一个完整的文件路径，返回该文件的大小；</p>]]></content>
      
      
      <categories>
          
          <category> python os模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升九</title>
      <link href="/post/8b7b2458.html"/>
      <url>/post/8b7b2458.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python-logging模块简单用法"><a href="#Python-logging模块简单用法" class="headerlink" title="Python logging模块简单用法"></a>Python logging模块简单用法</h5><p> logging 模块可以很容易地创建自定义的消息记录，这些日志消息将描述程序执行何时到达日志函数调用，并列出指定的任何变量当时的值。</p><p>启用 logging 模块很简单，直接将下面的代码复制到程序开头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=&#x27; %(asctime)s - %(levelname)s - %(message)s&#x27;)</span><br></pre></td></tr></table></figure><p>当 Python 记录一个事件的日志时，它会创建一个 LogRecord 对象，保存关于该事件的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level=logging.DEBUG, format=&#x27; %(asctime)s - %(levelname)s - %(message)s&#x27;)</span><br><span class="line">for i in range(0,5):</span><br><span class="line">   logging.debug(&#x27;i is &#x27; + str(i))</span><br></pre></td></tr></table></figure><p>通过 logging.debug() 函数可以打印日志信息，这个 debug() 函数将调用 basicConfig() 打印一行信息，这行信息的格式是在 basicConfig() 函数中指定的，并且包括传递给 debug() 的消息。</p><h6 id="Python-logging日志级别"><a href="#Python-logging日志级别" class="headerlink" title="Python logging日志级别"></a>Python logging日志级别</h6><p>“日志级别”提供了一种方式，按重要性对日志消息进行分类。5 个日志级别如图所示，从最不重要到最重要。利用不同的日志函数，消息可以按某个级别记入日志。</p><img src="/post/8b7b2458/40.png" class title="This is an image"><p>日志级别的好处在于，我们可以改变想看到的日志消息的优先级。比如说，向 basicConfig() 函数传入 logging.DEBUG 作为 level 关键字参数，这将显示所有级别为 DEBUG 的日志消息。</p><p>当开发了更多的程序后，我们可能只对错误感兴趣，在这种情况下，可以将 basicConfig() 的 level 参数设置为 logging.ERROR，这将只显示 ERROR 和 CRITICAL 消息，跳过 DEBUG、INFO 和 WARNING 消息。</p><h6 id="Python-logging禁用日志"><a href="#Python-logging禁用日志" class="headerlink" title="Python logging禁用日志"></a>Python logging禁用日志</h6><p>在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用。</p><p>logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可，</p><p>将日志消息输出到文件中<br>虽然日志消息很有用，但它们可能塞满屏幕，让你很难读到程序的输出。考虑到这种情况，可以将日志信息写入到文件，既能使屏幕保持干净，又能保存信息，一举两得。</p><p>将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(filename=&quot;aa.txt&quot;,level=logging.DEBUG, format=&#x27; %(asctime)s - %(levelname)s - %(message)s&#x27;)</span><br><span class="line">for i in range(0,5):</span><br><span class="line">   logging.debug(&#x27;i is &#x27; + str(i))</span><br></pre></td></tr></table></figure><p>此程序中，将日志消息存储到了 demo.txt 文件中，该文件就位于运行的程序文件所在的目录。</p><h5 id="文件路径，Python中如何书写文件路径"><a href="#文件路径，Python中如何书写文件路径" class="headerlink" title="文件路径，Python中如何书写文件路径"></a>文件路径，Python中如何书写文件路径</h5><p>路径中的 D:\ 指的是“根文件夹”，它包含了所有其他文件夹。在 Windows 中，根文件夹名为 D:\，也称为 D: 盘</p><p>在 Windows 上，路径书写使用反斜杠 “&quot; 作为文件夹之间的分隔符</p><p>不仅如此，如果需要创建带有文件名称的文件存储路径，<br>os.path.join() 函数同样很有用。<br>下面的例子将一个文件名列表中的名称，添加到文件夹名称的末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">path = os.getcwd()</span><br><span class="line">lis = [&quot;a.jpg&quot;,&quot;b.jpg&quot;,&quot;c.jpg&quot;]</span><br><span class="line">for i in lis:</span><br><span class="line">    x = os.path.join(path,i)</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><h5 id="Python绝对路径和相对路径详解"><a href="#Python绝对路径和相对路径详解" class="headerlink" title="Python绝对路径和相对路径详解"></a>Python绝对路径和相对路径详解</h5><h6 id="什么是绝对路径与相对路径"><a href="#什么是绝对路径与相对路径" class="headerlink" title="什么是绝对路径与相对路径"></a>什么是绝对路径与相对路径</h6><p>明确一个文件所在的路径，有 2 种表示方式，分别是：<br>绝对路径：总是从根文件夹开始，Window 系统中以盘符（C：、D：）作为根文件夹，而 OS X 或者 Linux 系统中以 &#x2F; 作为根文件夹。<br>相对路径：指的是文件相对于当前工作目录所在的位置。例如，当前工作目录为 “C:\Windows\System32”，若文件 demo.txt 就位于这个 System32 文件夹下，则 demo.txt 的相对路径表示为 “.\demo.txt”（其中 .\ 就表示当前所在目录）。</p><p>在使用相对路径表示某文件所在的位置时，除了经常使用 .\ 表示当前所在目录之外，还会用到 ..\ 表示当前所在目录的父目录。</p><h6 id="Python处理绝对路径和相对路径"><a href="#Python处理绝对路径和相对路径" class="headerlink" title="Python处理绝对路径和相对路径"></a>Python处理绝对路径和相对路径</h6><p>Python os.path 模块提供了一些函数，可以实现绝对路径和相对路径之间的转换，以及检查给定的路径是否为绝对路径，比如说：</p><p><a href="https://xiaoyangzst.vercel.app/post/6ef6247d.html">os模块</a></p><h5 id="Python文件基本操作"><a href="#Python文件基本操作" class="headerlink" title="Python文件基本操作"></a>Python文件基本操作</h5><p>Python 中，对文件的操作有很多种，常见的操作包括创建、删除、修改权限、读取、写入等</p><p>这些操作可大致分为以下 2 类：<br>删除、修改权限：作用于文件本身，属于系统级操作。</p><p>写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。</p><p>对文件的系统级操作功能单一，比较容易实现，可以借助 Python 中的专用模块（os、sys 等），并调用模块中的指定函数来实现。</p><p>假设如下代码文件的同级目录中有一个文件“a.txt”，通过调用 os 模块中的 remove 函数，可以将该文件删除，具体实现代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.remove(&quot;a.txt&quot;)</span><br></pre></td></tr></table></figure><p>文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：</p><p>打开文件：使用 open() 函数，该函数会返回一个<strong>文件对象</strong>；</p><p>对已打开文件做读&#x2F;写操作：读取文件内容可使用 read()、readline() 以及 readlines() 函数；<br>向文件中写入内容，可以使用 write() 函数。</p><p>关闭文件：完成对文件的读&#x2F;写操作之后，最后需要关闭文件，可以使用 close() 函数。</p><h5 id="Python-open-函数详解：打开指定文件"><a href="#Python-open-函数详解：打开指定文件" class="headerlink" title="Python open()函数详解：打开指定文件"></a>Python open()函数详解：打开指定文件</h5><p>在 Python 中，如果想要操作文件，首先需要创建或者打开指定的文件，并创建一个文件对象，而这些工作可以通过内置的 open() 函数实现。</p><p>语法格式：</p><p>file &#x3D; open(file_name [, mode&#x3D;’r’ [ , buffering&#x3D;-1 [ , encoding &#x3D; None ]]]) </p><p>名称要用引号（单引号或双引号都可以）括起来。</p><p>需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可，否则，此参数需要指定打开文件所在的完整路径。</p><p>mode：可选参数，用于指定文件的打开模式</p><img src="/post/8b7b2458/41.png" class title="This is an image"><p>如果不写，则默认以只读（r）模式打开文件。</p><p>buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区</p><p>encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同。</p><h6 id="open-是否需要缓冲区"><a href="#open-是否需要缓冲区" class="headerlink" title="open()是否需要缓冲区"></a>open()是否需要缓冲区</h6><p>通常情况下、建议大家在使用 open() 函数时打开缓冲区，即不需要修改 buffing 参数的值。</p><p>如果 buffing 参数的值为 0（或者 False），则表示在打开指定文件时不使用缓冲区；</p><p>如果 buffing 参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；</p><p>如果 buffing 参数的值为负数，则代表使用默认的缓冲区大小。</p><p>因为目前为止计算机内存的 I&#x2F;O 速度仍远远高于计算机外设（例如键盘、鼠标、硬盘等）的 I&#x2F;O 速度，如果不使用缓冲区，则程序在执行 I&#x2F;O 操作时，内存和外设就必须进行同步读写操作，也就是说，内存必须等待外设输入（输出）一个字节之后，才能再次输出（输入）一个字节。这意味着，内存中的程序大部分时间都处于等待状态。<br>而如果使用缓冲区，则程序在执行输出操作时，会先将所有数据都输出到缓冲区中，然后继续执行其它操作，缓冲区中的数据会有外设自行读取处理；同样，当程序执行输入操作时，会先等外设将数据读入缓冲区中，无需同外设做同步读写操作。</p><h6 id="open-文件对象常用的属性"><a href="#open-文件对象常用的属性" class="headerlink" title="open()文件对象常用的属性"></a>open()文件对象常用的属性</h6><p>成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：</p><p>file.name：返回文件的名称；</p><p>file.mode：返回打开文件时，采用的文件打开模式；</p><p>file.encoding：返回打开文件时使用的编码格式；</p><p>file.closed：判断文件是否己经关闭。</p><h6 id="Python-read-函数"><a href="#Python-read-函数" class="headerlink" title="Python read()函数"></a>Python read()函数</h6><p>对于借助 open() 函数，并以可读模式（包括 r、r+、rb、rb+）打开的文件，可以调用 read() 函数逐个字节（或者逐个字符）读取文件中的内容。如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；</p><p>反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。<br>语法格式： file.read([size])</p><p>file 表示已打开的文件对象；</p><p>size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。</p><p>当然，我们也可以通过使用 size 参数，指定 read() 每次可读取的最大字符（或者字节）数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = open(&quot;aa.txt, encoding= &quot;utf-8&quot;)</span><br><span class="line">print(file.read())</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>但是一般都使用这种方式打开<br>这样可以不用 关闭操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;aa.txt&quot;,encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">   print(f.read())</span><br></pre></td></tr></table></figure><h6 id="read-函数抛出UnicodeDecodeError异常的解决方法"><a href="#read-函数抛出UnicodeDecodeError异常的解决方法" class="headerlink" title="read()函数抛出UnicodeDecodeError异常的解决方法"></a>read()函数抛出UnicodeDecodeError异常的解决方法</h6><p>在使用 read() 函数时，如果 Python 解释器提示UnicodeDecodeError异常，其原因在于，目标文件使用的编码格式和 open() 函数打开该文件时使用的编码格式不匹配。<br>举个例子，如果目标文件的编码格式为 GBK 编码，而我们在使用 open() 函数并以文本模式打开该文件时，手动指定 encoding 参数为 UTF-8。这种情况下，由于编码格式不匹配，当我们使用 read() 函数读取目标文件中的数据时，Python 解释器就会提示UnicodeDecodeError异常。<br>要解决这个问题，要么将 open() 函数中的 encoding 参数值修改为和目标文件相同的编码格式，要么重新生成目标文件（即将该文件的编码格式改为和 open() 函数中的 encoding 参数相同）。</p><p>除此之外，还有一种方法：先使用二进制模式读取文件，然后调用 bytes 的 decode() 方法，使用目标文件的编码格式，将读取到的字节串转换成认识的字符串。<br>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#以二进制形式打开指定文件，该文件编码格式为 utf-8</span><br><span class="line">f = open(&quot;aa.txt&quot;,&#x27;rb+&#x27;)</span><br><span class="line">byt = f.read()</span><br><span class="line">print(byt)</span><br><span class="line">print(&quot;\n转换后：&quot;)</span><br><span class="line">print(byt.decode(&#x27;utf-8&#x27;))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h6 id="Python-readline-和readlines-函数：按行读取文件"><a href="#Python-readline-和readlines-函数：按行读取文件" class="headerlink" title="Python readline()和readlines()函数：按行读取文件"></a>Python readline()和readlines()函数：按行读取文件</h6><p>这 2 个函数都以“行”作为读取单位，即每次都读取目标文件中的一行。</p><p>对于读取以文本格式打开的文件，读取一行很好理解；</p><p>对于读取以二进制格式打开的文件，它们会以“\n”作为读取一行的标志。</p><h6 id="Python-readline-函数"><a href="#Python-readline-函数" class="headerlink" title="Python readline()函数"></a>Python readline()函数</h6><p>readline() 函数用于读取文件中的一行，包含最后的换行符“\n”。</p><p>语法格式：<br>file.readline([size])</p><p>size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。</p><h6 id="Python-readlines-函数"><a href="#Python-readlines-函数" class="headerlink" title="Python readlines()函数"></a>Python readlines()函数</h6><p>readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数<strong>返回是一个字符串列表</strong>，其中每个元素为文件中的一行内容。</p><p>语法格式：<br>file.readlines()</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升八</title>
      <link href="/post/36f0a209.html"/>
      <url>/post/36f0a209.html</url>
      
        <content type="html"><![CDATA[<h5 id="什么是异常处理，Python常见异常类型"><a href="#什么是异常处理，Python常见异常类型" class="headerlink" title="什么是异常处理，Python常见异常类型"></a>什么是异常处理，Python常见异常类型</h5><p>编写程序时遇到的错误可大致分为 2 类，分别为语法错误和运行时错误。</p><h6 id="Python语法错误"><a href="#Python语法错误" class="headerlink" title="Python语法错误"></a>Python语法错误</h6><p>语法错误，也就是解析代码时出现的错误。当代码不符合 Python 语法规则时，Python解释器在解析时就会报出 SyntaxError 语法错误，与此同时还会明确指出最早探测到错误的语句。</p><h6 id="Python运行时错误"><a href="#Python运行时错误" class="headerlink" title="Python运行时错误"></a>Python运行时错误</h6><p>运行时错误，即程序在语法上都是正确的，但在运行时发生了错误。<br>在 Python 中，把这种运行时产生错误的情况叫做异常</p><img src="/post/36f0a209/37.png" class title="This is an image"><h5 id="Python异常处理机制"><a href="#Python异常处理机制" class="headerlink" title="Python异常处理机制"></a>Python异常处理机制</h5><p>使用 Python 的异常处理机制就可以解决这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try：</span><br><span class="line">    if(用户输入不合理)：</span><br><span class="line">        raise 异常</span><br><span class="line">except Exception：</span><br><span class="line">    alert 输入不合法</span><br><span class="line">    goto retry</span><br><span class="line">#正常的业务代码</span><br></pre></td></tr></table></figure><p>此程序中，通过在 try 块中判断用户的输入数据是否合理，如果不合理，程序受 raise 的影响会进行到 except 代码块，对用户的错误输出进行处理，然后会继续执行正常的业务代码；反之，如果用户输入合理，那么程序将直接执行正常的业务代码。<br>try except 是 Python 实现异常处理机制的核心结构</p><h5 id="Python-try-except异常处理详解"><a href="#Python-try-except异常处理详解" class="headerlink" title="Python try except异常处理详解"></a>Python try except异常处理详解</h5><p>Python 中，用try except语句块捕获并处理异常<br>语法结构：</p><p>try:<br>    可能产生异常的代码块<br>except [ (Error1, Error2, … ) [as e] ]:<br>    处理异常的代码块1<br>except [ (Error3, Error4, … ) [as e] ]:<br>    处理异常的代码块2<br>except  [Exception]:<br>    处理其它异常</p><p>该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：<br>(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。<br>[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型<br>[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。</p><p>try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常</p><p>try except 语句的执行流程如下：<br>首先执行 try 中的代码块，如果执行过程中出现异常，<strong>系统会自动生成一个异常类型</strong>，并将该异常提交给 Python 解释器，此过程称为捕获异常。<br>当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。</p><p><strong>如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出</strong>。</p><p>事实上，不管程序代码块是否处于 try 块中，甚至包括 except 块中的代码，只要执行该代码块时出现了异常，系统都会自动生成对应类型的异常。<br>但是，如果此段程序没有用 try 包裹，又或者没有为该异常配置处理它的 except 块，则 Python 解释器将无法处理，程序就会停止运行；反之，如果程序发生的异常经 try 捕获并由 except 处理完成，则程序可以继续执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = int(input(&quot;输入被除数：&quot;))</span><br><span class="line">    b = int(input(&quot;输入除数：&quot;))</span><br><span class="line">    c = a / b</span><br><span class="line">    print(&quot;您输入的两个数相除的结果是：&quot;, c )</span><br><span class="line">except (ValueError, ArithmeticError):</span><br><span class="line">    print(&quot;程序发生了数字格式异常、算术异常之一&quot;)</span><br><span class="line">except :</span><br><span class="line">    print(&quot;未知异常&quot;)</span><br><span class="line">print(&quot;程序继续运行&quot;)</span><br></pre></td></tr></table></figure><p>上面程序中，使用了（ValueError, ArithmeticError）来指定所捕获的异常类型，这就表明该 except 块可以同时捕获这 2 种类型的异常；<br>只有 except 关键字，并未指定具体要捕获的异常类型，这种省略异常类的 except 语句也是合法的，它表示可捕获所有类型的异常，一般会作为异常捕获的最后一个 except 块。</p><h6 id="获取特定异常的有关信息"><a href="#获取特定异常的有关信息" class="headerlink" title="获取特定异常的有关信息"></a>获取特定异常的有关信息</h6><p>其实，每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：</p><p>args：返回异常的错误编号和描述字符串；</p><p>str(e)：返回异常信息，但不包括异常信息的类型；</p><p>repr(e)：返回较全的异常信息，包括异常信息的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    1/0</span><br><span class="line">except Exception as e:</span><br><span class="line">    # 访问异常的错误编号和详细信息</span><br><span class="line">    print(e.args)</span><br><span class="line">    print(str(e))</span><br><span class="line">    print(repr(e))</span><br></pre></td></tr></table></figure><p>除此之外，如果想要更加详细的异常信息，可以使用 traceback 模块</p><p>从程序中可以看到，由于 except 可能接收多种异常，因此为了操作方便，可以直接给每一个进入到此 except 块的异常，起一个统一的别名 e。</p><h5 id="Python异常处理机制的底层实现"><a href="#Python异常处理机制的底层实现" class="headerlink" title="Python异常处理机制的底层实现"></a>Python异常处理机制的底层实现</h5><p>try except异常处理的用法，简单来说，当位于 try 块中的程序执行出现异常时，会将该种异常捕获，同时找到对应的 except 块处理该异常，那么这里就有一个问题，它是如何找到对应的 except 块的呢？</p><p>我们知道，一个 try 块也可以对应多个 except 块，一个 except 块可以同时处理多种异常。如果我们想使用一个 except 块处理所有异常，就可以这样写</p><p>try:<br>    #…<br>except Exception:<br>    #…</p><p>try 块中可能出现的任何异常，Python 解释器都会交给仅有的这个<br> except 块处理，因为它的参数是 Exception，表示可以接收任何类型的异常。<br>注意，对于可以接收任何异常的 except 来说，其后可以跟 Exception，也可以不跟任何参数，但表示的含义都是一样的。</p><p>详细介绍一下 Exception。要知道，为了表示程序中可能出现的各种异常，Python 提供了大量的异常类，这些异常类之间有严格的继承关系，图显示了 Python 的常见异常类之间的继承关系。</p><img src="/post/36f0a209/38.png" class title="This is an image"><p>BaseException 是 Python 中所有异常类的基类，但对于我们来说，最主要的是 Exception 类，因为程序中可能出现的各种异常，都继承自 Exception。</p><p>如果用户要实现自定义异常，不应该继承 BaseException ，而应该继承 Exception 类。</p><p>关于如何<strong>自定义一个异常类</strong></p><p>当 try 块捕获到异常对象后，Python 解释器会拿这个异常类型依次和各个 except 块指定的异常类进行比较，如果捕获到的这个异常类，和某个 except 块后的异常类一样，又或者是该异常类的子类，那么 Python 解释器就会调用这个 except 块来处理异常；反之，Python 解释器会继续比较，直到和最后一个 except 比较完，如果没有比对成功，则证明该异常无法处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = int(input(&quot;输入 a：&quot;))</span><br><span class="line">    b = int(input(&quot;输入 b：&quot;))</span><br><span class="line">    print( a/b )</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;数值错误：程序只能接收整数参数&quot;)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;算术错误&quot;)</span><br><span class="line">except Exception:</span><br><span class="line">    print(&quot;未知异常&quot;)</span><br></pre></td></tr></table></figure><p>该程序中，根据用户输入 a 和 b 值的不同，可能会导致 ValueError、ArithmeticError 异常：</p><p>如果用户输入的 a 或者 b 是其他字符，而不是数字，会发生 ValueError 异常，try 块会捕获到该类型异常，同时 Python 解释器会调用第一个 except 块处理异常；</p><p>如果用户输入的 a 和 b 是数字，但 b 的值为 0，由于在进行除法运算时除数不能为 0，因此会发生 ArithmeticError 异常，try 块会捕获该异常，同时 Python 解释器会调用第二个 except 块处理异常；<br>当然，程序运行过程中，还可能由于其他因素出现异常，try 块都可以捕获，同时 Python 会调用最后一个 except 块来处理。<br>当一个 try 块配有多个 except 块时，这些 except 块应遵循这样一个排序规则，即可处理全部异常的 except 块（参数为 Exception，也可以什么都不写）要放到所有 except 块的后面，且所有父类异常的 except 块要放到子类异常的 except 块的后面。</p><h5 id="Python-try-except-else"><a href="#Python-try-except-else" class="headerlink" title="Python try except else"></a>Python try except else</h5><p>在原本的try except结构的基础上，Python 异常处理机制还提供了一个 else 块，也就是<strong>原有 try except 语句的基础上再添加一个 else 块</strong>，即try except else结构。</p><p>使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；<br>反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 20 / int(input(&#x27;请输入除数:&#x27;))</span><br><span class="line">    print(result)</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&#x27;必须输入整数&#x27;)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&#x27;算术错误，除数不能为 0&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;没有出现异常&#x27;)</span><br><span class="line">print(&quot;继续执行&quot;)</span><br></pre></td></tr></table></figure><p>当我们输入正确的数据时，try 块中的程序正常执行，Python 解释器执行完 try 块中的程序之后，会继续执行 else 块中的程序，继而执行后续的程序。</p><h5 id="Python-try-except-finally：资源回收"><a href="#Python-try-except-finally：资源回收" class="headerlink" title="Python try except finally：资源回收"></a>Python try except finally：资源回收</h5><p>Python 异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作。注意，和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 不是必须的<strong>else 必须和 try except 搭配使用</strong>。<br>在整个异常处理机制中，finally 语句的功能是：<strong>无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块</strong>。</p><p>基于 finally 语句的这种特性，在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在 finally 块中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = int(input(&quot;请输入 a 的值:&quot;))</span><br><span class="line">    print(20/a)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;发生异常！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;执行 else 块中的代码&quot;)   </span><br><span class="line">finally :</span><br><span class="line">    print(&quot;执行 finally 块中的代码&quot;)</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：<br>在整个异常处理结构中，只有 try 块是必需的，也就是说：<br>如果没有 try 块，则不能有后面的 except 块、else 块和 finally 块。</p><p>但是也不能只使用 try 块，要么使用 try except 结构，要么使用 try finally 结构；except 块、else 块、finally 块都是可选的，当然也可以同时出现；</p><p>可以有多个 except 块，但捕获父类异常的 except 块应该位于捕获子类异常的 except 块的后面；多个 except 块必须位于 try 块之后，finally 块必须位于所有的 except 块之后。要使用 else 块，其前面必须包含 try 和 except。</p><p>另外在通常情况下，不要在 finally 块中使用如 return 或 raise 等导致方法中止的语句，一旦在 finally 块中使用了 return 或 raise 语句，将会导致 try 块、except 块中的 return、raise 语句失效</p><p>同样，如果 Python 程序在执行 try 块、except 块包含有 return 或 raise 语句，则 Python 解释器执行到该语句时，会先去查找 finally 块，如果没有 finally 块，程序才会立即执行 return 或 raise 语句；</p><p>反之，如果找到 finally 块，系统立即开始执行 finally 块，只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、except 块里的 return 或 raise 语句。<br>但是，如果在 finally 块里也使用了 return 或 raise 等导致方法中止的语句，finally 块己经中止了方法，系统将不会跳回去执行 try 块、except 块里的任何代码。</p><h5 id="Python-raise用法"><a href="#Python-raise用法" class="headerlink" title="Python raise用法"></a>Python raise用法</h5><p>Python 允许我们在程序中手动设置异常，使用 raise 语句即可。</p><p>raise 语句的基本语法格式为：raise [exceptionName [(reason)]]<br>其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。</p><p>也就是说，raise 语句有如下三种常用的用法：<br>raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。</p><p>raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。<br>raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = input(&quot;输入一个数：&quot;)</span><br><span class="line">    #判断用户输入的是否为数字</span><br><span class="line">    if(not a.isdigit()):</span><br><span class="line">        raise ValueError(&quot;a 必须是数字&quot;)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;引发异常：&quot;,repr(e))</span><br></pre></td></tr></table></figure><p>当然，我们手动让程序引发异常，很多时候并不是为了让其崩溃。事实上，raise 语句引发的异常通常用 try except（else finally）异常处理结构来捕获并进行处理。例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = input(&quot;输入一个数：&quot;)</span><br><span class="line">    #判断用户输入的是否为数字</span><br><span class="line">    if(not a.isdigit()):</span><br><span class="line">        raise ValueError(&quot;a 必须是数字&quot;)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;引发异常：&quot;,repr(e))</span><br></pre></td></tr></table></figure><p> raise 不需要参数<br>正如前面所看到的，在使用 raise 语句时可以不带参数，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    a = input(&quot;输入一个数：&quot;)</span><br><span class="line">    if(not a.isdigit()):</span><br><span class="line">        raise</span><br><span class="line">except RuntimeError as e:</span><br><span class="line">    print(&quot;引发异常：&quot;,repr(e))</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h5 id="Python-sys-exc-info-方法：获取异常信息"><a href="#Python-sys-exc-info-方法：获取异常信息" class="headerlink" title="Python sys.exc_info()方法：获取异常信息"></a>Python sys.exc_info()方法：获取异常信息</h5><p>捕获异常时，有 2 种方式可获得更多的异常信息，分别是：<br>使用 sys 模块中的 exc_info 方法</p><p>使用 traceback 模块中的相关函数</p><p>模块 sys 中，有两个方法可以返回异常的全部信息，分别是 exc_info() 和 last_traceback()，这两个函数有相同的功能和用法</p><p>exc_info() 方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：</p><p>type：异常类型的名称<br>value：捕获到的异常实例<br>traceback：是一个 traceback 对象(无法直接看出有关异常的信息，还需要对其做进一步处理)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">try:</span><br><span class="line">    x = int(input(&quot;请输入一个被除数：&quot;))</span><br><span class="line">    print(&quot;30除以&quot;,x,&quot;等于&quot;,30/x)</span><br><span class="line">except:</span><br><span class="line">    print(sys.exc_info())</span><br><span class="line">    print(&quot;其他异常...&quot;)</span><br></pre></td></tr></table></figure><p>要查看 traceback 对象包含的内容，需要先引进 traceback 模块，然后调用 traceback 模块中的 print_tb 方法，并将 sys.exc_info() 输出的 traceback 对象作为参数参入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import traceback</span><br><span class="line">try:</span><br><span class="line">    x = int(input(&quot;请输入一个被除数：&quot;))</span><br><span class="line">    print(&quot;30除以&quot;,x,&quot;等于&quot;,30/x)</span><br><span class="line">except:</span><br><span class="line">    traceback.print_tb(sys.exc_info()[2])</span><br><span class="line">    print(&quot;其他异常...&quot;)</span><br></pre></td></tr></table></figure><h5 id="Python自定义异常类及用法"><a href="#Python自定义异常类及用法" class="headerlink" title="Python自定义异常类及用法"></a>Python自定义异常类及用法</h5><p>Python 允许用户自定义异常类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Error(Exception):</span><br><span class="line">   pass</span><br><span class="line">try:</span><br><span class="line">   raise Error()</span><br><span class="line">except :</span><br><span class="line">   print(&quot;error&quot;)</span><br></pre></td></tr></table></figure><p>另外，系统自带的异常只要触发会自动抛出（比如 NameError、ValueError 等），但用户自定义的异常需要用户自己决定什么时候抛出。也就是说，<strong>自定义的异常需要使用 raise 手动抛出。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class InputError(Exception):</span><br><span class="line">    &#x27;&#x27;&#x27;当输出有误时，抛出此异常&#x27;&#x27;&#x27;</span><br><span class="line">    #自定义异常类型的初始化</span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">    #返回异常类对象的说明信息</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return (&quot;&#123;&#125; is invalid input&quot;.format(repr(self.value)))</span><br><span class="line">   </span><br><span class="line">try:</span><br><span class="line">    raise InputError(1) # 抛出 MyInputError 这个异常</span><br><span class="line">except InputError as err:</span><br><span class="line">    print(&#x27;error: &#123;&#125;&#x27;.format(err))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升七</title>
      <link href="/post/686f287a.html"/>
      <url>/post/686f287a.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python可重载运算符有哪些"><a href="#Python可重载运算符有哪些" class="headerlink" title="Python可重载运算符有哪些"></a>Python可重载运算符有哪些</h5><p>这里给大家举一个与重载运算符相关的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class MyClass: #自定义一个类</span><br><span class="line">    def __init__(self, name , age): #定义该类的初始化函数</span><br><span class="line">        self.name = name #将传入的参数值赋值给成员交量</span><br><span class="line">        self.age = age</span><br><span class="line">    def __str__(self): #用于将值转化为字符串形式，等同于 str(obj)</span><br><span class="line">        return &quot;name:&quot;+self.name+&quot;;age:&quot;+str(self.age)</span><br><span class="line">   </span><br><span class="line">    __repr__ = __str__ #转化为供解释器读取的形式</span><br><span class="line">   </span><br><span class="line">    def __lt__(self, record): #重载 self&lt;record 运算符</span><br><span class="line">        if self.age &lt; record.age:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">   </span><br><span class="line">    def __add__(self, record): #重载 + 号运算符</span><br><span class="line">        return MyClass(self.name, self.age+record.age)</span><br><span class="line"></span><br><span class="line">myc = MyClass(&quot;Anna&quot;, 42) #实例化一个对象 Anna，并为其初始化</span><br><span class="line">mycl = MyClass(&quot;Gary&quot;, 23) #实例化一个对象 Gary，并为其初始化</span><br><span class="line">print(repr(myc)) #格式化对象 myc，</span><br><span class="line">print(myc) #解释器读取对象 myc，调用 repr</span><br><span class="line">print (str (myc)) #格式化对象 myc ，输出&quot;name:Anna;age:42&quot;</span><br><span class="line">print(myc &lt; mycl) #比较 myc&lt;mycl 的结果，输出 False</span><br><span class="line">print (myc+mycl) #进行两个 MyClass 对象的相加运算，输出 &quot;name:Anna;age:65&quot;</span><br></pre></td></tr></table></figure><p>通过将 myc 进行 repr、str 运算，从输出结果中可以看到，程序调用了重载的操作符方法 <strong>repr</strong> 和 __str__。而令 myc 和 mycl 进行 &lt; 号的比较运算以及加法运算，从输出结果中可以看出，程序调用了重载 &lt; 号的方法 <strong>lt</strong> 和 <strong>add</strong> 方法。</p><p>那么，Python 类支持对哪些方法进行重载呢？这个给大家提供一个表格（表 1），列出了 Python 中常用的可重载的运算符，以及各自的含义</p><h5 id="Python迭代器及其用法"><a href="#Python迭代器及其用法" class="headerlink" title="Python迭代器及其用法"></a>Python迭代器及其用法</h5><p>列表（list）、元组（tuple）、字典（dict）、集合（set）这些序列式容器，有一个共同的特性，<br>它们都支持使用 for 循环遍历存储的元素，都是可迭代的，因此它们又有一个别称，即迭代器。</p><p>从字面来理解，迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。</p><p>如果要<strong>自定义</strong>实现一个迭代器，则类中必须实现如下 2 个方法：<br><strong>next</strong>(self)：返回容器的下一个元素。<br><strong>iter</strong>(self)：该方法返回一个迭代器（iterator）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">class reverse:</span><br><span class="line">    def __init__(self,string):</span><br><span class="line">        self.index= len(string)</span><br><span class="line">        self.string= string</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index==0:</span><br><span class="line">            sys.exit(0)</span><br><span class="line">        self.index -= 1</span><br><span class="line">        return self.string[self.index]</span><br><span class="line">res= reverse(&quot;xiaoyang&quot;)</span><br><span class="line">for i in res:</span><br><span class="line">    print(i,end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure><p>迭代器本身是一个底层的特性和概念，在程序中并不常用，但它为生成器这一更有趣的特性提供了基础。</p><h5 id="Python迭代器实现字符串的逆序输出"><a href="#Python迭代器实现字符串的逆序输出" class="headerlink" title="Python迭代器实现字符串的逆序输出"></a>Python迭代器实现字符串的逆序输出</h5><p>实现思路是这样的，自定义一个类并重载其 <strong>init</strong>() 初始化方法，实现为自身私有成员赋值<br>同时重载 <strong>iter</strong>() 和 <strong>next</strong>() 方法，使其具有迭代器功能。在此基础上，如果想实现对用户输入的字符串进行逆序输出，就需要在 <strong>next</strong>() 方法中实现从后往前返回字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Reverse:</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        self.__string = string</span><br><span class="line">        self.__index = len(string)</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.__index == 0:</span><br><span class="line">            raise(StopIteration)</span><br><span class="line">        self.__index -= 1</span><br><span class="line">        return self.__string[self.__index]</span><br><span class="line">revstr = Reverse(&#x27;Python&#x27;)</span><br><span class="line">for c in revstr:</span><br><span class="line">    print(c,end=&quot; &quot;)</span><br></pre></td></tr></table></figure><h5 id="Python生成器"><a href="#Python生成器" class="headerlink" title="Python生成器"></a>Python生成器</h5><p>以 list 容器为例，在使用该容器迭代一组数据时，必须事先将所有数据存储到容器中，才能开始迭代；而生成器却不同，它可以实现在迭代的同时生成元素。<br>也就是说，对于可以用某种算法推算得到的多个数据，生成器并不会一次性生成它们，而是什么时候需要，才什么时候生成。<br>不仅如此，生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</p><p>定义一个以 yield 关键字标识返回值的函数；<br>调用刚刚创建的函数，即可创建一个生成器。<br>带有 yield 的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，工作原理同上。</p><p>yield 是一个类似 return的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。</p><p>简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def intNum():</span><br><span class="line">    print(&quot;开始执行&quot;)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        yield i</span><br><span class="line">        print(&quot;继续执行&quot;)</span><br><span class="line">num = intNum()</span><br></pre></td></tr></table></figure><p>我们就成功创建了一个 num 生成器对象。显然，和普通函数不同，intNum() 函数的返回值用的是 yield 关键字，而不是 return 关键字，此类函数又成为生成器函数。</p><p>和 return 相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。</p><p>不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</p><p>要想使生成器函数得以执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，有以下 2 种方式：</p><p>通过生成器（上面程序中的 num）调用 next() 内置函数或者 <strong>next</strong>() 方法；<br>通过 for 循环遍历生成器。</p><p>在上面程序的基础上，添加如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def diedai():</span><br><span class="line">   print(&quot;开始使用&quot;)</span><br><span class="line">   for i in range(0,11):</span><br><span class="line">      yield i</span><br><span class="line">num = diedai()</span><br><span class="line"># print(diedai())</span><br><span class="line">#调用 next() 内置函数</span><br><span class="line">print(next(num))#调用 __next__() 方法</span><br><span class="line">print(num.__next__())#通过for循环遍历生成器</span><br><span class="line">for i in num:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>这里有必要给读者分析一个程序的执行流程：</p><ol><li><p>首先，在创建有 num 生成器的前提下，通过其调用 next() 内置函数，会使 Python 解释器开始执行 intNum() 生成器函数中的代码，因此会输出“开始执行”，程序会一直执行到yield i，而此时的 i&#x3D;&#x3D;0，因此 Python 解释器输出“0”。由于受到 yield 的影响，程序会在此处暂停。</p></li><li><p>然后，我们使用 num 生成器调用 <strong>next</strong>() 方法，该方法的作用和 next() 函数完全相同（事实上，next() 函数的底层执行的也是 <strong>next</strong>() 方法），它会是程序继续执行，即输出“继续执行”，程序又会执行到yield i，此时 i&#x3D;&#x3D;1，因此输出“1”，然后程序暂停。</p></li><li><p>最后，我们使用 for 循环遍历 num 生成器，之所以能这么做，是因为 for 循环底层会不断地调用 next() 函数，使暂停的程序继续执行，因此会输出后续的结果。</p></li></ol><h5 id="Python生成器send-方法"><a href="#Python生成器send-方法" class="headerlink" title="Python生成器send()方法"></a>Python生成器send()方法</h5><p>我们知道，通过调用 next() 或者 <strong>next</strong>() 方法，可以实现从外界控制生成器的执行。除此之外，通过 send() 方法，还可以向生成器中传值。<br>值得一提的是，send() 方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的 send() 方法时，它和 next() 函数的功能完全相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def intNum():</span><br><span class="line">    print(&quot;开始执行&quot;)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        yield i</span><br><span class="line">        print(&quot;继续执行&quot;)</span><br><span class="line">num = intNum()</span><br><span class="line">print(num.send(None))</span><br><span class="line">print(num.send(None))</span><br></pre></td></tr></table></figure><p>带参数的 send(value) 的用法，其具备 next() 函数的部分功能，即将暂停在 yield 语句出的程序继续执行，但与此同时，该函数还会将 value 值作为 yield 语句返回值赋值给接收者。注意，带参数的 send(value) 无法启动执行生成器函数。也就是说，程序中第一次使用生成器调用 next() 或者 send() 函数时，不能使用带参数的 send() 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    bar_a = yield &quot;hello&quot;    </span><br><span class="line">    bar_b = yield bar_a</span><br><span class="line">    yield bar_b</span><br><span class="line">f = foo()</span><br><span class="line">print(f.send(None))</span><br><span class="line">print(f.send(&quot;漂亮鬼&quot;))</span><br><span class="line">print(f.send(&quot;https://xiaoyangzst.vercel.app&quot;))</span><br></pre></td></tr></table></figure><p>分析一下此程序的执行流程：</p><ol><li><p>首先，构建生成器函数，并利用器创建生成器（对象）f 。</p></li><li><p>使用生成器 f 调用无参的 send() 函数，其功能和 next() 函数完全相同，因此开始执行生成器函数，即执行到第一个 yield “hello” 语句，该语句会返回 “hello” 字符串，然后程序停止到此处（注意，此时还未执行对 bar_a 的赋值操作）。</p></li><li><p>下面开始使用生成器 f 调用有参的 send() 函数，首先它会将暂停的程序开启，同时还会将其参数“漂亮鬼”赋值给当前 yield 语句的接收者，也就是 bar_a 变量。程序一直执行完 yield bar_a 再次暂停，因此会输出“漂亮鬼”。</p></li></ol><p>4） 最后依旧是调用有参的 send() 函数，同样它会启动餐厅的程序，同时将参数”<a href="https://xiaoyangzst.vercel.app&quot;传给/">https://xiaoyangzst.vercel.app&quot;传给</a> bar_b，然后执行完 yield bar_b 后（输出”<a href="https://xiaoyangzst.vercel.app&quot;),程序执行再次暂停./">https://xiaoyangzst.vercel.app&quot;)，程序执行再次暂停。</a></p><p>yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面(右边)的值。重点是：下一次迭代时，从上一次迭       代遇到的yield后面的代码(下一行)开始执行</p><h5 id="Python生成器close-方法"><a href="#Python生成器close-方法" class="headerlink" title="Python生成器close()方法"></a>Python生成器close()方法</h5><p>当程序在生成器函数中遇到 yield 语句暂停运行时，此时如果调用 close() 方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    try:</span><br><span class="line">        yield 1</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        print(&#x27;捕获到 GeneratorExit&#x27;)</span><br><span class="line">f = foo()</span><br><span class="line">print(next(f))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>注意，虽然通过捕获 GeneratorExit 异常，可以继续执行生成器函数中剩余的代码，带这部分代码中不能再包含 yield 语句，否则程序会抛出 RuntimeError 异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    try:</span><br><span class="line">        yield 1</span><br><span class="line">    except GeneratorExit:</span><br><span class="line">        print(&#x27;捕获到 GeneratorExit&#x27;)</span><br><span class="line">        yield 2 #抛出 RuntimeError 异常</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">print(next(f))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>另外，生成器函数一旦使用 close() 函数停止运行，后续将无法再调用 next() 函数或者 <strong>next</strong>() 方法启动执行，否则会抛出 StopIteration 异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    yield &quot;c.biancheng.net&quot;</span><br><span class="line">    print(&quot;生成器停止执行&quot;)</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">print(next(f)) #输出 &quot;c.biancheng.net&quot;</span><br><span class="line">f.close()</span><br><span class="line">next(f) #原本应输出&quot;生成器停止执行&quot;</span><br></pre></td></tr></table></figure><h5 id="Python-函数装饰器及用法"><a href="#Python-函数装饰器及用法" class="headerlink" title="Python @函数装饰器及用法"></a>Python @函数装饰器及用法</h5><p>函数装饰器的工作原理<br>假设用 funA() 函数装饰器去装饰 funB() 函数：</p><p>#funA 作为装饰器函数<br>def funA(fn):<br>    #…<br>    fn() # 执行传入的fn参数<br>    #…<br>    return ‘…’</p><p>@funA<br>def funB():<br>    #…</p><p>实际上，上面程序完全等价于下面的程序：</p><p>def funA(fn):<br>    #…<br>    fn() # 执行传入的fn参数<br>    #…<br>    return ‘…’</p><p>def funB():<br>    #…</p><p>funB &#x3D; funA(funB)</p><p>通过比对以上 2 段程序不难发现，使用函数装饰器 A() 去装饰另一个函数 B()，其底层执行了如下 2 步操作：<br>将 B 作为参数传给 A() 函数；将 A() 函数执行完成的返回值反馈回B。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#funA 作为装饰器函数</span><br><span class="line">def funA(fn):</span><br><span class="line">    print(&quot;漂亮鬼&quot;)</span><br><span class="line">    fn() # 执行传入的fn参数</span><br><span class="line">    print(&quot;https://xiaoyangzst.vercel.app&quot;)</span><br><span class="line">    return &quot;装饰器函数的返回值&quot;</span><br><span class="line"></span><br><span class="line">@funA</span><br><span class="line">def funB():</span><br><span class="line">    print(&quot;学习 Python&quot;)</span><br><span class="line">print(funB)</span><br></pre></td></tr></table></figure><p>显然，被“＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值），</p><p>即如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；</p><p>同样，如果装饰器返回的是一个函数的名称，那么被修饰的函数名依然表示一个函数。<br><strong>实际上，所谓函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</strong></p><h6 id="带参数的函数装饰器"><a href="#带参数的函数装饰器" class="headerlink" title="带参数的函数装饰器"></a>带参数的函数装饰器</h6><p>在分析 funA() 函数装饰器和 funB() 函数的关系时，细心的读者可能会发现一个问题，即当 funB() 函数无参数时，可以直接将 funB 作为 funA() 的参数传入。但是，如果被修饰的函数本身带有参数，那应该如何传值呢？<br>比较简单的解决方法就是在函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def funA(fn):</span><br><span class="line">    # 定义一个嵌套函数</span><br><span class="line">    def say(arc):</span><br><span class="line">        print(&quot;Python教程:&quot;,arc)</span><br><span class="line">    return say</span><br><span class="line"></span><br><span class="line">@funA</span><br><span class="line">def funB(arc):</span><br><span class="line">    print(&quot;funB():&quot;, a)</span><br><span class="line">funB(&quot;1d23456789&quot;)</span><br></pre></td></tr></table></figure><p>其实，它和如下程序是等价的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def funA(fn):</span><br><span class="line">    # 定义一个嵌套函数</span><br><span class="line">    def say(arc):</span><br><span class="line">        print(&quot;Python教程:&quot;,arc)</span><br><span class="line">    return say</span><br><span class="line"></span><br><span class="line">def funB(arc):</span><br><span class="line">    print(&quot;funB():&quot;, arc)</span><br><span class="line">   </span><br><span class="line">funB = funA(funB)</span><br><span class="line">funB(&quot;http://c.biancheng.net/python&quot;)</span><br></pre></td></tr></table></figure><p>但还有一个问题需要解决，即如果当前程序中，有多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等，怎么办呢？<br>最简单的解决方式是用 *args 和 *<em>kwargs 作为装饰器内部嵌套函数的参数，</em>args 和 **kwargs 表示接受任意数量和类型的参数。举个例子：</p><p>def funA(fn):<br>    # 定义一个嵌套函数<br>    def say(*args,**kwargs):<br>        fn(*args,**kwargs)<br>    return say</p><p>@funA<br>def funB(arc):<br>    print(“211212：”,arc)</p><p>@funA<br>def other_funB(name,arc):<br>    print(name,arc)<br>funB(“2134567”)<br>other_funB(“324程：”,”234234324234234”)</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升六</title>
      <link href="/post/df93073c.html"/>
      <url>/post/df93073c.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python-del-方法：销毁对象"><a href="#Python-del-方法：销毁对象" class="headerlink" title="Python del()方法：销毁对象"></a>Python <strong>del</strong>()方法：销毁对象</h5><p>Python 通过调用 <strong>init</strong>() 方法构造当前类的实例化对象，而节 <strong>del</strong>() 方法，功能正好和 <strong>init</strong>() 相反，其用来销毁实例化对象。</p><p>事实上在编写程序时，如果之前创建的<strong>类实例化对象</strong>后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。<br>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。<br>无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 <strong>del</strong>() 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用 __init__() 方法构造对象&quot;)</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用__del__() 销毁对象，释放其空间&quot;)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">del clangs</span><br></pre></td></tr></table></figure><p><strong>读者千万不要误认为，只要为该实例对象调用 <strong>del</strong>() 方法，该对象所占用的内存空间就会被释放</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用 __init__() 方法构造对象&quot;)</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用__del__() 销毁对象，释放其空间&quot;)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">cl = clangs</span><br><span class="line">del clangs</span><br><span class="line">print(&#x27;nihao&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到，当程序中有其它变量（比如这里的 cl）引用该实例对象时，即便手动调用 <strong>del</strong>() 方法，该方法也不会立即执行。这和 Python 的垃圾回收机制的实现有关。</p><p><strong>Python 采用自动引用计数（简称 ARC）的方式实现垃圾回收机制。</strong></p><p>该方法的核心思想是：<br>每个 Python 对象都会配置一个计数器，初始 Python 实例对象的计数器值都为 0，如果有变量<strong>引用该实例对象</strong>，其计数器的值会加 1，依次类推；反之，每当一个变量取消对该实例对象的引用，计数器会减 1。如果一个 Python 对象的的计数器值为 0，则表明没有变量引用该 Python 对象，即证明程序不再需要它，此时 Python 就会自动调用 <strong>del</strong>() 方法将其回收。</p><p>以上面程序中的 clangs 为例，实际上构建 clangs 实例对象的过程分为 2 步，先使用 CLanguage() 调用该类中的 <strong>init</strong>() 方法构造出一个该类的对象（将其称为 C，计数器为 0），并立即用 clangs 这个变量作为所建实例对象的引用（ C 的计数器值 + 1）。在此基础上，又有一个 cl 变量引用 clangs（其实相当于引用 CLanguage()，此时 C 的计数器再 +1 ），这时如果调用del clangs语句，只会导致 C 的计数器减 1（值变为 1），因为 C 的计数器值不为 0，因此 C 不会被销毁（不会执行 <strong>del</strong>() 方法）。</p><p>需要额外说明的是，如果我们重写子类的 <strong>del</strong>() 方法（父类为非 object 的类），则必须显式调用父类的 <strong>del</strong>() 方法，这样才能保证在回收子类对象时，其占用的资源（可能包含继承自父类的部分资源）能被彻底释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用父类 __del__() 方法&quot;)</span><br><span class="line"></span><br><span class="line">class cl(CLanguage):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用子类 __del__() 方法&quot;)</span><br><span class="line">c = cl()</span><br><span class="line">del c</span><br></pre></td></tr></table></figure><p>正确做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用父类 __del__() 方法&quot;)</span><br><span class="line">class cl(CLanguage):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用子类 __del__() 方法&quot;)</span><br><span class="line">c = cl()</span><br><span class="line">del c</span><br><span class="line">CLanguage.__del__(cl)</span><br></pre></td></tr></table></figure><h5 id="Python-dir-用法：列出对象的所有属性（方法）名"><a href="#Python-dir-用法：列出对象的所有属性（方法）名" class="headerlink" title="Python dir()用法：列出对象的所有属性（方法）名"></a>Python <strong>dir</strong>()用法：列出对象的所有属性（方法）名</h5><p>Python 内置函数时，提到了 dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。<br>注意，通过 dir() 函数，不仅仅输出本类中新添加的属性名和方法（最后 3 个），还会输出从父类（这里为 object 类）继承得到的属性名和方法名。</p><p>值得一提的是，dir() 函数的内部实现，其实是在调用参数对象  <strong>dir</strong>() 方法的基础上，对该方法返回的属性名和方法名做了排序。<br>所以，除了使用 dir() 函数，我们完全可以自行调用该对象具有的 <strong>dir</strong>() 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用 __init__() 方法构造对象&quot;)</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;调用__del__() 销毁对象，释放其空间&quot;)</span><br><span class="line">    def __say(self):</span><br><span class="line">        pass</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.__dir__())</span><br></pre></td></tr></table></figure><p>使用 <strong>dir</strong>() 方法和 dir() 函数输出的数据是相同，仅仅顺序不同。</p><h5 id="Python-dict-属性：查看对象内部所有属性名和属性值组成的字典"><a href="#Python-dict-属性：查看对象内部所有属性名和属性值组成的字典" class="headerlink" title="Python __dict__属性：查看对象内部所有属性名和属性值组成的字典"></a>Python __dict__属性：查看对象内部所有属性名和属性值组成的字典</h5><p>在 Python 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。</p><p>为了方便用户查看类中包含哪些属性，Python 类提供了 <strong>dict</strong> 属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用</p><p>用<strong>类名</strong>直接调用 __dict__，会输出该由类中所有<strong>类属性</strong>组成的字典；</p><p>而使用<strong>类的实例对象</strong>调用 __dict__，会输出该类中所有<strong>实例属性</strong>组成的字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    a =23</span><br><span class="line">    b=21</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用 __init__() 方法构造对象&quot;)</span><br><span class="line">        self.name=12</span><br><span class="line">        self.data=42</span><br><span class="line">    def __say(self):</span><br><span class="line">        pass</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.__dict__)</span><br><span class="line">print(CLanguage.__dict__)</span><br></pre></td></tr></table></figure><p>对于具有继承关系的父类和子类来说，父类有自己的 __dict__，同样子类也有自己的 __dict__，它不会包含父类的 <strong>dict</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.name = &quot;12&quot;</span><br><span class="line">        self.add = &quot;23&quot;</span><br><span class="line">       </span><br><span class="line">class CL(CLanguage):</span><br><span class="line">    c = 1</span><br><span class="line">    d = 2</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.na = &quot;22&quot;</span><br><span class="line">        self.ad = &quot;h24&quot;</span><br><span class="line">#父类名调用__dict__</span><br><span class="line">print(CLanguage.__dict__)</span><br><span class="line">#子类名调用__dict__</span><br><span class="line">print(CL.__dict__)</span><br><span class="line">#父类实例对象调用 __dict__</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.__dict__)</span><br><span class="line">#子类实例对象调用 __dict__</span><br><span class="line">cl = CL()</span><br><span class="line">print(cl.__dict__)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Python-setattr-、getattr-、hasattr-函数用法详解"><a href="#Python-setattr-、getattr-、hasattr-函数用法详解" class="headerlink" title="Python setattr()、getattr()、hasattr()函数用法详解"></a>Python setattr()、getattr()、hasattr()函数用法详解</h5><h6 id="Python-hasattr-函数"><a href="#Python-hasattr-函数" class="headerlink" title="Python hasattr()函数"></a>Python hasattr()函数</h6><p>hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。<br>语法格式：</p><p>hasattr(obj, name)</p><p>其中 obj 指的是某个类的实例对象，name 表示指定的属性名或方法名。同时，该函数会将判断的结果（True 或者 False）作为返回值反馈回来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.name = &quot;12&quot;</span><br><span class="line">        self.add = &quot;23&quot;</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我正在学Python&quot;)</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(hasattr(clangs,&quot;name&quot;))</span><br><span class="line">print(hasattr(clangs,&quot;add&quot;))</span><br><span class="line">print(hasattr(clangs,&quot;say&quot;))</span><br></pre></td></tr></table></figure><p>无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，<strong>但不能精确判断，该名称代表的是属性还是方法。</strong></p><h6 id="Python-getattr-函数"><a href="#Python-getattr-函数" class="headerlink" title="Python getattr() 函数"></a>Python getattr() 函数</h6><p>getattr() 函数获取某个<strong>类实例对象中指定属性的值</strong>。没错，和 hasattr() 函数不同，该函数只会从类对象包含的所有属性中进行查找。<br>语法格式：<br>getattr(obj, name[, default])</p><p>obj 表示指定的类实例对象<br>name 表示指定的属性名<br>default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.name = &quot;12&quot;</span><br><span class="line">        self.add = &quot;23&quot;</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我正在学Python&quot;)</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(getattr(clangs,&quot;name&quot;))</span><br><span class="line">print(getattr(clangs,&quot;add&quot;))</span><br><span class="line">print(getattr(clangs,&quot;say&quot;))</span><br><span class="line">print(getattr(clangs,&quot;display&quot;,&#x27;no display&#x27;))</span><br></pre></td></tr></table></figure><p>对于类中已有的属性，getattr() 会返回它们的值，而如果该名称为方法名，则返回该方法的状态信息；反之，如果该明白不为类对象所有，要么返回默认的参数，要么程序报 AttributeError 错误。</p><h6 id="Python-setattr-函数"><a href="#Python-setattr-函数" class="headerlink" title="Python setattr()函数"></a>Python setattr()函数</h6><p>setattr() 函数的功能相对比较复杂，它最基础的功能是<strong>修改</strong>类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。<br>语法格式：</p><p>setattr(obj, name, value)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.name = &quot;12&quot;</span><br><span class="line">        self.add = &quot;23&quot;</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我正在学Python&quot;)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.name)</span><br><span class="line">print(clangs.add)</span><br><span class="line">setattr(clangs,&quot;name&quot;,&quot;Python&quot;)</span><br><span class="line">setattr(clangs,&quot;add&quot;,&quot;change&quot;)</span><br><span class="line">print(clangs.name)</span><br><span class="line">print(clangs.add)</span><br></pre></td></tr></table></figure><p>甚至利用 setattr() 函数，还可以将类属性修改为一个类方法，同样也可以将类方法修改成一个类属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line">    print(&quot;我正在学Python&quot;)</span><br><span class="line"></span><br><span class="line">class CLanguage:</span><br><span class="line">    def __init__ (self):</span><br><span class="line">        self.name = &quot;12&quot;</span><br><span class="line">        self.add = &quot;23&quot;</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.name)</span><br><span class="line">print(clangs.add)</span><br><span class="line">setattr(clangs,&quot;name&quot;,say)</span><br><span class="line">clangs.name(clangs)</span><br></pre></td></tr></table></figure><p>显然，通过修改 name 属性的值为 say（这是一个外部定义的函数），原来的 name 属性就变成了一个 name() 方法。</p><p>使用 setattr() 函数对实例对象中执行名称的属性或方法进行修改时，如果该名称查找失败，Python 解释器不会报错，<strong>而是会给该实例对象动态添加一个指定名称的属性或方法</strong>。：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line">    print(&quot;我正在学Python&quot;)</span><br><span class="line">class CLanguage:</span><br><span class="line">    pass</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">setattr(clangs,&quot;name&quot;,&quot;漂亮鬼&quot;)</span><br><span class="line">setattr(clangs,&quot;say&quot;,say)</span><br><span class="line">print(clangs.name)</span><br><span class="line">clangs.say(clangs)</span><br></pre></td></tr></table></figure><p>虽然 CLanguage 为空类，但通过 setattr() 函数，我们为 clangs 对象动态添加了一个 name 属性和一个 say() 方法。</p><h5 id="Python-call-方法"><a href="#Python-call-方法" class="headerlink" title="Python call()方法"></a>Python <strong>call</strong>()方法</h5><p>该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    # 定义__call__方法</span><br><span class="line">    def __call__(self,name,add):</span><br><span class="line">        print(&quot;调用__call__()方法&quot;,name,add)</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(&quot;漂亮鬼&quot;,&quot;https://xiaoyangzst.vercel.app&quot;)</span><br></pre></td></tr></table></figure><p>通过在 CLanguage 类中实现 <strong>call</strong>() 方法，使的 clangs 实例对象变为了可调用对象</p><p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter-Canvas画布控件</title>
      <link href="/post/20b2c4ea.html"/>
      <url>/post/20b2c4ea.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter-Canvas画布控件"><a href="#Tkinter-Canvas画布控件" class="headerlink" title="Tkinter Canvas画布控件"></a>Tkinter Canvas画布控件</h5><p>Canvas 控件具有两个功能，<br>1.<br>它可以用来绘制各种图形<br>如,弧形、线条、椭圆形、多边形和矩形等，<br>2.<br>Canvas 控件还可以用来展示图片（包括位图），我们将这些绘制在画布控件上的图形，称之为“画布对象”。</p><p>每一个画布对象都有一个“唯一身份ID”，这是 Tkinter 自动为其创建的，从而方便控制和操作这些画布对象。</p><p>通过 Canvas 控件创建一个简单的图形编辑器，让用户可以达到自定义图形的目的，就像使用画笔在画布上绘画一样，可以绘制各式各样的形状，从而有更好的人机交互体验。</p><p>常用属性：</p><p>background(bg)<br>指定 Canvas 控件的背景颜色</p><p>borderwidth(bd)<br>指定 Canvas 控件的边框宽度</p><p>closeenough</p><ol><li>指定一个距离，当鼠标与画布对象的距离小于该值时，认为鼠标位于画布对象上</li><li>该选项是一个浮点类型的值</li></ol><p>confine<br>指定 Canvas 控件是否允许滚动超出 </p><p>scrollregion<br>项设置的滚动范围，默认值为 True</p><p>selectbackground<br>指定当画布对象（即在 Canvas 画布上绘制的图形）被选中时的背景色</p><p>selectborderwidth<br>指定当画布对象被选中时的边框宽度（选中边框）</p><p>selectforeground<br>指定当画布对象被选中时的前景色</p><p>state<br>设置 Canvas 的状态：”normal” 或 “disabled”，默认值是 “normal”，注意，该值不会影响画布对象的状态</p><p>takefocus<br>指定使用 Tab 键可以将焦点移动到输入框中，默认为开启，将该选项设置为 False 避免焦点在此输入框中</p><p>width<br>指定 Canvas 的宽度，单位为像素</p><p>xscrollcommand与 scrollbar（滚动条）控件<br>相关联（沿着 x 轴水平方向）</p><p>xscrollincrement</p><ol><li>该选项指定 Canvas 水平滚动的“步长”</li><li>例如 ‘3c’ 表示 3 厘米，还可以选择的单位有 ‘i’（英寸），’m’（毫米）和 ‘p’（DPI，大约是 ‘1i’ 等于 ‘72p’）</li><li>默认为 0，表示可以水平滚动到任意位置</li></ol><p>yscrollcommand与 scrollbar 控件（滚动条）<br>相关联（沿着 y 轴垂直方向）</p><p>yscrollincrement</p><ol><li>该选项指定 Canvas 垂直滚动的“步长”</li><li>例如 ‘3c’ 表示 3 厘米，还可以选择的单位有 ‘i’（英寸），’m’（毫米）和 ‘p’（DPI，大约是 ‘1i’ 等于 ‘72p’）</li><li>默认值是 0，表示可以垂直方向滚动到任意位置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;400x200&#x27;)</span><br><span class="line"># 创库不允许改变</span><br><span class="line">window.resizable(0,0)</span><br><span class="line"># 创建画布</span><br><span class="line">canvas = tk.Canvas(window,</span><br><span class="line">                   bg=&#x27;#CDC9A5&#x27;,</span><br><span class="line">                   height=200,</span><br><span class="line">                   width=300)</span><br><span class="line">canvas.pack()</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>create_line(x0, y0, x1, y1, … , xn, yn, options)</p><ol><li><p>根据给定的坐标创建一条或者多条线段；</p></li><li><p>参数 x0,y0,x1,y1,…,xn,yn 定义线条的坐标；</p></li><li><p>参数 options 表示其他可选参数</p></li></ol><p>create_oval(x0, y0, x1, y1, options)</p><ol><li><p>绘制一个圆形或椭圆形；</p></li><li><p>参数 x0 与 y0 定义绘图区域的左上角坐标；参数 x1 与 y1 定义绘图区域的右下角坐标；</p></li><li><p>参数 options 表示其他可选参数</p></li></ol><p>create_polygon(x0, y0, x1, y1, … , xn, yn, options)</p><ol><li><p>绘制一个至少三个点的多边形；</p></li><li><p>参数 x0、y0、x1、y1、…、xn、yn 定义多边形的坐标；</p></li><li><p>参数 options 表示其他可选参数</p></li></ol><p>create_rectangle(x0, y0, x1, y1, options)</p><ol><li><p>绘制一个矩形；</p></li><li><p>参数 x0 与 y0 定义矩形的左上角坐标；参数 x 与 y1 定义矩形的右下角坐标；</p></li><li><p>参数 options 表示其他可选参数</p></li></ol><p>create_text(x0, y0, text, options)</p><ol><li><p>绘制一个文字字符串</p></li><li><p>参数 x0 与 y0 定义文字字符串的左上角坐标，参数 text 定义文字字符串的文字；</p></li><li><p>参数 options 表示其他可选参数</p></li></ol><p> create_image(x, y, image)</p><ol><li><p>创建一个图片;</p></li><li><p>参数 x 与 y 定义图片的左上角坐标；</p></li><li><p>参数 image 定义图片的来源，必须是 tkinter 模块的 BitmapImage 类或 PhotoImage 类的实例变量。</p></li></ol><p>create_bitmap(x, y, bitmap)</p><ol><li><p>创建一个位图；</p></li><li><p>参数 x 与 y 定义位图的左上角坐标；</p></li><li><p>参数 bitmap 定义位图的来源，参数值可以是<br> gray12、gray25、gray50、gray75、hourglass、error、questhead、info、warning 或 question，或者也可以直接使用 XBM（X Bitmap）类型的文件，此时需要在 XBM 文件名称前添加一个 @ 符号</p></li></ol><p>例如 bitmap&#x3D;@hello.xbmcreate_arc(coord, start, extent, fill)</p><ol><li>绘制一个弧形；</li><li>参数 coord 定义画弧形区块的左上角与右下角坐标；</li><li>参数 start 定义画弧形区块的起始角度（逆时针方向）；</li><li>参数 extent 定义画弧形区块的结束角度（逆时针方向）；</li><li>参数 fill 定义填充弧形区块的颜色。</li></ol><p>注意：上述方法都会返回一个画布对象的唯一 ID。关于 options 参数，下面会通过一个示例对经常使用的参数做相关介绍</p><p>从上述不难看出，Canvas 控件采用了坐标系的方式来确定画布中的每一点。</p><p>一般情况下，默认主窗口的左上角为坐标原点，这种坐标系被称作为“窗口坐标系”，但也会存在另外一种情况，即画布的大小可能大于主窗口，当发生这种情况的时，可以采用带滚动条的 Canvas 控件，此时会以画布的左上角为坐标原点，我们将这种坐标系称为“画布坐标系”。</p><ol><li>绘制直线<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">root = Tk()</span><br><span class="line">root.config(bg=&#x27;#87CEEB&#x27;)</span><br><span class="line">root.geometry(&#x27;450x350&#x27;)</span><br><span class="line">cv=Canvas(root,bg=&quot;white&quot;,width =300, height = 250)</span><br><span class="line">cv.pack()</span><br><span class="line"># 设置坐标点,此处可以元组的形式来设置坐标点</span><br><span class="line">point=[(10,20),(20,30),(30,40),(40,100),(80,120),(150,90)]</span><br><span class="line"># 创建画布，添加线条</span><br><span class="line"># fill 参数指定填充的颜色，如果为空字符串，则表示透明</span><br><span class="line"># dash 参数表示用来绘制虚线轮廓，元组参数，分别代表虚线中线段的长度和线段之间的间隔</span><br><span class="line"># arrow 设线段的箭头样式，默认不带箭头，参数值 first 表示添加箭头带线段开始位置，last表示到末尾占位置，both表示两端均添加</span><br><span class="line"># smooth 布尔值参数，表示是否以曲线的样式划线，默认为 False</span><br><span class="line"># width 控制线宽</span><br><span class="line">line1=cv.create_line(point,fill=&quot;purple&quot;,dash=(1,1),arrow=LAST,width=5)</span><br><span class="line"># print(&#x27;线段line1的画布id号:&#x27;,line1)</span><br><span class="line"># line2=cv.create_line(point,fill=&quot;red&quot;,arrow=BOTH,smooth=TRUE,width=5)</span><br><span class="line"># print(&#x27;线段line2的画布id号:&#x27;,line2)</span><br><span class="line"># 移动其中一条线段，只需要更改其坐标就可以,使用 coords()方法移动曲线</span><br><span class="line"># cv.coords(line2,50,30,25,35,35,40,50,120,60,170,10,180)</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure></li></ol><p>上述示例中涉及了一部分参数，比如 fill、dash、arrow 等，<br>对 create_line() 函数的相关参数做了简单介绍：</p><p>activedash<br>当画布对象状态为 “active” 的时候，绘制虚线</p><p>activefill<br>当画布对象状态为 “active” 的时候，填充颜色</p><p>activestipple<br>当画布对象状态为 “active” 的时候，指定填充的位图</p><p>activewidth<br>当画布对象状态为 “active” 的时候，指定边框的宽度</p><p>arrow</p><ol><li>默认线段是不带箭头的，通过设置该选项添加箭头到线段中</li><li>“first” 表示添加箭头到线段开始的位置</li><li>“last” 表示添加箭头到线段结束的位置</li><li>“both” 表示两端均添加箭头</li></ol><p>arrowshape<br>用一个三元组来指定箭头的形状，默认值是 (8, 10, 3)，元组中的数值分别代表箭头中三条边的长度</p><p>capstyle</p><ol><li>指定线段两端的样式，默认值是 “butt”</li><li>该选项的值可以是：<br>“butt”（线段的两段平切于起点和终点）<br>“projecting”（线段的两段在起点和终点的位置将 width 选项设置的长度分别延长一半）<br>“round”（线段的两段在起点和终点的位置将 width设置的长度分别延长一半，并以圆角进行绘制）</li></ol><p>dash<br>绘制虚线，该选项值是一个整数元组，元组中的元素分别代表短线的长度和间隔，比如 (3, 5) 代表 3 个像素的短线和 5 个像素的间隔</p><p>dashoffset<br>指定虚线开始的偏移位置，比如 dash&#x3D;(5, 1, 2, 1)，dashoffset&#x3D;3，则从 2 开始画虚线</p><p>disableddash<br>当画布对象状态为 “disabled” 的时候，绘制虚线</p><p>disabledfill<br>画布对象状态为 “disabled” 的时候，填充颜色</p><p>disabledstipple<br>当画布对象状态为 “disabled” 的时候，指定填充的位图</p><p>disabledwidth<br>当画布对象状态为 “disabled” 的时候，指定边框的宽度</p><p>fill<br>指定填充的颜色，空字符串表示透明</p><p>joinstyle</p><ol><li><p>指定当绘制两个相邻线段之间时接口的样式，默认为 “round”</p></li><li><p>该选项的值可以是：<br>“round”（以连接点为圆心，1&#x2F;2 width 选项设置的长度为半径来绘制圆角）<br>“bevel”（在连接点处将两线段的夹角做平切操作）<br>“miter”（沿着两线段的夹角延伸至一个点）</p></li></ol><p>offset<br>指定当点画模式时填充位图的偏移</p><p>smooth<br>默认值为 False，若设置为 True，表示将以曲线的样式代替所绘线段</p><p>splinesteps<br>当绘制曲线的时，该选项指定由多少条折线来构成曲线，默认值是 12，这里需要注意，只有当 smooth 选项为 True 时该选项才会生效。</p><p>state<br>指定该画布对象的状态，默认值为 “normal”，参数值有 “normal”，”disabled”（不可用）和 “hidden”（隐藏）三种状态。</p><p>stipple<br>指定一个位图进行填充，默认值为空字符串，表示实心</p><p>tags<br>为创建的画布对象添加标签width指定边框的宽度</p><p>对于扇形、矩形、三角形、圆形等，这些封闭式图形，它们由轮廓线和填充颜色两部分组成。在绘制这些图形时相关函数的可选参数与上述也存在略微差异</p><p>下面以绘制扇形的 create_arc() 函数为例做简单的介绍：</p><p>activedash<br>当画布对象状态为 “active” 的时候，绘制虚线</p><p>activefill<br>当画布对象状态为 “active” 的时候，填充颜色</p><p>activeoutline<br>当画布对象状态为 “active” 的时候，绘制轮廓线</p><p>activeoutlinestipple<br>当画布对象状态为 “active” 的时候，指定填充轮廓的位图</p><p>activestipple<br>当画布对象状态为 “active” 的时候，指定填充的位图</p><p>activewidth<br>当画布对象状态为 “active” 的时候，指定边框的宽度</p><p>dash<br>指定绘制虚线轮廓，与绘制线段的含义相同</p><p>dashoffset<br>指定虚线轮廓开始的偏移位置</p><p>disableddash<br>当画布对象状态为 “disabled” 的时候，绘制虚线</p><p>disabledfill<br>当画布对象状态为 “disabled” 的时候，填充颜色</p><p>disabledoutline<br>当画布对象状态为 “disabled” 的时候，绘制轮廓线</p><p>disabledoutlinestipple<br>当画布对象状态为 “disabled” 的时候，指定填充轮廓的位图</p><p>disabledstipple<br>当画布对象状态为 “disabled” 的时候，指定填充的位图</p><p>disabledwidth<br>当画布对象状态为 “disabled” 的时候，指定边框的宽度</p><p>extent<br>指定跨度（从 start 选项指定的位置开始到结束位置的角度）默认值是 90.0</p><p>fill<br>与上述表格的含义相同，表示指定的填充颜色，若为空字符串则为透明色</p><p>offset<br>指定当点画模式时填充位置的偏移，参数值为 “x,y”坐标偏移和位置偏移两种方式，比如 “ne”&#x2F;“e” 等outline指定轮廓的颜色</p><p>outlineoffset<br>指定当点画模式绘制轮廓时位图的偏移</p><p>outlinestipple<br>当 outline 选项被设置时，该选项用于指定一个位图来填充边框，默认值是空字符串，表示黑色</p><p>start<br>指定起始位置的偏移角度</p><p>style<br>默认创建的是扇形，指定该方法创建的是扇形（”pieslice”）、弓形（”chord”）还是弧形（”arc”）</p><p>tags<br>为创建的画布对象添加标签width指定边框的宽度</p><p>在实际的使用的过程中经常用到的参数有 dash、fill、outline、extend 和 start，但是这么多的参数我们也不可能都记住，这时查手册是一种很好的方法，官网文档地址：<a href="https://docs.python.org/3.7/library/tkinter.html">点击前往</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">root = Tk()</span><br><span class="line">root.config(bg=&#x27;#8DB6CD&#x27;)</span><br><span class="line">root.geometry(&#x27;500x400&#x27;)</span><br><span class="line"># 将画布设置为白色</span><br><span class="line">canvas = Canvas(root,width = 400,height = 400,bg=&#x27;white&#x27;)</span><br><span class="line"># 设置基准坐标</span><br><span class="line">x0,y0,x1,y1 = 10,10,80,80</span><br><span class="line"># 绘制扇形,起始角度为 0 度，结束角度为 270, 扇形区域填充色为淡蓝色，轮廓线为蓝色，线宽为 2px</span><br><span class="line">arc = canvas.create_arc(x0, y0, x1, y1,start = 0, extent = 270, fill = &#x27;#B0E0E6&#x27;,outline =&#x27;blue&#x27;,width = 2)</span><br><span class="line"># 绘制圆形</span><br><span class="line">oval = canvas.create_oval(x0+150, y0, x1+150, y1,fill =&#x27;#CD950C&#x27;,outline = &#x27;blue&#x27;,width=2)</span><br><span class="line"># 绘制矩形,并将轮廓线设置为透明色，即不显示最外围的轮廓线，默认为黑色</span><br><span class="line">rect = canvas.create_rectangle(x0,y0+100,x1,y1+100,fill=&#x27;red&#x27;,outline = &#x27;&#x27;)</span><br><span class="line"># 绘制一个三角形，填充色为绿色</span><br><span class="line">trigon = canvas.create_polygon(80,80,150,80,200,200, outline=&quot;&quot;, fill=&quot;green&quot;,)</span><br><span class="line"># 绘制一个多边形，首先定义一系列的多边形上的坐标点</span><br><span class="line">poly_points=[(0,280),(140,200),(140,240),(270,240),(270,320),(140,320),(140,360)]</span><br><span class="line">polygon = canvas.create_polygon(poly_points,fill=&quot;#BF3EFF&quot;)</span><br><span class="line">canvas.pack()</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>注意：create_rectangle() 方法的前两个参数决定了矩形的左上角坐标，后两个参数决定了矩形的右下角坐标；另外 create_oval() 方法并不是只能绘制圆形，还能绘制椭圆形，这取决于传入的参数。</p><p>Tkinter 展示图片、创建位图以及文本信息等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root= tk.Tk()</span><br><span class="line">w=root.winfo_screenwidth()</span><br><span class="line">h=root.winfo_screenheight()</span><br><span class="line">root.geometry(&quot;300x300+500+200&quot;)</span><br><span class="line">cv= tk.Canvas(root,bg=&quot;#AAAAFF&quot;)</span><br><span class="line">img= tk.PhotoImage(file=&quot;D:\\File\\All\\python\\blog\\img\\99.png&quot;)</span><br><span class="line">cv.create_image(10,10,image=img)</span><br><span class="line">cv.create_text(100,100,text=&#x27;漂亮鬼&#x27;,font =(&#x27;华文楷体&#x27;,15,&#x27;bold&#x27;))</span><br><span class="line">cv.pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>注意，添加到 Canvas 上的对象会一直保留直着。如果你希望修改它们，您可以使用 coords() 和 move() 方法来移动画布上的对象，当然您可以使用 delete() 来删除它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root= tk.Tk()</span><br><span class="line">w=root.winfo_screenwidth()</span><br><span class="line">h=root.winfo_screenheight()</span><br><span class="line">root.geometry(&quot;300x300+500+200&quot;)</span><br><span class="line">cv= tk.Canvas(root,bg=&quot;#AAAAFF&quot;)</span><br><span class="line">img= tk.PhotoImage(file=&quot;D:\\File\\All\\python\\blog\\img\\99.png&quot;)</span><br><span class="line">cv.create_image(10,10,image=img)</span><br><span class="line">cv.create_text(100,100,text=&#x27;漂亮鬼&#x27;,font =(&#x27;华文楷体&#x27;,15,&#x27;bold&#x27;))</span><br><span class="line">def move_img():</span><br><span class="line">    # 定义移动坐标</span><br><span class="line">    cv.move(img,50,30)</span><br><span class="line">btn=tk.Button(cv,text=&quot;点击移动画布&quot;,bg=&quot;#8A8A8A&quot;,activebackground=&quot;#7CCD7C&quot;,command=move_img)</span><br><span class="line"># 在指定位置创建一个窗口控件，tags来添加标签</span><br><span class="line">cv.create_window(365,250,height=30,width=30,window=btn)</span><br><span class="line"># 调用delete() 删除画布对象,若传入ALL，则删除所有的画布对象</span><br><span class="line">#cv.delete(image1)</span><br><span class="line">cv.pack()</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>这里可能没有效果，大家可以换一张比窗口小的图放上面移动就能看到明显效果了</p>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升五</title>
      <link href="/post/d98acf3f.html"/>
      <url>/post/d98acf3f.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python-MetaClass元类详解"><a href="#Python-MetaClass元类详解" class="headerlink" title="Python MetaClass元类详解"></a>Python MetaClass元类详解</h5><p>MetaClass元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，<strong>使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法</strong>。</p><p>如果在创建类时，想用 MetaClass 元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：</p><p>先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。<br>和前面创建的类不同，如果想把一个类设计成 MetaClass 元类，其必须符合以下条件：</p><p>必须显式继承自 type 类；<br>类中需要定义并实现 <strong>new</strong>() 方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该 <strong>new</strong>() 方法会自动被执行，用来修改新建的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#定义一个元类</span><br><span class="line">class FirstMetaClass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        # 动态为该类添加一个name属性</span><br><span class="line">        attrs[&#x27;name&#x27;] = &quot;xiiaoyang&quot;</span><br><span class="line">        attrs[&#x27;say&#x27;] = lambda self: print(&quot;调用 say() 实例方法&quot;)</span><br><span class="line">        return super().__new__(cls,name,bases,attrs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 <strong>new</strong>() 方法，因此可以断定 FirstMetaCLass 是一个元类。</p><p>可以看到，在这个元类的 <strong>new</strong>() 方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法。通过如下代码，可以验证这个结论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#定义类时，指定元类class CLanguage(object,metaclass=FirstMetaClass):</span><br><span class="line">    pass</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs.name)</span><br><span class="line">clangs.say()</span><br></pre></td></tr></table></figure><p>可以看到，在创建类时，通过在<strong>标注父类的同时指定元类</strong>（格式为metaclass&#x3D;元类名），则当 Python 解释器在创建这该类时，FirstMetaClass 元类中的 <strong>new</strong> 方法就会被调用，从而实现动态修改类属性或者类方法的目的。</p><p>显然，FirstMetaClass 元类的 <strong>new</strong>() 方法动态地为 Clanguage 类添加了 name 属性和 say() 方法，因此，即便该类在定义时是空类，它也依然有 name 属性和 say() 方法。</p><p><strong>使用的比较少</strong></p><h5 id="Python多态及用法详解"><a href="#Python多态及用法详解" class="headerlink" title="Python多态及用法详解"></a>Python多态及用法详解</h5><p>Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，</p><p>类的多态特性，还要满足以下 2 个前提条件：</p><p>继承：多态一定是发生在子类和父类之间；<br>重写：子类重写了父类的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 Clanguage 类的say方法&quot;)</span><br><span class="line">class CPython(CLanguage):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 CPython 类的say方法&quot;)</span><br><span class="line">class CLinux(CLanguage):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 CLinux 类的say方法&quot;)</span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br><span class="line">a = CLinux()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure><p>其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class WhoSay:</span><br><span class="line">    def say(self,who):</span><br><span class="line">        who.say()</span><br><span class="line">class CLanguage:</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 Clanguage 类的say方法&quot;)</span><br><span class="line">class CPython(CLanguage):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 CPython 类的say方法&quot;)</span><br><span class="line">class CLinux(CLanguage):</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;调用的是 CLinux 类的say方法&quot;)</span><br><span class="line">a = WhoSay()</span><br><span class="line">#调用 CLanguage 类的 say() 方法</span><br><span class="line">a.say(CLanguage())</span><br><span class="line">#调用 CPython 类的 say() 方法</span><br><span class="line">a.say(CPython())</span><br><span class="line">#调用 CLinux 类的 say() 方法</span><br><span class="line">a.say(CLinux())</span><br></pre></td></tr></table></figure><p>此程序中，通过给 WhoSay 类中的 say() 函数添加一个 who 参数，其内部利用传入的 who 调用 say() 方法。<br>这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 who 参数的是哪个类的实例对象，它就会调用那个类中的 say() 方法。</p><h5 id="Python枚举类定义和使用"><a href="#Python枚举类定义和使用" class="headerlink" title="Python枚举类定义和使用"></a>Python枚举类定义和使用</h5><p>一些具有特殊含义的类，其实例化对象的个数往往是固定的，<br>比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。<br>针对这种特殊的类，Python中有Enum 枚举类。</p><p>也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">class Color(Enum):</span><br><span class="line">    # 为序列值指定value值</span><br><span class="line">    red = 1</span><br><span class="line">    green = 2</span><br><span class="line">    blue = 3</span><br></pre></td></tr></table></figure><p>如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。<br>如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。</p><p>在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。</p><p>注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。</p><p>和普通类的用法不同，<strong>枚举类不能用来实例化对象</strong>，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种</p><p>如，以 Color 枚举类为例，在其基础上添加如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#调用枚举成员的 3 种方式</span><br><span class="line">print(Color.red)</span><br><span class="line">print(Color[&#x27;red&#x27;])</span><br><span class="line">print(Color(1))</span><br><span class="line">#调取枚举成员中的 value 和 name</span><br><span class="line">print(Color.red.value)</span><br><span class="line">print(Color.red.name)</span><br><span class="line">#遍历枚举类中所有成员的 2 种方式</span><br><span class="line">for color in Color:</span><br><span class="line">    print(color)</span><br></pre></td></tr></table></figure><p><strong>枚举类成员之间不能比较大小，但可以用 &#x3D;&#x3D; 或者 is 进行比较是否相等</strong></p><p>print(Color.red &#x3D;&#x3D; Color.green)<br>print(Color.red.name is Color.green.name)</p><p>需要注意的是，<strong>枚举类中各个成员的值，不能在类的外部做任何修改</strong><br>下面语法的做法是错误的：<br>Color.red &#x3D; 4</p><p>除此之外，该枚举类还提供了一个 <strong>members</strong> 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员</p><p>for name,member in Color.<strong>members</strong>.items():<br>    print(name,”-&gt;”,member)</p><p>注意：<strong>Python 枚举类中各个成员必须保证 name 互不相同，但 value 可以相同</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">class Color(Enum):</span><br><span class="line">    red = 1</span><br><span class="line">    green = 1</span><br><span class="line">    blue = 3</span><br><span class="line">print(Color[&#x27;green&#x27;])</span><br></pre></td></tr></table></figure><p>Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。</p><p>在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum,unique</span><br><span class="line">#添加 unique 装饰器</span><br><span class="line">@unique</span><br><span class="line">class Color(Enum):</span><br><span class="line">    red = 1</span><br><span class="line">    green = 1</span><br><span class="line">    blue = 3</span><br><span class="line">print(Color[&#x27;green&#x27;])</span><br></pre></td></tr></table></figure><p>除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数创建枚举类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line">#创建一个枚举类</span><br><span class="line">Color = Enum(&quot;Color&quot;,(&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;))</span><br></pre></td></tr></table></figure><p>Enum() 函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。</p><p>其实枚举一般使用的也比较少，只有在一些特殊的场合才会使用，而且它还可以使用其他的方法将就替换</p><h5 id="Python-new-方法详解"><a href="#Python-new-方法详解" class="headerlink" title="Python new()方法详解"></a>Python <strong>new</strong>()方法详解</h5><p><strong>new</strong>() 是一种负责创建<strong>类实例的静态方法</strong>，它无需使用 staticmethod 装饰器修饰，且该方法会优先 <strong>init</strong>() 初始化方法被调用。</p><p>一般情况下，覆写 <strong>new</strong>() 的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class demoClass:</span><br><span class="line">    instances_created = 0</span><br><span class="line">    def __new__(cls,*args,**kwargs):</span><br><span class="line">        print(&quot;__new__():&quot;,cls,args,kwargs)</span><br><span class="line">        instance = super().__new__(cls)</span><br><span class="line">        instance.number = cls.instances_created</span><br><span class="line">        cls.instances_created += 1</span><br><span class="line">        return instance</span><br><span class="line">    def __init__(self,attribute):</span><br><span class="line">        print(&quot;__init__():&quot;,self,attribute)</span><br><span class="line">        self.attribute = attribute</span><br><span class="line">test1 = demoClass(&quot;abc&quot;)</span><br><span class="line">test2 = demoClass(&quot;xyz&quot;)</span><br><span class="line">print(test1.number,test1.instances_created)</span><br><span class="line">print(test2.number,test2.instances_created)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>new</strong>() 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <strong>init</strong>() 方法的调用。而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class nonZero(int):</span><br><span class="line">    def __new__(cls,value):</span><br><span class="line">        return super().__new__(cls,value) if value != 0 else None</span><br><span class="line">    def __init__(self,skipped_value):</span><br><span class="line">        #此例中会跳过此方法</span><br><span class="line">        print(&quot;__init__()&quot;)</span><br><span class="line">        super().__init__()</span><br><span class="line">print(type(nonZero(-12)))</span><br><span class="line">print(type(nonZero(0)))</span><br></pre></td></tr></table></figure><p><strong>什么情况下使用 <strong>new</strong>() 呢？答案很简单，在 <strong>init</strong>() 不够用的时候。</strong></p><p>前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <strong>init</strong>() 方法中对其进行修改。</p><p>注意，由于 <strong>new</strong>() 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。<br>Python中大量使用 <strong>new</strong>() 方法且合理的，就是 MetaClass 元类。</p><h5 id="Python-repr-方法：显示属性"><a href="#Python-repr-方法：显示属性" class="headerlink" title="Python repr()方法：显示属性"></a>Python <strong>repr</strong>()方法：显示属性</h5><p>我们经常会直接输出类的实例化对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    pass</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs)</span><br></pre></td></tr></table></figure><p>通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是“类名+object at+内存地址”，对我们了解该实例化对象帮助不大。</p><p>事实上，当我们输出某个实例化对象时，其调用的就是该对象的 <strong>repr</strong>() 方法，输出的是该方法的返回值。</p><p>执行 print(clangs) 等同于执行 print(clangs.<strong>repr</strong>())，程序的输出结果是一样的（输出的内存地址可能不同）。</p><p>和 <strong>init</strong>(self) 的性质一样，Python 中的<strong>每个类都包含 <strong>repr</strong>() 方法</strong>，因为 object 类包含 <strong>reper</strong>() 方法，而 Python 中所有的类都直接或间接继承自 object 类。</p><p>默认情况下，<strong>repr</strong>() 会返回和调用者有关的 “类名+object at+内存地址”信息。<br>当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;漂亮鬼&quot;</span><br><span class="line">        self.add = &quot;https://xiaoyangzst.vercel.app/&quot;</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;CLanguage[name=&quot;+ self.name +&quot;,add=&quot; + self.add +&quot;]&quot;</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">print(clangs)</span><br></pre></td></tr></table></figure><p><strong>repr</strong>() 方法是类的实例化对象用来做“<strong>自我介绍</strong>”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升四</title>
      <link href="/post/c468ad7a.html"/>
      <url>/post/c468ad7a.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python继承机制及其使用"><a href="#Python继承机制及其使用" class="headerlink" title="Python继承机制及其使用"></a>Python继承机制及其使用</h5><p>继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</p><p>举个例子，假设现有一个 Shape 类，该类的 draw() 方法可以在屏幕上画出指定的形状，现在需要创建一个 Form 类，要求此类不但可以在屏幕上画出指定的形状，还可以计算出所画形状的面积。要创建这样的类，笨方法是将 draw() 方法直接复制到新类中，并添加计算面积的方法。</p><p>就是使用类的继承机制。实现方法为：让 From 类继承 Shape 类，这样当 From 类对象调用 draw() 方法时，Python 解释器会先去 From 中找以 draw 为名的方法，如果找不到，它还会自动去 Shape 类中找。如此，我们只需在 From 类中添加计算面积的方法即可，示例代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Shape:</span><br><span class="line">    def draw(self,content):</span><br><span class="line">        print(&quot;画&quot;,content)</span><br><span class="line">class Form(Shape):</span><br><span class="line">    def area(self):</span><br><span class="line">        #....</span><br><span class="line">        print(&quot;此图形的面积为...&quot;)</span><br><span class="line">shap= Form()</span><br><span class="line">shap.draw(&quot;circle&quot;)</span><br></pre></td></tr></table></figure><p>上面代码中，class From(Shape) 就表示 From 继承 Shape。<br>Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，From 是子类，Shape 是父类。<br>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可<br>语法格式：</p><p>class 类名(父类1, 父类2, …)：</p><p>类定义部分注意，如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即<br><strong>一个子类可以同时拥有多个直接父类</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我是一个人，名字是：&quot;,self.name)</span><br><span class="line">class Animal:</span><br><span class="line">    def display(self):</span><br><span class="line">        print(&quot;人也是高级动物&quot;)</span><br><span class="line">class Person(People, Animal):</span><br><span class="line">    pass</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = &quot;张三&quot;</span><br><span class="line">zhangsan.say()</span><br><span class="line">zhangsan.display()</span><br></pre></td></tr></table></figure><p>没错，<strong>子类拥有父类所有的属性和方法</strong>，即便该属性或方法是私有（private）的(与c++的区别)</p><p><strong>关于Python的多继承</strong></p><p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：<br>根据子类继承多个父类时这些父类的<strong>前后次序</strong>决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = People</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;People类&quot;,self.name)</span><br><span class="line">class Animal:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = Animal</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;Animal类&quot;,self.name)</span><br><span class="line">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span><br><span class="line">class Person(People, Animal):</span><br><span class="line">    pass</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = &quot;张三&quot;</span><br><span class="line">zhangsan.say()</span><br></pre></td></tr></table></figure><p><strong>一般不使用多继承 因为多继承容易使代码变得复杂化</strong></p><h5 id="Python父类方法重写"><a href="#Python父类方法重写" class="headerlink" title="Python父类方法重写"></a>Python父类方法重写</h5><p>子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。<br>但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，<strong>我们就需要在子类中重复父类的方法。</strong></p><p>举个例子，鸟通常是有翅膀的，也会飞，因此我们可以像如下这样定义个和鸟相关的类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bird:</span><br><span class="line">    def isWing(self):</span><br><span class="line">        print(&quot;鸟有翅膀&quot;)</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;鸟会飞&quot;)</span><br></pre></td></tr></table></figure><p>但是，对于鸵鸟来说，它虽然也属于鸟类，也有翅膀，但是它只会奔跑，并不会飞。针对这种情况，可以这样定义鸵鸟类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Ostrich(Bird):</span><br><span class="line">    #重写Bird类的fly()方法</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;鸵鸟不会飞&quot;)</span><br></pre></td></tr></table></figure><p>可以看到，因为 Ostrich 继承自 Bird，因此 Ostrich 类拥有 Bird 类的 isWing() 和 fly() 方法。其中，isWing() 方法同样适合 Ostrich，但 fly() 明显不适合，因此我们在 Ostrich 类中对 fly() 方法进行重写。<br>重写，有时又称覆盖，是一个意思，指的是对类中已有方法的内部实现进行修改。</p><p><strong>如何调用被重写的方法</strong><br><strong>事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。</strong></p><p>如果想调用父类中被重写的这个方法<br>很简单，前面讲过，Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数是备注类名即可。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Bird:</span><br><span class="line">    def isWing(self):</span><br><span class="line">        print(&quot;鸟有翅膀&quot;)</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;鸟会飞&quot;)</span><br><span class="line">class Ostrich(Bird):</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;鸵鸟不会飞&quot;)</span><br><span class="line">ostrich = Ostrich()</span><br><span class="line">Bird.fly(ostrich)</span><br></pre></td></tr></table></figure><p><strong>此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个 self 参数自定绑定值，因此采用这种调用方法，需要手动为 self 参数赋值。</strong></p><h5 id="Python-super-函数：调用父类的构造方法"><a href="#Python-super-函数：调用父类的构造方法" class="headerlink" title="Python super()函数：调用父类的构造方法"></a>Python super()函数：调用父类的构造方法</h5><p><strong>Python 中子类会继承父类所有的类属性和类方法</strong>。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。</p><p>Python 是一门支持多继承的面向对象编程语言，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法<br>显然，构造方法也是如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我是人，名字为：&quot;,self.name)</span><br><span class="line">class Animal:</span><br><span class="line">    def __init__(self,food):</span><br><span class="line">        self.food = food</span><br><span class="line">    def display(self):</span><br><span class="line">        print(&quot;我是动物,我吃&quot;,self.food)</span><br><span class="line">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span><br><span class="line">class Person(People, Animal):</span><br><span class="line">    pass</span><br><span class="line">per = Person(&quot;zhangsan&quot;)</span><br><span class="line">per.say()</span><br><span class="line">#per.display()</span><br></pre></td></tr></table></figure><p>Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。</p><p>但如果去掉最后一行的注释，运行此行代码，Python 解释器会报错</p><p><strong>这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。</strong></p><p>针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。</p><p>在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：<br>1.<br>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；<br>2.<br>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。</p><p>super() 语法格式</p><p><code>super().__init__(self,...)</code></p><p>修改上面的程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;我是人，名字为：&quot;,self.name)</span><br><span class="line">class Animal:</span><br><span class="line">    def __init__(self,food):</span><br><span class="line">        self.food = food</span><br><span class="line">    def display(self):</span><br><span class="line">        print(&quot;我是动物,我吃&quot;,self.food)</span><br><span class="line">class Person(People, Animal):</span><br><span class="line">    #自定义构造方法</span><br><span class="line">    def __init__(self,name,food):</span><br><span class="line">        #调用 People 类的构造方法</span><br><span class="line">        super().__init__(name)</span><br><span class="line">        #super(Person,self).__init__(name) #执行效果和上一行相同</span><br><span class="line">        #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法</span><br><span class="line">        #调用其它父类的构造方法，需手动给 self 传值</span><br><span class="line">        Animal.__init__(self,food)    </span><br><span class="line">per = Person(&quot;zhangsan&quot;,&quot;熟食&quot;)</span><br><span class="line">per.say()</span><br><span class="line">per.display()</span><br></pre></td></tr></table></figure><p>可以看到，Person 类自定义的构造方法中，调用 People 类构造方法，可以使用 super() 函数，也可以使用未绑定方法。但是调用 Animal 类的构造方法，只能使用未绑定方法。</p><h5 id="Python-slots-：限制类实例动态添加属性和方法"><a href="#Python-slots-：限制类实例动态添加属性和方法" class="headerlink" title="Python __slots__：限制类实例动态添加属性和方法"></a>Python __slots__：限制类实例动态添加属性和方法</h5><p>Python 也允许动态地为类或实例对象添加方法<br>我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；</p><p>但<strong>对于实例对象</strong>，则只允许动态地添加实例方法，不能添加类方法和静态方法。这个在前面已经提到过</p><p>为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    pass</span><br><span class="line">def info(self):</span><br><span class="line">    print(&quot;正在调用实例方法&quot;)</span><br><span class="line">   </span><br><span class="line">@classmethod</span><br><span class="line">def info2(cls):</span><br><span class="line">    print(&quot;正在调用类方法&quot;)</span><br><span class="line">@staticmethod</span><br><span class="line">def info3():</span><br><span class="line">    print(&quot;正在调用静态方法&quot;)</span><br><span class="line">#类可以动态添加以上 3 种方法，会影响所有实例对象</span><br><span class="line">CLanguage.info = info</span><br><span class="line">CLanguage.info2 = info2</span><br><span class="line">CLanguage.info3 = info3</span><br><span class="line">clang = CLanguage()</span><br><span class="line">#如今，clang 具有以上 3 种方法</span><br><span class="line">clang.info()</span><br><span class="line">clang.info2()</span><br><span class="line">clang.info3()</span><br><span class="line">#类实例对象只能动态添加实例方法，不会影响其它实例对象</span><br><span class="line">clang1 = CLanguage()</span><br><span class="line">clang1.info = info</span><br><span class="line">#必须手动为 self 传值</span><br><span class="line">clang1.info(clang1)</span><br></pre></td></tr></table></figure><p>Python 提供了 <strong>slots</strong> 属性，通过它可以避免用户频繁的给<strong>实例对象</strong>动态地添加属性或方法。</p><p>再次声明，<strong>slots</strong> 只能限制为<strong>实例对象</strong>动态添加属性和方法，而无法限制动态地为类添加属性和方法。</p><p><strong>slots</strong> 属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    __slots__ = (&#x27;name&#x27;,&#x27;add&#x27;,&#x27;info&#x27;)</span><br></pre></td></tr></table></figure><p>可以看到， CLanguage 类中指定了 <strong>slots</strong> 属性，这意味着，该类的实例对象仅限于动态添加 name、add、info 这 3 个属性以及 name()、add() 和 info() 这 3 个方法。</p><p>注意，对于动态添加的方法，<strong>slots</strong> 限制的是其方法名，并不限制参数的个数。</p><h5 id="Python-type-函数：动态创建类"><a href="#Python-type-函数：动态创建类" class="headerlink" title="Python type()函数：动态创建类"></a>Python type()函数：动态创建类</h5><p>type() 函数属于 Python 内置函数，通常用来查看某个变量的具体类型。<br>其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。<br>type() 函数的语法格式有 2 种：</p><p>type(obj)<br>type(name, bases, dict)</p><p>这 2 种语法格式，各参数的含义及功能分别是：<br><strong>第一种语法格式用来查看某个变量（类对象）的具体类型</strong>，obj 表示某个变量或者类对象。</p><p><strong>第二种语法格式用来创建类</strong>，<br>其中 name 表示类的名称；<br>bases 表示一个元组，其中存储的是该类的父类；<br>dict 表示一个字典，用于表示类内定义的属性或者方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def say(self):</span><br><span class="line">    print(&quot;我要学 Python！&quot;)</span><br><span class="line">CLanguage = type(&quot;CLanguage&quot;,(object,),dict(say = say, name = &quot;xiaoyang&quot;))</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">#调用 say() 方法和 name 属性</span><br><span class="line">clangs.say()</span><br><span class="line">print(clangs.name)</span><br></pre></td></tr></table></figure><p>注意，Python 元组语法规定，<strong>当 (object,) 元组中只有一个元素时，最后的逗号（,）不能省略</strong>。</p><p>如何判断 dict 字典中添加的是方法还是属性？</p><p>很简单，如果该键值对中，值为普通变量（如 “xiaoyang”），则表示为类添加了一个类属性；反之，如果值为外部定义的函数（如 say() ），则表示为类添加了一个实例方法。<br>可以看到，使用 type() 函数创建的类，和直接使用 class 定义的类并无差别。</p><p><strong>事实上，我们在使用 class 定义类时，Python 解释器底层依然是用 type() 来创建这个类</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升三</title>
      <link href="/post/88bac164.html"/>
      <url>/post/88bac164.html</url>
      
        <content type="html"><![CDATA[<h4 id="Python-property-函数：定义属性"><a href="#Python-property-函数：定义属性" class="headerlink" title="Python property()函数：定义属性"></a>Python property()函数：定义属性</h4><p>我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。<strong>正常情况下，类包含的属性应该是隐藏的</strong>，只允许通过类提供的方法来间接实现对类属性的访问和操作。</p><p>因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个 getter（或 setter）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    #设置 name 属性值的函数</span><br><span class="line">    def setname(self,name):</span><br><span class="line">        self.name = name</span><br><span class="line">    #访问nema属性值的函数</span><br><span class="line">    def getname(self):</span><br><span class="line">        return self.name</span><br><span class="line">    #删除name属性值的函数</span><br><span class="line">    def delname(self):</span><br><span class="line">        self.name=&quot;xxx&quot;</span><br><span class="line">clang = CLanguage(&quot;漂亮鬼&quot;)</span><br><span class="line">print(clang.getname())</span><br><span class="line">clang.setname(&quot;Python&quot;)</span><br><span class="line">print(clang.getname())</span><br><span class="line">clang.delname()</span><br><span class="line">print(clang.getname())</span><br></pre></td></tr></table></figure><p>Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性</p><p>property() 函数的基本使用格式：<br>属性名&#x3D;property(fget&#x3D;None, fset&#x3D;None, fdel&#x3D;None, doc&#x3D;None)</p><p>fget 参数用于指定获取该属性值的类方法，<br>fset 参数用于指定设置该属性值的方法，<br>fdel 参数用于指定删除该属性值的方法，<br>最后的 doc 是一个文档字符串，用于说明此函数的作用。</p><p>注意，在使用 property() 函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，property() 函数中参数的指定并不是完全随意的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        self.__name = n</span><br><span class="line">    def setname(self,n):</span><br><span class="line">        self.__name = n</span><br><span class="line">    def getname(self):</span><br><span class="line">        return self.__name</span><br><span class="line">    def delname(self):</span><br><span class="line">        self.__name=&quot;xxx&quot;</span><br><span class="line">    name = property(getname, setname, delname, &#x27;指明出处&#x27;)</span><br><span class="line">#调取说明文档的 2 种方式</span><br><span class="line">#print(CLanguage.name.__doc__)</span><br><span class="line">help(CLanguage.name)</span><br><span class="line">clang = CLanguage(&quot;漂亮鬼&quot;)</span><br><span class="line">#调用 getname() 方法</span><br><span class="line">print(clang.name)</span><br><span class="line">#调用 setname() 方法</span><br><span class="line">clang.name=&quot;Python&quot;</span><br><span class="line">print(clang.name)</span><br><span class="line">#调用 delname() 方法</span><br><span class="line">del clang.name</span><br><span class="line">print(clang.name)</span><br></pre></td></tr></table></figure><p>注意：<br>在此程序中，由于 getname() 方法中需要返回 name 属性，如果使用 self.name 的话，其本身又被调用 getname()，这将会先入无限死循环。为了避免这种情况的出现，<strong>程序中的 name 属性必须设置为私有属性</strong>，即使用 __name（前面有 2 个下划线）</p><h4 id="Python-property装饰器详解"><a href="#Python-property装饰器详解" class="headerlink" title="Python @property装饰器详解"></a>Python @property装饰器详解</h4><p>既要保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来<strong>访问方法</strong>，不需要在方法名后添加一对“（）”小括号。<br>@property 的语法格式如下：</p><p>@property<br>def 方法名(self)<br>    代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Rect:</span><br><span class="line">    def __init__(self,area):</span><br><span class="line">        self.__area = area</span><br><span class="line">    @property</span><br><span class="line">    def area(self):</span><br><span class="line">        return self.__area</span><br><span class="line">rect = Rect(30)</span><br><span class="line">#直接通过方法名来访问 area 方法</span><br><span class="line">print(&quot;矩形的面积是：&quot;,rect.area)</span><br></pre></td></tr></table></figure><p>使用 ＠property 修饰了 area() 方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么 area 属性将是一个只读属性。</p><p>也就是说，在使用 Rect 类时，无法对 area 属性重新赋值<br>运行如下代码会报错：<br>rect.area &#x3D; 90<br>print(“修改后的面积：”,rect.area)</p><p>而要想实现修改 area 属性的值，还需要为 area 属性添加 setter 方法，就需要用到 setter 装饰器<br>语法格式：<br>@方法名.setter<br>def 方法名(self, value):<br>    代码块</p><p>为 Rect 类中的 area 方法添加 setter 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@area.setter</span><br><span class="line">def area(self, value):</span><br><span class="line">    self.__area = value</span><br></pre></td></tr></table></figure><p>然后就可以修改area的值了</p><p>除此之外，还可以使用 deleter 装饰器来删除指定属性<br>语法格式：<br>@方法名.deleter<br>def 方法名(self):<br>    代码块<br>为 Rect 类中，给 area() 方法添加 deleter 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@area.deleter</span><br><span class="line">def area(self):</span><br><span class="line">    self.__area = 0</span><br></pre></td></tr></table></figure><p>＠property相当于前面的getname() 函数<br>@setter相当于setname()函数<br>@deleter 相当于delete()函数</p><h4 id="Python封装机制及实现方法"><a href="#Python封装机制及实现方法" class="headerlink" title="Python封装机制及实现方法"></a>Python封装机制及实现方法</h4><p>简单的理解封装（Encapsulation），即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。<br>大致相当于c++中的将里面的属性设置为私有，然后外面不能直接通过对象名直接访问，必须通过函数留一些接口才能访问到</p><p>封装绝不是将类中所有的方法都隐藏起来，一定要留一些像键盘、鼠标这样可供外界使用的类方法<br>对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。<br>并且，对类进行良好的封装，还可以提高代码的复用性。</p><h5 id="Python-类进行封装"><a href="#Python-类进行封装" class="headerlink" title="Python 类进行封装"></a>Python 类进行封装</h5><p>和其它面向对象的编程语言（如 C++、Java）不同，Python 类中的变量和函数，不是公有的（类似 public 属性），就是私有的（类似 private），这 2 种属性的区别如下：<br>public：公有属性的类变量和类函数，在类的外部、类内部以及子类中，都可以正常访问；<br>private：私有属性的类变量和类函数，只能在本类内部使用，类的外部以及子类都无法使用。</p><p>但是，Python 并没有提供 public、private 这些修饰符。为了实现类的封装</p><p>Python 采取了下面的方法：<br>默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线（_）；<br>如果类中的变量和函数，其名称以双下划线“__”开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。</p><p>除此之外，还可以定义以单下划线“_”开头的类属性或者类方法</p><p>（例如 _name、_display(self)），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法，初学者一定要遵守。</p><p>注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数__init__(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    def setname(self, name):</span><br><span class="line">        if len(name) &lt; 3:</span><br><span class="line">            raise ValueError(&#x27;名称长度必须大于3！&#x27;)</span><br><span class="line">        self.__name = name</span><br><span class="line">    def getname(self):</span><br><span class="line">        return self.__name</span><br><span class="line">    name = property(getname, setname)</span><br><span class="line">    def setadd(self, add):</span><br><span class="line">        if add.startswith(&quot;http://&quot;):</span><br><span class="line">            self.__add = add</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#x27;地址必须以 http:// 开头&#x27;)</span><br><span class="line">    def getadd(self):</span><br><span class="line">        return self.__add  </span><br><span class="line">    #为 add 配置 setter 和 getter 方法</span><br><span class="line">    add = property(getadd, setadd)</span><br><span class="line">    #定义个私有方法</span><br><span class="line">    def __display(self):</span><br><span class="line">        print(self.__name,self.__add)</span><br><span class="line">       </span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = &quot;漂亮鬼blog&quot;</span><br><span class="line">clang.add = &quot;http://xiaoyangzst.vercel.app/&quot;</span><br><span class="line">print(clang.name)</span><br><span class="line">print(clang.add)</span><br></pre></td></tr></table></figure><p>会做详细的讲解，这里可简单理解成，如果用户输入不规范，程序将会报错。<br>通过此程序的运行逻辑不难看出，通过对 CLanguage 类进行良好的封装，使得用户仅能通过暴露的 setter() 和 getter() 方法操作 name 和 add 属性，而通过对 setname() 和 setadd() 方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。<br>细心的读者可能还发现，CLanguage 类中还有一个 __display() 方法，由于该类方法为私有（private）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。</p><h4 id="Python封装底层实现原理详解"><a href="#Python封装底层实现原理详解" class="headerlink" title="Python封装底层实现原理详解"></a>Python封装底层实现原理详解</h4><p>类对象无法直接调用以双下划线开头命名的类属性和类方法，是因为其底层实现时，Python 偷偷改变了它们的名称。</p><p>是不是类似 display() 这种的私有方法，真的没有方法调用吗？如果你深入了解 Python 封装机制的底层实现原理，就可以调用它。<br><strong>事实上，对于以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 “_类名__属性（方法）名” 的格式</strong></p><p>前面display私有函数的调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">#调用name的setname()方法</span><br><span class="line">clang.name = &quot;漂亮鬼&quot;</span><br><span class="line">#调用add的setadd()方法</span><br><span class="line">clang.add = &quot;https://xiaoyangzst.vercel.app&quot;</span><br><span class="line">#直接调用隐藏的display()方法</span><br><span class="line">clang._CLanguage__display()</span><br></pre></td></tr></table></figure><p>不仅如此，那些原本我们认为是私有的类属性（例如 __name 和 __add），其底层的名称也改成了“_类名__属性名”的这种格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">clang.name = &quot;漂亮鬼&quot;</span><br><span class="line">clang.add = &quot;https://xiaoyangzst.vercel.app&quot;</span><br><span class="line">#直接调用 name 和 add 私有属性</span><br><span class="line">print(clang._CLanguage__name, clang._CLanguage_)</span><br></pre></td></tr></table></figure><p>甚至于，我们还可以通过这种方式修改 clang 对象的私有属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang._CLanguage__name = &quot;Python&quot;</span><br><span class="line">clang._CLanguage__add = &quot;https://xiaoyangzst.vercel.app&quot;</span><br><span class="line">print(clang._CLanguage__name,clang._CLanguage__add)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter-Scale控件</title>
      <link href="/post/ff3fc45d.html"/>
      <url>/post/ff3fc45d.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter-Scale控件详解"><a href="#Tkinter-Scale控件详解" class="headerlink" title="Tkinter Scale控件详解"></a>Tkinter Scale控件详解</h5><p>Scale 控件，即滑块控件或标尺控件，该控件可以创建一个类似于标尺式的滑动条对象，用户通过操作它可以直接设置相应的数值（刻度值)。</p><p>常用的基本属性：</p><p>activebackground<br>指定当鼠标在上方飘过的时候滑块的背景颜色</p><p>bigincrement</p><ol><li>设置“大”增长量</li><li>该选项设置增长量的大小</li><li>默认值是 0，增长量为范围的 1&#x2F;10</li></ol><p>borderwidth</p><ol><li>指定边框宽度</li><li>默认值是 2</li></ol><p>command</p><ol><li>指定一个函数，每当滑块发生改变的时候都会自动调用该函数</li><li>该函数有一个唯一的参数，就是最新的滑块位置</li><li>如果滑块快速地移动，函数可能无法获得每一个位置，但一定会获得滑块停下时的最终位置</li></ol><p>digits</p><ol><li>设置最多显示多少位数字</li><li>补充注释：例如设置 from 选项为 0，to 选项为 20，digits 选项设置为 5，那么滑块的范围就是在 0.000 ~ 20.000 直接滑动</li><li>默认值是 0（不开启）</li></ol><p>font</p><ol><li>指定滑块左侧的 Label 和刻度的文字字体</li><li>默认值由系统指定</li></ol><p>from_</p><ol><li>设置滑块最顶（左）端的位置</li><li>默认值是 0</li></ol><p>highlightcolor</p><ol><li>指定当 Scale 获得焦点的时候高亮边框的颜色</li><li>默认值由系统指定</li></ol><p>label</p><ol><li>你可以在垂直的 Scale 组件的顶端右侧（水平的话是左端上方）显示一个文本标签</li><li>默认值是不显示标签</li></ol><p>length</p><ol><li>Scale 组件的长度，默认值是 100 像素</li></ol><p>orient</p><ol><li>设置 Scale 控件是水平放置（HORIZONTAL）还是垂直放置（VERTICAL）</li><li>默认值是 VERTICAL（垂直放置）</li></ol><p>repeatdelay</p><ol><li>该选项指定鼠标左键点击滚动条凹槽的响应时间</li><li>默认值是 300（毫秒）</li></ol><p>repeatinterval</p><ol><li>该选项指定鼠标左键紧按滚动条凹槽时的响应间隔</li><li>默认值是 100（毫秒）</li></ol><p>resolution</p><ol><li>指定 Scale 组件的分辨率（每点击一下移动的步长）<br>示例： 比如 resolution 选项设置为 0.1 的话，那么每点击一下鼠标就是在 0.0 ~ 20.0 之间以 0.1 的步长移动</li><li>该参数的默认值是 1</li></ol><p>showvalue</p><ol><li>设置是否显示滑块旁边的数字</li><li>默认值为 True</li></ol><p>sliderlength</p><ol><li>设置滑块的长度</li><li>默认值是 30 像素</li></ol><p>state</p><ol><li>默认情况下 Scale 组件支持鼠标事件和键盘事件，可以通过设置该选项为 DISABLED 来禁用此功能</li><li>默认值是 NORMAL</li></ol><p>takefocus</p><ol><li>指定使用 Tab 键是否可以将焦点移动到该 Scale 组件上</li><li>默认是开启的，可以通过将该选项设置为 False 避免焦点落在此组件上</li></ol><p>tickinterval</p><ol><li>设置显示的刻度，如果设置一个值，那么就会按照该值的倍数显示刻度</li><li>默认值是不显示刻度</li></ol><p>to</p><ol><li>设置滑块最底（右）端的位置</li><li>默认值是 100</li></ol><p>troughcolor</p><ol><li>设置凹槽的颜色</li><li>默认值由系统指定</li></ol><p>variable</p><ol><li>指定一个与 Scale 组件相关联的 Tkinter 变量，该变量存放滑块最新的位置</li><li>当滑块移动的时候，该变量的值也会发生相应的变化</li></ol><p>width</p><ol><li>指定 Scale 组件的宽度</li><li>默认值是 15 像素</li></ol><p>Scale 常用方法有如下四个：</p><p>coords(value&#x3D;None)</p><ol><li>获得当前滑块位置相对于 Scale 控件左上角位置的相对坐标，</li><li>如果设置了 value 值，则返回当滑块位于该位置时与左上角的相对坐标get()获得当前滑块的位置（即当前数值），返回值可以为整型或者浮点型</li></ol><p>identify(x, y)<br>返回一个字符串表示指定位置下的 Scale 控件</p><p>set(value)<br>设置 Scale 控件的值，即滑块的位置，默认为初始位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win =Tk()</span><br><span class="line">win.geometry(&#x27;400x250&#x27;)</span><br><span class="line"># 添加一个 Scale 控件，默认垂直方向，步长设置为 5，长度为200，滑动块的大小为 50，最后使用label参数文本</span><br><span class="line">s=Scale(win, from_ =100, to =0,resolution =5,length =100,sliderlength= 10,label =&#x27;音量控制&#x27; )</span><br><span class="line">s.pack()</span><br><span class="line"># 设置滑块的位置</span><br><span class="line">s.set(value=15)</span><br><span class="line">mainloop()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;450x200+450+250&#x27;)</span><br><span class="line">window.resizable(0,0)</span><br><span class="line">label = tk.Label(window, bg=&#x27;#9FB6CD&#x27;,width=18, text=&#x27;&#x27;)</span><br><span class="line">label.grid(row =2)</span><br><span class="line">def select_price(value):</span><br><span class="line">    label.config(text=&#x27;您购买的数量是 &#x27; + value)</span><br><span class="line">scale = tk.Scale(window,</span><br><span class="line">             label=&#x27;选择您要购买的数量&#x27;,</span><br><span class="line">             from_=1,</span><br><span class="line">             to= 100,</span><br><span class="line">             orient=tk.HORIZONTAL,</span><br><span class="line">             length=400,</span><br><span class="line">             tickinterval=9,       # 设置刻度滑动条的间隔</span><br><span class="line">             command=select_price)  # 调用执行函数，是数值显示在 Label控件中</span><br><span class="line">scale.set(66)</span><br><span class="line">scale.grid(row =1)</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升二</title>
      <link href="/post/cae65769.html"/>
      <url>/post/cae65769.html</url>
      
        <content type="html"><![CDATA[<h4 id="Python-self用法"><a href="#Python-self用法" class="headerlink" title="Python self用法"></a>Python self用法</h4><p>在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将 self 参数作为方法的第一个参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;我使用了构造函数&quot;)</span><br><span class="line">    def say(self,name):</span><br><span class="line">        print(&quot;我名字是：&quot;,name)</span><br><span class="line">xiaoyang = Person()</span><br><span class="line">xiaoyang.say(&quot;xiaoyang&quot;)</span><br></pre></td></tr></table></figure><p>Python 只是规定，<strong>无论是构造方法还是实例方法，最少要包含一个参数</strong>，并没有规定该参数的具体名称。之所以将其命名为 self，只是程序员之间约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性（大家一看到 self，就知道它的作用）。</p><p>self 参数的具体作用打个比方<br>如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？<br>当然是通过 self 参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。如果你接触过其他面向对象的编程语言（例如 C++），<strong>其实 Python 类方法中的 self 参数就相当于 C++ 中的 this 指针</strong>。</p><p>也就是说，同一个类可以产生多个对象，<strong>当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象</strong>。如此，Python解释器就能知道到底要操作哪个对象的方法了。</p><p>程序在调用实例方法和构造方法时，不需要手动为第一个参数传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;正在执行构造方法&quot;)</span><br><span class="line">    def study(self):</span><br><span class="line">        print(self,&quot;正在学Python&quot;)</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.study()</span><br><span class="line">lisi = Person()</span><br><span class="line">lisi.study()</span><br></pre></td></tr></table></figure><h4 id="Python类变量和实例变量"><a href="#Python类变量和实例变量" class="headerlink" title="Python类变量和实例变量"></a>Python类变量和实例变量</h4><p>无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。</p><p>前面提到过，在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：<br>1.类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；<br>2.类体中，所有函数内部：以“<strong>self.变量名</strong>”的方式定义的变量，称为实例属性或实例变量；<br>3.类体中，所有函数内部：以“变量名&#x3D;变量值”的方式定义的变量，称为局部变量。</p><h5 id="类变量（类属性）"><a href="#类变量（类属性）" class="headerlink" title="类变量（类属性）"></a>类变量（类属性）</h5><p>类变量指的是在类中，但在各个类方法外定义的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    name = &quot;漂亮鬼&quot;</span><br><span class="line">    add = &quot;https://xiaoyangzst.vercel.app/&quot;</span><br><span class="line">    #下面定义了一个say实例方法</span><br><span class="line">    def say(self, content):</span><br><span class="line">        print(content)</span><br></pre></td></tr></table></figure><p><strong>类变量的特点</strong>: 所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。</p><h5 id="类方法的调用方式有-2-种，"><a href="#类方法的调用方式有-2-种，" class="headerlink" title="类方法的调用方式有 2 种，"></a>类方法的调用方式有 2 种，</h5><p>既可以使用类名直接调用，也可以使用类的实例化对象调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#使用类名直接调用</span><br><span class="line">print(CLanguage.name)</span><br><span class="line">print(CLanguage.add)</span><br><span class="line">#修改类变量的值</span><br><span class="line">CLanguage.name = &quot;Python&quot;</span><br><span class="line">CLanguage.add = &quot;http://python&quot;</span><br><span class="line">print(CLanguage.name)</span><br><span class="line">print(CLanguage.add)</span><br></pre></td></tr></table></figure><p><strong>通过类名不仅可以调用类变量，也可以修改它的值</strong>。</p><p>当然，也可以使用类对象来调用所属类中的类变量（此方式不推荐使用)</p><p>clang &#x3D; CLanguage()<br>print(clang.name)<br>print(clang.add)</p><p><strong>注意</strong>：因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象<br>通过类名修改类变量，会作用到所有的实例化对象</p><h5 id="实例变量（实例属性）"><a href="#实例变量（实例属性）" class="headerlink" title="实例变量（实例属性）"></a>实例变量（实例属性）</h5><p>实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。<br>另外，<strong>实例变量只能通过对象名访问，无法通过类名访问</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;票连跪&quot;</span><br><span class="line">        self.add = &quot;https://xiaoyangzst.app.vercel&quot;</span><br><span class="line">    def say(self):</span><br><span class="line">        self.catalog = 78</span><br></pre></td></tr></table></figure><p>此 CLanguage 类中，name、add 以及 catalog 都是实例变量。其中，由于 <strong>init</strong>() 函数在创建类对象时会自动调用，而 say() 方法需要类对象手动调用。因此，CLanguage 类的类对象都会包含 name 和 add 实例变量，而只有调用了 say() 方法的类对象，才包含 catalog 实例变量。</p><h5 id="为什么不推荐使用类对象调用类变量"><a href="#为什么不推荐使用类对象调用类变量" class="headerlink" title="为什么不推荐使用类对象调用类变量"></a>为什么不推荐使用类对象调用类变量</h5><p>前面讲过，通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的<strong>实例变量</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">print(clang.name)</span><br><span class="line">print(clang.add)</span><br><span class="line">clang.name = &quot;Python&quot;</span><br><span class="line">clang.add = &quot;http://python&quot;</span><br><span class="line">#clang实例变量的值</span><br><span class="line">print(clang.name)</span><br><span class="line">print(clang.add)</span><br><span class="line">#类变量的值</span><br><span class="line">print(CLanguage.name)</span><br><span class="line">print(CLanguage.add)</span><br></pre></td></tr></table></figure><p>通过类对象是无法修改类变量的值的，本质其实是给 clang 对象新添加 name 和 add 这 2 个<strong>实例变量</strong></p><p><strong>实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量</strong>，这也是不推荐“类变量使用对象名调用”的原因。<br>另外，和<strong>类变量不同，通过某个对象修改实例变量的值，不会影响类的其它实例化对象，更不会影响同名的类变量。</strong></p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>除了实例变量，类方法中还可以定义局部变量。和前者不同，局部变量直接以“变量名&#x3D;值”的方式进行定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    def count(self,money):</span><br><span class="line">        sale = 0.8*money</span><br><span class="line">        print(&quot;优惠后的价格为：&quot;,sale)</span><br><span class="line">clang = CLanguage()</span><br><span class="line">clang.count(100)</span><br></pre></td></tr></table></figure><p>通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。</p><h4 id="Python实例方法、静态方法和类方法"><a href="#Python实例方法、静态方法和类方法" class="headerlink" title="Python实例方法、静态方法和类方法"></a>Python实例方法、静态方法和类方法</h4><p>和类属性一样，类方法也可以进行更细致的划分，具体可分为类方法、实例方法和静态方法。<br>和类属性的分类不同，对于初学者来说，区分这 3 种类方法是非常简单的，采用 @classmethod 修饰的方法为类方法；<br>采用 @staticmethod 修饰的方法为静态方法；<br>不用任何修改的方法为实例方法。<br>其中 @classmethod 和 @staticmethod 都是函数装饰器</p><h5 id="Python类实例方法"><a href="#Python类实例方法" class="headerlink" title="Python类实例方法"></a>Python类实例方法</h5><p>通常情况下，在类中定义的方法默认都是实例方法。前面，我们已经定义了不只一个实例方法。不仅如此，类的构造方法理论上也属于实例方法，只不过它比较特殊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    #类构造方法，也属于实例方法</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;漂亮鬼&quot;</span><br><span class="line">        self.add = &quot;https:/xiaoyangzst.vercel.app&quot;</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;正在调用 say() 实例方法&quot;)</span><br></pre></td></tr></table></figure><p>实例方法最大的特点就是，它最少也要包含一个 self 参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。<strong>实例方法通常会用类对象直接调用</strong></p><p>当然，<strong>Python 也支持使用类名调用实例方法，但此方式需要手动给 self 参数传值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clang = CLanguage()</span><br><span class="line">CLanguage.say(clang)</span><br><span class="line">class CLanguage:</span><br><span class="line">    def info(self):</span><br><span class="line">        print(self,&quot;正在学 Python&quot;)</span><br><span class="line">#通过类名直接调用实例方法</span><br><span class="line">CLanguage.info(&quot;zhangsan&quot;)</span><br></pre></td></tr></table></figure><h5 id="Python-类方法"><a href="#Python-类方法" class="headerlink" title="Python 类方法"></a>Python 类方法</h5><p>Python 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，<br>Python 会自动将类本身绑定给 cls 参数（注意，绑定的不是类对象）。<br>也就是说，我们在调用类方法时，无需显式为 cls 参数传参。和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;漂亮鬼&quot;</span><br><span class="line">        self.add = &quot;https:/xiaoyangzst.vercel.app&quot;</span><br><span class="line">    #下面定义了一个类方法</span><br><span class="line">    @classmethod</span><br><span class="line">    def info(cls):</span><br><span class="line">        print(&quot;正在调用类方法&quot;,cls)</span><br></pre></td></tr></table></figure><p>注意，如果没有 ＠classmethod，则 Python 解释器会将 fly() 方法认定为实例方法，而不是类方法。<br><strong>类方法推荐使用类名直接调用</strong>，当然也可以使用实例对象来调用（不推荐）</p><h5 id="Python类静态方法"><a href="#Python类静态方法" class="headerlink" title="Python类静态方法"></a>Python类静态方法</h5><p>静态方法，其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。<br>静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。<br>静态方法需要使用＠staticmethod修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def info(name,add):</span><br><span class="line">        print(name,add)</span><br></pre></td></tr></table></figure><p><strong>静态方法的调用，既可以使用类名，也可以使用类对象</strong></p><p>在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能</p><h4 id="浅谈Python类命名空间"><a href="#浅谈Python类命名空间" class="headerlink" title="浅谈Python类命名空间"></a>浅谈Python类命名空间</h4><p>Python 类体中的代码位于独立的命名空间（称为类命名空间）中。换句话说，所有用 class 关键字修饰的代码块，都可以看做是位于独立的命名空间中。</p><p>和类命名空间相对的是全局命名空间，即整个 Python 程序默认都位于全局命名空间中。而类体则独立位于类命名空间中。</p><p>但需要注意的一点是，当使用类对象调用类方法时，在传参方面是和外界的函数有区别的，因为 Python 会自动会第一个参数绑定方法的调用者，而位于全局空间中的函数，则必须显式为第一个参数传递参数。</p><h4 id="Python描述符"><a href="#Python描述符" class="headerlink" title="Python描述符"></a>Python描述符</h4><p>Python 中，通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作<br>本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。<br>描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和 super 类型</p><p>描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：<br><strong>set</strong>(self, obj, type&#x3D;None)：在设置属性时将调用这一方法（后续用 setter 表示）；<br><strong>get</strong>(self, obj, value)：在读取属性时将调用这一方法（后续用 getter 表示）；<br><strong>delete</strong>(self, obj)：对属性调用 del 时将调用这一方法。</p><p>其中，实现了 setter 和 getter 方法的描述符类被称为数据描述符；<br>反之，如果只实现了 getter 方法，则称为非数据描述符。</p><p>在每次查找属性时，描述符协议中的方法都由类对象的特殊方法 <strong>getattribute</strong>() 调用（注意不要和 <strong>getattr</strong>() 弄混）。也就是说，每次使用类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 <strong>getattribute</strong>()，它会按照下列顺序查找该属性：</p><p>验证该属性是否为类实例对象的数据描述符；<br>如果不是，就查看该属性是否能在类实例对象的 <strong>dict</strong> 中找到；<br>最后，查看该属性是否为类实例对象的非数据描述符。</p><p>1、位于搜索链上的顺序。搜索链（或者优先链）的顺序大概是这样的：<br>数据描述符＞实体属性（存储在实体的_dict_中）&gt;非数据描述符。<br>这个顺序初看起来挺晦涩。解释如下：<br>获取一个属性的时候：<br>首先，看这个属性是不是一个数据描述符，如果是，就直接执行描述符的_get_，并返回值。<br>其次，如果这个属性不是数据描述符，那就按常规去从_dict_里面取。<br>最后，如果_dict_里面还没有，但这是一个非数据描述符，则执行非数据描述符的_get_方法，并返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class revealAccess:</span><br><span class="line">    def __init__(self, initval = None, name = &#x27;var&#x27;):</span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __get__(self, obj, objtype):</span><br><span class="line">        print(&quot;Retrieving&quot;,self.name)</span><br><span class="line">        return self.val</span><br><span class="line"></span><br><span class="line">    def __set__(self, obj, val):</span><br><span class="line">        print(&quot;updating&quot;,self.name)</span><br><span class="line">        self.val = val</span><br><span class="line">class myClass:</span><br><span class="line">    x = revealAccess(10,&#x27;var &quot;x&quot;&#x27;)</span><br><span class="line">    y = 5</span><br><span class="line">m = myClass()</span><br><span class="line">print(m.x)</span><br><span class="line">m.x = 20</span><br><span class="line">print(m.x)</span><br><span class="line">print(m.y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果为：<br>Retrieving var “x”<br>10<br>updating var “x”<br>Retrieving var “x”<br>20<br>5</p><p>可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的 <strong>get</strong>() 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 <strong>set</strong>() 方法</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter--Checkbutton复选框控件</title>
      <link href="/post/4f692c96.html"/>
      <url>/post/4f692c96.html</url>
      
        <content type="html"><![CDATA[<h5 id="Checkbutton复选框控件"><a href="#Checkbutton复选框控件" class="headerlink" title="Checkbutton复选框控件"></a>Checkbutton复选框控件</h5><p>Checkbutton 控件是一种供用户选择相应条目的按钮控件，但与 Radiobutton 不同的是，Checkbutton 控件不仅允许用户选择一项，还允许用户同时选择多项，各个选项之间属于并列的关系。复选框控件同样有许多适用场景，比如选择兴趣爱好、选择选修课，以及购买多个物品等，在这种情况下都可以使用复选框控件<br>语法格式：</p><p>Checkbutton(master&#x3D;None, **options)</p><p>复选框控件，除了具有常用的共有属性之外，还具有一些其他重要属性和常用方法<br>属性 ：<br>text<br>显示的文本，使用 “\n” 来对文本进行换行。</p><p>variable</p><ol><li>和复选框按钮关联的变量，该变量值会随着用户选择行为来改变（选或不选），即在 onvalue 和 offvalue 设置值之间切换，这些操作由系统自动完成</li><li>在默认情况下，variable 选项设置为 1 表示选中状态，反之则为 0，表示不选中。</li></ol><p>onvalue通过设置 onvalue 的值来自定义选中状态的值。offvalue通过设置 offvalue 的值来自定义未选中状态的值。</p><p>indicatoron<br>默认为 True，表示是否绘制用来选择的选项的小方块，当设置为 False 时，会改变原有按钮的样式，与单选按钮相同</p><p>selectcolor<br>选择框的颜色（即小方块的颜色），默认由系统指定</p><p>selectimage<br>设置当 Checkbutton 为选中状态的时候显示的图片，若如果没有指定 image 选项，该选项被忽略</p><p>textvariableCheckbutton<br>显示 Tkinter 变量（通常是一个 StringVar 变量）的内容，如果变量被修改，Checkbutton 的文本会自动更新</p><p>wraplength<br>表示复选框文本应该被分成多少行，该选项指定每行的长度，单位是屏幕单元，默认值为 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from typing_extensions import IntVar</span><br><span class="line">root= tk.Tk()</span><br><span class="line">root.geometry(&quot;400x400+300+300&quot;)</span><br><span class="line">CheckVar1 = tk.IntVar()</span><br><span class="line">CheckVar2 = tk.IntVar()</span><br><span class="line">CheckVar3 = tk.IntVar()</span><br><span class="line">check1 = tk.Checkbutton(root, text=&quot;Python&quot;,variable = CheckVar1,onvalue=1,offvalue=0)</span><br><span class="line">check2 = tk.Checkbutton(root, text=&quot;C语言&quot;,variable = CheckVar2,onvalue=1,offvalue=0)</span><br><span class="line">check3 = tk.Checkbutton(root, text=&quot;Java&quot;,variable = CheckVar3,onvalue=1,offvalue=0)</span><br><span class="line">check1.pack(side=tk.LEFT)</span><br><span class="line">check2.pack(side=tk.LEFT)</span><br><span class="line">check3.pack(side=tk.LEFT)</span><br><span class="line">check1.select()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>复杂版 – 嘿嘿</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;500x200&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line">lb = Label(text=&#x27;C语言&#x27;,font=(&#x27;微软雅黑&#x27;, 18,&#x27;bold&#x27;),fg=&#x27;#CD7054&#x27;)</span><br><span class="line">lb.pack()</span><br><span class="line"># 新建整型变量</span><br><span class="line">CheckVar1 = IntVar()</span><br><span class="line">CheckVar2 = IntVar()</span><br><span class="line">CheckVar3 = IntVar()</span><br><span class="line"># 设置三个复选框控件，使用variable参数来接收变量</span><br><span class="line">check1 = Checkbutton(win, text=&quot;Python&quot;,variable = CheckVar1,onvalue=1,offvalue=0)</span><br><span class="line">check2 = Checkbutton(win, text=&quot;C语言&quot;,variable = CheckVar2,onvalue=1,offvalue=0)</span><br><span class="line">check3 = Checkbutton(win, text=&quot;Java&quot;,variable = CheckVar3,onvalue=1,offvalue=0)</span><br><span class="line"># 选择第一个为默认选项</span><br><span class="line">check1.select ()</span><br><span class="line">check1.pack (side = LEFT)</span><br><span class="line">check2.pack (side = LEFT)</span><br><span class="line">check3.pack (side = LEFT)</span><br><span class="line">def study():</span><br><span class="line">    #没有选择任何项目的情况下</span><br><span class="line">    if (CheckVar1.get() == 0 and CheckVar2.get() == 0 and CheckVar3.get() == 0):</span><br><span class="line">        s = &#x27;您还没选择任语言&#x27;</span><br><span class="line">    else:</span><br><span class="line">        s1 = &quot;Python&quot; if CheckVar1.get() == 1 else &quot;&quot;</span><br><span class="line">        s2 = &quot;C语言&quot; if CheckVar2.get() == 1 else &quot;&quot;</span><br><span class="line">        s3 = &quot;Java&quot; if CheckVar3.get() == 1 else &quot;&quot;</span><br><span class="line">        s = &quot;您选择了%s %s %s&quot; % (s1, s2, s3)</span><br><span class="line">     #设置标签lb2的字体</span><br><span class="line">    lb2.config(text=s)</span><br><span class="line">btn = Button(win,text=&quot;选好了&quot;,bg=&#x27;#BEBEBE&#x27;,command=study)</span><br><span class="line">btn.pack(side = LEFT)</span><br><span class="line"># 该标签，用来显示选择的文本</span><br><span class="line">lb2 = Label(win,text=&#x27;&#x27;,bg =&#x27;#9BCD9B&#x27;,font=(&#x27;微软雅黑&#x27;,11,&#x27;bold&#x27;),width = 5,height=2)</span><br><span class="line">lb2.pack(side = BOTTOM, fill = X)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><p>复选框控件提供以下常用方法</p><p>desellect()<br>取消 Checkbutton 组件的选中状态，也就是设置 variable 为 offvalue</p><p>flash()<br>刷新 Checkbutton 组件，对其进行重绘操作，即将前景色与背景色互换从而产生闪烁的效果。</p><p>invoke()</p><ol><li>调用 Checkbutton 中 command 选项指定的函数或方法，并返回函数的返回值</li><li>如果 Checkbutton 的state(状态)”disabled”是 （不可用）或没有指定 command 选项，则该方法无效</li></ol><p>select()<br>将 Checkbutton 组件设置为选中状态，也就是设置 variable 为 onvalue</p><p>toggle()<br>改变复选框的状态，如果复选框现在状态是 on，就改成 off，反之亦然</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;500x200&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line">lb = Label(text=&#x27;漂亮鬼&#x27;,font=(&#x27;微软雅黑&#x27;, 18,&#x27;bold&#x27;),fg=&#x27;#CD7054&#x27;)</span><br><span class="line">lb.pack()</span><br><span class="line"># 设置三个复选框控件</span><br><span class="line">check1 = Checkbutton(win, text=&quot;Python&quot;,font=(&#x27;微软雅黑&#x27;, 15,&#x27;bold&#x27;),onvalue=1,offvalue=0)</span><br><span class="line">check2 = Checkbutton(win, text=&quot;C语言&quot;,font=(&#x27;微软雅黑&#x27;, 15,&#x27;bold&#x27;),onvalue=1,offvalue=0)</span><br><span class="line">check3 = Checkbutton(win, text=&quot;Java&quot;,font=(&#x27;微软雅黑&#x27;, 15,&#x27;bold&#x27;),onvalue=1,offvalue=0)</span><br><span class="line"># 将第一个 复选框按钮的 variable值，设置为 onvalue =1 ，表示选中状态</span><br><span class="line">check1.select ()</span><br><span class="line">check2.select ()</span><br><span class="line"># 取消了第一个复选框的选中状态</span><br><span class="line">check1.toggle()</span><br><span class="line">check1.pack (side = LEFT)</span><br><span class="line">check2.pack (side = LEFT)</span><br><span class="line">check3.pack (side = LEFT)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提升一</title>
      <link href="/post/f16679c0.html"/>
      <url>/post/f16679c0.html</url>
      
        <content type="html"><![CDATA[<h4 id="面向对象编程的相关术语"><a href="#面向对象编程的相关术语" class="headerlink" title="面向对象编程的相关术语"></a>面向对象编程的相关术语</h4><p>面向对象中，常用术语包括：</p><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>可以理解是一个模板，通过它可以创建出无数个具体实例。<br>比如， tortoise 表示的只是乌龟这个物种，通过它可以创建出无数个实例来代表各种不同特征的乌龟（这一过程又称为类的实例化）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class tortoise:</span><br><span class="line">    bodyColor = &quot;绿色&quot;</span><br><span class="line">    footNum = 4</span><br><span class="line">    weight = 10</span><br><span class="line">    hasShell = True</span><br><span class="line">    def crawl(self):</span><br><span class="line">        print(&quot;乌龟会爬&quot;)</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;乌龟吃东西&quot;)</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;乌龟在睡觉&quot;)</span><br><span class="line">    def protect(self):</span><br><span class="line">        print(&quot;乌龟缩进了壳里&quot;)</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>类并不能直接使用，通过类创建出的实例（又称对象）才能使用。这有点像汽车图纸和汽车的关系，图纸本身（类）并不能为人们使用，通过图纸创建出的一辆辆车（对象）才能使用。</p><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>类中的所有变量称为属性。<br>如:<br>tortoise 这个类中，bodyColor、footNum、weight、hasShell 都是这个类拥有的属性。</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>类中的所有函数通常称为方法。<br>不过，和函数所有不同的是，<strong>类方法至少要包含一个 self 参数</strong>。例如，tortoise 类中，crawl()、eat()、sleep()、protect() 都是这个类所拥有的方法，<strong>类方法无法单独使用，只能和类的对象一起使用。</strong></p><h5 id="Python类的定义"><a href="#Python类的定义" class="headerlink" title="Python类的定义"></a>Python类的定义</h5><p>Python 中定义一个类使用 class 关键字实现<br>语法格式：</p><p>class 类名：<br>    多个（≥0）类属性…<br>    多个（≥0）类方法…</p><p><strong>注意</strong>：无论是类属性还是类方法，对于类来说，它们都不是必需的，可以有也可以没有。<br>另外，Python 类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序</p><p>给类起好名字之后，其后要跟有冒号（：），表示告诉 Python 解释器，下面<br>要开始设计类的内部功能了，也就是编写类属性和类方法。<br>类属性指的就是包含在类中的变量；而类方法指的是包含类中的函数。<br><strong>换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称</strong>。<br><strong>需要注意的一点是</strong>，同属一个类的所有类属性和类方法，要保持统一的缩进格式，通常统一缩进 4 个空格。</p><h5 id="说明文档："><a href="#说明文档：" class="headerlink" title="说明文档："></a>说明文档：</h5><p>和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置</p><p>根据定义属性位置的不同，在各个<strong>类方法之外</strong>定义的变量称为<strong>类属性或类变量</strong>（如 add 属性），而在<strong>类方法中</strong>定义的属性称为<strong>实例属性</strong>（或实例变量）</p><p>事实上，我们完全可以创建一个没有任何类属性和类方法的类，换句话说，Python 允许创建空类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Empty:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>可以看到，如果一个类没有任何类属性和类方法，那么可以直接用 pass 关键字作为类体即可。<strong>但在实际应用中，很少会创建空类，因为空类没有任何实际意义</strong>。</p><h4 id="init-类构造方法-构造函数"><a href="#init-类构造方法-构造函数" class="headerlink" title="init()类构造方法(构造函数)"></a><strong>init</strong>()类构造方法(构造函数)</h4><p>在创建类时，我们可以手动添加一个 <strong>init</strong>() 方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p><p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。<br>Python 类中，手动添加构造方法的语法格式：</p><p>def <strong>init</strong>(self,…):<br>    代码块</p><p>注意，此方法的方法名中，开头和结尾各有 2 个下划线，且中间不能有空格</p><p><strong>init</strong>() <strong>方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数</strong>。<br>也就是说，类的构造方法最少也要有一个 self 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TheFirstDemo:</span><br><span class="line">    &#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span><br><span class="line">    #构造方法</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用构造方法&quot;)</span><br><span class="line">    def say(self, content):</span><br><span class="line">        print(content)</span><br><span class="line">    add= 10</span><br><span class="line">zhangsan = TheFirstDemo()</span><br></pre></td></tr></table></figure><p>注意，即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法。</p><p>仅包含 self 参数的 <strong>init</strong>() 构造方法，又称为类的默认构造方法。</p><p>zhangsan &#x3D; TheFirstDemo()<br>这行代码的含义是创建一个名为 zhangsan 的 TheFirstDemo 类对象</p><p>在 <strong>init</strong>() 构造方法中，<strong>除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割</strong>。<br>例如，下面的代码在创建 <strong>init</strong>() 方法时，额外指定了 2 个参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class TheFirstDemo:</span><br><span class="line">    &#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span><br><span class="line">    #构造方法</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;调用构造方法&quot;)</span><br><span class="line">zhangsan = TheFirstDemo()</span><br></pre></td></tr></table></figure><p>由于创建对象时会调用类的构造方法，<br>如果构造函数有多个参数时，需要手动传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TheFirstDemo:</span><br><span class="line">    &#x27;&#x27;&#x27;这是一个学习Python定义的第一个类&#x27;&#x27;&#x27;</span><br><span class="line">    #构造方法</span><br><span class="line">    def __init__(self,nihao):</span><br><span class="line">        print(&quot;调用构造方法&quot;)</span><br><span class="line">        print(nihao)</span><br><span class="line">zhangsan = TheFirstDemo(&quot;nihao&quot;)</span><br></pre></td></tr></table></figure><p>self 不需要手动传递参数。</p><h4 id="Python类对象的创建和使用"><a href="#Python类对象的创建和使用" class="headerlink" title="Python类对象的创建和使用"></a>Python类对象的创建和使用</h4><p>创建类对象的过程，又称为类的实例化。(c++&#x2F;java都是)</p><h5 id="Python类的实例化"><a href="#Python类的实例化" class="headerlink" title="Python类的实例化"></a>Python类的实例化</h5><p>对已定义好的类进行实例化，其语法格式：</p><p><strong>类名(参数)</strong></p><p>定义类时，如果没有手动添加 <strong>init</strong>() 构造方法，又或者添加的 <strong>init</strong>() 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    name = &quot;漂亮鬼的个人博客&quot;</span><br><span class="line">    add = &quot;https://xiaoyangzst.vercel.app/&quot;</span><br><span class="line">    def __init__(self,name,add):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.add = add</span><br><span class="line">        print(name,&quot;网址为：&quot;,add)</span><br><span class="line">    def say(self, content):</span><br><span class="line">        print(content)</span><br><span class="line">#将该CLanguage对象赋给clanguage变量</span><br><span class="line">clanguage = CLanguage(&quot;漂亮鬼的个人博客&quot;,&quot;https://xiaoyangzst.vercel.app/&quot;)</span><br></pre></td></tr></table></figure><p>由于构造方法除 self 参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的 name 值和 add 值（self 参数是特殊参数，不需要手动传值，Python 会自动传给它值）<br>类变量和实例变量：<br>定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性）<br>定义在类方法中的变量为实例变量（或者实例属性）</p><h5 id="Python类对象的使用"><a href="#Python类对象的使用" class="headerlink" title="Python类对象的使用"></a>Python类对象的使用</h5><p>定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：<br><strong>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量</strong>；（注意操作的对象是实例变量）<br>调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。</p><h5 id="类对象访问变量或方法"><a href="#类对象访问变量或方法" class="headerlink" title="类对象访问变量或方法"></a>类对象访问变量或方法</h5><p>使用已创建好的类对象访问类中实例变量的语法格式：</p><p>类对象名.变量名</p><p>使用类对象调用类中方法的语法格式：</p><p>对象名.方法名(参数)</p><p>注意，对象名和变量名以及方法名之间用点 “.” 连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CLanguage :</span><br><span class="line">    name = &quot;漂亮鬼的个人博客&quot;</span><br><span class="line">    add = &quot;https://xiaoyangzst.vercel.app/&quot;</span><br><span class="line">    def __init__(self,name,add):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.add = add</span><br><span class="line">        print(name,&quot;网址为：&quot;,add)</span><br><span class="line">    def say(self, content):</span><br><span class="line">        print(content)</span><br><span class="line">#将该CLanguage对象赋给clanguage变量</span><br><span class="line">clanguage = CLanguage(&quot;漂亮鬼的个人博客&quot;,&quot;https://xiaoyangzst.vercel.app/&quot;)</span><br><span class="line">#输出name和add实例变量的值</span><br><span class="line">print(clanguage.name,clanguage.add)</span><br><span class="line"></span><br><span class="line">#修改实例变量的值</span><br><span class="line">clanguage.name=&quot;Python&quot;</span><br><span class="line">clanguage.add=&quot;https://xiaoyangzst.vercel.app/&quot;</span><br><span class="line"></span><br><span class="line">#调用clanguage的say()方法</span><br><span class="line">clanguage.say(&quot;人生苦短，我用Python&quot;)</span><br><span class="line">不用给self参数传值</span><br><span class="line"></span><br><span class="line">#再次输出name和add的值</span><br><span class="line">print(clanguage.name,clanguage.add)</span><br></pre></td></tr></table></figure><h5 id="给类对象动态添加-x2F-删除变量"><a href="#给类对象动态添加-x2F-删除变量" class="headerlink" title="给类对象动态添加&#x2F;删除变量"></a>给类对象动态添加&#x2F;删除变量</h5><p>Python 支持为已创建好的对象动态增加 <strong>实例变量</strong>，方法也很简单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#为clanguage对象增加一个money实例变量</span><br><span class="line">clanguage.money= 159.9</span><br><span class="line">print(clanguage.money)</span><br></pre></td></tr></table></figure><p>通过直接增加一个新的实例变量并为其赋值，就成功地为 clanguage 对象添加了 money 变量。</p><p>动态删除,使用 del 语句即可实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除新添加的 money 实例变量</span><br><span class="line">del clanguage.money</span><br><span class="line">#再次尝试输出 money，此时会报错</span><br><span class="line">print(clanguage.money)</span><br></pre></td></tr></table></figure><h5 id="给类对象动态添加方法"><a href="#给类对象动态添加方法" class="headerlink" title="给类对象动态添加方法"></a>给类对象动态添加方法</h5><p>Python 也允许为对象动态增加方法。以前面的 Clanguage 类为例，由于其内部只包含一个 say() 方法，因此该类实例化出的 clanguage 对象也只包含一个 say() 方法。但其实，我们还可以为 clanguage 对象动态添加其它方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#先定义一个函数</span><br><span class="line">def info(self):</span><br><span class="line">    print(&quot;---info函数---&quot;, self)</span><br><span class="line">#使用info对clanguage的foo方法赋值（动态绑定方法）</span><br><span class="line">clanguage.foo = info</span><br><span class="line">#Python不会自动将调用者绑定到第一个参数，</span><br><span class="line">#因此程序需要手动将调用者绑定为第一个参数</span><br><span class="line">clanguage.foo(clanguage)  # ①</span><br><span class="line">#这是俩种添加方法的方式</span><br><span class="line">#使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）</span><br><span class="line">clanguage.bar = lambda self: print(&#x27;--lambda表达式--&#x27;, self)</span><br><span class="line">clanguage.bar(clanguage) # ②</span><br></pre></td></tr></table></figure><p>上面的代码分别使用函数、lambda 表达式为 clanguage 对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。</p>]]></content>
      
      
      <categories>
          
          <category> python提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter单选框和多选框按钮</title>
      <link href="/post/d6a06432.html"/>
      <url>/post/d6a06432.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter单选框和多选框按钮"><a href="#Tkinter单选框和多选框按钮" class="headerlink" title="Tkinter单选框和多选框按钮"></a>Tkinter单选框和多选框按钮</h5><p>单选框按钮控件（Radiobutton），同样允许用户选择具体的选项值，不过与 Listbox 相比，单选按钮控件仅允许用户选择单一的选项值，各个选项值之间是互斥的关系，因此只有一个选项可以被用户选择。<br><strong>Radiobutton 控件通常都是成组出现的，所有控件都使用相同的变量</strong></p><p><strong>Radiobutton 可以包含文本或图像，每一个按钮都可以与一个 Python 函数相关联。</strong></p><p>当按钮被按下时，对应的函数会被执行。这里需要注意的是，单选按钮控件仅能显示单一字体的文本，但文本可以跨越多行，除此之外，您还可以为个别的字符添加下划线。Radiobutton 除常用的共有属性之外，还具有一些其他属性</p><p>activebackground<br>设置当 Radiobutton 处于活动状态（通过 state 选项设置状态）的背景色，默认值由系统指定</p><p>compound</p><ol><li>默认值为 None，控制 Radiobutton 中文本和图像的混合模式，默认情况下，如果有指定位图或图片，则不显示文本</li><li>如果该选项设置为 “center”，文本显示在图像上（文本重叠图像）</li><li>设置为 “bottom”，”left”，”right” 或 “top”，那么图像显示在文本的旁边，比如如”bottom”，则显示图像在文本的下方。</li></ol><p>disabledforeground<br>指定当 Radiobutton 不可用的时的前景色颜色，默认由系统指定</p><p>indicatoron</p><ol><li>该参数表示选项前面的小圆圈是否被绘制，默认为 True，即绘制；</li><li>如果设置为 False，则会改变单选按钮的样式，当点击时按钮会变成 “sunken”（凹陷），再次点击变为 “raised”（凸起）</li></ol><p>selectcolor<br>设置当 Radiobutton 为选中状态的时候显示的图片；如果没有指定 image 选项，该选项被忽略</p><p>takefocus<br>如果是 True，该组件接受输入焦点，默认为 False</p><p>variable<br>表示与 Radiobutton 控件关联的变量，注意同一组中的所有按钮的 variable 选项应该都指向同一个变量，通过将该变量与 value 选项值对比，可以判断用户选中了哪个按钮。</p><p>Radiobutton 控件的常用方法</p><p>deselect()<br>取消该按钮的选中状态</p><p>flash()<br>刷新 Radiobutton 控件，该方法将重绘 Radiobutton控件若干次（即在”active” 和 “normal” 状态间切换）</p><p>invoke()</p><ol><li>调用 Radiobutton 中 command 参数指定的函数，并返回函数的返回值</li><li>如果 Radiobutton 控件的 state(状态) 是 “disabled” （不可用）或没有指定 command 选项，则该方法无效</li></ol><p>select()<br>将 Radiobutton 控件设置为选中状态</p><p>Radiobutton 控件用来解决多选一的问题，它通常是成组出现的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line"></span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;400x180&#x27;)</span><br><span class="line"># IntVar() 用于处理整数类型的变量</span><br><span class="line">v = tk.IntVar()</span><br><span class="line"># 根据单选按钮的 value 值来选择相应的选项</span><br><span class="line">v.set(0)</span><br><span class="line"># 使用 variable 参数来关联 IntVar() 的变量 v</span><br><span class="line">tk.Radiobutton(window, text=&quot;C语言中文网&quot;, variable=v, value=0).pack(anchor = &#x27;w&#x27;)</span><br><span class="line">tk.Radiobutton(window, text=&quot;CSDN平台&quot;, variable=v, value=2).pack(anchor = &#x27;w&#x27;)</span><br><span class="line">tk.Radiobutton(window, text=&quot;知乎平台&quot;, variable=v, value=3).pack(anchor = &#x27;w&#x27;)</span><br><span class="line">tk.Radiobutton(window, text=&quot;牛客网平台&quot;, variable=v, value=4).pack(anchor = &#x27;w&#x27;)</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line"></span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;400x180&#x27;)</span><br><span class="line">site = [(&#x27;美团外卖&#x27;,1),</span><br><span class="line">        (&#x27;饿了么外卖&#x27;,2),</span><br><span class="line">        (&#x27;美团闪购&#x27;,3),</span><br><span class="line">        (&#x27;艾奇外卖&#x27;,4)]</span><br><span class="line"># IntVar() 用于处理整数类型的变量</span><br><span class="line">v = tk.IntVar()</span><br><span class="line">for name, num in site:</span><br><span class="line">    radio_button = tk.Radiobutton(window,text = name, variable = v,value =num)</span><br><span class="line">    radio_button.pack(anchor =&#x27;w&#x27;)</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">def select():</span><br><span class="line">    dict = &#123;1:&#x27;C语言中文网&#x27;,2:&#x27;菜鸟教程&#x27;,3:&#x27;W3SCHOOL&#x27;,4:&#x27;微学苑&#x27;&#125;</span><br><span class="line">    strings = &#x27;您选择了&#x27; + dict.get(v.get()) + &#x27;，祝您学习愉快&#x27;</span><br><span class="line">    lable.config(text = strings)</span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;400x180&#x27;)</span><br><span class="line">lable = tk.Label(window,font=(&#x27;微软雅黑&#x27;, &#x27;15&#x27;,&#x27;bold&#x27;),fg=&#x27;#43CD80&#x27;)</span><br><span class="line">lable.pack(side =&#x27;bottom&#x27;)</span><br><span class="line">site = [(&#x27;C语言中文网&#x27;,1),</span><br><span class="line">        (&#x27;菜鸟教程&#x27;,2),</span><br><span class="line">        (&#x27;W3SCHOOL&#x27;,3),</span><br><span class="line">        (&#x27;微学苑&#x27;,4)]</span><br><span class="line"># IntVar() 用于处理整数类型的变量</span><br><span class="line">v = tk.IntVar()</span><br><span class="line">for name, num in site:</span><br><span class="line">    radio_button = tk.Radiobutton(window,text = name, variable = v,value =num,command = select,indicatoron = False)</span><br><span class="line">    radio_button.pack(anchor =&#x27;w&#x27;)</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><p>建议都自己手动敲一下这些代码，直接复制粘贴效果不大</p>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter_Combobox控件</title>
      <link href="/post/fe65fb3c.html"/>
      <url>/post/fe65fb3c.html</url>
      
        <content type="html"><![CDATA[<h5 id="Combobox控件"><a href="#Combobox控件" class="headerlink" title="Combobox控件"></a>Combobox控件</h5><p>通过前面内容的介绍我们知道 Listbox 是一个供用户从列表项中选择相应条目的控件。但在有些情况下，比如列表的项目过多时，若使用列表控件，列出所有选项就会显得界面格外臃肿，这时就需要用到 Combobox 控件，也就是下拉菜单控件（或称复合框），该控件是列表控件的改进版，具有更加灵活的界面，因此其应用场景相比于前者要更加广泛。</p><p><strong>不过需要注意的是 Combobox 并不包含在 tkinter 模块中，而是包含在tkinter.ttk子模块中，因此若想使用 Combobox 控件，需要使用下面的导包方式</strong>：</p><p>from tkinter import ttk</p><p>语法格式：</p><p>cbox&#x3D;Combobox(窗口对象,[参数列表])</p><p>Combobox 控件在形式虽然与列表控件存在不同，但它们的本质是相同，因此属性和方法是<strong>通用</strong>的。</p><p>对于 Combobox 控件而言，它常用的方法有两个，分别是 get() 和 current()，前者表示获取当前选中选项的内容，后者表示获取选中选项的索引值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import tkinter</span><br><span class="line">from tkinter import ttk # 导入ttk模块，下拉菜单控件位于ttk子模块中</span><br><span class="line">win = tkinter.Tk()</span><br><span class="line">win.geometry(&#x27;400x250&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line">cbox = ttk.Combobox(win)</span><br><span class="line"># 使用 grid() 来控制控件的位置</span><br><span class="line">cbox.grid(row = 1, sticky=&quot;NW&quot;)</span><br><span class="line"># 设置下拉菜单中的值</span><br><span class="line">cbox[&#x27;value&#x27;] = (&#x27;C&#x27;,&#x27;C#&#x27;,&#x27;Go&#x27;,&#x27;Python&#x27;,&#x27;Java&#x27;)</span><br><span class="line">#通过 current() 设置下拉菜单选项的默认值</span><br><span class="line">cbox.current(3)</span><br><span class="line"># 编写回调函数，绑定执行事件,向文本插入选中文本</span><br><span class="line">def func(event):</span><br><span class="line">    text.insert(&#x27;insert&#x27;,cbox.get()+&quot;\n&quot;)</span><br><span class="line"># 绑定下拉菜单事件</span><br><span class="line">cbox.bind(&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;,func)</span><br><span class="line">text = tkinter.Text(win)</span><br><span class="line">text.grid(pady = 5)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识六</title>
      <link href="/post/547ff74f.html"/>
      <url>/post/547ff74f.html</url>
      
        <content type="html"><![CDATA[<h5 id="函数传递参数的方式"><a href="#函数传递参数的方式" class="headerlink" title="函数传递参数的方式"></a>函数传递参数的方式</h5><p>Python 中，根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：</p><p>值传递：适用于实参类型为不可变类型（字符串、数字、元组）；</p><p>引用（地址）传递：适用于实参类型为可变类型（列表，字典）,<br>函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；</p><p>函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。<br>例如，定义一个名为 demo 的函数，分别为传入一个字符串类型的变量（代表值传递）和列表类型的变量（代表引用传递）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def nihao(str):</span><br><span class="line">    str +=str</span><br><span class="line">    print(str)</span><br><span class="line">str1 = &quot;213&quot;</span><br><span class="line">nihao(str1)</span><br><span class="line">print(&#x27;值传递：%s&#x27; %str1)</span><br><span class="line">list = [1,2,3]</span><br><span class="line">nihao(list)</span><br><span class="line">print(&#x27;引用传递：%s&#x27; %list)</span><br></pre></td></tr></table></figure><h5 id="函数关键字参数及用法"><a href="#函数关键字参数及用法" class="headerlink" title="函数关键字参数及用法"></a>函数关键字参数及用法</h5><p>关键字参数是指使用形式参数的名字来确定输入的参数值。<br><strong>通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可</strong></p><p>可以看到，在调用有参函数时，既可以根据位置参数来调用，也可以使用关键字参数（程序中第 8 行）来调用。在使用关键字参数调用时，可以任意调换参数传参的位置。<br>当然，还可以像第 7 行代码这样，使用位置参数和关键字参数混合传参的方式。但需要注意，混合传参时关键字参数必须位于所有的位置参数之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def dis_str(str1,str2):</span><br><span class="line">    print(&quot;str1:&quot;,str1)</span><br><span class="line">    print(&quot;str2:&quot;,str2)</span><br><span class="line">#位置参数</span><br><span class="line">dis_str(&quot;http://c.biancheng.net/python/&quot;,&quot;http://c.biancheng.net/shell/&quot;)</span><br><span class="line">#关键字参数</span><br><span class="line">dis_str(&quot;http://c.biancheng.net/python/&quot;,str2=&quot;http://c.biancheng.net/shell/&quot;)</span><br><span class="line">dis_str(str2=&quot;http://c.biancheng.net/python/&quot;,str1=&quot;http://c.biancheng.net/shell/&quot;)</span><br></pre></td></tr></table></figure><h5 id="函数默认参数设置"><a href="#函数默认参数设置" class="headerlink" title="函数默认参数设置"></a>函数默认参数设置</h5><p>Python 定义带有默认值参数的函数，<br>语法格式：<br>def 函数名(…，形参名，形参名&#x3D;默认值)：<br>    代码块</p><pre><code>**注意**：在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。</code></pre><p>当然在调用 dis_str() 函数时，也可以给所有的参数传值，这时即便 str2 有默认值，它也会优先使用传递给它的新值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#str1没有默认参数，str2有默认参数</span><br><span class="line">def dis_str(str1,str2 = &quot;http://c.biancheng.net/python/&quot;):</span><br><span class="line">    print(&quot;str1:&quot;,str1)</span><br><span class="line">    print(&quot;str2:&quot;,str2)</span><br><span class="line">dis_str(&quot;http://c.biancheng.net/shell/&quot;)</span><br><span class="line">dis_str(&quot;http://c.biancheng.net/java/&quot;,&quot;http://c.biancheng.net/golang/&quot;)</span><br></pre></td></tr></table></figure><p>但如果使用 Python 提供的内置函数，又或者其它第三方提供的函数，怎么知道哪些参数有默认值呢？<br>可以使用<br>“函数名.__defaults__”查看函数的默认值参数的当前值，其返回值是一个元组。以dis_str() 函数为例，在其基础上，执行如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(dis_str.__defaults__)</span><br></pre></td></tr></table></figure><h5 id="函数返回多个值的方法"><a href="#函数返回多个值的方法" class="headerlink" title="函数返回多个值的方法"></a>函数返回多个值的方法</h5><p>实际上 Python 也是如此，只不过 Python 函数能以返回列表或者元组的方式，将要返回的多个值保存到序列中，从而间接实现返回多个值的目的。<br>因此，实现 Python 函数返回多个值，有以下 2 种方式：</p><p>在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组；</p><p>函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def nihao(str):</span><br><span class="line">    a = 1</span><br><span class="line">    b =2</span><br><span class="line">    return a,b,str</span><br><span class="line">print(nihao (3))</span><br></pre></td></tr></table></figure><h5 id="将局部变量变成全局变量"><a href="#将局部变量变成全局变量" class="headerlink" title="将局部变量变成全局变量"></a>将局部变量变成全局变量</h5><p>在函数体内定义全局变量。使用 global 关键字对变量进行修饰后，该变量就会变为全局变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def text():</span><br><span class="line">    global add</span><br><span class="line">    add= &quot;http://c.biancheng.net/java/&quot;</span><br><span class="line">    print(&quot;函数体内访问：&quot;,add)</span><br><span class="line">text()</span><br><span class="line">print(&#x27;函数体外访问：&#x27;,add)</span><br></pre></td></tr></table></figure><h5 id="获取指定作用域范围中的变量"><a href="#获取指定作用域范围中的变量" class="headerlink" title="获取指定作用域范围中的变量"></a>获取指定作用域范围中的变量</h5><p>在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：</p><ol><li><p>globals()函数<br>globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#全局变量</span><br><span class="line">Pyname = &quot;Python教程&quot;</span><br><span class="line">def text():#局部变量</span><br><span class="line">    Shename = &quot;shell教程&quot;</span><br><span class="line">    print(globals())</span><br></pre></td></tr></table></figure></li><li><p>locals()函数<br>locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。<br>这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#全局变量</span><br><span class="line">Pyname = &quot;Python教程&quot;</span><br><span class="line">def text():#局部变量</span><br><span class="line">    Shename = &quot;shell教程&quot;</span><br><span class="line">    print(&quot;函数内部的 locals:&quot;)</span><br><span class="line">    print(locals())</span><br><span class="line">text()</span><br><span class="line">print(&quot;函数外部的 locals:&quot;)</span><br><span class="line">print(locals())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，当使用 locals() 函数获得所有局部变量组成的字典时，可以向 <strong>globals() 函数那样，通过指定键访问对应的变量值，但无法对变量值做修改</strong></p></li></ol><h5 id="局部变量和全局变量同名"><a href="#局部变量和全局变量同名" class="headerlink" title="局部变量和全局变量同名"></a>局部变量和全局变量同名</h5><p>当函数内部的局部变量和函数外部的全局变量同名时，在函数内部，局部变量会“遮蔽”同名的全局变量。</p><h5 id="lambda表达式（匿名函数）及用法"><a href="#lambda表达式（匿名函数）及用法" class="headerlink" title="lambda表达式（匿名函数）及用法"></a>lambda表达式（匿名函数）及用法</h5><p>lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。<br>语法格式：name &#x3D; lambda [list] : 表达式<br>其中，定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。</p><p>该语法格式转换成普通函数的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def name(list):</span><br><span class="line">    return 表达式</span><br><span class="line">name(list)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = lambda x,y:x+y</span><br><span class="line">print(add(3,4))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识五</title>
      <link href="/post/52663f4c.html"/>
      <url>/post/52663f4c.html</url>
      
        <content type="html"><![CDATA[<h5 id="Python字符串对齐方法（ljust-、rjust-和center"><a href="#Python字符串对齐方法（ljust-、rjust-和center" class="headerlink" title="Python字符串对齐方法（ljust()、rjust()和center()"></a>Python字符串对齐方法（ljust()、rjust()和center()</h5><h6 id="ljust-方法"><a href="#ljust-方法" class="headerlink" title="ljust()方法"></a>ljust()方法</h6><p>ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。<br>格式如下：S.ljust(width[, fillchar])</p><p>S：表示要进行填充的字符串<br>width：表示包括 S 本身长度在内，字符串要占的总长度；<br>fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = &quot;xiaoyang&quot;</span><br><span class="line">print(n.ljust(15,&quot;1&quot;))</span><br></pre></td></tr></table></figure><h6 id="rjust-方法"><a href="#rjust-方法" class="headerlink" title="rjust()方法"></a>rjust()方法</h6><p>rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。<br>格式如下：S.rjust(width[, fillchar])<br>各个参数的含义和 ljust() 完全相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = &quot;xiaoyang&quot;</span><br><span class="line">print(n.rjust(15,&quot;1&quot;))</span><br></pre></td></tr></table></figure><h6 id="center-方法"><a href="#center-方法" class="headerlink" title="center()方法"></a>center()方法</h6><p>center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。<br>格式如下：S.center(width[, fillchar])<br>其中各个参数的含义和 ljust()、rjust() 方法相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = &quot;xiaoyang&quot;</span><br><span class="line">print(n.center(15,&quot;1&quot;))</span><br></pre></td></tr></table></figure><h5 id="startswith-方法"><a href="#startswith-方法" class="headerlink" title="startswith()方法"></a>startswith()方法</h5><p>startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False。<br>语法格式： str.startswith(sub[,start[,end]])</p><p>str：表示原字符串；<br>sub：要检索的子串；<br>start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；<br>end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;xiaoyang&quot;</span><br><span class="line">print(a.startswith(&quot;xiao&quot;))</span><br></pre></td></tr></table></figure><h5 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith()方法"></a>endswith()方法</h5><p>endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False。<br>语法格式：<br>str.endswith(sub[,start[,end]])<br>str：表示原字符串；<br>sub：表示要检索的字符串；<br>start：指定检索开始时的起始位置索引（字符串第一个字符对应的索引值为 0），如果不指定，默认从头开始检索。<br>end：指定检索的结束位置索引，如果不指定，默认一直检索到结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;xiaoyang&quot;</span><br><span class="line">print(a.endwith(&quot;xiao&quot;))</span><br></pre></td></tr></table></figure><h5 id="title-方法"><a href="#title-方法" class="headerlink" title="title()方法"></a>title()方法</h5><p>title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。<br>语法格式：str.title()<br>str 表示要进行转换的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;I LIKE C&quot;</span><br><span class="line">print(str.title())</span><br></pre></td></tr></table></figure><h5 id="lower-方法"><a href="#lower-方法" class="headerlink" title="lower()方法"></a>lower()方法</h5><p>lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。<br>语法格式：str.lowerr()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;I LIKE C&quot;</span><br><span class="line">print(str.lower())</span><br></pre></td></tr></table></figure><h5 id="upper-方法"><a href="#upper-方法" class="headerlink" title="upper()方法"></a>upper()方法</h5><p>upper() 的功能和 lower() 方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。<br>语法格式：str.upper()<br>str 表示要进行转换的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;i like you&quot;</span><br><span class="line">print(str.upper())</span><br></pre></td></tr></table></figure><h5 id="strip-lstrip-rstrip"><a href="#strip-lstrip-rstrip" class="headerlink" title="strip() , lstrip(), rstrip()"></a>strip() , lstrip(), rstrip()</h5><p>删除字符串<strong>前后</strong>（左右两侧）的空格或特殊字符。</p><p>lstrip()：删除字符串前面（左边）的空格或特殊字符。</p><p>rstrip()：删除字符串后面（右边）的空格或特殊字符。<br>注意，Python 的 str 是不可变的（不可变的意思是指，字符串一旦形成，它所包含的字符序列就不能发生任何改变），因此这三个<strong>方法只是返回字符串前面或后面空白被删除之后的副本，并不会改变字符串本身</strong>。</p><h6 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip()方法"></a>strip()方法</h6><p>strip() 方法用于删除字符串左右两个的空格和特殊字符</p><p>语法格式为： str.strip([chars])<br>str 表示原字符串<br>[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;                 I LIKE C &quot;</span><br><span class="line">print(str.strip())</span><br></pre></td></tr></table></figure><p>分析运行结果不难看出，通过 strip() 确实能够删除字符串左右两侧的空格和特殊字符，但并没有真正改变字符串本身 </p><h6 id="lstrip-方法"><a href="#lstrip-方法" class="headerlink" title="lstrip()方法"></a>lstrip()方法</h6><p>lstrip() 方法用于去掉字符串左侧的空格和特殊字符。<br>语法格式：str.lstrip([chars])<br>str 和 chars 参数的含义，分别同 strip() 语法格式中的 str 和 chars 完全相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;                 I LIKE C &quot;</span><br><span class="line">print(str.ltrip())</span><br></pre></td></tr></table></figure><h6 id="rstrip-方法"><a href="#rstrip-方法" class="headerlink" title=".rstrip()方法"></a>.rstrip()方法</h6><p>rstrip() 方法用于删除字符串右侧的空格和特殊字符<br>语法格式： str.rstrip([chars])<br>str 和 chars 参数的含义和前面 2 种方法语法格式中的参数完全相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;                 I LIKE C     &quot;</span><br><span class="line">print(str.rstrip())</span><br></pre></td></tr></table></figure><h5 id="encode-方法"><a href="#encode-方法" class="headerlink" title="encode()方法"></a>encode()方法</h5><p>encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。<br>语法格式：<br>str.encode([encoding&#x3D;”utf-8”][,errors&#x3D;”strict”])</p><p>注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。</p><img src="/post/52663f4c/35.png" class title="This is an image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;xiaoyang你好&quot;</span><br><span class="line">print(str.encode())</span><br></pre></td></tr></table></figure><h5 id="decode-方法"><a href="#decode-方法" class="headerlink" title="decode()方法"></a>decode()方法</h5><p>和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。<br>语法格式：<br>bytes.decode([encoding&#x3D;”utf-8”][,errors&#x3D;”strict”])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = &quot;xiaoyang你好&quot;</span><br><span class="line">b = str.encode()</span><br><span class="line">print(b.decode())</span><br></pre></td></tr></table></figure><h5 id="dir-函数-和-help-函数"><a href="#dir-函数-和-help-函数" class="headerlink" title="dir() 函数 和 help()函数"></a>dir() 函数 和 help()函数</h5><p>用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等<br>它的用法为：dir(obj)</p><p>obj 表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。</p><p> help() 函数用来查看某个函数或者模块的帮助文档<br> 它的用法为：help(obj)<br>obj 表示要查看的对象。obj 可以不写，此时 help() 会进入帮助子程序。<br>掌握了以上两个函数，我们就可以自行查阅 Python 中所有方法、函数、变量、类的用法和功能了。</p><p><strong>使用 help() 查看某个函数的用法时，函数名后边不能带括号，例如将上面的命令写作help(str.lower())就是错误的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def nihao( a, b):</span><br><span class="line">    &quot;&quot;&quot;输出俩个数之和&quot;&quot;&quot;</span><br><span class="line">    print(a+b)</span><br><span class="line">a1 = 1</span><br><span class="line">a2 = 2</span><br><span class="line">nihao(a1,a2)</span><br><span class="line">print(dir(nihao))</span><br><span class="line">print()</span><br><span class="line">print(help(nihao))</span><br></pre></td></tr></table></figure><h5 id="空语句-pass"><a href="#空语句-pass" class="headerlink" title="空语句 pass"></a>空语句 pass</h5><p>pass 是 Python 中的关键字，用来让解释器跳过此处，什么都不做。<br>就像上面的情况，有时候程序需要占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过 pass 语句来实现。使用 pass 语句比使用注释更加优雅。</p><h5 id="assert断言函数及用法"><a href="#assert断言函数及用法" class="headerlink" title="assert断言函数及用法"></a>assert断言函数及用法</h5><p>assert 语句通常用于检查用户的输入是否符合规定<br>当 assert 语句后的表达式值为真时，程序继续执行；反之，程序停止执行，并报 AssertionError 错误</p><p>语法格式：assert 条件表达式 [,描述信息]</p><p>[,描述信息] 作为可选参数，用于对条件表达式可能产生的异常进行描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a= 2</span><br><span class="line">b = 3</span><br><span class="line">assert a&lt;b , &quot;error&quot;</span><br></pre></td></tr></table></figure><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>语法格式如下：<br>for 迭代变量 in 字符串|列表|元组|字典|集合：代码块</p><p>格式中，迭代变量用于存放从序列类型变量中读取出来的元素，<br>所以一般不会在循环中对迭代变量手动赋值；代码块指的是具有相同缩进格式的多行代码（和 while 一样），由于和循环结构联用，因此代码块又称为循环体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in  range(1,20):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h5 id="for-循环遍历字典"><a href="#for-循环遍历字典" class="headerlink" title="for 循环遍历字典"></a>for 循环遍历字典</h5><p>在使用 for 循环遍历字典时，经常会用到和字典相关的 3 个方法，即 items()、keys() 以及 values()。如果使用 for 循环直接遍历字典，则迭代变量会被先后赋值为每个键值对中的键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&quot;1&quot;:&quot;nihao&quot;, &quot;2&quot;: &quot;hello&quot;, &quot;3&quot;:&quot;Hi&quot;&#125;</span><br><span class="line">for i in  a.items():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>Python 中，无论是 while 循环还是 for 循环，其后都可以紧跟着一个 else 代码块，它的作用是当循环条件为 False 跳出循环时，程序会最先执行 else 代码块中的代码。</p><h5 id="2-种强制离开当前循环体的办法：Continue语句和break语句"><a href="#2-种强制离开当前循环体的办法：Continue语句和break语句" class="headerlink" title="2 种强制离开当前循环体的办法：Continue语句和break语句"></a>2 种强制离开当前循环体的办法：Continue语句和break语句</h5><p>使用 continue 语句，可以跳过执行本次循环体中剩余的代码，转而执行下一次的循环。只用 break 语句，可以完全终止当前循环。</p><h5 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h5><p>列表推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的列表。<br>语法格式：[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ]</p><p>[if 条件表达式] 不是必须的，可以使用，也可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [x**x for x in range(1,5)]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h5><p>元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。<br>语法格式：(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )</p><p>用 [] 括起来的部分，可以使用，也可以省略。</p><p>如果我们想要使用元组推导式获得新元组或新元组中的元素，有以下三种方式：</p><ol><li><p>使用 tuple() 函数，可以直接将生成器对象转换成元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (x for x in range(1,10))</span><br><span class="line">print(tuple(a))</span><br></pre></td></tr></table></figure><p>要使用tuple函数不然输出的是a的一段地址</p></li><li><p>直接使用 for 循环遍历生成器对象，可以获得各个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (x for x in range(1,10))</span><br><span class="line">for i in a:</span><br><span class="line">    print(i,end=&#x27; &#x27;)</span><br><span class="line">print(tuple(a))</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>next</strong>() 方法遍历生成器对象，也可以获得各个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (x for x in range(3))</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br><span class="line">print(a.__next__())</span><br></pre></td></tr></table></figure></li></ol><h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5><p>Python 中，使用字典推导式可以借助列表、元组、字典、集合以及 range 区间，快速生成符合需求的字典。<br>语法格式：{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}</p><p>用 [] 括起来的部分，可以使用，也可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listdemo = &#123;&quot;123&quot; : &quot;一二三&quot;, &quot;456&quot;:&quot;四五六&quot;&#125;</span><br><span class="line">newdict = &#123;key:len(key) for key in listdemo&#125;</span><br><span class="line">print(newdict)</span><br></pre></td></tr></table></figure><h5 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h5><p>Python中，使用集合推导式可以借助列表、元组、字典、集合以及 range 区间，快速生成符合需求的集合。</p><p>集合推导式的语法格式和字典推导式完全相同：</p><p>{ 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] }<br>其中，用 [] 括起来的部分，可以使用，也可以省略。</p><p>既然生成的是集合，那么其保存的元素必须是唯一的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnew = &#123;i**2 for i in range(3)&#125;</span><br><span class="line">print(setnew)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识四</title>
      <link href="/post/4f845d09.html"/>
      <url>/post/4f845d09.html</url>
      
        <content type="html"><![CDATA[<h5 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h5><p><strong>Python 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同</strong>。<br>感觉集合使用的非常的少</p><p>从形式上看，和字典类似，Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔，如下所示：</p><p>{element1,element2,…,elementn}<br>elementn 表示集合中的元素，个数没有限制<br>从内容上看，<strong>同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组</strong>，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误<br>并且需要注意的是，数据必须保证是唯一的，因为集合对于每种数据元素，只会保留一份。<br>由于 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。</p><h5 id="创建set集合"><a href="#创建set集合" class="headerlink" title="创建set集合"></a>创建set集合</h5><p>Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。</p><p>使用 {} 创建</p><p>在 Python 中，创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的<br>语法格式：setname &#x3D; {element1,element2,…,elementn}</p><p>setname 表示集合的名称，起名时既要符合 Python 命名规范，也要避免与 Python 内置函数重名。</p><p>set()函数创建集合</p><p>set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合<br>语法格式：setname &#x3D; set(iteration)<br>iteration 就表示字符串、列表、元组、range 对象等数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1 = set(&quot;c.biancheng.net&quot;)</span><br><span class="line">set2 = set([1,2,3,4,5])</span><br><span class="line">set3=set((1,2,3,4,5))</span><br><span class="line">print(&quot;set1:&quot;,set1)</span><br><span class="line">print(&quot;set2:&quot;,set2)</span><br><span class="line">print(&quot;set3:&quot;,set3)</span><br></pre></td></tr></table></figure><p>注意，如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。</p><h5 id="访问set集合元素"><a href="#访问set集合元素" class="headerlink" title="访问set集合元素"></a>访问set集合元素</h5><p>由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1,&#x27;c&#x27;,1,(1,2,3),&#x27;c&#x27;&#125;</span><br><span class="line">for ele in a:</span><br><span class="line">    print(ele,end=&#x27; &#x27;)</span><br></pre></td></tr></table></figure><h5 id="删除set集合"><a href="#删除set集合" class="headerlink" title="删除set集合"></a>删除set集合</h5><p>和其他序列类型一样，手动函数集合类型，也可以使用 del() 语句</p><h5 id="向-set-集合中添加元素：add"><a href="#向-set-集合中添加元素：add" class="headerlink" title="向 set 集合中添加元素：add()"></a>向 set 集合中添加元素：add()</h5><p>set 集合中添加元素，可以使用 set 类型提供的 add() 方法实现<br>语法格式：<br>setname.add(element)</p><p>setname 表示要添加元素的集合<br>element 表示要添加的元素内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set3=set((1,2,3,4,5))</span><br><span class="line">print(&quot;set1:&quot;,set3)</span><br><span class="line">set3.add(8)</span><br><span class="line">print(set3)</span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据，</strong>否则 Python 解释器会报 TypeError 错误</p><p>当成整体添加进去的</p><h5 id="从set集合中删除元素：remove"><a href="#从set集合中删除元素：remove" class="headerlink" title="从set集合中删除元素：remove()"></a>从set集合中删除元素：remove()</h5><p>删除现有 set 集合中的指定元素，可以使用 <strong>remove()</strong> 方法<br>语法格式：<br>setname.remove(element)</p><p>使用此方法删除集合中元素，需要注意的是，如果被删除元素本就不包含在集合中，则此方法会抛出 KeyError 错误</p><p>可以使用 <strong>discard()</strong> 方法，此方法和 remove() 方法的用法完全相同，唯一的区别就是，当删除集合中元素失败时，此方法不会抛出任何错误。</p><h5 id="set集合做交集、并集、差集运算"><a href="#set集合做交集、并集、差集运算" class="headerlink" title="set集合做交集、并集、差集运算"></a>set集合做交集、并集、差集运算</h5><p><img src="en-resource://database/569:1" alt="c9d93e16d9be661d5f1b99511529f6d0.png"></p><h5 id="set集合方法"><a href="#set集合方法" class="headerlink" title="set集合方法"></a>set集合方法</h5><p><img src="en-resource://database/571:1" alt="4ee7f45f9f2aca4af266ff1ee5bd8606.png"><br><img src="en-resource://database/573:1" alt="1916ac8b80a2a3117eb9a155e2744478.png"></p><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h5><p><strong>浅拷贝</strong>，指的是重新分配一块内存，创建一个新的对象，但里面的元素是原对象中各个子对象的<strong>引用</strong>。<br>对数据采用浅拷贝的方式时，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会出现一些问题</p><p><strong>深拷贝</strong>，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</p><h5 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h5><p>在 Python 中拼接（连接）字符串很简单，可以直接将两个字符串紧挨着写在一起<br>strname &#x3D; “str1” “str2”</p><p>strname 表示拼接以后的字符串变量名<br>str1 和 str2 是要拼接的字符串内容<br>使用这种写法，Python 会自动将两个字符串拼接在一起</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;hello&quot; &quot; xiaoyang&quot;</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，这种写法只能拼接字符串常量,如果需要使用变量，就得借助+运算符来拼接</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;nihao&quot;</span><br><span class="line">str2 = &quot; xiaoyang&quot;</span><br><span class="line">a = str1+str2</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="字符串和数字的拼接"><a href="#字符串和数字的拼接" class="headerlink" title="字符串和数字的拼接"></a>字符串和数字的拼接</h5><p> Python 不允许直接拼接数字和字符串，所以我们必须先将数字转换成字符串。<br>可以借助 str() 和 repr() 函数将数字转换为字符串<br>str(obj)<br>repr(obj)<br>obj 表示要转换的对象，它可以是数字、列表、元组、字典等多种类型的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello &quot;</span><br><span class="line">str2 = &quot;岁的漂亮鬼&quot;</span><br><span class="line">year =18</span><br><span class="line">n = str1 + str(year) + str2</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><h5 id="截取字符串（字符串切片）"><a href="#截取字符串（字符串切片）" class="headerlink" title="截取字符串（字符串切片）"></a>截取字符串（字符串切片）</h5><p>字符串是由多个字符构成的，字符之间是有顺序的，这个顺序号就称为索引（index）。Python 允许通过索引来操作字符串中的单个或者多个字符，比如获取指定索引处的字符，返回指定字符的索引值等。</p><p><strong>获取单个字符</strong><br>知道字符串名字以后，在方括号[ ]中使用索引即可访问对应的字符<br>语法格式：<br>strname[index]<br>strname 表示字符串名字，index 表示索引值。<br>Python 允许从字符串的两端使用索引：<br>当以字符串的左端（字符串的开头）为起点时，索引是从 0 开始计数的；字符串的第一个字符的索引为 0，第二个字符的索引为 1，第三个字符串的索引为 2 ……<br>当以字符串的右端（字符串的末尾）为起点时，索引是从 -1 开始计数的；字符串的倒数第一个字符的索引为 -1，倒数第二个字符的索引为 -2，倒数第三个字符的索引为 -3 ……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello&quot;</span><br><span class="line">print(str1[1])</span><br></pre></td></tr></table></figure><p><strong>获取多个字符（字符串截去&#x2F;字符串切片）</strong><br>使用[ ]除了可以获取单个字符外，还可以指定一个范围来获取多个字符，也就是一个子串或者片段<br>strname[start : end : step]</p><p>strname：要截取的字符串<br>start：表示要截取的第一个字符所在的索引（截取时包含该字符）。如果不指定，默认为 0，也就是从字符串的开头截取<br>end：表示要截取的最后一个字符所在的索引（截取时不包含该字符）。如果不指定，默认为字符串的长度；<br>step：指的是从 start 索引处的字符开始，每 step 个距离获取一个字符，直至 end 索引出的字符。step 默认值为 1，当省略该值时，最后一个冒号也可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello &quot;</span><br><span class="line">print(str1[0:3])</span><br><span class="line">print(str1[-4:-1])</span><br></pre></td></tr></table></figure><h5 id="len-函数和encode-函数"><a href="#len-函数和encode-函数" class="headerlink" title="len()函数和encode()函数"></a>len()函数和encode()函数</h5><p>python 中，要想知道一个字符串有多少个字符（获得字符串长度），或者一个字符串占用多少个字节，可以使用 len 函数。</p><p>语法格式：<br>len（string）<br>string 用于指定要进行长度统计的字符串。</p><p>在实际开发中，除了常常要获取字符串的长度外，有时还要获取字符串的字节数。<br>在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式</p><p>encode() 方法，将字符串进行编码后再获取它的字节数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;人生苦短，我用Python&quot;</span><br><span class="line">len(str1.encode())</span><br></pre></td></tr></table></figure><h5 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h5><p>split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。</p><p>语法格式：str.split(sep,maxsplit)<br>str：表示要进行分割的字符串；</p><p>sep：用于指定分隔符，可以包含多个字符。此<strong>参数默认为 None，表示所有空字符，包括空格、换行符“\n”、制表符“\t”等</strong>。</p><p>maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello I am your brother&quot;</span><br><span class="line">print(str1.split())</span><br></pre></td></tr></table></figure><p>在未指定 sep 参数时，split() 方法默认采用空字符进行分割，但当字符串中有连续的空格或其他空字符时，都会被视为一个分隔符对字符串进行分割，</p><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h5><p>使用 join() 方法合并字符串时，它会将列表（或元组）中多个字符串采用固定的分隔符连接在一起。</p><p>语法格式：newstr &#x3D; str.join(iterable)</p><p>newstr：表示合并后生成的新字符串<br>str：用于指定合并时的分隔符<br>iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;www&quot;,&quot;xiaoyangzst&quot;,&quot;vercel&quot;,&quot;app&quot;]</span><br><span class="line">a =&#x27;.&#x27;.join(list)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h5><p>count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。<br>语法格式：<br>str.count(sub[,start[,end]])</p><p>str：表示原字符串；<br>sub：表示要检索的字符串；<br>start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；<br>end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;www&quot;,&quot;xiaoyangzst&quot;,&quot;vercel&quot;,&quot;app&quot;]</span><br><span class="line">a =&#x27;.&#x27;.join(list)</span><br><span class="line">print(a)</span><br><span class="line">print()</span><br><span class="line">c=a.count(&#x27;.&#x27;)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><h5 id="find-方法和index-方法"><a href="#find-方法和index-方法" class="headerlink" title="find()方法和index()方法"></a>find()方法和index()方法</h5><p>find() 方法用于检索字符串中是否包含目标字符串，如果包含，则返回第一次出现该字符串的索引；反之，则返回 -1。<br>语法格式：<br>str.find(sub[,start[,end]])<br>str：表示原字符串；<br>sub：表示要检索的目标字符串；<br>start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；<br>end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;www&quot;,&quot;xiaoyangzst&quot;,&quot;vercel&quot;,&quot;app&quot;]</span><br><span class="line">a =&#x27;.&#x27;.join(list)</span><br><span class="line">c=a.find(&#x27;.&#x27;)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>同 find() 方法类似，index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。<br>语法格式：<br>str.index(sub[,start[,end]])<br>str：表示原字符串；<br>sub：表示要检索的子字符串；<br>start：表示检索开始的起始位置，如果不指定，默认从头开始检索；<br>end：表示检索的结束位置，如果不指定，默认一直检索到结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list = [&quot;www&quot;,&quot;xiaoyangzst&quot;,&quot;vercel&quot;,&quot;app&quot;]</span><br><span class="line">a =&#x27;.&#x27;.join(list)</span><br><span class="line">print(a)</span><br><span class="line">print()</span><br><span class="line">c = a.index(&#x27;.&#x27;)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识三</title>
      <link href="/post/3563117.html"/>
      <url>/post/3563117.html</url>
      
        <content type="html"><![CDATA[<h5 id="tuple元组详解"><a href="#tuple元组详解" class="headerlink" title="tuple元组详解"></a>tuple元组详解</h5><p>元组和列表（list）的不同之处在于：<br>列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。<br>从形式上看，元组的所有元素都放在一对小括号( )中，相邻元素之间用逗号,分隔，如下所示：<br>(ele1, ele2, … , elen)<br>其中 ele1~elen 表示元组中的各个元素，个数没有限制，只要是 Python 支持的数据类型就可以。并且在同一个元组中，元素的类型可以不同</p><h5 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h5><p>Python 提供了两种创建元组的方法</p><ol><li><p>使用 ( ) 直接创建<br>通过( )创建元组后，一般使用&#x3D;将它赋值给某个变量，具体格式为：tuplename &#x3D; (element1, element2, …, elementn)<br>tuplename 表示变量名，element1 ~ elementn 表示元组的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = (7, 14, 21, 28, 35)</span><br><span class="line">course = (&quot;Python教程&quot;, &quot;http://c.biancheng.net/python/&quot;)</span><br><span class="line">abc = ( &quot;Python&quot;, 19, [1,2], (&#x27;c&#x27;,2.0) )</span><br></pre></td></tr></table></figure><p>在 Python 中，<strong>元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的</strong>，只要将各元素用逗号隔开，Python 就会将其视为元组，<br>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">course = &quot;Python教程&quot;, &quot;http://c.biancheng.net/python/&quot;</span><br><span class="line">print(course)</span><br></pre></td></tr></table></figure><p><strong>需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号,，否则 Python 解释器会将它视为字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#最后加上逗号</span><br><span class="line">a =(&quot;http://c.biancheng.net/cplus/&quot;,)</span><br></pre></td></tr></table></figure></li><li><p>使用tuple()函数创建元组<br>Python提供了一个内置的函数 tuple()，用来将其它数据类型转换为元组类型。<br>tuple() 的语法格式如下：tuple(data)<br>其中，data 表示可以转化为元组的数据，包括字符串、元组、range 对象等。</p></li></ol><h5 id="访问元组元素"><a href="#访问元组元素" class="headerlink" title="访问元组元素"></a>访问元组元素</h5><p>和列表一样，我们可以使用索引（Index）访问元组中的某个元素（得到的是一个元素的值），也可以使用切片访问元组中的一组元素（得到的是一个新的子元组）<br>使用索引访问元组元素：<br>tuplename[i]<br>tuplename 表示元组名字，i 表示索引值。元组的索引可以是正数，也可以是负数。<br>使用切片访问元组元素：<br>tuplename[start : end : step]<br>其中，start 表示起始索引，end 表示结束索引，step 表示步长。</p><h5 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h5><p>前面我们已经说过，元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。<br>对元组变量进行重新赋值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = (100, 0.5, -36, 73)</span><br><span class="line">print(tup)#对元组进行重新赋值</span><br><span class="line">tup = (&quot;nihao&quot;,&quot;hello&quot;)</span><br><span class="line">print(tup)</span><br></pre></td></tr></table></figure><p>添加元素的方法可以，但是有限制只能添加在最前面或者最后面<br><strong>另外，还可以通过连接多个元组（使用+可以拼接元组）的方式向元组中添加新元素</strong></p><h5 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h5><p>当创建的元组不再使用时，可以通过 del 关键字将其删除</p><h5 id="dict字典详解"><a href="#dict字典详解" class="headerlink" title="dict字典详解"></a>dict字典详解</h5><p>字典（dict）是一种无序的、可变的序列，它的元素以“键值对（key-value）”的形式存储。相对地，列表（list）和元组（tuple）都是有序的序列，它们的元素在底层是挨着存放的。</p><p>字典中，习惯将各元素对应的索引称为键（key），各个键对应的元素称为值（value）<br><strong>字典的主要特征</strong><br>通过键而不是通过索引来读取元素<br>字典是任意数据类型的无序集合<br>字典中的键必须唯一<br>键可以是整数、字符串或者元组，只要符合唯一和不可变的特性就行；字典的值可以是 Python 支持的任意数据类型</p><h5 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h5><p>创建字典的方式有很多</p><ol><li>使用 { } 创建字典</li></ol><p>由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号:分隔，相邻元素之间使用逗号,分隔，所有元素放在大括号{ }中。</p><p>使用{ }创建字典的语法格式如下：</p><p>dictname &#x3D; {‘key’:’value1’, ‘key2’:’value2’, …, ‘keyn’:valuen}<br>其中 dictname 表示字典变量名，keyn : valuen 表示各个元素的键值对。需要注意的是，同一字典中的各个键必须唯一，不能重复。</p><ol start="2"><li>通过 fromkeys() 方法创建字典<br>Python 中，还可以使用 dict 字典类型提供的 fromkeys() 方法创建带有默认值的字典，具体格式为：<br>dictname &#x3D; dict.fromkeys(list，value&#x3D;None)<br>list 参数表示字典中所有键的列表（list）<br>value 参数表示默认值，如果不写，则为空值 None<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knowledge = [&#x27;语文&#x27;, &#x27;数学&#x27;, &#x27;英语&#x27;]</span><br><span class="line">scores = dict.fromkeys(knowledge, 60)</span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure></li><li>通过 dict() 映射函数创建字典</li></ol><h5 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h5><p>列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。<br>访问字典元素的具体格式为：<br>dictname[key]<br>dictname 表示字典变量的名字<br>key 表示键名。注意，键必须是存在的，否则会抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = ([&#x27;two&#x27;,26], [&#x27;one&#x27;,88], [&#x27;three&#x27;,100], [&#x27;four&#x27;,-59])</span><br><span class="line">dic = dict(tup)</span><br><span class="line">print(dic[&#x27;one&#x27;]) #键存在</span><br><span class="line">print(dic[&#x27;five&#x27;]) #键不存在</span><br></pre></td></tr></table></figure><p>除了上面这种方式外，Python 更推荐使用 dict 类型提供的 get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。<br>get() 方法的语法格式为：<br>dictname.get(key[,default])</p><p>dictname 表示字典变量的名字；<br>key 表示指定的键；<br>default 用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回 None。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = dict(two=0.65, one=88, three=100, four=-59)</span><br><span class="line">print( a.get(&#x27;one&#x27;) )</span><br></pre></td></tr></table></figure><p>注意，当键不存在时，get() 返回空值 None，如果想明确地提示用户该键不存在，那么可以手动设置 get() 的第二个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = dict(two=0.65, one=88, three=100, four=-59)</span><br><span class="line">print( a.get(&#x27;five&#x27;, &#x27;该键不存在&#x27;) )</span><br></pre></td></tr></table></figure><p>运行结果：<br>该键不存在</p><h5 id="删除字典"><a href="#删除字典" class="headerlink" title="删除字典"></a>删除字典</h5><p>和删除列表、元组一样，手动删除字典也可以使用 del 关键字</p><h5 id="字典添加键值对"><a href="#字典添加键值对" class="headerlink" title="字典添加键值对"></a>字典添加键值对</h5><p>为字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：<br>dictname[key] &#x3D; value<br>dictname 表示字典名称<br>key 表示新的键<br>value 表示新的值，只要是 Python 支持的数据类型都可以。</p><h5 id="字典修改键值对"><a href="#字典修改键值对" class="headerlink" title="字典修改键值对"></a>字典修改键值对</h5><p><strong>Python 字典中键（key）的名字不能被修改</strong>，我们只能修改值（value）。<br>字典中各元素的键必须是唯一的，因此，<strong>如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉</strong>，以此达到修改元素值的目的。</p><h5 id="字典删除键值对"><a href="#字典删除键值对" class="headerlink" title="字典删除键值对"></a>字典删除键值对</h5><p>删除字典中的键值对，还是可以使用 del 语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">del a[&#x27;语文&#x27;]</span><br><span class="line">del a[&#x27;数学&#x27;]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="判断字典中是否存在指定键值对"><a href="#判断字典中是否存在指定键值对" class="headerlink" title="判断字典中是否存在指定键值对"></a>判断字典中是否存在指定键值对</h5><p>如果要判断字典中是否存在指定键值对，首先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。需要指出的是，对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">print(&#x27;数学&#x27; in a) </span><br><span class="line">print(&#x27;物理&#x27; in a) </span><br></pre></td></tr></table></figure><h5 id="dir查询"><a href="#dir查询" class="headerlink" title="dir查询"></a>dir查询</h5><p>Python 字典的数据类型为 dict，我们可使用 dir(dict) 来查看该类型包含哪些方法</p><h5 id="keys-、values-和-items-方法"><a href="#keys-、values-和-items-方法" class="headerlink" title="keys()、values() 和 items() 方法"></a>keys()、values() 和 items() 方法</h5><p>它们用来获取字典中的特定数据：<br>keys() 方法用于返回字典中的所有键（key）</p><p>values() 方法用于返回字典中所有键对应的值（value）</p><p>items() 用于返回字典中所有的键值对（key-value）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scores = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">print(scores.keys())</span><br><span class="line">print(scores.values())</span><br><span class="line">print(scores.items())</span><br></pre></td></tr></table></figure><p>如果想使用这三个方法返回的数据，一般有下面两种方案：</p><ol><li>使用 list() 函数，将它们返回的数据转换成列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">b = list(a.keys())</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></li><li>使用 for in 循环遍历它们的返回值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">for k in a.keys():</span><br><span class="line">    print(k,end=&#x27; &#x27;)</span><br><span class="line">print()</span><br><span class="line">for v in a.values():</span><br><span class="line">    print(v,end=&#x27; &#x27;)</span><br><span class="line">print()</span><br><span class="line">for k,v in a.items():</span><br><span class="line">    print(&quot;key:&quot;,k,&quot; value:&quot;,v)</span><br></pre></td></tr></table></figure></li></ol><h5 id="copy-方法"><a href="#copy-方法" class="headerlink" title="copy() 方法"></a>copy() 方法</h5><p>copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: [1,2,3]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h5 id="update-方法"><a href="#update-方法" class="headerlink" title="update() 方法"></a>update() 方法</h5><p>update() 方法可以使用一个字典所包含的键值对来更新己有的字典。<br>在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;</span><br><span class="line">a.update(&#123;&#x27;one&#x27;:4.5, &#x27;four&#x27;: 9.3&#125;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="pop-和-popitem-方法"><a href="#pop-和-popitem-方法" class="headerlink" title="pop() 和 popitem() 方法"></a>pop() 和 popitem() 方法</h5><p>pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，popitem() 总是弹出底层中的最后一个 key-value<br>语法格式：<br>dictname.pop(key)<br>dictname.popitem()<br>dictname 表示字典名<br>key 表示键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90, &#x27;化学&#x27;: 83, &#x27;生物&#x27;: 98, &#x27;物理&#x27;: 89&#125;</span><br><span class="line">print(a)</span><br><span class="line">a.pop(&#x27;化学&#x27;)</span><br><span class="line">print(a)</span><br><span class="line">a.popitem()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault() 方法"></a>setdefault() 方法</h5><p>setdefault() 方法用来返回某个 key 对应的 value<br>语法格式：<br>dictname.setdefault(key, defaultvalue)</p><p>dictname 表示字典名称<br>key 表示键<br>defaultvalue 表示默认值（可以不写，不写的话是 None）</p><p>当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#x27;数学&#x27;: 95, &#x27;语文&#x27;: 89, &#x27;英语&#x27;: 90&#125;</span><br><span class="line">print(a)</span><br><span class="line">#key不存在，指定默认值</span><br><span class="line">a.setdefault(&#x27;物理&#x27;, 94)</span><br><span class="line">print(a)</span><br><span class="line">#key不存在，不指定默认值</span><br><span class="line">a.setdefault(&#x27;化学&#x27;)</span><br><span class="line">print(a)</span><br><span class="line">#key存在，指定默认值</span><br><span class="line">a.setdefault(&#x27;数学&#x27;, 100)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter列表框控件</title>
      <link href="/post/ecbd7cdb.html"/>
      <url>/post/ecbd7cdb.html</url>
      
        <content type="html"><![CDATA[<h4 id="Tkinter列表框和组合框控件"><a href="#Tkinter列表框和组合框控件" class="headerlink" title="Tkinter列表框和组合框控件"></a>Tkinter列表框和组合框控件</h4><p>列表框，即 Listbox。在使用 Tkinter 进行 GUI 编程的过程中，如果需要用户自己进行选择时就可以使用列表框控件。列表框中的选项可以是多个条目，也可以是单个唯一条目，但常用于多个条目</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>activate(index)<br>将给定索引号对应的选项激活，即文本下方画一条下划线</p><p>bbox(index)<br>返回给定索引号对应的选项的边框，返回值是一个以像素为单位的 4 元祖表示边框：(xoffset, yoffset, width, height)， xoffset 和 yoffset 表示距离左上角的偏移位置</p><p>curselection()<br>返回一个元组，包含被选中的选项序号（从 0 开始）</p><p>delete(first, last&#x3D;None)<br>删除参数 first 到 last 范围内（包含 first 和 last）的所有选项</p><p>get(first, last&#x3D;None)<br>返回一个元组，包含参数 first 到 last 范围内（包含 first 和 last）的所有选项的文本</p><p>index(index)<br>返回与 index 参数相应选项的序号</p><p>itemcget(index, option)<br>获得 index 参数指定的项目对应的选项（由 option 参数指定）</p><p>itemconfig(index, **options)</p><p>设置 index 参数指定的项目对应的选项（由可变参数 option 指定）</p><p>nearest(y)<br>返回与给定参数 y 在垂直坐标上最接近的项目的序号</p><p>selection_set(first, last&#x3D;None)<br>设置参数 first 到 last 范围内（包含 first 和 last）选项为选中状态，使用 selection_includes(序号) 可以判断选项是否被选中。 </p><p>size()<br>返回 Listbox 组件中选项的数量</p><p>xview(*args)</p><p>该方法用于在水平方向上滚动 Listbox 组件的内容，一般通过绑定 Scollbar 组件的 command 选项来实现。 如果第一个参数是 “moveto”，则第二个参数表示滚动到指定的位置：0.0 表示最左端，1.0 表示最右端；如果第一个参数是 “scroll”，则第二个参数表示滚动的数量，第三个参数表示滚动的单位（可以是 “units” 或 “pages”）<br>例如：xview(“scroll”, 2, “pages”)表示向右滚动二行。</p><p>yview(*args)</p><p>该方法用于在垂直方向上滚动 Listbox 组件的内容，一般通过绑定 Scollbar 组件的 command 选项来实现</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除了共有属性之外，列表框控件也有一些其他属性</p><p>listvariable</p><ol><li>指向一个 StringVar 类型的变量，该变量存放 Listbox 中所有的项目</li><li>在 StringVar 类型的变量中，用空格分隔每个项目，例如 var.set(“c c++ java python”)</li></ol><p>selectbackground<br>指定当某个项目被选中的时候背景颜色，默认值由系统指定</p><p>selectborderwidth</p><ol><li>指定当某个项目被选中的时候边框的宽度</li><li>默认是由 selectbackground 指定的颜色填充，没有边框</li><li>如果设置了此选项，Listbox 的每一项会相应变大，被选中项为 “raised” 样式</li></ol><p>selectforeground<br>指定当某个项目被选中的时候文本颜色，默认值由系统指定</p><p>selectmode<br>决定选择的模式，tk 提供了四种不同的选择模式，分别是：”single”（单选）、”browse”（也是单选，但拖动鼠标或通过方向键可以直接改变选项）、”multiple”（多选）和 “extended”（也是多选，但需要同时按住 Shift 键或 Ctrl 键或拖拽鼠标实现），默认是 “browse”</p><p>setgrid<br>指定一个布尔类型的值，决定是否启用网格控制，默认值是 False</p><p>takefocus<br>指定该组件是否接受输入焦点（用户可以通过 tab 键将焦点转移上来），默认值是 True</p><p>xscrollcommand<br>为 Listbox 组件添加一条水平滚动条，将此选项与 Scrollbar 组件相关联即可</p><p>yscrollcommand<br>为 Listbox 组件添加一条垂直滚动条，将此选项与 Scrollbar 组件相关联即可</p><p>eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;400x200&#x27;)</span><br><span class="line"># 创建列表选项</span><br><span class="line">listbox1 =Listbox(win)</span><br><span class="line">listbox1.pack()</span><br><span class="line"># i表示索引值，item 表示值，根据索引值的位置依次插入</span><br><span class="line">for i,item in enumerate([&quot;C&quot;,&quot;C++&quot;,&quot;C#&quot;,&quot;Python&quot;,&quot;Java&quot;]):</span><br><span class="line">    listbox1.insert(i,item)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><p>除了上述使用 enumerate() 来实现选项插入的方法外，还可以使用 “end” 实现，它表示将选项插入到最后一个位置，所以“Java”一定会被插入到最后一个位置上，而之前的选项会依次向前排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&quot;400x400+500+100&quot;)</span><br><span class="line">list =tk.Listbox(root,selectbackground=&quot;#AAAAFF&quot;)</span><br><span class="line">list.pack()</span><br><span class="line">n1 = [&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;]</span><br><span class="line">for i in n1:</span><br><span class="line">    list.insert(&#x27;end&#x27;,i)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><ol start="2"><li>增加滚动条和删除功能</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from logging import RootLogger</span><br><span class="line">import tkinter as tk</span><br><span class="line">from turtle import right </span><br><span class="line">root = tk.Tk()</span><br><span class="line">s = tk.Scrollbar(root)</span><br><span class="line">s.pack(side=tk.RIGHT,fill=tk.Y)</span><br><span class="line">root.geometry(&quot;400x400+500+100&quot;)</span><br><span class="line">list =tk.Listbox(root,selectbackground=&quot;#AAAAFF&quot;,selectmode = tk.MULTIPLE,height =5, yscrollcommand = s.set)</span><br><span class="line">list.pack()</span><br><span class="line">s.config(command = list.yview)</span><br><span class="line">n1 = [&quot;张三&quot;, &quot;李四&quot;,&quot;王五&quot;,&#x27;老四&#x27;,&quot;小路&quot;,&quot;康康&quot;,&quot;小小&quot;,&quot;美美&quot;,&quot;小杨&quot;]</span><br><span class="line">for i in n1:</span><br><span class="line">    list.insert(&#x27;end&#x27;,i)</span><br><span class="line">bt = tk.Button(root,text=&#x27;删除&#x27;,command = lambda x = list:x.delete(tk.ACTIVE))</span><br><span class="line">bt.pack(side = tk.BOTTOM)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><ol start="3"><li>StringVar() 添加列表选项</li></ol><p>StringVar() 方法动态地获取列表框中的选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import messagebox</span><br><span class="line">window = tk.Tk()</span><br><span class="line">window.geometry(&#x27;400x180&#x27;)</span><br><span class="line">var1 = tk.StringVar()</span><br><span class="line">l = tk.Label(window, bg=&#x27;#AAAAFF&#x27;, font=(&#x27;微软雅黑&#x27;, 15), width=20, textvariable=var1)</span><br><span class="line">l.pack()</span><br><span class="line">def click_button():</span><br><span class="line">    # 使用 curselection来选中文本</span><br><span class="line">    try:</span><br><span class="line">        val = lb.get(lb.curselection())</span><br><span class="line">        var1.set(val)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        e = &#x27;发现一个错误&#x27;</span><br><span class="line">        messagebox.showwarning(e,&#x27;没有选择任何条目&#x27;)</span><br><span class="line"></span><br><span class="line">b1 = tk.Button(window, text=&#x27;获取当前选项&#x27;, command=click_button)</span><br><span class="line">b1.pack()</span><br><span class="line">var2 = tk.StringVar()</span><br><span class="line">lb = tk.Listbox(window, listvariable=var2)</span><br><span class="line">items = [&quot;C&quot;, &quot;Java&quot;, &quot;Python&quot;, &quot;C#&quot;, &quot;Golang&quot;, &quot;Runby&quot;]</span><br><span class="line">for i in items:</span><br><span class="line">    lb.insert(&#x27;end&#x27;, i) </span><br><span class="line">lb.pack()</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识二</title>
      <link href="/post/410aa71a.html"/>
      <url>/post/410aa71a.html</url>
      
        <content type="html"><![CDATA[<h5 id="列表（list）和元组（tuple）字典（dict）和集合（set）的数据储存"><a href="#列表（list）和元组（tuple）字典（dict）和集合（set）的数据储存" class="headerlink" title="列表（list）和元组（tuple）字典（dict）和集合（set）的数据储存"></a>列表（list）和元组（tuple）字典（dict）和集合（set）的数据储存</h5><p>列表（list）和元组（tuple）比较相似，它们都<strong>按顺序保存元素</strong>，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：<strong>列表是可以修改的，而元组是不可修改的</strong></p><p>字典（dict）和集合（set）<strong>存储的数据都是无序的</strong>，每份元素占用不同的内存，其中字典元素以 key-value 的形式保存。</p><h5 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h5><p>序列类型包括字符串、列表、元组、集合和字典，这些序列支持以下几种通用的操作，但比较特殊的是，<strong>集合和字典不支持索引、切片、相加和相乘操作。</strong></p><h5 id="序列切片"><a href="#序列切片" class="headerlink" title="序列切片"></a>序列切片</h5><p>切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列</p><p>sname[start : end : step]<br>参数的含义分别是：<br>sname：表示序列的名称；<br>start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；<br>end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；<br>step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，<strong>如果 step 的值大于 1，则在进行切片去序列元素时，会“跳跃式”的取元素</strong>。如果省略设置 step 的值，则最后一个冒号就可以省略。</p><h5 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h5><p>Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素</p><h5 id="检查元素是否包含在序列中-in关键字"><a href="#检查元素是否包含在序列中-in关键字" class="headerlink" title="检查元素是否包含在序列中 in关键字"></a>检查元素是否包含在序列中 in关键字</h5><p>Python 中，可以使用 in 关键字检查某元素是否为序列的成员<br>和 in 关键字用法相同，但功能恰好相反的，还有 not in 关键字，它用来检查某个元素是否不包含在指定的序列中</p><h5 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h5><p>从形式上看，列表会将所有元素都放在一对中括号[ ]里面，相邻元素之间用逗号分隔<br>list &#x3D; [ele1,ele2,…..,elen]<br>格式中，ele1 ~ elen 表示列表中的元素，个数没有限制，只要是 Python 支持的数据类型就可以。<br>从内容上看，列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同<br><strong>注意</strong>：在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性</p><h5 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h5><ol><li>使用 [ ] 直接创建列表</li></ol><p>listname &#x3D; [element1 , element2 , element3 , … , elementn]</p><ol start="2"><li>使用 list() 函数创建列表<br>除了使用[ ]创建列表外，Python 还提供了一个内置的函数 list()，使用它可以将其它数据类型转换为列表类型</li></ol><h5 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h5><p>列表是 Python 序列的一种<br>可以使用索引（Index）访问列表中的某个元素（得到的是一个元素的值）<br>也可以使用切片访问列表中的一组元素（得到的是一个新的子列表）</p><h5 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h5><p>对于已经创建的列表，如果不再使用，可以使用del关键字将其删除。<br>实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收</p><p>del 关键字的语法格式为：<br>del listname</p><h5 id="append-方法添加元素"><a href="#append-方法添加元素" class="headerlink" title="append()方法添加元素"></a>append()方法添加元素</h5><p>append() 方法用于在列表的<strong>末尾追加元素</strong></p><p>语法格式：<br>listname.append(obj)</p><p>当给 append() 方法传递列表或者元组和字符串时，此方法会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表</p><h5 id="extend-方法添加元素"><a href="#extend-方法添加元素" class="headerlink" title="extend()方法添加元素"></a>extend()方法添加元素</h5><p>extend() 和 append() 的不同之处在于：<strong>extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中</strong></p><p>语法格式：<br>listname.extend(obj)</p><h5 id="insert-方法插入元素"><a href="#insert-方法插入元素" class="headerlink" title="insert()方法插入元素"></a>insert()方法插入元素</h5><p>语法格式：<br>listname.insert(index , obj)</p><p>index 表示指定位置的索引值。<br>insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。<br><strong>当插入列表或者元祖和字符串时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的</strong></p><h5 id="del根据索引值删除元素"><a href="#del根据索引值删除元素" class="headerlink" title="del根据索引值删除元素"></a>del根据索引值删除元素</h5><p>del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素。</p><p>del 可以删除列表中的单个元素<br>格式为：</p><p>del listname[index]<br>listname 表示列表名称，index 表示元素的索引值。</p><p>del 也可以删除中间一段连续的元素<br>格式为：</p><p>del listname[start : end]<br>start 表示起始索引，end 表示结束索引<br>del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素</p><h5 id="pop-根据索引值删除元素"><a href="#pop-根据索引值删除元素" class="headerlink" title="pop()根据索引值删除元素"></a>pop()根据索引值删除元素</h5><p>pop() 方法用来删除列表中指定索引处的元素<br>格式如下：<br>listname.pop(index)</p><p>listname 表示列表名称<br>index 表示索引值。<br><strong>如果不写 index 参数，默认会删除列表中的最后一个元素，类似于数据结构中的“出栈</strong>”</p><h5 id="remove-根据元素值进行删除"><a href="#remove-根据元素值进行删除" class="headerlink" title="remove()根据元素值进行删除"></a>remove()根据元素值进行删除</h5><p>remove() 方法会根据元素本身的值来进行删除操作</p><p>需要注意的是，remove() 方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发 ValueError 错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [40, 36, 89, 2, 36, 100, 7]</span><br><span class="line">nums.remove(36)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure><h5 id="clear-删除列表所有元素"><a href="#clear-删除列表所有元素" class="headerlink" title="clear()删除列表所有元素"></a>clear()删除列表所有元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4]</span><br><span class="line">print(list[1:4])</span><br><span class="line">list.clear()</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><h5 id="修改单个元素"><a href="#修改单个元素" class="headerlink" title="修改单个元素"></a>修改单个元素</h5><p>修改单个元素非常简单，直接对元素赋值即可<br>list[2] &#x3D; -26 </p><h5 id="修改一组元素"><a href="#修改一组元素" class="headerlink" title="修改一组元素"></a>修改一组元素</h5><p>Python 支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。<br>添加元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4]</span><br><span class="line">list[0:2]= [5,6]</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [1,2,3,4]</span><br><span class="line">list[0:2]= []</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><h5 id="list列表查找元素-index-方法"><a href="#list列表查找元素-index-方法" class="headerlink" title="list列表查找元素 index() 方法"></a>list列表查找元素 index() 方法</h5><p>index() 方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致 ValueError 错误，所以在查找之前最好使用 count() 方法判断一下<br>语法格式：<br>listname.index(obj, start, end)</p><p>istname 表示列表名称<br>obj 表示要查找的元素<br>start 表示起始位置<br>end 表示结束位置</p><p>start 和 end 参数用来指定检索范围<br>start 和 end 可以都不写，此时会检索整个列表；如果只写 start 不写 end，那么表示检索从 start 到末尾的元素；如果 start 和 end 都写，那么表示检索 start 和 end 之间的元素。<br><strong>index() 方法会返回元素所在列表中的索引值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [40, 36, 89, 2, 36, 100, 7, -20.5, -999]</span><br><span class="line">print( nums.index(2) ) </span><br><span class="line">print( nums.index(100, 3, 7) )</span><br></pre></td></tr></table></figure><h5 id="list列表查找元素count-方法"><a href="#list列表查找元素count-方法" class="headerlink" title="list列表查找元素count()方法"></a>list列表查找元素count()方法</h5><p><strong>count() 方法用来统计某个元素在列表中出现的次数</strong><br>语法格式为：<br>listname.count(obj)</p><p>listname 代表列表名，obj 表示要统计的元素<br>如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = [40, 36, 89, 2, 36, 100, 7, -20.5, 36]</span><br><span class="line">print(&quot;36出现了%d次&quot; % nums.count(36))</span><br><span class="line">if nums.count(100):</span><br><span class="line">    print(&quot;列表中存在100这个元素&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;列表中不存在100这个元素&quot;)</span><br></pre></td></tr></table></figure><h5 id="range-快速初始化数字列表"><a href="#range-快速初始化数字列表" class="headerlink" title="range()快速初始化数字列表"></a>range()快速初始化数字列表</h5><p>Python range() 函数能够轻松地生成一系列的数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for value in range(1,5):</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure><p>range() 只是打印数字 1~4，因为range() 函数的用法是：让 Python 从指定的第一个值开始，一直数到指定的第二个值停止，但<strong>不包含</strong>第二个值（这里为 5）</p><h5 id="list实现队列"><a href="#list实现队列" class="headerlink" title="list实现队列"></a>list实现队列</h5><p>使用 list 列表模拟队列功能的实现方法是，定义一个 list 变量，存入数据时使用 insert() 方法，设置其第一个参数为 0，即表示每次都从最前面插入数据；读取数据时，使用 pop() 方法，即将队列的最后一个元素弹出。满足先进先出的原则就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue = []</span><br><span class="line">queue.insert(0,1)</span><br><span class="line">queue.insert(0,2)</span><br><span class="line">queue.insert(0,&quot;hello&quot;)</span><br><span class="line">print(queue)</span><br><span class="line">print(&quot;取一个元素：&quot;,queue.pop())</span><br><span class="line">print(&quot;取一个元素：&quot;,queue.pop())</span><br><span class="line">print(&quot;取一个元素：&quot;,queue.pop())</span><br></pre></td></tr></table></figure><h5 id="Python-list实现栈"><a href="#Python-list实现栈" class="headerlink" title="Python list实现栈"></a>Python list实现栈</h5><p>使用 list 列表模拟栈功能的实现方法是，使用 append() 方法存入数据；使用 pop() 方法读取数据。append() 方法向 list 中存入数据时，每次都在最后面添加数据，这和前面程序中的 insert() 方法正好相反。满足后进先出就ok</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#定义一个空 list 当做栈</span><br><span class="line">stack = []</span><br><span class="line">stack.append(1)</span><br><span class="line">stack.append(2)</span><br><span class="line">stack.append(&quot;hello&quot;)</span><br><span class="line">print(stack)</span><br><span class="line">print(&quot;取一个元素：&quot;,stack.pop())</span><br><span class="line">print(&quot;取一个元素：&quot;,stack.pop())</span><br><span class="line">print(&quot;取一个元素：&quot;,stack.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础知识一</title>
      <link href="/post/7a8a89b3.html"/>
      <url>/post/7a8a89b3.html</url>
      
        <content type="html"><![CDATA[<h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><ol><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行，一般书写是一条语句占一行</li></ol><p>​eg.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height=float(input(&quot;输入身高：&quot;)) ;weight=fioat(input(&quot;输入体重：&quot;)) ;</span><br><span class="line">#这种是错误的</span><br></pre></td></tr></table></figure><ol start="2"><li><p>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。</p></li><li><p>在 Python 中，标识符中的字母是严格区分大小写</p></li><li><p>Python 语言中，以下划线开头的标识符有特殊含义<br>例如:<br>以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；</p></li></ol><p>​以双下划线开头的标识符（如__add）表示类的私有成员；</p><p>​以双下划线作为开头和结尾的标识符（如 __init__），是专用标识符。</p><ol start="5"><li><p>Python 允许使用汉字作为标识符</p></li><li><p>不要使用内置函数的名字作为标识符使用<br>（例如变量名、函数名、类名、模板名、对象名等），虽然这样做 Python 解释器不会报错，但这会导致同名的内置函数被覆盖，从而无法使用</p></li><li><p>Python 整数的取值范围是无限的<br>不管多大或者多小的数字,不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int</p></li><li><p>Python 默认支持对复数的简单计算。</p></li><li><p>Python 字符串中的双引号和单引号没有任何区别</p></li><li><p>字符串的换行<br>Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠\</p></li></ol><h5 id="多个字符串显示"><a href="#多个字符串显示" class="headerlink" title="多个字符串显示"></a>多个字符串显示</h5><p>建议每行不超过 80 个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠 \ 进行连接。如果一个字符串文本无法实现一行完全显示，则可以使用小括号将其分开显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=(&quot;C语言中文网是中国领先的C语言程序设计专业网站，&quot;</span><br><span class="line">&quot;提供C语言入门经典教程、C语言编译器、C语言函数手册等。&quot;)</span><br><span class="line">s=&quot;C语言中文网是中国领先的C语言程序设计专业网站，\</span><br><span class="line">提供C语言入门经典教程、C语言编译器、C语言函数手册等。&quot;</span><br></pre></td></tr></table></figure><h5 id="变量值"><a href="#变量值" class="headerlink" title="变量值"></a>变量值</h5><p>变量的值不是一成不变的，它可以随时被修改，只要重新赋值即可；<br>另外你也不用关心数据的类型，可以将不同类型的数据赋值给同一个变量</p><h5 id="弱类型语言有两个特点"><a href="#弱类型语言有两个特点" class="headerlink" title="弱类型语言有两个特点"></a>弱类型语言有两个特点</h5><p>变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。<br>变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。</p><h5 id="当字符串内容中出现引号时，我们需要进行特殊处理，否则-Python-会解析出错"><a href="#当字符串内容中出现引号时，我们需要进行特殊处理，否则-Python-会解析出错" class="headerlink" title="当字符串内容中出现引号时，我们需要进行特殊处理，否则 Python 会解析出错"></a>当字符串内容中出现引号时，我们需要进行特殊处理，否则 Python 会解析出错</h5><ol><li><p>对引号进行转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = &#x27;I\&#x27;m a great coder!&#x27;</span><br><span class="line">str2 = &quot;引文双引号是\&quot;，中文双引号是“&quot;</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure></li><li><p>使用不同的引号包围字符串<br>如果字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然</p></li></ol><h5 id="Python长字符串"><a href="#Python长字符串" class="headerlink" title="Python长字符串"></a>Python长字符串</h5><p>长字符串，就是可以直接换行（不用加反斜杠\）书写的字符串。<br>Python 长字符串由三个双引号”””或者三个单引号’’’包围</p><p>如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了</p><p>长字符串中的换行、空格、缩进等空白符都会原样输出</p><h5 id="Python原始字符串"><a href="#Python原始字符串" class="headerlink" title="Python原始字符串"></a>Python原始字符串</h5><p>在原始字符串中，\不会被当作转义字符，所有的内容都保持“原汁原味”的样子。<br>普通字符串或者长字符串的开头加上r前缀，就变成了原始字符串</p><p><strong>一般在写文件的路径时使用原始字符串更好</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = r&#x27;原始字符串内容&#x27;</span><br><span class="line">str2 = r&quot;&quot;&quot;原始字符串内容&quot;&quot;&quot;</span><br><span class="line">print(str1)</span><br><span class="line">print(str2)</span><br></pre></td></tr></table></figure><h5 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h5><p>bytes只负责以字节序列的形式（<strong>二进制形式</strong>）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。</p><h5 id="Python缓存重用机制"><a href="#Python缓存重用机制" class="headerlink" title="Python缓存重用机制"></a>Python缓存重用机制</h5><img src="/post/7a8a89b3/24.png" class title="This is an image"><p>大家可以上手试一下这个</p><h5 id="Python-内置函数将字符串转换成想要的类型"><a href="#Python-内置函数将字符串转换成想要的类型" class="headerlink" title="Python 内置函数将字符串转换成想要的类型"></a>Python 内置函数将字符串转换成想要的类型</h5><p> eg：<br>int(string) 将字符串转换成 int 类型；<br>float(string) 将字符串转换成 float 类型；<br>bool(string) 将字符串转换成 bool 类型。</p><img src="/post/7a8a89b3/27.png" class title="This is an image"><h5 id="指定对齐方式"><a href="#指定对齐方式" class="headerlink" title="指定对齐方式"></a>指定对齐方式</h5><p>print() 输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度</p><img src="/post/7a8a89b3/26.png" class title="This is an image"><h5 id="指定小数精度和格式化字符串"><a href="#指定小数精度和格式化字符串" class="headerlink" title="指定小数精度和格式化字符串"></a>指定小数精度和格式化字符串</h5><p>对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。<br>%m.nf<br>%.nf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = 8</span><br><span class="line">print(&quot;C语言！&quot; % age)</span><br></pre></td></tr></table></figure><h5 id="‘-’重复字符串"><a href="#‘-’重复字符串" class="headerlink" title="‘*’重复字符串"></a>‘*’重复字符串</h5><p>“* “除了可以用作乘法运算，还可以用来重复字符串，也即将 n 个同样的字符串连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;hello &quot;</span><br><span class="line">print(str1 * 4)</span><br></pre></td></tr></table></figure><h5 id="x2F-和-x2F-x2F-运算符"><a href="#x2F-和-x2F-x2F-运算符" class="headerlink" title="&#x2F;和&#x2F;&#x2F;运算符"></a>&#x2F;和&#x2F;&#x2F;运算符</h5><p>&#x2F;的计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是小数。<br>&#x2F;&#x2F;当有小数参与运算时，结果才是小数，否则就是整数。</p><h5 id="取余"><a href="#取余" class="headerlink" title="取余%"></a>取余%</h5><p>只有当第二个数字是负数时，求余的结果才是负数。换句话说，求余结果的正负和第一个数字没有关系，只由第二个数字决定。%两边的数字都是整数时，求余的结果也是整数；但是只要有一个数字是小数，求余的结果就是小数。</p><h5 id="次方（乘方）运算符"><a href="#次方（乘方）运算符" class="headerlink" title="** 次方（乘方）运算符"></a>** 次方（乘方）运算符</h5><p>Python ** 运算符用来求一个 x 的 y 次方，也即次方（乘方）运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;----次方运算----&#x27;)</span><br><span class="line">print(&#x27;3**4 =&#x27;, 3**4)</span><br><span class="line">print(&#x27;2**5 =&#x27;, 2**5)</span><br></pre></td></tr></table></figure><h5 id="is和is-not"><a href="#is和is-not" class="headerlink" title="is和is not"></a>is和is not</h5><img src="/post/7a8a89b3/28.png" class title="This is an image"><p>如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了<br>可以使用 dir()查询</p><h5 id="and-or-not"><a href="#and-or-not" class="headerlink" title="and,or,not"></a>and,or,not</h5><img src="/post/7a8a89b3/29.png" class title="This is an image"><h5 id="Python三目运算符"><a href="#Python三目运算符" class="headerlink" title="Python三目运算符"></a>Python三目运算符</h5><p>格式：<br>exp1 if condition else exp2</p><p>condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python基础知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter--Text文本框控件</title>
      <link href="/post/6b4ce71c.html"/>
      <url>/post/6b4ce71c.html</url>
      
        <content type="html"><![CDATA[<h4 id="Tkinter-Text文本框控件"><a href="#Tkinter-Text文本框控件" class="headerlink" title="Tkinter Text文本框控件"></a>Tkinter Text文本框控件</h4><p>Text 文本控件是 Tkinter 中经常使用的控件，与 Entry 控件相比，Text 控件用于显示和编辑多行文本，而 Entry 控件则适合处理单行文本。<br>Text 控件的有很多的适用场景，比如显示某个产品的详细信息，或者人物介绍等。</p><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>除了基本的共有属性之外，Text 控件还具备以下属性：</p><p>autoseparators<br>默认为 True，表示执行撤销操作时<strong>是否自动插入一个“分隔符”</strong>（其作用是用于分隔操作记录）</p><p>exportselection<br>默认值为 True，表示被选中的文本是否可以被复制到剪切板，若是 False 则表示不允许。</p><p>insertbackground<br>设置插入光标的颜色，默认为 BLACK</p><p>insertborderwidth<br>设置插入光标的边框宽度，默认值为 0</p><p>insertofftime<br>该选项控制光标的闪烁频频率（灭的状态）</p><p>insertontime<br>该选项控制光标的闪烁频频率（亮的状态）</p><p>selectbackground<br>指定被选中文本的背景颜色，默认由系统决定</p><p>selectborderwidth<br>指定被选中文本的背景颜色，默认值是0</p><p>selectforeground<br>指定被选中文本的字体颜色，默认值由系统指定</p><p>setgrid<br>默认值是 False，指定一个布尔类型的值，确定是否启用网格控制</p><p>spacing1<br>指定 Text 控件文本块中每一行与上方的空白间隔，注意忽略自动换行，且默认值为 0。</p><p>spacing2<br>指定 Text 控件文本块中自动换行的各行间的空白间隔，忽略换行符，默认值为0</p><p>spacing3<br>指定 Text 组件文本中每一行与下方的空白间隔，忽略自动换行，默认值是 0</p><p>tabs<br>定制 Tag 所描述的文本块中 Tab 按键的功能，默认被定义为 8 个字符宽度，比如 tabs&#x3D;(‘1c’, ‘2c’, ‘8c’) 表示前 3 个 Tab 宽度分别为 1厘米，2厘米，8厘米。</p><p>undo<br>该参数默认为 False，表示关闭 Text 控件的“撤销”功能，若为 True 则表示开启</p><p>wrap<br>该参数用来设置当一行文本的长度超过 width 选项设置的宽度时，是否自动换行，参数值 none（不自动换行）、char（按字符自动换行）、word（按单词自动换行）</p><p>xscrollcommand<br>该参数与 Scrollbar 相关联，表示沿水平方向上下滑动</p><p>yscrollcommand<br>该参数与 Scrollbar 相关联，表示沿垂直方向左右滑动</p><h5 id="基本方法-即可调用的函数"><a href="#基本方法-即可调用的函数" class="headerlink" title="基本方法(即可调用的函数)"></a>基本方法(即可调用的函数)</h5><p>Text 中的方法有几十个之多，这里不进行一一列举，主要对常用的方法进行介绍，如下表所示：</p><p>bbox(index)<br>返回指定索引的字符的边界框，返回值是一个 4 元组，格式为<br>(x,y,width,height)</p><p>edit_modified()<br>该方法用于查询和设置 modified 标志（该标标志用于追踪 Text 组件的内容是否发生变化）</p><p>edit_redo()<br>“恢复”上一次的“撤销”操作，如果设置 undo 选项为 False，则该方法无效。</p><p>edit_separator()<br>插入一个“分隔符”到存放操作记录的栈中，用于表示已经完成一次完整的操作，如果设置 undo 选项为 False，则该方法无效。</p><p>get(index1, index2)<br>返回特定位置的字符，或者一个范围内的文字。</p><p>image_cget(index, option)<br>返回 index 参数指定的嵌入 image 对象的 option 选项的值，如果给定的位置没有嵌入 image 对象，则抛出 TclError 异常</p><p>image_create()<br>在 index 参数指定的位置嵌入一个 image 对象，该 image 对象必须是 Tkinter 的 PhotoImage 或 BitmapImage 实例。</p><p>insert(index, text)<br>在 index 参数指定的位置插入字符串，第一个参数也可以设置为 INSERT，表示在光标处插入，END 表示在末尾处插入。</p><p>delete(startindex [, endindex])<br>删除特定位置的字符，或者一个范围内的文字。</p><p>see(index)<br>如果指定索引位置的文字是可见的，则返回 True，否则返回 False。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;400x420&#x27;)</span><br><span class="line"># 创建一个文本控件</span><br><span class="line"># width 一行可见的字符数；height 显示的行数</span><br><span class="line">text = Text(win, width=50, height=30, undo=True, autoseparators=False)</span><br><span class="line">text.pack()</span><br><span class="line"># INSERT 光标处插入；END 末尾处插入</span><br><span class="line">text.insert(INSERT, &#x27;xiaoyyangzst.vercel.app&#x27;)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><p>上述代码中 Text 控件通过 heigt 和 width 参数来控制文本域的大小（即纸张大小），当然您也可以将其设置为自适用模式，即不设置具体的文本域大小。</p><p>下面定义上述代码做一下稍微改动，为其增加“撤销”和“恢复”的功能，代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;400x300&#x27;)</span><br><span class="line">text = Text(win, width=50, height=20, undo=True, autoseparators=False)</span><br><span class="line">text.grid()</span><br><span class="line"># INSERT 光标处插入；END 末尾处插入</span><br><span class="line">text.insert(INSERT, &#x27;xiaoyyangzst.vercel.app&#x27;)</span><br><span class="line"># 定义撤销和恢复方法，调用edit_undo()和 edit_redo()方法</span><br><span class="line">def backout():</span><br><span class="line">    text.edit_undo()</span><br><span class="line">def regain():</span><br><span class="line">    text.edit_redo()</span><br><span class="line">Button(win,text = &#x27;撤销&#x27;,command = backout).grid(row=3, column=0, sticky=&quot;w&quot;, padx=10, pady=5)</span><br><span class="line">Button(win,text = &#x27;恢复&#x27;,command = regain).grid(row=3, column=0, sticky=&quot;e&quot;, padx=10, pady=5)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><p>注意：点击“撤销”按钮后输入的所有语句都会被删除，如果再点击“恢复”按钮，刚刚删除的内容又会恢复。</p><p>文本控件（Text）支持三种类型的特殊结构，即 Mark、Tag 以及 Index，每一种结构都有相应的方法，下面对这些结构做相关的介绍。</p><p><strong>Index文本索引</strong></p><p>Index 索引，用于指定字符在文本中的真实位置，这与我们经常使用 Python 索引是一样的，不过在 Text 文本控件中，两者之间的使用形式存在一些差异。Tkinter 提供以下文本索引类型，如下表所示：</p><p><strong>索引类型说明</strong><br>INSERT<br>对应插入光标的位置</p><p>CURRENT<br>对应与鼠标坐标最接近的位置</p><p>END<br>对应 Text 控件的文本域中最后一个字符的下一个位置</p><p>“line.column”<br>表示某一行某一列的一个位置，比如 1.2 表示第一行第二列的一个位置</p><p>“line.end”<br>表示某一行到末尾的最后一个位置</p><p>SEL一种针对于 Tag 的特殊索引用法，(SEL_FIRST,SEL_LAST) 表示当前被选中的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">root = Tk()</span><br><span class="line">root.geometry(&#x27;400x200&#x27;)</span><br><span class="line">text =Text(root, width=35, heigh=15)</span><br><span class="line">text.pack()</span><br><span class="line"># 在文本域中插入文字</span><br><span class="line">text.insert(INSERT, &#x27;漂亮鬼&#x27;)</span><br><span class="line"># 继续向后插入文字</span><br><span class="line">text.insert(&quot;insert&quot;, &quot;，I love Python&quot;)</span><br><span class="line"># 获取字符，使用get() 方法</span><br><span class="line">print(text.get(&quot;1.3&quot;, &quot;1.end&quot;))</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><strong>Tag文本标签</strong></p><p>Tag（标签）用来给一定范围内的文字起一个标签名，通过该标签名就能操控某一范围内的文字，比如修改文本的字体、尺寸和颜色。除此之外，该标签还可以和事件函数绑定在一起使用。<br><strong>这里需要注意，Tags 的名字是由字符串组成的，但不能是空白字符串。</strong></p><p>Tag 提供了一些常用的方法，通过这些方法可以操作 Tag（标签），常用方法如下：</p><p>tag_add(tagName,index1,index2)<br>为指定索引范围内的内容添加一个标签名字，如果 index2 不存在，则单独为 Index1 指定的内容添加</p><p>Tagtag_bind(tagName, sequence, func, add&#x3D;None)<br>为 Tag 绑定事件，解除绑定使用 tag_unbind() 方法</p><p>tag_cget（tagName,option）<br>返回 tagName 指定的 option 选项的值</p><p>tag_configure(tagName, cnf&#x3D;None, **kw)</p><p>设置 tagName 的选项</p><p>tag_delete(tagNames)<br>删除单个或者多个 tagNames 指定的标签</p><p>tag_lower(tagName, belowThis&#x3D;None)<br>降低 Tag 的优先级，如果 belowThis 参数不为空，则表示 tagName 需要比 belowThis 指定的 Tag 优先级更低</p><p>tag_names(index&#x3D;None)<br>如果不带参数，表示返回 Text 组件中所有 Tags 的名字，若存在 index 参数则返回该位置上所有 Tags 的名字</p><p>tag_nextrange(tagName, index1, index2&#x3D;None) 在 index1 到 index2 的范围内第一个 tagName 的位置，若不存在则返回空字符串。</p><p>tag_raise(tagName, aboveThis&#x3D;None)<br>提高 Tag 的优先级，如果 aboveThis 参数不为空，则表示 tagName 需要比 aboveThis 指定的 Tag 优先级更高</p><p>tag_ranges(tagName)<br>返回所有 tagName 指定的文本，并将它们的范围以列表的形式返回</p><p>tag_remove(tagName, index1, index2&#x3D;None)<br>删除 index1 到 index2 之间所有的 tagName，如果忽略 index2 参数，那么只删除 index1 指定字符的 tagName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">from tkinter import *</span><br><span class="line">win = Tk()</span><br><span class="line">win.title(string = &quot;漂亮鬼&quot;)</span><br><span class="line">text = Text (win)</span><br><span class="line"># 在Text控件内插入- -段文字 ，INSERT表示在光标处插入，END表示在末尾处插入</span><br><span class="line">text.insert (INSERT,  text.insert(INSERT, &#x27;xiaoyyangzst.vercel.app\n\n&quot;)</span><br><span class="line"># 跳下一行</span><br><span class="line">text.insert (INSERT, &quot;\n\n&quot;)</span><br><span class="line"># 在Text控件内插入- -个按钮</span><br><span class="line">button = Button(text, text=&quot;关闭&quot;,command=win.quit)</span><br><span class="line">text. window_create (END, window=button)</span><br><span class="line"># 填充水平和垂直方向,这里设置 expand为 True 否则不能垂直方向延展</span><br><span class="line">text .pack (fill=BOTH,expand=True)</span><br><span class="line"># 在第一行文字的第0个字符到第6个字符处插入标签，标签名称为&quot;name&quot;</span><br><span class="line">text.tag_add(&quot;name&quot;, &quot;1.0&quot;, &quot;1.6&quot;)</span><br><span class="line"># 将插入的按钮设置其标签名为&quot;button&quot;</span><br><span class="line">text.tag_add (&quot;button&quot;, button)</span><br><span class="line">#使用 tag_config() 来改变标签&quot;name&quot;的前景与背景颜色,并加下画线，通过标签控制字符的样式</span><br><span class="line">text.tag_config(&quot;name&quot;, font=(&#x27;微软雅黑&#x27;,18,&#x27;bold&#x27;),background=&quot;yellow&quot;, foreground= &quot;blue&quot;,underline=1)</span><br><span class="line">#设置标签&quot;button&quot;的居中排列</span><br><span class="line">text. tag_config(&quot;button&quot;, justify=&quot;center&quot;)</span><br><span class="line">win .mainloop()</span><br></pre></td></tr></table></figure><p><strong>Mark文本标记</strong></p><p>Mark（标记）通常被用来当作书签，它可以帮助用户快速找到内容的指定位置，并且跟随相应的字符一起移动。<br>Mark 有两种类型的标记，分别是“INSERT”和“CURRENT”，其含义如下：<br>INSERT：指定当前插入光标的位置，Tkinter 会在该位置绘制一个闪烁的光标；<br>CURRENT：用于指定当前光标所处坐标最邻近的位置。它们是 Tkinter 中预定义的标记，因此不能被删除。除此上述标记外，我们还可以通过 user-define marks（用户自定义标记） 的方式来自定义 Mark。Tkinter 也提供了一些有关 Mark 的常用的方法，<br>如下所示：</p><p>mark_gravity(markName, direction&#x3D;None)<br>设置 Mark 的移动方向，默认是 “right”，也可以设置为 “left” ，表示即如果在 Mark 处插入文本的话，Mark 的标记移动方向，也就是文本的插入方向。</p><p>mark_names()<br>返回 Text 组件中所有 Marks 的名字</p><p>mark_next(index)<br>返回在 index 指定的位置后边的一个 Mark 的名字</p><p>mark_previous(index)<br>返回在 index 指定的位置前边的一个 Mark 的名字</p><p>mark_set(markName, index)<br>移动 Mark 到 index 参数指定的位置，如果 markName 参数指定的 Mark 不存在，则创建一个新的 </p><p>Markmark_unset(MarkName)<br>删除指定的 Mark</p><p>注意：如果在 Mark 标记的位置之前插入或删除文本，那么 Mark 跟着一起移动。如果要删除 Mark 需要使用 mark_unset() 方法，但是只会删除 Mark 周围的文本，并不会删除 Mark 标记本身。下面看一组简单的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&#x27;400x200&#x27;)</span><br><span class="line">text = tk.Text(root, width=35, heigh=15)</span><br><span class="line">text.pack()</span><br><span class="line"></span><br><span class="line">text.insert(&quot;insert&quot;, &quot;nihao&quot;)</span><br><span class="line"># 设置标记，这里的 1.end 表示 第一行最后一个字符，当然也可以使用数字来表示比如 1.5 表示第一行第五个字符</span><br><span class="line">text.mark_set(&quot;name&quot;, &quot;1.end&quot;)</span><br><span class="line">text.insert(&quot;name&quot;, &quot;,网址：www.xiaoyangzst.vercel.app&quot;)</span><br><span class="line"># 跟着自动移动，往后插入，而不是停留在原位置</span><br><span class="line">text.insert(&quot;name&quot;, &quot;,欢迎光临&quot;)</span><br><span class="line"># 若使用 mark_unset() 可以删除指定的标记</span><br><span class="line"># text.mark_unset(&quot;name&quot;)</span><br><span class="line"># 但使用delete来清楚所有的内容， mark 标记依旧会存在</span><br><span class="line"># text.delete(&quot;1.0&quot;,&quot;end&quot;)</span><br><span class="line"># 依然可以使用 name标记来插入</span><br><span class="line"># text.insert(&quot;name&quot;, &quot;Python答疑&quot;)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pillow为图片添加水印</title>
      <link href="/post/67fd3ea0.html"/>
      <url>/post/67fd3ea0.html</url>
      
        <content type="html"><![CDATA[<h3 id="Pillow为图片添加水印"><a href="#Pillow为图片添加水印" class="headerlink" title="Pillow为图片添加水印"></a>Pillow为图片添加水印</h3><p>Pillow 库提供了添加水印的方法，操作简单，易学、易用。<br>水印是附着在原图片上一段文字信息，因此添加水印的过程中会涉及两个问题：</p><p>第一、如何使文字信息附着在图片上；</p><p>第二、如何绘制文字信息。只要解决了这两个问题就可以成功添加水印。</p><p>Pillow 提供的ImageDraw和ImageFont模块成功解决了上述问题。</p><h4 id="ImageDraw"><a href="#ImageDraw" class="headerlink" title="ImageDraw"></a>ImageDraw</h4><p>PIL.ImageDraw 模块提供了一系列的绘图方法，通过该模块可以创建一个新的图形，或者在现有的图像上再绘制一个图形，从而起到对原图注释和修饰的作用。</p><p>draw &#x3D; ImageDraw.Draw(im)</p><p><strong>上述方法会返回一个 ImageDraw 对象</strong><br>参数 im 表示 Image 对象。<strong>这里我们可以把 Image 对象理解成画布</strong>，通过调用 ImageDraw 对象的一些方法，实现了在画布上绘制出新的图形目的。ImageDraw 对象的常用方法如下表所示：</p><img src="/post/67fd3ea0/67.png" class title="This is an image"><p>表格中第一个方法 text() 需要与 ImageFont 模块一起使用</p><p>绘制矩形图的语法格式如下：</p><p>draw.rectangle(xy, fill&#x3D;None, outline&#x3D;None)</p><p>参数说明如下：<br>xy：<strong>元组参数值</strong>，以图像的左上角为坐标原点，表示矩形图的位置、图形大小的坐标序列，形如 ((x1,y1,x2,y2))；<br>fill：矩形图的背景填充色；</p><p>outline：矩形图的边框线条颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\src=http __pic4.zhimg.com_v2-9428748e22b6e7a563de20aa75a257e3_r.jpg&amp;refer=http __pic4.zhimg.webp&quot;)</span><br><span class="line">draw = ImageDraw.Draw(img)</span><br><span class="line">draw.rectangle((0,0,100,100),fill= &quot;blue&quot;,outline=(0,0,0))</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h4 id="ImageFont"><a href="#ImageFont" class="headerlink" title="ImageFont"></a>ImageFont</h4><p>PIL.ImagreFont 模块通过加载不同格式的字体文件，从而在图像上绘制出不同类型的文字，<br>如 TrueType 和 OpenType 类型的字体。</p><p>创建字体对象的语法格式如下：</p><p>font &#x3D; ImageFont.truetype(font&#x3D;’字体文件路径’, size&#x3D;字体大小)</p><p>如果想要在图片上添加文本，还需要使用 ImageDraw.text() 方法，语法格式如下：<br>draw.text((x,y), “text”, font, fill)</p><p>参数说明如下：<br>(x,y)：图像左上角为坐标原点，(x,y) 表示添加文本的起始坐标位置；<br>text：字符串格式，要添加的文本内容；<br>font：ImageFont 对象；<br>fill：文本填充颜色。下面看一组使用示例，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw,ImageFont</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\src=http __pic4.zhimg.com_v2-9428748e22b6e7a563de20aa75a257e3_r.jpg&amp;refer=http __pic4.zhimg.webp&quot;)</span><br><span class="line">draw = ImageDraw.Draw(img)</span><br><span class="line">font = ImageFont.truetype(&quot;C:/Windows/Fonts/FREESCPT.TTF&quot;,size=70)</span><br><span class="line">draw.text(xy=(80,50),text=&#x27;hello&#x27;,fill=&quot;#AAAAFF&quot;,font=font)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><p>一般可以把这些都写在一个函数里面留一个接口，就好了</p>]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pillow图像降噪处理和颜色处理</title>
      <link href="/post/4c1116f9.html"/>
      <url>/post/4c1116f9.html</url>
      
        <content type="html"><![CDATA[<h4 id="Pillow图像降噪处理"><a href="#Pillow图像降噪处理" class="headerlink" title="Pillow图像降噪处理"></a>Pillow图像降噪处理</h4><p>由于成像设备、传输媒介等因素的影响，图像总会或多或少的存在一些不必要的干扰信息，我们将这些干扰信息统称为“噪声”</p><p>如数字图像中常见的“椒盐噪声”，指的是图像会随机出现的一些白、黑色的像素点。图像噪声既影响了图像的质量，又妨碍人们的视觉观赏。因此，噪声处理是图像处理过程中必不可少的环节之一，我们把处理图像噪声的过程称为“图像降噪”。</p><p>随着数字图像技术的不断发展，图像降噪方法也日趋成熟，通过某些算法来构造滤波器是图像降噪的主要方式。滤波器能够有效抑制噪声的产生，并且不影响被处理图像的形状、大小以及原有的拓扑结构。</p><p>Pillow 通过 ImageFilter 类达到图像降噪的目的，该类中集成了不同种类的滤波器，通过调用它们从而实现图像的平滑、锐化、边界增强等图像降噪操作。</p><p><strong>使用 ImageFilter 类也会返回一个新对象</strong></p><p>常见的降噪滤波器如下</p><img src="/post/4c1116f9/66.png" class title="This is an image"><p>模糊处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img1 = img.filter(ImageFilter.BLUR)</span><br><span class="line">img1.show()</span><br></pre></td></tr></table></figure><p>轮廓图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img1 = img.filter(ImageFilter.CONTOUR)</span><br><span class="line">img1.show()</span><br></pre></td></tr></table></figure><p>边缘检测 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img1 = img.filter(ImageFilter.FIND_EDGES)</span><br><span class="line">img1.show()</span><br></pre></td></tr></table></figure><p>浮雕图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img1 = img.filter(ImageFilter.EMBOSS)</span><br><span class="line">img1.show()</span><br></pre></td></tr></table></figure><p>可以一个一个试试里面的不同的滤波器，还是挺好玩的 ，这里面这个轮廓图加上界面的话可以弄一个画素描的程序出来，但是一般都是用opencv里面的玩</p><h4 id="Pillow图像颜色处理"><a href="#Pillow图像颜色处理" class="headerlink" title="Pillow图像颜色处理"></a>Pillow图像颜色处理</h4><p>Pillow 提供了颜色处理模块 ImageColor，该模块支持不同格式的颜色，比如 RGB 格式的颜色三元组、十六进制的颜色名称（#ff0000）以及颜色英文单词（”red”）。同时，它还可以将 CSS（层叠样式表，用来修饰网页）风格的颜色转换为 RGB 格式。</p><p>注意，在 ImageColor 模块对颜色的大小写并不敏感，比如 “Red” 也可以写为 “ red”。</p><p><strong>颜色命名</strong></p><p>ImageColor 支持多种颜色模式的的命名（即使用固定的格式对颜值进行表示），比如我们熟知的<br>RGB 色彩模式，除此之外，还有 HSL （色调-饱和度-明度）、HSB （又称 HSV，色调-饱和度-亮度）色彩模式。</p><p>HSL：<br>H：即 Hue 色调，取值范围 0 -360，其中 0 表示“red”，120 表示 “green”，240 表示“blue”；</p><p>S：即 Saturation 饱和度，代表色彩的纯度，取值 0~100%，其中 0 代表灰色（gry），100% 表示色光最饱和；</p><p>L：即 Lightness 明度，取值为 0~100%，其中 0 表示“black”黑色，50% 表示正常颜色，100% 则表示白色。</p><p>getrgb()方法顾名思义，该函数用来得到颜色的 RGB 值，语法格式如下：</p><p>PIL.ImageColor.getrgb(color)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image,ImageColor</span><br><span class="line">color1=ImageColor.getrgb(&quot;blue&quot;)</span><br><span class="line">print(color1)</span><br><span class="line">color2=ImageColor.getrgb(&#x27;#DCDCDC&#x27;)</span><br><span class="line">print(color2)</span><br><span class="line">color3=ImageColor.getrgb(&#x27;HSL(0,100%,50%)&#x27;)</span><br><span class="line">print(color3)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter库--Entry输入控件</title>
      <link href="/post/6210bf9c.html"/>
      <url>/post/6210bf9c.html</url>
      
        <content type="html"><![CDATA[<h4 id="Tkinter-Entry输入控件"><a href="#Tkinter-Entry输入控件" class="headerlink" title="Tkinter Entry输入控件"></a>Tkinter Entry输入控件</h4><p>Entry 控件是 Tkinter GUI 编程中的基础控件之一，它的作用就是允许用户输入内容，从而实现 GUI 程序与用户的交互，比如当用户登录软件时，输入用户名和密码，此时就需要使用 Entry 控件。</p><p>Entry 控件使用起来非常简单，下面对该控件做简单的介绍。<br>基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tk_entry = Entry( master, option, ... )</span><br></pre></td></tr></table></figure><h5 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h5><p>基本属性Entry 控件除了具备一些共有属性之外，还有一些自身的特殊属性，如下表所示：</p><p>exportselection<br>默认情况下，如果在输入框中选中文本会复制到粘贴板，如果要忽略这个功能，可以设置为 exportselection&#x3D;0</p><p>selectbackground<br>选中文字时的背景颜色</p><p>selectforeground<br>选中文字时的前景色</p><p>show<br>指定文本框内容以何种样式的字符显示，<br>比如密码可以将值设为 show&#x3D;”*”</p><p>textvariable<br>输入框内值，也称动态字符串，<strong>使用 StringVar() 对象来设置，而 text 为静态字符串对象</strong></p><p>text</p><p>输入框内值，也称静态字符串</p><p>xscrollcommand<br>设置输入框内容滚动条，当输入的内容大于输入框的宽度时使用户</p><p>动态数据类型上述表格中提及了 StringVar() 方法，和其同类的方法还有 BooleanVar()、DoubleVar()、IntVar() 方法，不难看出他们分别代表一种数据类型，即字符串、布尔值、浮点型、整型，这些方法并不属于 Python 内置方法，而是 Tkinter 特有的方法。</p><p>在界面编程的过程中，有时我们需要“动态跟踪”一些变量值的变化，从而保证值的变换及时的反映到显示界面上，但是 Python 内置的数据类型是无法这一目的的，因此使用了 Tcl 内置的对象，我们把这些方法创建的数据类型称为“动态类型”<br>比如 StringVar() 创建的字符串，称为“动态字符串”。常与textvariable一块使用<br>这里写一个时钟看看其的用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">import time #这里需要引入另一个模块，为了获取时间</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&#x27;450x150&#x27;)</span><br><span class="line"># 获取时间的函数</span><br><span class="line">def gettime():</span><br><span class="line">    # 获取当前时间</span><br><span class="line">    dstr.set(time.strftime(&quot;%H:%M:%S&quot;))</span><br><span class="line">    # 每隔 1s 调用一次 gettime()函数来获取时间</span><br><span class="line">    root.after(1000, gettime)</span><br><span class="line"># 生成动态字符串</span><br><span class="line">dstr = tk.StringVar()</span><br><span class="line"># 利用 textvariable 来实现文本变化</span><br><span class="line">lb = tk.Label(root,textvariable=dstr,font=(&quot;楷书&quot;,45))</span><br><span class="line">lb.pack()</span><br><span class="line"># 调用生成时间的函数</span><br><span class="line">gettime()</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>常用方法除了一些基本的属性之外，Entry 控件还提供了一些常用的方法，如下所示：</p><p>delete()<br>根据索引值删除输入框内的值</p><p>get()<br>获取输入框内的值</p><p>set()<br>设置输入框内的值</p><p>insert()<br>在指定的位置插入字符串</p><p>index()<br>返回指定的索引值</p><p>select_clear()<br>取消选中状态</p><p>select_adujst()<br>确保输入框中选中的范围包含 index 参数所指定的字符，选中指定索引和光标所在位置之前的字符</p><p>select_from (index)<br>设置一个新的选中范围，通过索引值 index 来设置</p><p>select_present()<br>返回输入框是否有处于选中状态的文本，如果有则返回 true，否则返回false</p><p>select_to()<br>选中指定索引与光标之间的所有值</p><p>select_range()<br>选中指定索引与光标之间的所有值，参数值为 start,end，要求 start 必须小于 end。</p><p>注意：<br>在 Entry 控件中，我们可以通过以下方式来指定字符的所在位置：</p><p>数字索引：表示从 0 开始的索引数字；</p><p>“ANCHOE”：在存在字符的情况下，它对应第一个被选中的字符；</p><p>“END”：对应已存在文本中的最后一个位置；</p><p>“insert(index,’字符’)：将字符插入到 index 指定的索引位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">win = tk.Tk()</span><br><span class="line">win.geometry(&#x27;500x500&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line">entry1 = tk.Entry(win,width=300)</span><br><span class="line">entry1.pack(padx=20, pady=20)</span><br><span class="line"># 插入默认文本</span><br><span class="line">entry1.insert(0,&#x27;博主的个人博客：xiaoyangzst.velcer.app&#x27;)</span><br><span class="line"># 得到输入框字符串</span><br><span class="line">print(entry1.get())</span><br><span class="line"># entry1.delete(0, &quot;end&quot;)</span><br><span class="line"># 删除所有字符</span><br><span class="line"># entry1.delete(0, tk.END)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><h5 id="Entry控件验证功能"><a href="#Entry控件验证功能" class="headerlink" title="Entry控件验证功能"></a>Entry控件验证功能</h5><p>Entry 控件也提供了对输入内容的验证功能，比如要求输入英文字母，你却输入了数字，这就属于非法输入，Entry 控件通过以下参数实现对内容的校验：</p><p>validate<br>指定验证方式，字符串参数，参数值有 focus、focusin、focusout、key、all、none。 </p><p>validatecommand<br>指定用户自定义的验证函数，该函数只能返回 True 或者 Fasle</p><p>invalidcommand<br>当 validatecommand 指定的验证函数返回 False 时，可以使用该参数值再指定一个验证函数。</p><p>下面对 <strong>validate</strong> 的参数值做简单的介绍：</p><p>focus<br>当 Entry 组件获得或失去焦点的时候验证</p><p>focusin<br>当 Entry 组件获得焦点的时候验证</p><p>focusout<br>当 Entry 组件失去焦点的时候验证</p><p>key<br>当输入框被编辑的时候验证</p><p>all<br>当出现上边任何一种情况的时候验证</p><p>none<br>默认不启用验证功能，需要注意的是这里是字符串的 ‘none’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import messagebox</span><br><span class="line">win = tk.Tk()</span><br><span class="line">win.geometry(&#x27;250x200+250+200&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line">labe1 = tk.Label(win,text=&quot;账号：&quot;)</span><br><span class="line">labe1.grid(row=0)</span><br><span class="line">labe2 = tk.Label(win,text=&quot;密码：&quot;)</span><br><span class="line">labe2.grid(row=1)</span><br><span class="line">Dy_String = tk.StringVar()</span><br><span class="line">def check():</span><br><span class="line">    if entry1.get()== &quot;漂亮鬼&quot;:</span><br><span class="line">        messagebox.showinfo(&quot;恭喜&quot;,&quot;输入正确&quot;)</span><br><span class="line">    else:</span><br><span class="line">        messagebox.showinfo(&quot;恭喜&quot;,&quot;输入错误&quot;)</span><br><span class="line">    </span><br><span class="line"># 使用验证参数 validata,参数值为 focusout 当失去焦点的时候，验证输入框内容是否正确</span><br><span class="line">entry1 = tk.Entry(win,textvariable =Dy_String,validate =&quot;focusout&quot;,validatecommand=check)</span><br><span class="line">entry2 = tk.Entry(win,textvariable =Dy_String,validate =&quot;focusout&quot;,validatecommand=check)</span><br><span class="line"># 对控件进行布局管理，放在文本标签的后面</span><br><span class="line">entry1.grid(row=0, column=1)</span><br><span class="line">entry2.grid(row=1, column=1)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><p>不仅如此，Tkinter 还为验证函数提供可一些<strong>额外</strong>的选项，不过想要使用这些额外选项，需要提前使用 <strong>register()</strong> 方法对验证函数进行注册，</p><p>常用的选项：<br>%d<br>有 3 个参数值，其中 0 表示删除操作；1 表示插入操作；2 表示获得、失去焦点或 textvariable 变量的值被修改导</p><p>%i<br>当用户进行插入或者删除操作的时，该选项不爱哦是插入或者删除的索引位置，若是其他的情况则选项值为 -1</p><p>%P<br>该选项值指定了输入框内的文本内容，只有当输入框的值允许改变的时候，该选项值才会生效。</p><p>%s<br>改值为调用验证函数钱输入框内的文本内容</p><p>%S<br>该选项值，只有插入或者删除操作触发验证函数的时候才会生效，它表示了被删除或者插入的内容</p><p>%v<br>表示当前 Entry 控件的 validate 参数的值</p><p>%V<br>表示触发验证函数的原因，值为 focus、focusin 、focusout、all、key.. 中的一个。</p><p>%W<br>该选项表示控件类型，即控件的名字（Entry）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line"># 创建窗体</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;300x300&#x27;)</span><br><span class="line"># 创建一个容器来包括其他控件</span><br><span class="line">frame = Frame (win)</span><br><span class="line"># 创建一个计算器</span><br><span class="line">def calc() :</span><br><span class="line">    result = &quot;= &quot;+ str (eval(expression.get()))</span><br><span class="line">    label.config(text =result)</span><br><span class="line">label = Label (frame)</span><br><span class="line">entry = Entry (frame)</span><br><span class="line">expression = StringVar ()</span><br><span class="line">entry [&quot;textvariable&quot;] = expression</span><br><span class="line">button1 = Button (frame, text=&quot;等 于&quot;,command=calc)</span><br><span class="line">entry.focus ()</span><br><span class="line">frame.pack ()</span><br><span class="line">entry .pack()</span><br><span class="line">label .pack (side=&quot;left&quot;)</span><br><span class="line">button1.pack (side=&quot;right&quot;)</span><br><span class="line">frame .mainloop()</span><br></pre></td></tr></table></figure><p>这种博主也用的少，可以了解一下就好了</p><h5 id="Spinbox-高级输入框"><a href="#Spinbox-高级输入框" class="headerlink" title="Spinbox 高级输入框"></a>Spinbox 高级输入框</h5><p>Spinbox 高级输入框Spinbox 是 Entry 控件的升级版，该控件不仅允许用户直接输入内容，还支持用户使用微调选择器（即上下按钮调节器）来输入内容。在一般情况下，Spinbox 控件用于在固定的范围内选取一个值的时候使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&#x27;300x200+300+300&#x27;)</span><br><span class="line"># 如果是数字使用 from_和to参数，范围 0-20,并且与2步长递增或递减</span><br><span class="line">w = tk.Spinbox(root,from_=0,to=20, increment=2,width = 15,)</span><br><span class="line">w.pack()</span><br><span class="line"># 显示窗口</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p><strong>若不是数字，而是字符串形式的选项值，则采用values参数以元组的形式进行传参</strong>，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&#x27;300x200+300+300&#x27;)</span><br><span class="line"># 使用 values 参数以元组的形式进行传参</span><br><span class="line">strings = tk.Spinbox(root,values=(&#x27;Python&#x27;,&#x27;java&#x27;,&#x27;C语言&#x27;,&#x27;PHP&#x27;))</span><br><span class="line">strings.pack()</span><br><span class="line"># 开启事件循环</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter库--Button控件</title>
      <link href="/post/11221ecd.html"/>
      <url>/post/11221ecd.html</url>
      
        <content type="html"><![CDATA[<h4 id="Tkinter-Button按钮控件"><a href="#Tkinter-Button按钮控件" class="headerlink" title="Tkinter Button按钮控件"></a>Tkinter Button按钮控件</h4><p>Button 控件是 Tkinter 中常用的窗口部件之一，同时也是实现程序与用户交互的主要控件。通过用户点击按钮的行为来执行回调函数，是 Button 控件的主要功用。</p><p>首先自定义一个函数或者方法，然后将函数与按钮关联起来，最后，当用户按下这个按钮时，Tkinter 就会自动调用相关函数。</p><p>按钮控件使用起来非常简单，它同样可以包含文本、图像、位图，并通过command参数回调函数。当然按钮也并非一定要执行回调函数（callback function），它也只可以当一个“摆设”，不过这样的按钮是没有“灵魂的”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line"># from setuptools import Command</span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&quot;300x300&quot;)</span><br><span class="line">btn = tk.Button(root, text =&quot;xiaoyang&quot;, command=quit)</span><br><span class="line">btn.pack()</span><br><span class="line">root.mainloop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Button-控件的常营属性如下所示："><a href="#Button-控件的常营属性如下所示：" class="headerlink" title="Button 控件的常营属性如下所示："></a>Button 控件的常营属性如下所示：</h5><p>anchor<br>控制文本所在的位置，默认为中心位置（CENTER）</p><p>activebackground<br>当鼠标放在按钮上时候，按钮的背景颜色</p><p>activeforeground当鼠标放在按钮上时候，按钮的前景色</p><p>bd<br>按钮边框的大小，默认为 2 个像素</p><p>bg<br>按钮的背景色</p><p>command<br>用来执行按钮关联的回调函数。当按钮被点击时，执行该函数</p><p>fg<br>按钮的前景色</p><p>font按钮文本的字体样样式</p><p>height<br>按钮的高度</p><p>highlightcolor<br>按钮控件高亮处要显示的颜色</p><p>image<br>按钮上要显示的图片</p><p>justify<br>按钮显示多行文本时，用来指定文本的对齐方式，参数值有 LEFT&#x2F;RIGHT&#x2F;CENTER</p><p>padx&#x2F;pady<br>padx 指定 x 轴（水平方向）的间距大小，pady 则表示 y轴（垂直方向）的间距大小</p><p>ipadx&#x2F;ipady<br>ipadx 指标签文字与标签容器之间的横向距离；</p><p>ipady 则表示标签文字与标签容器之间的纵向距离</p><p>state设置按钮的可用状态，可选参数有NORMAL&#x2F;ACTIVE&#x2F;DISABLED，默认为 NORMAL</p><p>text<br>按钮控件要显示的文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import messagebox</span><br><span class="line"># from setuptools import Command </span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&quot;300x300&quot;)</span><br><span class="line">def tishi():</span><br><span class="line">    # 使用消息对话框控件，showinfo()表示温馨提示</span><br><span class="line">    messagebox.showinfo(title=&#x27;温馨提示&#x27;, message=&#x27;hello&#x27;)</span><br><span class="line">btn = tk.Button(root, text =&quot;xiaoyang&quot;, command=tishi)</span><br><span class="line">btn.pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>下面为 Button 控件添加一张背景图片，实现代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import Image, messagebox</span><br><span class="line"># from setuptools import Command </span><br><span class="line">root = tk.Tk()</span><br><span class="line">root.geometry(&quot;300x300&quot;)</span><br><span class="line">photo = tk.PhotoImage(file=&quot;D:\\File\\All\\web\\python\\blog\\99.png&quot;)</span><br><span class="line">def tishi():</span><br><span class="line">    # 使用消息对话框控件，showinfo()表示温馨提示</span><br><span class="line">    messagebox.showinfo(title=&#x27;温馨提示&#x27;, message=&#x27;hello&#x27;)</span><br><span class="line">btn = tk.Button(root, text =&quot;xiaoyang&quot;, command=tishi,image= photo,width=20,height=20)</span><br><span class="line">btn.pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>按钮的布局按钮在主窗口中的布局，通常使用 grid() 函数来完成，该函数以网格状的形式（即行和列）来管理窗口的布局。grid() 布局管理器提供了一个sticky参数，通过该参数可以设置按钮的方位，该参数默认将控件设置居中，其他参数值有 N&#x2F;S&#x2F;W&#x2F;E（上&#x2F;下&#x2F;左&#x2F;右），而且可以组合在一起使用，比如 NW&#x2F;WE&#x2F;SE&#x2F;SW&#x2F;NE 等，这与anchor参数控制文本的显示位置，有着异曲同工之妙。如下图所示：</p><p>注意：<br><strong>值得大家注意的是 grid() 布局方法不能与 pack() 混合在一起使用</strong></p><p>使用了grid布局就不用再使用pack了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">from tkinter import messagebox</span><br><span class="line">win = tk.Tk()</span><br><span class="line">win.geometry(&#x27;400x200+100+100&#x27;)</span><br><span class="line">win.resizable(0,0)</span><br><span class="line"># 将俩个标签分别布置在第一行、第二行</span><br><span class="line">tk.Label(win, text=&quot;账号：&quot;).grid(row=0)</span><br><span class="line">tk.Label(win, text=&quot;密码：&quot;).grid(row=1)</span><br><span class="line"># 创建输入框控件</span><br><span class="line">e1 = tk.Entry(win)</span><br><span class="line"># 以 * 的形式显示密码</span><br><span class="line">e2 = tk.Entry(win,show=&#x27;*&#x27;)</span><br><span class="line">e1.grid(row=0, column=1, padx=10, pady=5)</span><br><span class="line">e2.grid(row=1, column=1, padx=10, pady=5)</span><br><span class="line"># 编写一个简单的回调函数</span><br><span class="line">def login():</span><br><span class="line">    messagebox.showinfo(&#x27;hello&#x27;)</span><br><span class="line"># 使用 grid()的函数来布局，并控制按钮的显示位置</span><br><span class="line">tk.Button(win, text=&quot;登录&quot;, width=10, command=login).grid(row=3, column=0, sticky=&quot;w&quot;, padx=10, pady=5)</span><br><span class="line">tk.Button(win, text=&quot;退出&quot;, width=10, command=win.quit).grid(row=3, column=1, sticky=&quot;e&quot;, padx=10, pady=5)</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pillow图像几何变换</title>
      <link href="/post/2d89a648.html"/>
      <url>/post/2d89a648.html</url>
      
        <content type="html"><![CDATA[<h4 id="Pillow图像几何变换"><a href="#Pillow图像几何变换" class="headerlink" title="Pillow图像几何变换"></a>Pillow图像几何变换</h4><p>图像的几何变换主要包括图像翻转、图像旋转和图像变换操作，Image 类提供了处理这些操作的函数 transpose()、rotate() 和 transform()，下面分别对它们进行讲解。</p><h5 id="transpose图像翻转"><a href="#transpose图像翻转" class="headerlink" title="transpose图像翻转"></a>transpose图像翻转</h5><p>transpose()翻转操作该函数可以实现图像的垂直、水平翻转</p><p><strong>返回一个新的Image对象</strong></p><p>语法格式如下：</p><p>Image.transpose(method)</p><p>method 参数决定了图片要如何翻转，参数值如下：</p><p>Image.FLIP_LEFT_RIGHT：左右水平翻转；</p><p>Image.FLIP_TOP_BOTTOM：上下垂直翻转；</p><p>Image.ROTATE_90：图像旋转 90 度；</p><p>Image.ROTATE_180：图像旋转 180 度；</p><p>Image.ROTATE_270：图像旋转 270 度；</p><p>Image.TRANSPOSE：图像转置；</p><p>Image.TRANSVERSE：图像横向翻转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img1 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;) </span><br><span class="line">img2 = img1.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">img2.show()</span><br></pre></td></tr></table></figure><h6 id="rotate-任意角度旋转"><a href="#rotate-任意角度旋转" class="headerlink" title="rotate()任意角度旋转"></a>rotate()任意角度旋转</h6><p>当我们想把图像旋转任意角度时，可以使用 rotate() 函数，<br><strong>产生一张规定大小的新图像</strong><br>语法格式如下：<br>Image.rotate(angle, resample&#x3D;PIL.Image.NEAREST, expand&#x3D;None, center&#x3D;None, translate&#x3D;None, fillcolor&#x3D;None)</p><p>参数说明如下：</p><p>angle：表示任意旋转的角度；</p><p>resample：重采样滤波器，默认为 PIL.Image.NEAREST 最近邻插值方法；</p><p>expand：可选参数，表示是否对图像进行扩展，如果参数值为 True 则扩大输出图像，如果为 False 或者省略，则表示按原图像大小输出；</p><p>center：可选参数，指定旋转中心，参数值是长度为 2 的元组，默认以图像中心进行旋转；</p><p>translate：参数值为二元组，表示对旋转后的图像进行平移，以左上角为原点；</p><p>fillcolor：可选参数，填充颜色，图像旋转后，对图像之外的区域进行填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img1 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;) </span><br><span class="line">img2 = img1.rotate(50,translate=(100,100))</span><br><span class="line">img2.show()</span><br></pre></td></tr></table></figure><h6 id="transform-图像变换"><a href="#transform-图像变换" class="headerlink" title="transform()图像变换"></a>transform()图像变换</h6><p>transform()图像变换该函数能够对图像进行变换操作，通过指定的变换方式，<strong>产生一张规定大小的新图像</strong><br>语法格式如下：</p><p>Image.transform(size, method, data&#x3D;None, resample&#x3D;0) </p><p>参数说明：</p><p>size：指定新图片的大小 (元组)；</p><p>method：指定图片的变化方式，比如 Image.EXTENT 表示矩形变换；</p><p>data：该参数用来给变换方式提供所需数据；</p><p>resample：图像重采样滤波器，默认参数值为 PIL.Image.NEAREST。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img1 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;) </span><br><span class="line">img2 = img1.transform((1000,1000),Image.EXTENT,data=[0,0,30 + img1.width//4,img1.height//3])</span><br><span class="line">img2.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pillow图像分离与合并</title>
      <link href="/post/f6193f79.html"/>
      <url>/post/f6193f79.html</url>
      
        <content type="html"><![CDATA[<h4 id="Pillow图像分离与合并"><a href="#Pillow图像分离与合并" class="headerlink" title="Pillow图像分离与合并"></a>Pillow图像分离与合并</h4><p>图像（指数字图像）由许多像素点组成，像素是组成图像的基本单位，而每一个像素点又可以使用不同的颜色，最终呈现出了绚丽多彩的图像。它们的本质就是图片呈现颜色时需要遵循的规则，比如 RGB、RGBA、CYMK 等，</p><p><strong>而图像的分离与合并，指的就是图像颜色的分离和合并</strong>。</p><p>Image 类提供了用于分离图像和合并图像的方法 split() 和 merge() 方法，通常情况下，这两个方法会一起使用。</p><h5 id="split（）分离操作"><a href="#split（）分离操作" class="headerlink" title="split（）分离操作"></a>split（）分离操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">r,g,b = img.split()</span><br><span class="line">r.show()</span><br><span class="line">g.show()</span><br><span class="line">b.show()</span><br></pre></td></tr></table></figure><h5 id="merge-合并操作"><a href="#merge-合并操作" class="headerlink" title="merge()合并操作"></a>merge()合并操作</h5><p>Image 类提供的 merge() 方法可以实现图像的合并操作。</p><p><strong>注意，图像合并，可以是单个图像合并，也可以合并两个以上的图像</strong>。merge() 方法的语法格式如下：</p><p>Image.merge(mode, bands)</p><p>参数说明如下：mode：指定输出图片的模式(前面文章博主有介绍)</p><p>bands：参数类型为<strong>元组或者列表序列</strong>，其元素值是组成图像的颜色通道，比如 RGB 分别代表三种颜色通道，可以表示为 (r,g,b)。</p><p>注意，<strong>该函数会返回一个新的 Image 对象</strong>。</p><ol><li>单个图像的合并指的是将颜色通道进行重新组合，从而得到不一样的图片效果，代码如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">r,g,b = img.split()</span><br><span class="line">ing_merge= Image.merge(&#x27;RGB&#x27;, (g,b,r))</span><br><span class="line">ing_merge.save(&quot;D:\\File\\All\\web\\python\\blog\\4.jpg&quot;)</span><br><span class="line">ing_merge.show()</span><br></pre></td></tr></table></figure></li><li>两张图片的合并操作也并不复杂，但是要求<strong>两张图片的模式、图像大小必须要保持一致</strong>，否则不能合并。因此，对于那些模式、大小不同的图片要进行预处理。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img1 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img2 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\670099.jpg&quot;)</span><br><span class="line">img3 = img1.resize(img2.size)</span><br><span class="line">print(img3.size)</span><br><span class="line">r1,g1,b1 = img2.split()   </span><br><span class="line">r2,g2,b2 = img3.split()</span><br><span class="line">img4 = Image.merge(&#x27;RGB&#x27;,(r1,g2,b1))</span><br><span class="line">img4.show()</span><br></pre></td></tr></table></figure></li></ol><p>一般不会将多张图片混合因为看起来怪怪的</p><h5 id="扩展知识：blend-混合图片"><a href="#扩展知识：blend-混合图片" class="headerlink" title="扩展知识：blend() 混合图片"></a>扩展知识：blend() 混合图片</h5><p>Image 类也提供了 blend() 方法来混合 RGBA 模式的图片（PNG 格式），函数的语法格式如下：<br>Image.blend(image1,image2, alpha)<br>参数说明如下：<br>image1，image2：表示两个 Image 对象，<strong>俩张图片的大小应该一样大</strong>。</p><p>alpha：表示透明度，取值范围为 0 到 1，当取值为 0 时，输出图像相当于 image1 的拷贝，而取值为 1 时，则是 image2 的拷贝，只有当取值为 0.5 时，才为两个图像的中合。因此改值的大小决定了两个图像的混合程度。</p><p><strong>该函数会返回一个新的 Image 对象</strong>。</p><p>与 RGB 模式相比，RGBA 在 RGB 的基础上增加了透明度，通过 Alpha 取值来决定两个图像的混合程度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img1 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\670099.png&quot;)</span><br><span class="line">img2 = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\99.png&quot;)</span><br><span class="line">img4 = img2.resize(img1.size)</span><br><span class="line">img3 = Image.blend(img1,img4,0.5)</span><br><span class="line">img3.show()   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言杂项知识（一）</title>
      <link href="/post/f77ed13.html"/>
      <url>/post/f77ed13.html</url>
      
        <content type="html"><![CDATA[<h5 id="头文件的概念"><a href="#头文件的概念" class="headerlink" title="头文件的概念"></a>头文件的概念</h5><p>这一篇文章里面的知识比较杂也比较乱，但是看一下还是用一定的作用（相当于提醒一点易错点吧）</p><h5 id="引入头文件的原因"><a href="#引入头文件的原因" class="headerlink" title="引入头文件的原因"></a>引入头文件的原因</h5><p>#include &lt;stdio.h&gt;是什么意思呢？<br>C语言开发者们编写了很多常用函数，并分门别类的放在了不同的文件，这些文件就称为头文件（header file）。每个头文件中都包含了若干个功能类似的函数，调用某个函数时，要引入对应的头文件，否则编译器找不到函数。<br>实际上，头文件往往只包含函数的说明，也就是告诉我们函数怎么用，而函数本身保存在其他文件中，在链接时才会找到。</p><p>对于初学者，可以暂时理解为头文件中包含了若干函数。引入头文件使用#include命令，并将文件名放在&lt; &gt;中，#include 和 &lt; &gt; 之间可以有空格，也可以没有。</p><h5 id="数据的长度"><a href="#数据的长度" class="headerlink" title="数据的长度"></a>数据的长度</h5><p>这个还是比较重要</p><img src="/post/f77ed13/68.png" class title="This is an test image"><h5 id="强类型语言和弱类型语言"><a href="#强类型语言和弱类型语言" class="headerlink" title="强类型语言和弱类型语言"></a>强类型语言和弱类型语言</h5><p>除了C语言，Java、C++、C#等在定义变量时也必须指明数据类型，这样的编程语言称为强类型语言。而PHP、JavaScript等在定义变量时不必指明数据类型，编译系统会自动推演，这样的编程语言称为弱类型语言</p><h5 id="格式控制符"><a href="#格式控制符" class="headerlink" title="格式控制符"></a>格式控制符</h5><p>%d称为格式控制符，它指明了以何种形式输出数据。格式控制符均以%开头，后跟其他字符。%d 表示以十进制形式输出一个整数。</p><p>printf的格式控制的完整格式：%-0m.n格式字符</p><p>下面对组成格式说明的各项加以说明：<br>①%：表示格式说明的起始符号，不可缺少。<br>②-：有-表示左对齐输出，如省略表示右对齐输出。<br>③0：有0表示指定空位填0,如省略表示指定空位不填。<br>④m.n：m指域宽，即对应的输出项在输出设备上所占的字符数。N指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。<br>格式字符有d, s, c,f,lf等</p><p>不同整型的输出使用不同的格式控制符可以输出不同类型的整数，它们分别是：%hd用来输出 short int 类型；%d用来输出 int 类型；%ld用来输出 long int 类型。</p><h5 id="占用内存理解："><a href="#占用内存理解：" class="headerlink" title="占用内存理解："></a>占用内存理解：</h5><p>让整数占用更少的内存可以在 int 前边加 short，让整数占用更多的内存可以在 int 前边加 long<br>也可以将 int 省略，只写 short 和 long</p><p>只有 short 的长度是确定的，是两个字节，而 int 和 long 的长度无法确定，在不同的环境下有不同的表现</p><p>实际情况也确实如此，C语言并没有严格规定 short、int、long 的长度，只做了宽泛的限制：short 至少占用 2 个字节。int 建议为一个机器字长。32 位环境下机器字长为 4 字节，64 位环境下机器字长为 8 字节。short 的长度不能大于 int，long 的长度不能小于 int。</p><h5 id="sizeof-操作符"><a href="#sizeof-操作符" class="headerlink" title="sizeof 操作符"></a>sizeof 操作符</h5><p>sizeof 操作符获取某个数据类型的长度可以使用 sizeof 操作符，<br>sizeof 用来获取某个数据类型或变量所占用的字节数，如果后面跟的是变量名称，那么可以省略( )，如果跟的是数据类型，就必须带上( )。需要注意的是，sizeof 是C语言中的操作符，不是函数，所以可以不带( )<br>通常可以利用它计算字符串的长度</p><h5 id="二进制数、八进制数和十六进制数的表示"><a href="#二进制数、八进制数和十六进制数的表示" class="headerlink" title="二进制数、八进制数和十六进制数的表示"></a>二进制数、八进制数和十六进制数的表示</h5><ol><li><p>二进制二进制由 0 和 1 两个数字组成，使用时必须以0b或0B（不区分大小写）开头<br>eg.<br>int a &#x3D; 0b101;<br>int b &#x3D; -0b110010;</p></li><li><p>八进制八进制由 0~7 八个数字组成，使用时必须以0开头（注意是数字 0，不是字母 o）<br>int a &#x3D; 015;<br>int b &#x3D; -0101;</p></li><li><p>十六进制十六进制由数字 0<del>9、字母 A</del>F 或 a~f（不区分大小写）组成，使用时必须以0x或0X（不区分大小写）开头，</p></li></ol><p>int a &#x3D; 0X2A;<br>int b &#x3D; -0XA0; </p><p><strong>一般整数初始化的时候都是用十进制表示</strong></p><p><strong>输出的话比较重要，有时候可能比赛的题会出这种二进制数、八进制数和十六进制数的输出</strong></p><img src="/post/f77ed13/69.png" class title="This is an test image"><h5 id="正负号在内存中存储"><a href="#正负号在内存中存储" class="headerlink" title="正负号在内存中存储"></a>正负号在内存中存储</h5><p>符号也是数字的一部分，也要在内存中体现出来。符号只有正负两种情况，用1位（Bit）就足以表示；C语言规定，把内存的最高位作为符号位。<br>以 int 为例，它占用 32 位的内存，0~30 位表示数值，31 位表示正负号<br>在编程语言中，计数往往是从0开始，例如字符串 “abc123”，我们称第 0 个字符是 a，第 1 个字符是 b，第 5 个字符是 3</p><p>C语言规定，在符号位中，用 0 表示正数，用 1 表示负数。</p><h5 id="源码，反码，补码"><a href="#源码，反码，补码" class="headerlink" title="源码，反码，补码"></a>源码，反码，补码</h5><ol><li><p>原码将一个整数转换成二进制形式，就是其原码。例如<br>short a &#x3D; 6;，a 的原码就是0000 0000 0000 0110；<br>更改 a 的值a &#x3D; -18;，此时 a 的原码就是1000 0000 0001 0010。<br>通俗的理解，原码就是一个整数本来的二进制形式。</p></li><li><p>反码谈到反码，正数和负数要区别对待，因为它们的反码不一样。对于正数，它的反码就是其原码（原码和反码相同）；负数的反码是将原码中除符号位以外的所有位（数值位）取反，也就是 0 变成 1，1 变成 0。</p></li></ol><p>​例如short a &#x3D; 6; a 的原码和反码都是0000 0000 0000 0110；<br>​更改 a 的值a &#x3D; -18;此时 a 的反码是1111 1111 1110 1101。</p><ol start="3"><li>补码正数和负数的补码也不一样，也要区别对待。对于正数，它的补码就是其原码（原码、反码、补码都相同）；负数的补码是其反码加 1。</li></ol><p>例如short a &#x3D; 6;a 的原码、反码、补码都是0000 0000 0000 0110；<br>更改 a 的值a &#x3D; -18;，此时 a 的补码是1111 1111 1110 1110。可以认为，补码是在反码的基础上打了一个补丁，进行了一下修正，所以叫“补码”。原码、反码、补码的概念只对负数有实际意义，对于正数，它们都一样。</p><p>在计算机内存中，<strong>整数一律采用补码的形式来存储</strong>。这意味着，当读取整数时还要采用逆向的转换，也就是将补码转换为原码。将补码转换为原码也很简单：先减去 1，再将数值位取反即可。</p><h5 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h5><p>main 是程序的入口函数，一个C程序必须有 main 函数，而且只能有一个。<br>一个程序当中可以使用return 返回值，也可以不使用return<br>使用return 程序运行正确一般返回 0。</p><p>puts 输出完成后会自动换行，而 printf 不会，要自己添加换行符，这是 puts 和 printf 在输出字符串时的一个区别</p><p>这里主要想说的时这一点，刚开始博主也是不清楚还可以这么输出</p><p>%e 以指数形式输出 float 类型，输出结果中的 e 小写；%E 以指数形式输出 float 类型，输出结果中的 E 大写；%le 以指数形式输出 double 类型，输出结果中的 e 小写；%lE 以指数形式输出 double 类型，输出结果中的 E 大写。</p><p>对代码的说明：%f 和 %lf 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乱乱乱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter库---Label标签控件</title>
      <link href="/post/6b688c36.html"/>
      <url>/post/6b688c36.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter-Label标签控件"><a href="#Tkinter-Label标签控件" class="headerlink" title="Tkinter Label标签控件"></a>Tkinter Label标签控件</h5><p>Label（标签）控件，是 Tkinter 中最常使用的一种控件，主要用来显示窗口中的文本或者图像，并且不同的 Lable（标签）允许设置各自不同的背景图片。<br><strong>常用的属性</strong><br>anchor<br>控制文本（或图像）在 Label 中显示的位置（方位），通过方位的英文字符串缩写（n、ne、e、se、s、sw、w、nw、center）实现定位，默认为居中（center）</p><p>bg<br>用来设置背景色</p><p>bd<br>即 borderwidth 用来指定 Label 控件的边框宽度，单位为像素，默认为 2 个像素</p><p>bitmap<br>指定显示在 Label 控件上的位图，若指定了 image 参数，则该参数会被忽略</p><p>compound<br>控制 Lable 中文本和图像的混合模式，若选项设置为 CENTER，则文本显示在图像上，如果将选项设置为 BOTTOM、LEFT、RIGHT、TOP，则图像显示在文本旁边。</p><p>cursor<br>指定当鼠标在 Label 上掠过的时候，鼠标的的显示样式，参数值为 arrow、circle、cross、plus</p><p>disableforeground<br>指定当 Label 设置为不可用状态的时候前景色的颜色</p><p>font<br>指定 Lable 中文本的 (字体,大小,样式）元组参数格式，一个 Lable 只能设置一种字体</p><p>fg<br>设置 Label 的前景色height&#x2F;width设置 Lable 的高度&#x2F;宽度，如果 Lable 显示的是文本，那么单位是文本单元，如果 Label 显示的是图像，那么单位就是像素，如果不设置，Label 会自动根据内容来计算出标签的高度</p><p>highlightbackground<br>当 Label 没有获得焦点的时候高亮边框的颜色，系统的默认是标准背景色</p><p>highlightcolor<br>指定当 Lable 获得焦点的话时候高亮边框的颜色，系统默认为0，不带高亮边框</p><p>image<br>指定 Label 显示的图片，一般是 PhotoImage、BitmapImage 的对象</p><p>justify<br>表示多行文本的对齐方式，参数值为 left、right、center，注意文本的位置取决于 anchor 选项</p><p>padx&#x2F;pady<br>padx 指定 Label 水平方向上的间距（即内容和边框间），pady 指定 Lable 水平方向上的间距（内容和边框间的距离）</p><p>relief<br>指定边框样式，默认值是 “flat”，其他参数值有 “groove”、”raised”、”ridge”、”solid”或者”sunken”</p><p>state<br>该参数用来指定 Lable 的状态，默认值为”normal”（正常状态），其他可选参数值有”active”和”disabled”</p><p>takefocus<br>默认值为False，如果是 True，表示该标签接受输入焦点text用来指定 Lable 显示的文本，注意文本内可以包含换行符underline给指定的字符添加下划线，默认值为 -1 表示不添加，当设置为 1 时，表示给第二个文本字符添加下划线。</p><p>wraplength<br>将 Label 显示的文本分行，该参数指定了分行后每一行的长度，默认值为 0</p><ol><li>Label控件构成一个控件主要由背景和前景两部分组成。其中背景由三部分构成分别是内容区域、填充区、边框，这三个区域的大小通过以下属性进行控制：<br> width&#x2F;height   padx&#x2F;pady   borderwidth<br>边框的宽度可以通过 borderwidth 来调整，其样式可以通过relief来设置（默认为平的 flat）；<br>填充区的大小调整分为水平方向和垂直方向，可以使用padx和pady来调整；内容区则主要用来显示文字或者图片，其大小由 width&#x2F;height 来控制。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">win = tk.Tk()</span><br><span class="line">win.geometry(&#x27;400x200&#x27;)</span><br><span class="line"># 若内容是文字则以字符为单位，图像则以像素为单位</span><br><span class="line">label = tk.Label(win, text=&quot;你好&quot;,font=(&#x27;宋体&#x27;,20, &#x27;bold italic&#x27;),bg=&quot;#7CCD7C&quot;,</span><br><span class="line">                 width=30,height=5，</span><br><span class="line">                 padx=10, pady=15, borderwidth=10, relief=&quot;sunken&quot;)</span><br><span class="line">label.pack()</span><br><span class="line">win.mainloop()</span><br></pre></td></tr></table></figure><ol start="2"><li>标签添加背景图Label（标签）除了可以显示文本之外，还可以用来显示图片，通过一组示例做简单的说明，代码如下所示：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">root= tk.Tk()</span><br><span class="line">root.geometry(&#x27;300x300&#x27;)</span><br><span class="line">phont = tk.PhotoImage(file=&#x27;D:\\File\\All\\web\\python\\blog\\99.png&#x27;)</span><br><span class="line">lab = tk.Label(root,image=phont,width=100,height=100)</span><br><span class="line">lab.pack()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><ol start="3"><li>Message控件Message 控件与 Label 控件的功能类似，它主要用来显示多行不可编辑的文本信息，与 Label 的不同之处在于该控件增加了自动分行的功能。下面对它做简单的介绍，示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">#创建主窗口</span><br><span class="line">win = Tk()</span><br><span class="line">win.geometry(&#x27;400x300&#x27;)</span><br><span class="line">msg = Message (win, text=&#x27;hello&#x27;,width =60,font=(&#x27;微软雅黑&#x27;,10,&#x27;bold&#x27;))</span><br><span class="line">msg .pack (side=LEFT)</span><br><span class="line">#开始程序循环</span><br><span class="line">win .mainloop ()</span><br></pre></td></tr></table></figure></li></ol><p>Label控件Tkinter中使用的非常多</p>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Label控件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tkinter库的常用控件,方法和属性</title>
      <link href="/post/a3cef9b3.html"/>
      <url>/post/a3cef9b3.html</url>
      
        <content type="html"><![CDATA[<h5 id="Tkinter常用控件"><a href="#Tkinter常用控件" class="headerlink" title="Tkinter常用控件"></a>Tkinter常用控件</h5><p>Button  按钮<br>点击按钮时触发&#x2F;执行一些事件（函数）</p><p>Canvas  画布<br>提供绘制图，比如直线、矩形、多边形等</p><p>Checkbutton复选框<br>多项选择按钮，用于在程序中提供多项选择框</p><p>Entry文本框<br>输入框用于接收单行文本输入</p><p>Frame框架（容器）控件<br>定义一个窗体（根窗口也是一个窗体），用于承载其他控件，即作为其他控件的容器</p><p>Lable标签控件<br>用于显示单行文本或者图片</p><p>LableFrame容器控件<br>一个简单的容器控件，常用于复杂的窗口布局。</p><p>Listbox列表框控件<br>以列表的形式显示文本</p><p>Menu菜单控件<br>菜单组件（下拉菜单和弹出菜单）</p><p>Menubutton菜单按钮控件<br>用于显示菜单项</p><p>Message信息控件<br>用于显示多行不可编辑的文本，与 Label控件类似，增加了自动分行的功能</p><p>messageBox消息框控件<br>定义与用户交互的消息对话框</p><p>OptionMenu选项菜单<br>下拉菜单</p><p>PanedWindow窗口布局管理组件<br>为组件提供一个框架，允许用户自己划分窗口空间</p><p>Radiobutton单选框<br>单项选择按钮，只允许从多个选项中选择一项</p><p>Scale进度条控件<br>定义一个线性“滑块”用来控制范围，可以设定起始值和结束值，并显示当前位置的精确值</p><p>Spinbox高级输入框<br>Entry 控件的升级版，可以通过该组件的上、下箭头选择不同的值</p><p>Scrollbar滚动条<br>默认垂直方向，鼠标拖动改变数值，可以和 Text、Listbox、Canvas等控件配合使用</p><p>Text多行文本框<br>接收或输出多行文本内容</p><p>Toplevel子窗口<br>在创建一个独立于主窗口之外的子窗口，位于主窗口的上一层，可作为其他控件的容器</p><h5 id="控件基本属性"><a href="#控件基本属性" class="headerlink" title="控件基本属性"></a>控件基本属性</h5><p>每个控件都有着各自不同的功能，即使有些控件功能相似，但它们的适用场景也不同。在 Tkinter 中不同的控件受到各自参数的约束，所有控件既有相同属性，也有各自独有的属性。对这些控件的<strong>共用属性</strong>做简单介绍，</p><p>anchor<br>定义控件或者文字信息在窗口内的位置</p><p>bg<br>bg 是 background 的缩写，用来定义控件的背景颜色，参数值可以颜色的十六进制数，或者颜色英文单词</p><p>bitmap<br>定义显示在控件内的位图文件</p><p>borderwidth<br>定于控件的边框宽度，单位是像素</p><p>command<br>该参数用于执行事件函数，比如单击按钮时执行特定的动作，可将执行用户自定义的函数</p><p>cursor<br>当鼠标指针移动到控件上时，定义鼠标指针的类型，字符换格式，参数值有 crosshair（十字光标）watch（待加载圆圈）plus（加号）arrow（箭头）等</p><p>font<br>若控件支持设置标题文字，就可以使用此属性来定义，它是一个数组格式的参数 (字体,大小，字体样式)</p><p>fg<br>fg 是 foreground 的缩写，<strong>用来定义控件的前景色，也就是字体的颜色</strong></p><p>height<br>该参数值用来设置控件的高度，文本控件以字符的数目为高度（px），其他控件则以像素为单位</p><p>image<br>定义显示在控件内的图片文件</p><p>justify<br>定义多行文字的排列方式，此属性可以是 LEFT&#x2F;CENTER&#x2F;RIGHT</p><p>padx&#x2F;pady<br>定义控件内的文字或者图片与控件边框之间的水平&#x2F;垂直距离</p><p>relief<br>定义控件的边框样式，参数值为FLAT（平的）&#x2F;RAISED（凸起的）&#x2F;SUNKEN（凹陷的）&#x2F;GROOVE（沟槽桩边缘）&#x2F;RIDGE（脊状边缘）</p><p>text<br>定义控件的标题文字</p><p>state<br>控制控件是否处于可用状态，参数值默认为 NORMAL&#x2F;DISABLED，默认为 NORMAL（正常的）</p><p>width<br>用于设置控件的宽度，使用方法与 height 相同</p><p>小伙伴们可以把他当成一张表格来查看</p><h5 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h5><p>窗口常用方法下表列出了<strong>窗口的常用方法</strong>，其中 window 代表主窗口对象：</p><p>window.title(“my title”)<br>接受一个字符串参数，为窗口起一个标题</p><p>window.resizable()<br>是否允许用户拉伸主窗口大小，默认为可更改，当设置为 resizable(0,0)或者resizable(False,False)时不可更改</p><p>window.geometry()<br>设定主窗口的大小以及位置，当参数值为 None 时表示获取窗口的大小和位置信息。</p><p>eg.</p><p>geometry(‘450x400+300+200’)</p><p>设置主窗口的宽度为 450，高度为 400，同时窗口距离左边屏幕的距离为 300（以像素为单位），距离屏幕顶部的距离为 200，这里我们将带“+”的参数值称为“位置参数”，当然，您也可以将它们设置为负数，如下所示：geometry(‘+-1500+-2000’)当设置了一个超过屏幕的负参数值时，主窗口会被移动至“屏幕之外”，此时就看不到主窗口了，这也是隐藏窗口的一种方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line">window = tk.Tk()</span><br><span class="line"># 设置窗口大小变量</span><br><span class="line">window.geometry(&#x27;450x400+300+200&#x27;)</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><p>window.quit()<br>关闭当前窗口</p><p>window.update()<br>刷新当前窗口</p><p>window.mainloop()<br>设置窗口主循环，使窗口循环显示（一直显示，指导窗口被关闭）</p><p>window.iconbitmap()<br>设置窗口左上角的图标（图标是.ico文件类型）</p><p>window.config(background &#x3D;”red”)<br>设置窗口的背景色为红色，也可以接受 16 进制的颜色值</p><p>window.minsize(50,50)<br>设置窗口被允许调整的最小范围，即宽和高各50</p><p>window.maxsize(400,400)<br>设置窗口被允许调整的最大范围，即宽和高各400</p><p>window.attributes(“-alpha”,0.5)<br>用来设置窗口的一些属性，比如透明度（-alpha）、是否置顶（-topmost）即将主屏置于其他图标之上、是否全屏（-fullscreen）全屏显示等</p><p>window.state(“normal”)<br>用来设置窗口的显示状态，参数值 normal（正常显示），icon（最小化），zoomed（最大化），</p><p>window.withdraw()<br>用来隐藏主窗口，但不会销毁窗口。</p><p>window.deiconify()<br>将窗口从隐藏状态还原</p><p>window.iconify()<br>设置窗口最小化</p><p>window.winfo_screenwidth()<br>window.winfo_screenheight()<br>获取电脑屏幕的分辨率（尺寸）</p><p>window.winfo_width()<br>window.winfo_height()<br>获取窗口的大小，同样也适用于其他控件，但是使用前需要使用<br>window.update() 刷新屏幕，否则返回值为1</p><p>window.protocol(“协议名”,回调函数)<br>启用协议处理机制，常用协议有 WN_DELETE_WINDOW，当用户点击关闭窗口时，窗口不会关闭，而是触发回调函数。 Tinter 除了提供事件绑定机制之外，还提供了协议处理机制，它指的是应用程序和窗口管理器之间的交互，最常用的协议为 WM_DELETE_WINDOW。当 Tkinter 使用 WM_DELETE_WINDOW 协议与主窗口进行交互时，Tkinter 主窗口右上角x号的关闭功能失效，也就是无法通过点击x来关闭窗口，而是转变成调用用户自定义的函数</p><p>eg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import Tk</span><br><span class="line"># 导入 对话框控件</span><br><span class="line">from tkinter import messagebox</span><br><span class="line">root = Tk()</span><br><span class="line"># 定义回调函数，当用户点击窗口x退出时，执行用户自定义的函数</span><br><span class="line">def QueryWindow():</span><br><span class="line">    # 显示一个警告信息，点击确后，销毁窗口</span><br><span class="line">    if messagebox.showwarning(&quot;警告&quot;,&quot;出现了一个错误&quot;):</span><br><span class="line">        # 这里使用 destory()关闭窗口，也可以使用上面提到的quit方法</span><br><span class="line">        root.destroy()</span><br><span class="line"># 使用协议机制与窗口交互，并回调用户自定义的函数</span><br><span class="line">root.protocol(&#x27;WM_DELETE_WINDOW&#x27;, QueryWindow)</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></table></figure><p>下面通一个示例对上述表格中的常用方法做简单地介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import tkinter as tk</span><br><span class="line"></span><br><span class="line">window =tk.Tk()</span><br><span class="line">#设置窗口大小:宽x高,注,此处不能为 &quot;*&quot;,必须使用 &quot;x&quot;</span><br><span class="line">window.geometry(&#x27;450x300&#x27;)</span><br><span class="line"># 获取电脑屏幕的大小</span><br><span class="line">print(&quot;电脑的分辨率是%dx%d&quot;%(window.winfo_screenwidth(),window.winfo_screenheight()))</span><br><span class="line"># 要求窗口的大小，必须先刷新一下屏幕</span><br><span class="line">window.update()</span><br><span class="line">print(&quot;窗口的分辨率是%dx%d&quot;%(window.winfo_width(),window.winfo_height()))</span><br><span class="line"># 如使用该函数则窗口不能被拉伸</span><br><span class="line"># window.resizable(0,0)</span><br><span class="line"># 改变背景颜色</span><br><span class="line">window.config(background=&quot;#6fb765&quot;)</span><br><span class="line"># 设置窗口处于顶层</span><br><span class="line">window.attributes(&#x27;-topmost&#x27;,True)</span><br><span class="line"># 设置窗口的透明度</span><br><span class="line">window.attributes(&#x27;-alpha&#x27;,1)</span><br><span class="line"># 设置窗口被允许最大调整的范围，与resizble()冲突</span><br><span class="line">window.maxsize(600,600)</span><br><span class="line"># 设置窗口被允许最小调整的范围，与resizble()冲突</span><br><span class="line">window.minsize(50,50)</span><br><span class="line">#更改左上角窗口的的icon图标</span><br><span class="line">window.iconbitmap(&#x27;C:/Users/1.ico&#x27;)</span><br><span class="line">#添加文本内容,并对字体添加相应的格式 font(字体,字号,&quot;字体类型&quot;)</span><br><span class="line">text=tk.Label(window,text=&quot;漂亮鬼，网址：www.xiaoyang.vercel.app&quot;,bg=&quot;yellow&quot;,fg=&quot;red&quot;,font=(&#x27;Times&#x27;, 15, &#x27;bold italic underline&#x27;))</span><br><span class="line">#将文本内容放置在主窗口内</span><br><span class="line">text.pack()</span><br><span class="line"># 添加按钮，以及按钮的文本，并通过command 参数设置关闭窗口的功能</span><br><span class="line">button=tk.Button(window,text=&quot;关闭&quot;,command=window.quit)</span><br><span class="line"># 将按钮放置在主窗口内</span><br><span class="line">button.pack(side=&quot;bottom&quot;)</span><br><span class="line">#进入主循环，显示主窗口</span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python--tkinter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pillow图像格式转化和缩放操作</title>
      <link href="/post/1e6c0b4.html"/>
      <url>/post/1e6c0b4.html</url>
      
        <content type="html"><![CDATA[<h4 id="Pillow图片格式转换"><a href="#Pillow图片格式转换" class="headerlink" title="Pillow图片格式转换"></a>Pillow图片格式转换</h4><p>图片格式之间的转换主要有以下两种方法：</p><p>save() 方法用于保存图像，当不指定文件格式时，它会以默认的图片格式来存储；如果指定图片格式，则会以指定的格式存储图片。</p><p>save() 的语法格式如下：</p><p>Image.save(fp, format&#x3D;None)</p><p>fp：图片的存储路径，要声明图片的名字和格式；<br>format：可选参数，可以指定图片的格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">img.save(&quot;D:\\File\\All\\web\\python\\blog\\949.jpg&quot;)</span><br></pre></td></tr></table></figure><p>convert()+save()注意，<strong>并非所有的图片格式都可以用 save() 方法转换完成，</strong><br>比如将 PNG 格式的图片保存为 JPG 格式，如果直接使用 save() 方法就会出现以下错误：</p><p>引发错误的原因是由于 PNG 和 JPG 图像模式不一致导致的。<br>其中 PNG 是四通道 RGBA 模式，即红色、绿色、蓝色、Alpha 透明色；<br>JPG 是三通道 RGB 模式。因此要想实现图片格式的转换，就要将 PNG 转变为三通道 RGB 模式。<br>Image 类提供的 convert() 方法可以实现图像模式的转换。该函数提供了多个参数，比如 mode、matrix、dither 等，其中最关键的参数是 mode，其余参数无须关心。语法格式如下：<br>convert(mode)<br>mode：指的是要转换成的<strong>图像模式</strong><br>params：其他可选参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">im= img.convert(&quot;RGBA&quot;)</span><br><span class="line">im.save(&quot;D:\\File\\All\\web\\python\\blog\\99.png&quot;)</span><br></pre></td></tr></table></figure><p><strong>covert() 会返回一个新的 image 对象</strong></p><h5 id="Pillow图像缩放操作"><a href="#Pillow图像缩放操作" class="headerlink" title="Pillow图像缩放操作"></a>Pillow图像缩放操作</h5><p>Image 类提供的 resize() 方法能够实现任意缩小和放大图像。<br>resize() 函数的语法格式如下：</p><p>resize(size, resample&#x3D;image.BICUBIC, box&#x3D;None,<br>reducing_gap&#x3D;None) 一般使用就用第一个参数比较常见</p><p>size：<strong>元组参数</strong> (width,height)，图片缩放后的尺寸；一般表示大小的基本上都是元组参数</p><p>resample：可选参数，指图像重采样滤波器，与 thumbnail() 的 resample 参数类似，默认为 Image.BICUBIC；</p><p>box：对指定图片区域进行缩放，box 的参数值是长度为 4 的像素坐标元组，即 (左,上,右,下)。<br>注意，被指定的区域必须在原图的范围内，如果超出范围就会报错。当不传该参数时，默认对整个原图进行缩放；</p><p>reducing_gap：可选参数，浮点参数值，用于优化图片的缩放效果，常用参数值有 3.0 和 5.0。</p><p>注意，<strong>resize() 会返回一个新的 image 对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">im=img.resize((900,900))</span><br><span class="line"># im.save(&quot;D:\\File\\All\\web\\python\\blog\\49.jpg&quot;)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure><p>对图片的局部位置进行放大，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">im=img.resize((100,100),box=(0,0,120,120))</span><br><span class="line"># im.save(&quot;D:\\File\\All\\web\\python\\blog\\49.jpg&quot;)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure><p>​    实际使用时局部放大用的非常少</p><h5 id="创建缩略图缩略图"><a href="#创建缩略图缩略图" class="headerlink" title="创建缩略图缩略图"></a>创建缩略图缩略图</h5><p>（thumbnail image）指的是将原图缩小至一个指定大小（size）的图像。通过创建缩略图可以使图像更易于展示和浏览。Image 对象提供了一个 thumbnail() 方法用来生图像的缩略图，该函数的语法格式如下：</p><p>thumbnail(size,resample)</p><p>size：元组参数，指的是<strong>缩小后</strong>的图像大小；</p><p>resample：可选参数，指图像重采样滤波器，有四种过滤方式，分别是 Image.BICUBIC（双立方插值法）、PIL.Image.NEAREST（最近邻插值法）、PIL.Image.BILINEAR（双线性插值法）、PIL.Image.LANCZOS（下采样过滤插值法），默认为 Image.BICUBIC。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">im = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">im.thumbnail((150,50))</span><br><span class="line"># im.save(&quot;D:\\File\\All\\web\\python\\blog\\49.jpg&quot;)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure><p><strong>注意，缩略图的尺寸可能与您指定的尺寸不一致，这是因为 Pillow 会对原图像的长、宽进行等比例缩小</strong>，当指定的尺寸不符合图像的尺寸规格时，缩略图就会创建失败， 比如指定的尺寸超出了原图像的尺寸规格</p><h5 id="批量修改图片尺寸"><a href="#批量修改图片尺寸" class="headerlink" title="批量修改图片尺寸"></a>批量修改图片尺寸</h5><p>采用批量处理方法，比如批量转换格式，批量修改尺寸，批量添加水印，批量创建缩略图等，这是一种提升工作效率的有效途径，它避免了单一、重复的操作。通过 Pillow 提供的 Image.resize() 方法可以批量地修改图片尺寸，下面看一组简单的示例。首先找一些类型相同，但尺寸不一的图片，并把它们放入桌面的 image01 文件夹中</p><p>批量修改图片尺寸</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from PIL import Image</span><br><span class="line">#读取图片目录</span><br><span class="line">fileName = os.listdir(&#x27;C:/Users/Administrator/Desktop/image01/&#x27;)</span><br><span class="line">print(fileName)</span><br><span class="line">#设定尺寸</span><br><span class="line">width = 350</span><br><span class="line">height = 350</span><br><span class="line">#如果目录不存在，则创建目录</span><br><span class="line">if not os.path.exists(&#x27;C:/Users/Administrator/Desktop/NewImage/&#x27;):</span><br><span class="line">    os.mkdir(&#x27;C:/Users/Administrator/Desktop/NewImage/&#x27;)</span><br><span class="line">#循环读取每一张图片</span><br><span class="line">for img in fileName:</span><br><span class="line">    old_pic = Image.open(&#x27;C:/Users/Administrator/Desktop/image01/&#x27; + img)</span><br><span class="line">    new_image = old_pic.resize((width, height),Image.BILINEAR)</span><br><span class="line">    print (new_image)</span><br><span class="line">    new_image.save(&#x27;C:/Users/Administrator/Desktop/NewImage/&#x27;+img)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>这里原理其实非常简单 ，即使需要大家对文件的下官操作非常熟悉</p>]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pillow创建对象和对象属性</title>
      <link href="/post/5951139c.html"/>
      <url>/post/5951139c.html</url>
      
        <content type="html"><![CDATA[<p>这里博主分享一个pillow库的使用笔记专题</p><h4 id="Pillow"><a href="#Pillow" class="headerlink" title="Pillow"></a>Pillow</h4><p>除了 PIL 和 Pillow 库之外，Python 还提供了一些其他图像处理库：<br>Scikit-image：一款基于 scipy 科学计算的图像处理软件包，以数组的形式对图像进行处理；<br>OpenCV：其实是一个 C++ 图像处理库，不过它提供了 Python 语言的接口。（需要进阶的话可以看这个）</p><p>opencv在人工智能，面部识别方面应用的比较广泛</p><p>Pillow库特点Pillow 库作为图像处理的常用库，主要有以下三大特点：</p><ol><li><p>支持广泛的文件格式Pillow 支持广泛的图像格式，比如 “jpeg”，”png”，”bmp”，”gif”，”ppm”，”tiff” 等。同时，它也支持图像格式之间的相互转换。</p></li><li><p>提供了丰富的功能Pillow 提供了丰富的图像处理功能，可概括为两个方面：<br>图像归档，包括创建缩略图、生成预览图像、图像批量处理等；<br>图像处理，则包括调整图像大小、裁剪图像、像素点处理、添加滤镜、图像颜色处理等。</p></li><li><p>配合GUI工具使用Pillow 库可以配合 Python GUI（图形用户界面）工具 Tkinter 一起使用(将他俩联系在一起用才好玩，不然没有界面，看起来没有感觉)</p></li></ol><h5 id="Pillow创建Image对象"><a href="#Pillow创建Image对象" class="headerlink" title="Pillow创建Image对象"></a>Pillow创建Image对象</h5><p>Image 类是 Pillow 库中最为重要的类，该类被定义在和与其同名的 Image 模块中。</p><p>使用下列导包方式引入 Image 模块：from PIL import Image</p><p>使用 Image 类可以实例化一个 Image 对象，通过调用该对象的一系列属性和方法对图像进行处理。</p><p>Pilow 提供了<strong>两种创建 Image 实例对象</strong>的方法：</p><ol><li>open()使用 Image 类的 open() 方法，可以创建一个 Image 对象，语法格式如下：<br>  im &#x3D; Image.open(fp,mode&#x3D;”r”)</li></ol><p>  fp：即 filepath 的缩写，表示文件路径，字符串格式；<br>  mode：可选参数，若出现该参数，则必须设置为 “r”，否则会引发 ValueError 异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&#x27;D:\\File\\All\\web\\python\\blog\\670099.jpg&#x27;)</span><br><span class="line">#调用show()函数才能显示出图片</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><ol start="2"><li>new()使用 Image 类提供的 new() 方法可以创建一个新的 Image 对象，语法格式如下:</li></ol><p>im&#x3D;Image.new(mode,size,color)</p><p>mode：图像模式，字符串参数，比如 RGB（真彩图像）、L（灰度图像）、CMYK（色彩图打印模式）等（下面博主会介绍）；</p><p>size：图像大小，<strong>元组</strong>参数（width, height）代表图像的像素大小；</p><p>color：图片颜色，默认值为 0 表示黑色，参数值支持（R,G,B）三元组数字格式、颜色的十六进制值以及颜色英文单词。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im = Image.new(mode=&#x27;RGB&#x27;,size=(200,200),color=&#x27;#AAAAFF&#x27;)</span><br><span class="line">im.show()</span><br></pre></td></tr></table></figure><p>new相当于创建一个新的图片了而open相当于是打开一张图片</p><h4 id="Pillow-Image对象属性"><a href="#Pillow-Image对象属性" class="headerlink" title="Pillow Image对象属性"></a>Pillow Image对象属性</h4><p>一般直接输出这个对象就可以看到关于吧这张图片的大部分的信息，可以不用使用这些属性来查看了</p><h5 id="1-size：查看图像的尺寸"><a href="#1-size：查看图像的尺寸" class="headerlink" title="1) size：查看图像的尺寸"></a>1) size：查看图像的尺寸</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line"># 方法一</span><br><span class="line">print(img.size)</span><br><span class="line"># 方法二</span><br><span class="line">print(img)</span><br><span class="line"># 方法三</span><br><span class="line">print(img.width,img.height)</span><br></pre></td></tr></table></figure><h5 id="2-format：查看图片的格式"><a href="#2-format：查看图片的格式" class="headerlink" title="2) format：查看图片的格式"></a>2) format：查看图片的格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">print(img.format)</span><br></pre></td></tr></table></figure><h5 id="3-readonly：图片是否为只读"><a href="#3-readonly：图片是否为只读" class="headerlink" title="3) readonly：图片是否为只读"></a>3) readonly：图片是否为只读</h5> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">print(img.readonly)</span><br></pre></td></tr></table></figure><p>该属性的返回为 0 或者 1，分别对应着是和否，输出结果如下：图像是否为只读: 1</p><h5 id="4-info：查看图片相关信息"><a href="#4-info：查看图片相关信息" class="headerlink" title="4) info：查看图片相关信息"></a>4) info：查看图片相关信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">print(img.info)</span><br></pre></td></tr></table></figure><p>该属性的返回值为字典格式，输出结果如下：图像信息: {‘dpi’: (96, 96), ‘Software’: ‘Snipaste’}</p><p>主要显示的都是二进制源码</p><h5 id="5-mode：图像模式"><a href="#5-mode：图像模式" class="headerlink" title="5)mode：图像模式"></a>5)mode：图像模式</h5> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(&quot;D:\\File\\All\\web\\python\\blog\\947849.jpg&quot;)</span><br><span class="line">print(img.mode)</span><br></pre></td></tr></table></figure><img src="/post/5951139c/65.png" class title="This is an test image">]]></content>
      
      
      <categories>
          
          <category> python--Pillow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言编译链接和软件安装</title>
      <link href="/post/cdb8b2bb.html"/>
      <url>/post/cdb8b2bb.html</url>
      
        <content type="html"><![CDATA[<h4 id="C语言编译和链接"><a href="#C语言编译和链接" class="headerlink" title="C语言编译和链接"></a>C语言编译和链接</h4><p>我们平时所说的程序，是指双击后就可以直接运行的程序，这样的程序被称为可执行程序，在 Windows 下，可执行程序的后缀有.exe和.com（其中.exe比较常见）</p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>C语言代码由固定的词汇按照固定的格式组织起来，简单直观，程序员容易识别和理解，但是对于CPU，C语言代码就是天书，根本不认识，CPU只认识几百个二进制形式的指令。这就需要一个工具，将C语言代码转换成CPU能够识别的二进制指令，也就是将代码加工成 .exe 程序的格式；这个工具是一个特殊的软件，叫做编译器</p><p>编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为<strong>编译</strong></p><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做<strong>目标文件</strong>（Object File）的中间文件（或者说临时文件）。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是.obj；对于 GCC（linux系统上面的），目标文件的后缀是.o</p><p>目标文件经过链接以后才能变成可执行文件</p><p><strong>编译：</strong><br>只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。<br><strong>链接：</strong><br>其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做链接器</p><p>随着学习的深入，我们编写的代码越来越多，最终需要将它们分散到多个源文件中，编译器每次只能编译一个源文件，生成一个目标文件，这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个目标文件组合起来。</p><p>实际开发中，除了编译器是必须的工具，我们往往还需要很多其他辅助软件</p><p>eg.<br>编辑器：用来编写代码，并且给代码着色，以方便阅读；<br>代码提示器：输入部分代码，即可提示全部代码，加速代码的编写过程；<br>调试器：观察程序的每一个运行步骤，发现程序的逻辑错误；<br>项目管理工具：对程序涉及到的所有资源进行管理，包括源文件、图片、视频、第三方库等；<br>漂亮的界面：各种按钮、面板、菜单、窗口等控件整齐排布，操作更方便(c语言中涉及比较少)<br>这些工具通常被打包在一起，统一发布和安装<br>它们统称为集成开发环境（IDE，Integrated Development Environment）。<br>在实际开发中，我一般也是使用集成开发环境，而不是单独地使用编译器。<br>（vs code 就是一个编译器）</p><h4 id="Windows-下-IDE推荐"><a href="#Windows-下-IDE推荐" class="headerlink" title="Windows 下 IDE推荐"></a>Windows 下 IDE推荐</h4><ol><li><p>Visual Studio Windows 下首先推荐大家使用微软开发的 Visual Studio 2022</p><p>这个是博主自己用的安装包<a href="https://pan.baidu.com/s/1cW_wtbAwJwF4OaHljk1X9w">这儿呢Visual Studio 2022</a></p><p>提取码：2111</p></li><li><p>Dev C++如果你讨厌 VS 的复杂性，那么可以使用 Dev C++。Dev C++ 是一款免费开源的 C&#x2F;C++ IDE，内嵌 GCC 编译器（Linux GCC 编译器的 Windows 移植版），是 NOI、NOIP 等比赛的指定工具。Dev C++ 的优点是体积小（只有几十兆）、安装卸载方便、学习成本低，缺点是调试功能弱。</p><p><a href="https://pan.baidu.com/s/1AkhqynA1yV6ZlErKq4fTeA">Dev C++</a> 提取码：2111</p></li><li><p>Visual C++ 6.0（简称VC 6.0）是微软开发的一款经典的 IDE，很多高校都以 VC 6.0 为教学工具来讲解C和C++。</p><p><a href="https://pan.baidu.com/s/1JmZrSOL1Dv5yp_tb09ujhw">Visual C++ 6.0</a>提取码：2111</p><p>不会安装的可以自行百度</p></li></ol><h4 id="程序安装解释"><a href="#程序安装解释" class="headerlink" title="程序安装解释"></a>程序安装解释</h4><p>不同的操作系统，安装软件的方法虽然不一样，但基本原理是相同的，主要的思想就是将程序的二进制可执行文件拷贝到某个目录，设置一些路径。如果程序运行时需要一些库，将这些库拷贝到系统目录即可。</p><p>程序的安装基本上要经过下面四个步骤：</p><ol><li><p>将程序的<strong>可执行文件</strong>从安装包所在的位置，拷贝到要安装的目录。安装程序的时候，程序会给用户指定一个默认的安装目录，如果用户需要，也可以自定义安装，改变安装目录。一般所谓的“绿色软件”到此就安装结束了，可以使用了。</p></li><li><p>如果有必要，可以向系统目录拷贝一些动态链接库（DLL）。（可选操作）有的程序，比如大型游戏，可能需要很多动态链接库（DLL）的支持，这时候程序可能会将这些 DLL 拷贝到系统库的默认目录，Win7 下一般拷贝到C:\Windows\System32\（读者不妨打开该目录，会看到很多 DLL 文件）。有些程序用到的 DLL 文件不是系统必需的，只能由程序自己使用，这样放在系统目录里就不太合适，安装的软件多了，就会造成系统臃肿，所以这些 DLL 会被拷贝到程序的安装目录。</p></li><li><p>向系统注册表中写入相应的设置项，注册程序或者库的安装信息。（可选操作）安装前，用户可能会对软件做一些设置，安装时，这些设置就会被写入注册表。另外，当安装程序将 DLL 文件拷贝到系统目录时，一些 DLL 还需要向系统注册，告诉系统我在这里，不然使用的时候可能会找不到。</p></li><li><p>在开始菜单或者桌面上位程序创建快捷方式。（可选操作）创建快捷方式主要是为了用户使用方便，有了快捷方式，就不用再到安装目录去启动程序了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据在内存中的存储</title>
      <link href="/post/6601b08a.html"/>
      <url>/post/6601b08a.html</url>
      
        <content type="html"><![CDATA[<p>这里博主给大家分享一下博主学习c&#x2F;c++的时候学习的计算机基础的知识</p><p>这里博主建议小白可以先不看这篇文章，等有一定的基础过后再回过来看这篇文章就不会那么迷糊了</p><p>博主本人就是这样学的</p><h3 id="数据在内存中的存储"><a href="#数据在内存中的存储" class="headerlink" title="数据在内存中的存储"></a>数据在内存中的存储</h3><h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><p>内存条是一个非常精密的部件，包含了上亿个电子元器件，它们很小，达到了纳米级别。这些元器件，实际上就是电路；电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压。5V 是通电，用1来表示，0V 是断电，用0来表示。所以，一个元器件有2种状态，0 或者 1（没想到吧内存条竟然是这样的，当时博主也没想到）</p><p>一般情况下我们不一个一个的使用元器件，而是将8个元器件看做一个单位，即使表示很小的数，例如 1，也需要8个，也就是 00000001。</p><p>一个元器件称为1比特（Bit）或1位，8个元器件称为1字节（Byte），那么16个元器件就是2Byte，32个就是4Byte，<br>1024Byte，简写为1KB（程序猿经典1024，哈哈）<br>1024KB，简写为1MB<br>1024MB，简写为1GB。</p><p>以后可别再以为1kb就是1000个字节了哈（作为程序员属实丢不起这个人）</p><h4 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h4><p>在计算机系统中，运行的应用程序的数据都是保存在内存中，不同类型的数据，保存的内存区域不同，包括：<br>    1、栈区[stack]：由<strong>编译器自动分配释放</strong>，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的<strong>栈</strong>。<br>    2、堆区[heap]：一<strong>般由程序员分配释放</strong>，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于<strong>链表</strong>。<br>    3、全局区[静态区]：全局变量和静态变量的存储是放在一块的，<strong>初始化</strong>的全局变量和静态变量在一块区域，<strong>未初始化</strong>的全局变量和未初始化的静态变量在<strong>相邻</strong>的另一块区域。<strong>程序结束后由系统释放</strong>。<br>    4、文字常量区：存放常量字符串。程序结束后由系统释放。<br>    5、程序代码区：存放函数体的二进制代码。<br>    6、寄存器区：用来保存栈顶指针和指令指针(汇编操作)</p><p>这里第4 5 6点见的比较少    </p><h5 id="一-栈区中的数据"><a href="#一-栈区中的数据" class="headerlink" title="(一)栈区中的数据"></a>(一)栈区中的数据</h5><p>​    1、应用程序启动后，<strong>操作系统</strong>会为应用程序在栈区中开辟内存空间，用于存放局部变量以及函数的参数等；<br>​    2、iOS主线程栈区大小为1M，MAC主线程栈区大小为8M；<br>​    3、栈区中的变量由编译器负责分配和释放；<br>​    4、栈区中的数据以“栈”的形式管理的，后进先出(LIFO)<br>​    5、访问栈区中变量的效率高，<strong>不会出现内存碎片</strong><br>​    6、栈区中的变量名(不带*)相当于是<strong>指向栈区数据的指针别名</strong>，变量名可以简化程序猿的工作。<br>​<br>​    </p><h5 id="二-堆区中的数据"><a href="#二-堆区中的数据" class="headerlink" title="(二)堆区中的数据"></a>(二)堆区中的数据</h5><p>​    1、由于栈区中的空间有限，iOS的应用程序中，对象都是建立在堆中的<br>​    2、堆区包括<strong>系统内存</strong>和<strong>虚拟内存</strong>(硬盘缓存)，由所有正在运行的应用程序共享使用；<br>​    3、堆区中的内存分配由<strong>操作系统</strong>负责，操作系统使用一个链表统一维护所有已经分配的内存记录<br>​    4、由于<strong>堆区是由所有应用程序共享</strong>的，操作系统以匿名(只记录内存地址和大小，不记录具体类型)的方式记录已经分配的内存区域<br>​    5、要访问堆区中的数据，必须通过<strong>指针</strong>的方式才可以进行，指针的类型决定了访问堆中的数据方式<br>​    6、当某一内存区域不再使用时，<strong>程序需要通知操作系统回收该内存区域</strong>，从而可以保证该内存区域被其他程序再次使用，否则，该区域将永远无法再次分配，这就是“内存泄露”<br>​    7、如果某一区域已经被释放，仍然试图访问该区域，会提示“坏内存访问”，这就是“野指针错误”<br>​    8、相比较栈区，堆区中的效率要低很多，同时容易出现内存碎片<br>​    9、相比较栈区，堆区中的访问方式更加灵活，对象占用的内存也可以更大</p><h5 id="运行软件原理"><a href="#运行软件原理" class="headerlink" title="运行软件原理"></a>运行软件原理</h5><p>eg.<br>双击QQ图标，操作系统就会知道你要运行这个软件，它会在硬盘中找到你安装的QQ软件，将数据复制到内存，QQ不是在硬盘中运行的，而是在内存中运行的。(不仅qq是这样的其他所有的软件都是这样的)</p><p><strong>因为内存的读写速度比硬盘快很多</strong></p><p>读写速度，内存 &gt; 固态硬盘 &gt; 机械硬盘</p><p>所以，不管是运行QQ还是编辑Word文档，都是先将硬盘上的数据复制到内存，才能让<strong>CPU</strong>来处理，这个过程就叫作载入内存。完成这个过程需要一个特殊的程序，这个程序就叫做加载器</p><p><strong>CPU直接与内存打交道</strong>，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。</p><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>这里就是说到上面堆区提到的虚拟内存</p><p>如果我们运行的程序较多，占用的空间就会超过内存（内存条）容量。</p><p>eg.<br>计算机的内存容量为8G，却运行着10个程序，这10个程序共占用12G的空间，也就意味着需要从硬盘复制 12G 的数据到内存，这显然是不可能的。<br><strong>但是</strong>操作系统,为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存</p><p>正是因为 虚拟内存 的存在，通过 虚拟内存 可以让程序可以拥有超过系统物理内存大小的可用内存空间。<br>另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错）</p><p>硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现”卡死“现象，即使CPU强劲，也不会有大的改观</p><p>CPU直接从内存中读取数据，处理完成后将结果再写入内存。</p><p>所以小伙伴们买电脑要买内存大的，运行就更快</p><h5 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h5><p>收录了 128 个字符，包含了基本的拉丁字母（英文字母）、阿拉伯数字（也就是 1234567890）、标点符号（,.!等）、特殊符号（@#$%^&amp;等）以及一些具有控制功能的字符</p><img src="/post/6601b08a/68.jpg" class title="This is an image"><h5 id="GB2312编码和GBK编码，将中文存储到计算机"><a href="#GB2312编码和GBK编码，将中文存储到计算机" class="headerlink" title="GB2312编码和GBK编码，将中文存储到计算机"></a>GB2312编码和GBK编码，将中文存储到计算机</h5><p>eg.<br>GBK就是在保存你的帖子的时候，一个汉字占用两个字节。外国人看会出现乱码，此为我国为自己汉字编码而形成之解决方案。UTF8就是在保存你的帖子的时候，一个汉字占用3个字节。。但是外国人看的话不会乱码。</p><h5 id="Unicode字符集，将全世界的文字存储到计算机"><a href="#Unicode字符集，将全世界的文字存储到计算机" class="headerlink" title="Unicode字符集，将全世界的文字存储到计算机"></a>Unicode字符集，将全世界的文字存储到计算机</h5><p><strong>Unicode 是一套字符集，而不是一套字符编码</strong></p><p>字符集定义了字符和二进制的对应关系，为每个字符分配了唯一的编号。<br>可以将字符集理解成一个很大的表格，它列出了所有字符和二进制的对应关系，计算机显示文字或者存储文字，就是一个查表的过程。</p><p>字符编码规定了如何将字符的编号存储到计算机中。字符编号在存储之前必须要经过转换，在读取时还要再逆向转换一次，使用的这套转换方案就叫做字符编码。</p><p>Unicode 可以使用的<strong>编码方案</strong>有三种，分别是：<br>       1. UTF-8：一种变长的编码方案，使用 1~6 个字节来存储<br>       2. UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储<br>       3. UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变</p><p><strong>注意</strong>：只有 UTF-8 兼容 ASCII，UTF-32 和 UTF-16 都不兼容 ASCII</p><p>本文对于编码部分博主介绍的比较少，如果想深入了解的小伙伴们自行百度</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制的介绍和进制的转换--详细版</title>
      <link href="/post/34c02115.html"/>
      <url>/post/34c02115.html</url>
      
        <content type="html"><![CDATA[<p>先介绍一下 这是博主第二次学习进制的时候使用的笔记资料（不要问为啥是第二次学习，🙃😭因为第一次学完忘了）并且博主在第一次学习的时候，没有很好的笔记在进制转换的时候把自己搅混了</p><p>第二次学习完了将自己的一些对教程当中的关键的分享给大家</p><p>这里博主<strong>建议</strong>在阅读的时候大家，对于博主给出的例子都动手算一下</p><h4 id="二进制、八进制和十六进制"><a href="#二进制、八进制和十六进制" class="headerlink" title="二进制、八进制和十六进制"></a>二进制、八进制和十六进制</h4><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><p>在计算机内部，数据都是以二进制的形式存储的</p><p>其实二进制加减法和十进制加减法的思想是类似的</p><p>对于十进制，进行加法运算时逢十进一，进行减法运算时借一当十；<br>对于二进制，进行加法运算时逢二进一，进行减法运算时借一当二。</p><p> 二进制加法：1+0&#x3D;1、1+1&#x3D;10、11+10&#x3D;101、111+111&#x3D;1110</p><p> 二进制减法：1-0&#x3D;1、10-1&#x3D;1、101-11&#x3D;10、1100-111&#x3D;101</p><p>大家可以类比去记忆这个</p><h5 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h5><p>八进制有 0~7 共8个数字（<strong>一定要记住是0-7不是1-8或者0-8</strong>），基数为8，</p><p>加法运算时逢八进一，减法运算时借一当八（其实八进制二进制还有个十六进制他们的加减法运算规则是一样的）</p><p><strong>注意</strong>：八进制数一般是不能以0开头的</p><p>八进制加法：3+4&#x3D;7、5+6&#x3D;13、75+42&#x3D;137、2427+567&#x3D;3216</p><p>八进制减法：6-4&#x3D;2、52-27&#x3D;23、307-141&#x3D;146、7430-1451&#x3D;5757</p><h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><p>十六进制中由0-9+A-F组成的，用A来表示10，B表示11，C表示12，D表示13，E表示14，F表示15，因此有 0~F 共16个数字，基数为16，加法运算时逢16进1，减法运算时借1当16</p><p><strong>注意</strong>：十六进制中的字母不区分大小写，ABCDEF 也可以写作 abcdef。</p><p><strong>注意</strong>：十六进制数一般是不能以0开头的</p><p>十六进制加法：6+7&#x3D;D、18+BA&#x3D;D2、595+792&#x3D;D27、2F87+F8A&#x3D;3F11</p><p>十六进制减法：D-3&#x3D;A、52-2F&#x3D;23、E07-141&#x3D;CC6、7CA0-1CB1&#x3D;5FEF</p><h4 id="进制转换：二进制、八进制、十六进制、十进制之间的转换"><a href="#进制转换：二进制、八进制、十六进制、十进制之间的转换" class="headerlink" title="进制转换：二进制、八进制、十六进制、十进制之间的转换"></a>进制转换：二进制、八进制、十六进制、十进制之间的转换</h4><p><strong>一定要记住这里</strong></p><p> 将十进制和其他进制间的转换分为一类</p><p>将其他进制间的转换分为另一类</p><h5 id="将二进制、八进制、十六进制转换为十进制"><a href="#将二进制、八进制、十六进制转换为十进制" class="headerlink" title="将二进制、八进制、十六进制转换为十进制"></a>将二进制、八进制、十六进制转换为十进制</h5><p>假设当前数字是 N 进制，那么：<br>对于整数，从<strong>右往左</strong>看，第 i 位的位权等于N^(i-1)<br>对于小数，要从<strong>左往右</strong>看，第 j 位的位权为N^(-j)。（仔细理解这俩句话，套着下面的例子实践他）</p><h6 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h6><p>eg.  将八进制数字 53627 转换成十进制：</p><p>53627 &#x3D; 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 &#x3D; 22423（十进制）</p><p><strong>解析</strong>：从右往左看，第1位的位权为 8^0&#x3D;1，第2位的位权为 8^1&#x3D;8，第3位的位权为 8^2&#x3D;64，第4位的位权为 8^3&#x3D;512，第5位的位权为 8^4&#x3D;4096 …… 第n位的位权就为 8^n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。</p><p>eg.  将十六进制数字 9FA8C 转换成十进制：</p><p>9FA8C &#x3D; 9×16^4 + 15×16^3 + 10×16^2 + 8×16^1 + 12×16^0 &#x3D; 653964（十进制）</p><p><strong>解析</strong>：从右往左看，第1位的位权为 16^0&#x3D;1，第2位的位权为 16^1&#x3D;16，第n位的位权就为 16^n-1。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。</p><p>eg.  将二进制数字转换成十进制也是类似的道理：</p><p>11010 &#x3D; 1×2^4 + 1×2^3 + 0×2^2 + 1×2^1 + 0×2^0 &#x3D; 26（十进制）</p><p>这里就不给解析了</p><h6 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h6><p>eg. 将八进制数字 0.5176 转换成十进制：</p><p>0.5176 &#x3D;  5×8^-1 + 1×8^-2 + 7×8^-3 + 6×8^-4 &#x3D; 0.65576171875（十进制）</p><p>小数部分和整数部分相反，要从左往右看，第1位的位权为 8^-1&#x3D;1&#x2F;8，第2位的位权为 8^-2&#x3D;1&#x2F;64，第3位的位权为 8^-3&#x3D;1&#x2F;512，第4位的位权为 8^-4&#x3D;1&#x2F;4096 …… 第m位的位权就为 8^-m。</p><p>eg. 将二进制数字 0.1101 转换成十进制：</p><p>0.1101 &#x3D; 1×2^-1 + 1×2^-2 + 0×2^-3 + 1×2^-4 &#x3D; 0.8125（十进制）</p><p>小数部分和整数部分相反，要从左往右看，第1位的位权为 2^-1&#x3D;1&#x2F;2，第2位的位权为 2^-2&#x3D;1&#x2F;4，第3位的位权为 2^-3&#x3D;1&#x2F;8…… 第m位的位权就为 2^-m。</p><p><strong>如果一个数字既包含了整数部分又包含了小数部分，那么将整数部分和小数部分开，分别按照上面的方法完成转换，然后再合并在一起即可</strong></p><p>eg. 将八进制数字 423.5176 转换成十进制：</p><p>423.5176 &#x3D; 4×82 + 2×81 + 3×80 + 5×8-1 + 1×8-2 + 7×8-3 + 6×8-4 &#x3D; 275.65576171875（十进制）</p><h5 id="将十进制转换为二进制、八进制、十六进制"><a href="#将十进制转换为二进制、八进制、十六进制" class="headerlink" title="将十进制转换为二进制、八进制、十六进制"></a>将十进制转换为二进制、八进制、十六进制</h5><p>将十进制转换为其它进制时比较复杂，整数部分和小数部分的算法不一样</p><h6 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h6><p>十进制整数转换为 N 进制整数采用“<strong>除 N 取余，逆序排列</strong>”法。</p><p><strong>具体做法</strong>：将 N 作为除数，用十进制整数除以 N，可以得到一个商和余数；保留余数，用商继续除以 N，又得到一个新的商和余数；仍然保留余数……如此反复进行，每次都保留余数，用商接着除以 N，直到商为 0 时为止。</p><p><strong>把先得到的余数作为 N 进制数的低位数字，后得到的余数作为 N 进制数的高位数字，依次排列起来，就得到了 N 进制数字</strong>。</p><p>eg.</p><p>将十进制数字 36926 转换成八进制的过程：<br>十进制数字 36926 转换成八进制的结果为 110076。</p><p>十进制数字 42 转换成二进制<br>十进制数字 42 转换成二进制的结果为 101010</p><p>建议动手计算一下（不明白可以私信博主）</p><h6 id="小数部分"><a href="#小数部分" class="headerlink" title="小数部分"></a>小数部分</h6><p>十进制小数转换成 N 进制小数采用“<strong>乘 N 取整，顺序排列</strong>”法。</p><p><strong>具体做法</strong>：用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分；将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积……如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求的精度为止。</p><p><strong>把取出的整数部分按顺序排列起来，先取出的整数作为 N 进制小数的高位数字，后取出的整数作为低位数字，这样就得到了 N 进制小数。</strong>（注意这里是先取出的整数做高位数字）</p><p>eg.</p><p>十进制小数 0.930908203125 转换成八进制小数</p><p>十进制小数 0.930908203125 转换成八进制小数的结果为 0.7345</p><p>将十进制小数 0.6875 转换成二进制小数</p><p>十进制小数 0.6875 转换成二进制小数的结果为 0.1011</p><p><strong>如果一个数字既包含了整数部分又包含了小数部分，那么将整数部分和小数部分开，分别按照上面的方法完成转换，然后再合并在一起即可</strong></p><h5 id="二进制和八进制、十六进制的转换"><a href="#二进制和八进制、十六进制的转换" class="headerlink" title="二进制和八进制、十六进制的转换"></a>二进制和八进制、十六进制的转换</h5><h6 id="二进制整数和八进制整数之间的转换"><a href="#二进制整数和八进制整数之间的转换" class="headerlink" title="二进制整数和八进制整数之间的转换"></a>二进制整数和八进制整数之间的转换</h6><p>二进制整数转换为八进制整数时，每三位二进制数字转换为一位八进制数字，运算的顺序是从低位向高位依次进行，高位不足三位用零补齐。</p><p>eg.</p><p>将二进制整数 1110111100 转换为八进制：</p><p>二进制整数 1110111100 转换为八进制的结果为 1674</p><p>八进制整数转换为二进制整数时，思路是相反的，每一位八进制数字转换为三位二进制数字，运算的顺序也是从低位向高位依次进行。</p><p>eg.</p><p>将八进制整数 2743 转换为二进制：</p><p>八进制整数 2743 转换为二进制的结果为 10111100011</p><h6 id="二进制整数和十六进制整数之间的转换"><a href="#二进制整数和十六进制整数之间的转换" class="headerlink" title="二进制整数和十六进制整数之间的转换"></a>二进制整数和十六进制整数之间的转换</h6><p>二进制整数转换为十六进制整数时，每四位二进制数字转换为一位十六进制数字，运算的顺序是从低位向高位依次进行，高位不足四位用零补齐。</p><p>eg.</p><p>将二进制整数 10 1101 0101 1100 转换为十六进制：</p><p>二进制整数 10 1101 0101 1100 转换为十六进制的结果为 2D5C</p><p>十六进制整数转换为二进制整数时，思路是相反的，每一位十六进制数字转换为四位二进制数字，运算的顺序也是从低位向高位依次进行。</p><p>eg.</p><p>将十六进制整数 A5D6 转换为二进制：</p><p>十六进制整数 A5D6 转换为二进制的结果为 1010 0101 1101 0110</p>]]></content>
      
      
      <categories>
          
          <category> c/c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机底层必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L1-006连续因子----团体程序设计天梯赛</title>
      <link href="/post/95b4e652.html"/>
      <url>/post/95b4e652.html</url>
      
        <content type="html"><![CDATA[<p><strong>题：</strong></p><p>一个正整数 N 的因子中可能存在若干连续的数字。例如 630 可以分解为 3×5×6×7，其中 5、6、7 就是 3 个连续的数字。给定任一正整数 N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。</p><p><strong>输入格式：</strong><br>输入在一行中给出一个正整数 N（1&lt;N&lt;231）。</p><p><strong>输出格式：</strong><br>首先在第 1 行输出最长连续因子的个数；然后在第 2 行中按 因子1因子2……*因子k 的格式输出最小的连续因子序列，其中因子按递增顺序输出，1 不算在内。</p><p><strong>输入样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure><h5 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a><strong>输出样例：</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5*6*7</span><br></pre></td></tr></table></figure><p><strong>答案：</strong></p><p><strong>源码当中有注释较详细的解析，如有不理解的可以私信博主</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n = 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">int i = 0,j=0, a = 0, sum=0,num = 0,temp=0,qidian1=0,qidian2=0;</span><br><span class="line">int x = sqrt(n);// 连续因子当中最大的那一个 一定会小于这个正整数的平方根</span><br><span class="line">//找连续因子</span><br><span class="line">for (i = 2;i &lt;= x;i++)</span><br><span class="line">&#123;</span><br><span class="line">num = 0;// num 是使用来记录 满足条件的连续数的个数 ，每次使用完后要初始化为0 ，</span><br><span class="line">sum = n;</span><br><span class="line">qidian1 = i; //记录最开始连续的是哪一个数</span><br><span class="line">//判断 i 是否满足是连续的</span><br><span class="line">for (j = i;sum%j==0&amp;&amp;sum!=0;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum /= j;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">//筛选最长因子个数</span><br><span class="line">if (num &gt; temp)</span><br><span class="line">&#123;</span><br><span class="line">temp = num;</span><br><span class="line">qidian2 = qidian1; // 记录最长连续因子的 起点</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否有连续因子</span><br><span class="line">if (temp == 0)</span><br><span class="line">printf(&quot;1\n%d&quot;, n);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, temp);</span><br><span class="line">i = qidian2;</span><br><span class="line">while (i &lt; qidian2 + temp)</span><br><span class="line">&#123;</span><br><span class="line">if (i != qidian2)</span><br><span class="line">printf(&quot;*&quot;);</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 天梯赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 天梯赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L1-002打印沙漏-----团体程序设计天梯赛</title>
      <link href="/post/f356fe17.html"/>
      <url>/post/f356fe17.html</url>
      
        <content type="html"><![CDATA[<p><strong>L1-002 打印沙漏</strong><br>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。</p><p>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。</p><p><strong>输入格式:</strong><br>输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。</p><p><strong>输出格式:</strong><br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。</p><p><strong>输入样例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19 *</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>博主就不给单独的解释这个，源码里面都有详细的注释</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num;</span><br><span class="line">    char s;</span><br><span class="line">    int left; //剩下的符号个数</span><br><span class="line">    int i = 1; //每一行要打印符号的个数</span><br><span class="line">    int n = 1;//总共能打印的符号个数</span><br><span class="line">    int j, k;</span><br><span class="line">    int count;</span><br><span class="line">    int total;</span><br><span class="line">    scanf(&quot;%d %c&quot;, &amp;num, &amp;s);</span><br><span class="line">    while (n &lt;= num &amp;&amp; i &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i+2;</span><br><span class="line">        n = n + 2 * i; </span><br><span class="line">    &#125;</span><br><span class="line">    n = n - 2 * i;</span><br><span class="line">    i = i - 2;</span><br><span class="line">    left = num - n;</span><br><span class="line">    // 上半部分符号打印，包括1个的哪一行</span><br><span class="line">    for (j = i; j &gt;= 1; j = j - 2)</span><br><span class="line">    &#123;</span><br><span class="line">    // 判断是否要输出空格，以及输出空格的个数</span><br><span class="line">        total = (i - j) / 2;</span><br><span class="line">        if (total) </span><br><span class="line">        &#123;</span><br><span class="line">            while (total)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">                total--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 输出对应行要打印的符号</span><br><span class="line">        for (count = j; count &gt;= 1; count--)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            printf(&quot;%c&quot;, s);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 下半部分符号的打印，从3开始</span><br><span class="line">    for (k = 3; k &lt;= i; k = k+2)</span><br><span class="line">    &#123;</span><br><span class="line">    // 判断是否要输出空格，以及输出空格的个数</span><br><span class="line">        total = (i - k) / 2;</span><br><span class="line">        if (total)</span><br><span class="line">        &#123;</span><br><span class="line">            while (total)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">                total--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (count = k; count &gt;=1; count--)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line">            printf(&quot;%c&quot;, s);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, left);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>有不明白的可以加博主的联系方式私信博主</strong></p>]]></content>
      
      
      <categories>
          
          <category> 天梯赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博主自己做了的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown工具--typora破解版</title>
      <link href="/post/ff89f67d.html"/>
      <url>/post/ff89f67d.html</url>
      
        <content type="html"><![CDATA[<p>获得其他免费资源 请点这儿<a href="https://1yzf2zst.github.io/link/">传送门</a></p><p><strong>Typora</strong>是一款简单易用的 Markdown 编辑器。</p><h5 id="介绍一下markdown语言"><a href="#介绍一下markdown语言" class="headerlink" title="介绍一下markdown语言"></a>介绍一下markdown语言</h5><p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，在其中还可以嵌套html和css。</p><h5 id="markdown语言学习"><a href="#markdown语言学习" class="headerlink" title="markdown语言学习"></a>markdown语言学习</h5><p>这门语言，学习非常简单，刚开始只需要记住一些常用的格式和语法即可，就能满足大部分小伙伴的使用需求，如果想要进阶，那就还需要了解怎么使用latex公式和流程图和甘特图。</p><p>因为比较简单博主就不专门出一篇教程，这里给大家推荐几篇其他大佬的markdown入门到进阶教程<a href="http://t.csdn.cn/M0HtE">点这里哦</a></p><h5 id="软件推荐"><a href="#软件推荐" class="headerlink" title="软件推荐"></a>软件推荐</h5><p>这里给大家推荐俩个app</p><p>一个是：<strong>typora</strong></p><p>另一个是：<strong>印象笔记</strong></p><h6 id="typora-破解版安装"><a href="#typora-破解版安装" class="headerlink" title="typora 破解版安装"></a>typora 破解版安装</h6><p>是一款简单易用的 Markdown 编辑器，它的界面非常的简洁直观，并且功能各方面也是非常的不错。</p><p>这里给大家分享一个 破解版的typora </p><p>这里是安装包<a href="https://pan.baidu.com/s/1yAKMCsn4LSfS-ggxggvNJA">我在这呢–点我安装呗</a> 提取码：2111</p><p><strong>第一步</strong>：解压压缩包，然后像正常安装软件一样安装 typora，<strong>记下安装路径</strong></p><p><strong>第二步</strong>：用解压后文件里的app.asar </p><img src="/post/ff89f67d/jieyahou.png" class title="This is an image"><p>到安装路径下的resources文件夹里，替换掉里面原有的app.asar文件</p><img src="/post/ff89f67d/lincunwei.png" class title="This is an image"><p><strong>第三步</strong>:重启typora，输入邮箱、注册码</p><img src="/post/ff89f67d/jihuo.png" class title="This is an image"><p>邮箱：<a href="mailto:&#x78;&#105;&#x61;&#x6a;&#105;&#101;&#114;&#108;&#117;&#97;&#x6e;&#x74;&#x69;&#97;&#110;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;">&#x78;&#105;&#x61;&#x6a;&#105;&#101;&#114;&#108;&#117;&#97;&#x6e;&#x74;&#x69;&#97;&#110;&#64;&#49;&#54;&#51;&#x2e;&#99;&#111;&#x6d;</a> (可以随便写)<br>授权码: E8Q9Y5-KXMTL5-7578SL-4S5XKS</p><img src="/post/ff89f67d/success.png" class title="This is an image"><p>然后就可以正常使用了，嘿嘿🤭</p><p><strong>本博主声明，这里该操作仅供学习使用，请在下载24小时之内删除，请支持正版</strong></p><h6 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h6><p>印象笔记的话大家可以去官方下载，博主还是比较推荐使用它的，和typora一样比较简洁，很方便使用，但是他的服务比较多 ，嗯嗯 大家懂得。</p><p>这里也给一个下载链接<a href="https://pan.baidu.com/s/1XCMZG1qpWz3iSa7YaLnnMg">点这儿呢</a></p><p>提取码：2111</p><p><strong>本博主再次声明，这里该操作仅供学习使用，请在下载24小时之内删除，请支持正版</strong></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白嫖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站简介</title>
      <link href="/post/d431311d.html"/>
      <url>/post/d431311d.html</url>
      
        <content type="html"><![CDATA[<h4 id="博主建站成功"><a href="#博主建站成功" class="headerlink" title="博主建站成功"></a>博主建站成功</h4><p>历时俩天，终于简单的将自己，心心念念的个人博客网站搭起来。 嘿嘿😁</p><p>在搭建的过程中学习了许多的网上的一些搭建教程，给想要和我一样搭建属于自己的个人博客的小伙伴推荐一些博主认为比较详细的教程。</p><p><strong>计算机小白勿来</strong></p><h4 id="搭建和美化教程推荐"><a href="#搭建和美化教程推荐" class="headerlink" title="搭建和美化教程推荐"></a>搭建和美化教程推荐</h4><p><strong>搭建教程</strong>：<a href="https://www.bilibili.com/video/BV1mU4y1j72n?p=1&vd_source=ed0aad5b295bd6d3af5a85de9cbf348c">b站</a>这是一个视频教程比较详细，但是比较遗憾的是里面没有提供美化教程</p><p><a href="https://wushishu.xyz/">武师叔</a>这是一个blog搭建的比较漂亮的博主写的教程</p><p><strong>建议在搭建博客是将这俩个教程结合起来看，因为武师叔的教程里面有给出一些解决在搭建的时候出现的问题的解决方法</strong></p><p><strong>美化教程</strong>：<a href="https://dhndzwxj.vercel.app/3276806131.html">博士大佬</a>这位博主的教程给的比较详细有美化，也有搭建的教程</p><p><a href="http://haiyong.site/post/22e1d5da.html#Butterfly-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96">海拥</a>的教程，里面介绍了好一些漂亮的，美化挂件</p><p><a href="https://butterfly.js.org/">Jerry</a>讲的比较全面</p><p>博主就推荐这些搭建教程，有还想要其他详细教程的小伙伴可以私信博主</p><p><strong>注意：</strong>博主建议美化的时候，每美化一个地方就把他部署到本地，看一下是否有错误，别等教程看完后一块部署，不然可能在你的命令框弹出1mol的bug（<strong>博主亲测，玩废了四回在在美化阶段</strong>）</p><h4 id="搭站总结"><a href="#搭站总结" class="headerlink" title="搭站总结"></a>搭站总结</h4><p>对于搭建个人的博客网站，对小白比较不友好，因为你们会在搭建过程中遇到非常多的bug（哪怕你跟着教程一步一步的来），并且有很多对于你来说，你是在网上找不到解决方法的，官方给的参考文档是全英文版，所以对于小白来说想搭建并美化出一个漂亮的个人博客网站非常不容易。</p><p>到时候博主将会考虑这些出一套利用GitHub&#x2F;gitee+hexo搭建和美化的教程（该教程对小白会比较友好）届时欢迎各位来一起交流</p><p><strong>对于本站，后续博主还会继续完善本博客网站。</strong></p><h4 id="博主介绍"><a href="#博主介绍" class="headerlink" title="博主介绍"></a>博主介绍</h4><p>博主是一名在校双非大学生</p><p>主要研究的是 python c, qt,后续还会学习java（技术还比较菜）。</p><p>还会一些 前端html ，css，js，和c++，（会简单的使用，但是没有接触过一些项目）</p><p><strong>博主的其他博客：</strong></p><p>主要使用 csdn ，知乎博主主要是分享一些高清壁纸和动漫图片</p><p>掘金博主才开始使用不久里面的内容比较少（建议大家也可以去使用）</p><p>牛客，博主主要用来刚学一门语言的时候，用来刷题的（进阶的话可以去<a href="https://pintia.cn/home">PTA</a>和<a href="https://leetcode.cn/problemset/all/">leetcode</a>）</p><p>csdn :<a href="https://blog.csdn.net/smallcabbage12?spm=1000.2115.3001.5343">博主csdn的链接</a></p><p>知乎：<a href="https://www.zhihu.com/people/ming-zhao-39-10">知乎</a></p><p>掘金：<a href="https://juejin.cn/user/3474910374795448">掘金</a></p><p>牛客：<a href="https://www.nowcoder.com/profile/575419922">牛客</a></p><h4 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h4><p>qq: 2562644984</p><p>wechat: zst210621yzf</p><p>这个博客网站博主会主要使用来 介绍一些博主的技术学习和一些教程，资料, 资源的分享</p><h4 id="后续博客使用"><a href="#后续博客使用" class="headerlink" title="后续博客使用"></a>后续博客使用</h4><p>后续博主将相册开放出来，会给各位爱动漫和其他美照的小伙伴带一波福利（博主爬虫精挑，全高清）😎</p><p>会和大家分享一些项目的源码和破解app</p><p>对于这个博客网站博主会一直运营下去，非常非常期待各位小伙伴访问博主的博客和博主一起交流</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一篇博客哦 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
